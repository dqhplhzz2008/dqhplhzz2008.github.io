<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="小奥の部落格">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://gitpages.yushuai.xyz">
    <!--SEO-->

    <meta name="keywords" content="编程">


    <meta name="description" content="题目1：机器人的运动范围题目描述 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>《剑指Offer》题目解析（3） | 小奥の部落格</title>


    <link rel="alternate" href="/atom.xml" title="小奥の部落格" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="小奥">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 不忘初心，奋力前行！ </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://gitpages.yushuai.xyz">小奥の部落格</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/algorithm/"><i class="fa "></i>Algorithm</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cpp/"><i class="fa "></i>C/C++</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/learning/"><i class="fa "></i>Learning Notes</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>Time Line</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="http://www.yushuai.xyz/cv"><i class="fa "></i>About</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="《剑指Offer》题目解析（3）">
            
	            《剑指Offer》题目解析（3）
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/C-C/">C/C++</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/编程/">编程</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/03/04</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="题目1：机器人的运动范围"><a href="#题目1：机器人的运动范围" class="headerlink" title="题目1：机器人的运动范围"></a>题目1：机器人的运动范围</h2><p><strong>题目描述</strong> 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ <strong>题目解析</strong> 这个题可以看做是广度搜索优先（BFS）的一个拓展或者说是改编。如果说没有“不<strong>能进入行坐标和列坐标的数位之和大于****k****的格子</strong>”这个条件，那么它就是一个纯粹的BFS问题，设置上这个，就基本上就相当于只是多了一个条件。所以我们需要做的就是以下几个工作： 1.设置标志位。bool _flags=new bool[rows_cols]。 2.将移动一步单独设置为一个子函数，在这个函数里面，原始的判断条件只是： if(i&gt;=0 &amp;&amp; i&lt; rows &amp;&amp; j &gt;=0 &amp;&amp; j<cols && flags\[i*cols+j\]="=false)" 而现在则变成了： if(i>=0 &amp;&amp; i&lt; rows &amp;&amp; j &gt;=0 &amp;&amp; j&lt;cols &amp;&amp; <strong>(gssum(i) + gssum(j) &lt;= threshold)</strong> &amp;&amp; flags[i*cols+j]==false) <strong>代码</strong></cols></p>
<pre><code>int movingCount(int threshold, int rows, int cols)
    {
        bool *flags=new bool[rows*cols];//所有格子的标志位默认设置为false
        for(int i=0;i&lt;rows*cols;i++)
            flags[i]=false;
        int count = movingstep(threshold, rows, cols, 0, 0, flags);;//记录可访问格子数量
        return count;
    }
    int movingstep(int threshold, int rows, int cols, int i, int j, bool *flags)
    {
        int count = 0;
        if(i&gt;=0 &amp;&amp; i&lt; rows &amp;&amp; j &gt;=0 &amp;&amp; j&lt;cols &amp;&amp; (gssum(i) + gssum(j) &lt;= threshold) &amp;&amp; flags[i*cols+j]==false)
        {
            flags[i*cols+j]=true;
            count = 1 + movingstep(threshold, rows, cols, i+1, j, flags)+movingstep(threshold, rows, cols, i-1, j, flags)+movingstep(threshold, rows, cols, i, j+1, flags)+movingstep(threshold, rows, cols, i, j-1, flags);
        }
        return count;

    }

    int gssum(int i)
    {
        int sum = 0;
        while(i)
        {
            sum += i % 10;;
            i /= 10;
        }
        return sum;
    }
</code></pre><h2 id="题目2：把字符串转换成整数"><a href="#题目2：把字符串转换成整数" class="headerlink" title="题目2：把字符串转换成整数"></a>题目2：把字符串转换成整数</h2><p><strong>题目描述</strong> 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 <strong>题目解析</strong> 本题目其实是一个很简单的题目，只需要很细心判断以下几处问题即可： 1.不考虑最前面的空格； 2.若除去空格后的第一位为“+”或“-”，则分别将标志位做不同的设置，若为数字，直接将标志位设置为同“+”，若为其它则直接返回0； 3.后续几位直接判断是否为0~9之间的数字，由于是字符串格式，所以为ascii码，这样，我们在转换成int格式的时候，直接用该字符减去’0’即可。 <strong>代码</strong></p>
<pre><code>int StrToInt(string str) {
       int len=str.length();
       if(len==0)
           return 0;
       int i = 0;
       int res = 0;
       int fla = 1;
       //滤掉前面的空格
       while(str[i]==&apos; &apos;){
           i++;
       }
       //进行符号判断
       if(str[i]==&apos;+&apos;){
           i++;
       }else if(str[i]==&apos;-&apos;){
           i++;
           fla=-1;
       }
       while(str[i]!=&apos;\0&apos;){
           //对字符进行是否为数字的判断
           if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;){
               res=res*10+fla*(str[i]-&apos;0&apos;);
               i++;
           }else{
               res=0;
               break;
           }

       }
       return res;
   }
</code></pre><h2 id="题目3：表示数值的字符串"><a href="#题目3：表示数值的字符串" class="headerlink" title="题目3：表示数值的字符串"></a>题目3：表示数值的字符串</h2><p><strong>题目描述</strong> 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 <strong>题目解析</strong> 表示数值的字符串遵循的规则； 1.在数值之前可能有一个“+”或“-”，接下来是0到9的数位表示数值的整数部分，如果数值是一个小数，那么小数点后面可能会有若干个0到9的数字。 2表示数值的小数部分，如果用科学计数法表示，接下来是一个‘e’或者‘E’，以及紧跟着一个整数（可以有正负号）表示指数。 <strong>代码</strong></p>
<pre><code>bool isNumeric(char* string)
    {
        if(string == NULL)
            return false;
        if(*string == &apos;+&apos; || *string ==&apos;-&apos;)
            string++;
        if(*string ==&apos;\0&apos;)
            return false;
        int dot = 0;//小数点的个数
        int num = 0;//数字的个数
        int ex = 0;//e指数的个数
        while(*string !=&apos;\0&apos;)
        {
            if((*string &gt;= &apos;0&apos;) &amp;&amp; (*string &lt;=&apos;9&apos;))
            {
                num++;
                string++;
            }
            //小数点开始
            else if(*string ==&apos;.&apos;)
            {
                if(dot&gt; 0 || ex &gt; 0)
                    return false;
                dot++;
                string++;
            }
            //指数e
            else if((*string ==&apos;e&apos;) ||(*string == &apos;E&apos;))
            {
                if(num ==0 || ex &gt; 0)
                    return false;
                string++;
                ex++;
                if(*string == &apos;+&apos; || *string ==&apos;-&apos;)
                    string ++;
                if(*string==&apos;\0&apos;)
                    return false;

            }
            else
                return false;
        }
        return true;



    }
</code></pre><h2 id="题目4：链表中环的入口节点"><a href="#题目4：链表中环的入口节点" class="headerlink" title="题目4：链表中环的入口节点"></a>题目4：链表中环的入口节点</h2><p><strong>题目描述</strong> 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 <strong>题目解析</strong> 其实我的思路是把每个访问过的结点做标记，然后不断往下走后，遇到的第一个标记过的点，就是还的入口结点，如果没有遇到，则就不存在环，返回null。但是这种方法比较复杂，而且很难找到标志每个结点的特点在哪里。 所以可以这样考虑。如图4.1所示。 <img src="https://raw.githubusercontent.com/dqhplhzz2008/Study-notes/master/jianzhioffer/images/lianbiaohuanrukou.jpg" alt="约束条件"> 图4.1 示意图 我们假设x为AB之间的距离，a为从b到c的距离（顺时针移动），c为环的长度。我们可以设置两个指针，一个快一个慢，然后快的是慢的速度的两倍。设快指针为f，慢指针为s，则当快指针和慢指针相遇的时候，s=x+m_c+a，f=x+n_c+a，m和n为某不同的常数，s=f。所以x=(n-2m)c-a=(n-2m-1)c+c-a。n-2m-1可为0。这里为了处理方便，省略前面这个类似于周期的东西，只留下c-a。c-a是什么？c-a就是图4.1中灰色的这条线。也就是说，AB之间的距离=灰色的线。这样，我们可以再重新将f这个指针（也可以是s）指向A，那么当f和s相遇的时候，所在的结点就是入口结点。 <strong>代码</strong></p>
<pre><code>ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
        if((pHead==NULL)||(pHead-&gt;next==NULL)||(pHead-&gt;next-&gt;next==NULL))
            return NULL;
        ListNode* fast = pHead-&gt;next-&gt;next;
        ListNode* slow = pHead-&gt;next;
        //先判断有没有环
        while(fast!=slow)
        {
            if((fast-&gt;next !=NULL) &amp;&amp;(fast-&gt;next-&gt;next!=NULL)){
                fast=fast-&gt;next-&gt;next;
                slow=slow-&gt;next;
            }
            else{
                return NULL;
            }
        }
        //如果能执行到这一步，说明有环，且此时fast==slow。
        //然后把fast调整到头部，此时fast和slow第一次相遇的位置就是入口地址
        fast=pHead;
        while(fast!=slow)
        {
            fast=fast-&gt;next;
            slow=slow-&gt;next;
        }
        return slow;

    }
</code></pre><h2 id="题目5：把二叉树打印成多行"><a href="#题目5：把二叉树打印成多行" class="headerlink" title="题目5：把二叉树打印成多行"></a>题目5：把二叉树打印成多行</h2><p><strong>题目描述</strong> 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 <strong>题目解析</strong> 如果不加上“打印成多行”，那么这就是一个层序遍历，利用队列实现即可。而加上这个要求之后，只需要增加两个参数设置，当参数达到阈值后，输出第一行。 <strong>代码</strong></p>
<pre><code>vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) {
           vector&lt;vector&lt;int&gt; &gt; vect;//最后输出的结果
           if(pRoot==NULL)
               return vect;//若pRoot为空，直接返回空
           //接下来总体上就是一个层序遍历的变体，所以可以使用层序遍历进行修改完成此题目
           //层序遍历可以利用队列来实现。
           //首先新建一个队列，然后将链表的头push进去，然后弹出，获得头的值，然后再分别push进去其左右两个结点。然后弹出头上的
           //然后判断其左右结点是否有，有就push进去。这样层序遍历其实就是用队列来输入输出。
           queue&lt;TreeNode*&gt; tmp;
           tmp.push(pRoot);
           while(!tmp.empty())
           {
               int l=0;
               int h=tmp.size();
               vector&lt;int&gt; t;
               while(l++&lt;h)//按行输出
               {
                   TreeNode* k = tmp.front();
                   tmp.pop();
                   t.push_back(k-&gt;val);
                   if(k-&gt;left)
                       tmp.push(k-&gt;left);
                   if(k-&gt;right)
                       tmp.push(k-&gt;right);
               }
               vect.push_back(t);
           }
           return vect;
       }
</code></pre><h2 id="题目6：按之字形顺序打印二叉树"><a href="#题目6：按之字形顺序打印二叉树" class="headerlink" title="题目6：按之字形顺序打印二叉树"></a>题目6：按之字形顺序打印二叉树</h2><p><strong>题目描述</strong> 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 <strong>题目解析</strong> 这个题目是对于题目5的拓展，我们依旧可以借鉴层序遍历，但是这里我们要使用的是两个堆栈。总体上是一样的。 假设我们输出第一行，那么按照顺序输出以后，push进堆栈的顺序要和之前的相反，这样push进入第二个堆栈。当用第二个堆栈输出的时候，就要先左后右push进入第一个堆栈。 <strong>代码</strong></p>
<pre><code>vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) {
        vector&lt;vector&lt;int&gt; &gt; res;//结果存放
        stack&lt;TreeNode*&gt; stackl,stackr;//从右往左和从左往右输出结果的堆栈
        if(pRoot!=NULL)
        {
            stackl.push(pRoot);//跟层序遍历类似，先把根节点push进去
        }
        struct TreeNode* node;//中介的结点，类似于层序遍历
        while(!stackl.empty() || !stackr.empty())
        {
            vector&lt;int&gt; tmp;
            if(!stackl.empty()){
                while(!stackl.empty())
                {
                    node=stackl.top();
                    stackl.pop();
                    tmp.push_back(node-&gt;val);
                    if(node-&gt;left!=NULL)
                        stackr.push(node-&gt;left);
                    if(node-&gt;right!=NULL)
                        stackr.push(node-&gt;right);
                }
                res.push_back(tmp);

            }
            else if(!stackr.empty()){
                while(!stackr.empty()){
                    node=stackr.top();
                    stackr.pop();
                    tmp.push_back(node-&gt;val);
                    if(node-&gt;right!=NULL)
                        stackl.push(node-&gt;right);
                    if(node-&gt;left!=NULL)
                        stackl.push(node-&gt;left);
                }
                res.push_back(tmp);
            }
        }
        return res;

    }
</code></pre><h2 id="题目7：二叉搜索树的第k个节点"><a href="#题目7：二叉搜索树的第k个节点" class="headerlink" title="题目7：二叉搜索树的第k个节点"></a>题目7：二叉搜索树的第k个节点</h2><p><strong>题目描述</strong> 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 <strong>题目解析</strong> 这个题看着挺唬人，实际非常简单。由于二叉搜索树本身就是具有顺序特点的二叉树，因此这个题实际上是中序遍历二叉搜索树，然后输出中序遍历的第k个值。 <strong>代码</strong></p>
<pre><code>class Solution {
private:
    int count;
public:
    void inorder(TreeNode* root, TreeNode* &amp;ans)
    {
        if(root)
        {
            inorder(root-&gt;left,ans);
            count--;//记录是第几个值
            if(!count)
                ans=root;
            inorder(root-&gt;right,ans);
        }
    }
    TreeNode* KthNode(TreeNode* pRoot, int k)
    {
        if(pRoot==NULL || k&lt;1)
            return NULL;
        TreeNode* ans = NULL;
        count = k;
        inorder(pRoot, ans);
        return ans;
    }


};
</code></pre><h2 id="题目8：翻转单词顺序"><a href="#题目8：翻转单词顺序" class="headerlink" title="题目8：翻转单词顺序"></a>题目8：翻转单词顺序</h2><p><strong>题目描述</strong> 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ <strong>题目解析</strong> 这个题目其实最容易想到的就是，我们可以整个句子翻转过来，这样做的结果是，每个单词正好也都是反序的，我们只需要再调用一次翻转，将单词翻转就变成了正序。 <strong>代码</strong></p>
<pre><code>void ReversedWord(string &amp;str, int st, int en)
    {
        while(st &lt; en)
        {
            swap(str[st++],str[en--]);
        }
    }
    string ReverseSentence(string str) {
        int len = str.size();
        int st = 0;
        int en = 0;
        ReversedWord(str,0,len-1);//先整体翻转
        int i=0;
         while(i &lt; len)
         {
             while(i &lt; len &amp;&amp; str[i] == &apos; &apos;) //空格跳过
                i++;
            en = st = i; //记录单词的第一个字符的位置
            while(i &lt; len &amp;&amp; str[i] != &apos; &apos;) //不是空格 找单词最后一个字符的位置
            {
                i++;
                en++;
            }
            ReversedWord(str, st, en - 1); //局部翻转
         }

        return str;
    }
</code></pre><h2 id="题目9：扑克牌顺子"><a href="#题目9：扑克牌顺子" class="headerlink" title="题目9：扑克牌顺子"></a>题目9：扑克牌顺子</h2><p><strong>题目描述</strong> LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 <strong>题目解析</strong> 顺子要求： 1.牌面不重复； 2.牌面是连续的。 为了满足以上条件，所以做了以下两个步骤： 1.设置flag。只要不重复，很多都会用到flag，由于扑克牌里面有14种牌，所以flag数组长度为14，默认为0，有重复就加1。 2.寻找最大最小值，计算它们的差值，判断结果。由于牌面不重复，又由于只有五张，所以max-min&lt;5的时候（其实就是为4的时候），肯定是连续的，若大了，肯定不连续。 <strong>代码</strong></p>
<pre><code>bool IsContinuous( vector&lt;int&gt; numbers ) {
       if(numbers.empty())
           return false;
       int count[14]={0};
       int max = -1;
       int min = 14;
       for(int i=0;i&lt;numbers.size();i++)
       {
           count[numbers[i]]++;
           if(numbers[i]==0)
               continue;
           if(count[numbers[i]]&gt;1)
               return false;
           if(numbers[i] &gt; max)
               max = numbers[i];
           if(numbers[i] &lt; min)
               min = numbers[i];
       }
       if(max - min &lt;5)
           return true;
       return false;
   }
</code></pre><h2 id="题目10：矩阵中的路径"><a href="#题目10：矩阵中的路径" class="headerlink" title="题目10：矩阵中的路径"></a>题目10：矩阵中的路径</h2><p><strong>题目描述</strong> 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 <strong>题目解析</strong> 类似于题目3，在此就不具体说了。 <strong>代码</strong></p>
<pre><code>private:
    bool isPath(char *matrix, vector&lt;char&gt; flags, char* str, int i, int j, int rows, int cols)
    {
        if(i&lt;0|| i&gt;=rows || j&lt;0 || j&gt;=cols)
            return false;
        if(matrix[i*cols+j] == *str &amp;&amp; flags[i*cols+j]==0)
        {
            flags[i*cols+j]=1;
            if(*(str+1)==0)
                return true;
            bool cond = isPath(matrix,flags,(str+1),i,j-1,rows,cols) ||
                isPath(matrix,flags,(str+1),i-1,j,rows,cols)||
                isPath(matrix,flags,(str+1),i,j+1,rows,cols)||
                isPath(matrix,flags,(str+1),i+1,j,rows,cols); 
            if(cond==false)
                flags[i*cols+j]=0;
            return cond;

        }
        else
            return false;
    }
public:
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        vector&lt;char&gt; flags(rows*cols,0);
        bool con = false;
        for(int i=0;i&lt;rows;i++)
            for(int j =0;j&lt;cols;j++)
            {
                con = (con||  isPath(matrix,flags,str,i,j,rows,cols) );
            }
            return con;

    }
</code></pre>
    </div>
    
        <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="http://www.yushuai.xyz/zjyt/alipay.jpg"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="http://www.yushuai.xyz/zjyt/weixin.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">感觉不错？欢迎给我 打个赏~我将不胜感激！</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">小奥</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/03/04/e3-80-8a-e5-89-91-e6-8c-87offer-e3-80-8b-e9-a2-98-e7-9b-ae-e8-a7-a3-e6-9e-90-ef-bc-884-ef-bc-89/" class="pre-post btn btn-default" title="《剑指Offer》题目解析（4）">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">《剑指Offer》题目解析（4）</span>
        </a>
    
    
        <a href="/2019/03/01/e6-b5-8b-e8-af-95-e6-96-87-e4-bb-b6-trashed/" class="next-post btn btn-default" title="测试文件">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">测试文件</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>






                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目1：机器人的运动范围"><span class="toc-text">题目1：机器人的运动范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目2：把字符串转换成整数"><span class="toc-text">题目2：把字符串转换成整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目3：表示数值的字符串"><span class="toc-text">题目3：表示数值的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目4：链表中环的入口节点"><span class="toc-text">题目4：链表中环的入口节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目5：把二叉树打印成多行"><span class="toc-text">题目5：把二叉树打印成多行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目6：按之字形顺序打印二叉树"><span class="toc-text">题目6：按之字形顺序打印二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目7：二叉搜索树的第k个节点"><span class="toc-text">题目7：二叉搜索树的第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目8：翻转单词顺序"><span class="toc-text">题目8：翻转单词顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目9：扑克牌顺子"><span class="toc-text">题目9：扑克牌顺子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目10：矩阵中的路径"><span class="toc-text">题目10：矩阵中的路径</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>