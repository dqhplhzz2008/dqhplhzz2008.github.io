<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="小奥の部落格">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://tech.yushuai.xyz">
    <!--SEO-->

    <meta name="keywords" content="算法,动态规划">


    <meta name="description" content="关于最长公共子序列（LCS）最长公共子序列和最长公共子串是有区别的，之前我一直把它们混淆。

最长公共子串举例：假设S1={A,D,C,B,E,X,Q}，S2={H,P,D,C,B,E,M,L}...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>动态规划 | 小奥の部落格</title>


    <link rel="alternate" href="/atom.xml" title="小奥の部落格" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="小奥">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 不忘初心，奋力前行！ </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://tech.yushuai.xyz">小奥の部落格</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/algorithm/"><i class="fa "></i>Algorithm</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/C-C/"><i class="fa "></i>C/C++</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/learning/"><i class="fa "></i>Learning Notes</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>Time Line</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="http://www.yushuai.xyz/cv"><i class="fa "></i>About</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="动态规划">
            
	            动态规划
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/algorithm/">algorithm</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/动态规划/">动态规划</a> <a class="tag-link" href="/tags/算法/">算法</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/03/20</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="关于最长公共子序列（LCS）"><a href="#关于最长公共子序列（LCS）" class="headerlink" title="关于最长公共子序列（LCS）"></a>关于最长公共子序列（LCS）</h2><p>最长公共子序列和最长公共子串是有区别的，之前我一直把它们混淆。</p>
<ol>
<li>最长公共子串举例：假设S1={A,D,C,B,E,X,Q}，S2={H,P,D,C,B,E,M,L}<br>那么它们的最长公共子串就是{D,C,B,E}。这是我通常理解的东西。<br>最长公共子序列。</li>
<li>最长公共子序列举例：假设S1={A,<strong>B</strong>,C,<strong>A</strong>,<strong>D</strong>,A,<strong>B</strong>}，S2={<strong>B</strong>,<strong>A</strong>,C,<strong>D</strong>,<strong>B</strong>,A}，那么它们的LCS就是{B,A,D,B}。</li>
</ol>
<h2 id="求解最长公共子序列"><a href="#求解最长公共子序列" class="headerlink" title="求解最长公共子序列"></a>求解最长公共子序列</h2><p>这是一个动态规划问题。如何求解最长公共子序列（以下用LCS代替）呢？我们假设已经知道Z={z1,z2,…zk}是X={x1,x2,…,xm}和Y={y1,y2,…,yn}的LCS，那么可以分以下三种情况讨论（具体每种情况证明不再累述）：</p>
<ol>
<li>xm=yn=zk：那么Zk-1是Xm-1和Yn-1的LCS。</li>
<li>xm≠yn，yn≠zk：我们可以把yn去掉，那么Zk是Xm和Yn-1的LCS。</li>
<li>xm≠yn，xm≠zk：我们可以把xm去掉，那么Zk是Xm-1和Yn的LCS。</li>
</ol>
<p>基于以上情况，我们可以得到LCS递归式。我们假设c[i][j]表示Xi和Yi的LCS长度，那么：</p>
<ul>
<li>c[i][j]=0(i=0或j=0)；</li>
<li>c[i][j]=c[i-1]c[j-1]+1(i,j&gt;0且xi=yi）；</li>
<li>c[i][j]=max{c[i-1][j],c[i],[j-1]}；（i,j&gt;0且xi≠yi）。</li>
</ul>
<p>这样我们就可以得到LCS的长度。如何得到具体内容是什么呢？我们可以借用一个辅助数组b[i][j]，这个数组用来记录c[i][j]的来源，分别有如下情况：</p>
<ul>
<li>c[i][j]=c[i-1][j-1]+1，则b[i][j]=1；</li>
<li>c[i][j]=c[i][j-1]，则b[i][j]=2；</li>
<li>c[i][j]=c[i-1][j]，则b[i][j]=3。</li>
</ul>
<p>这样就可以根据b[m][n]反向追踪LCS，当b[i][j]=1，输出xi；当b[i][j]=2，追踪c[i][j-1]；当b[i][j]=3，追踪c[i-1][j]，直到i=0或j=0停止。</p>
<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><p>（1）初始化。初始化c[][]第1行和第1列为0。<br>（2）开始操作。具体是将s1[i]分别与s2[j-1]（j=1,2,…,len2）进行比较，若字符相等c[i][j]=左上角数值+1，且b[i][j]=1；若不相等，则c[i][j]等于左侧或者上侧重最大的一个数值，若左侧和上侧相等，则取左侧，且b[i][j]=2或3（当取左侧为2，取上侧为3）。最后的c[][]和b[][]如下所示：<br>下表是c[][]：</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>A</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>A</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>D</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>A</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>下表是b[][]：</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>3</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>3</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>7</td>
<td>0</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>根据c[][]可以得出，LCS的长度为4（也就是c[][]最后一个值）。然后开始判断内容是什么，这是要根据b[][]来。<br>首先，b[7][6]=2，向左找b[7][5]=1，所以向左上角找b[6][4]，得到字母为s1[6]=[B]；<br>b[6][4]=3，向上找b[5][4]=1，向左上角找b[4][3]，得到字母s1[4]=[D]；<br>b[4][3]=2，向左找b[4][2=1，向左上角找b[3][1]，得到字母s1[3]=[A]；<br>b[3][1]=3，向上找b[2][1]=1，向左上角找b[1][0]，得到字母s1[1]=[B].<br>由于b[1][0]=0，所以算法停止，返回结果为“BADB”。</p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><pre><code>void LCSL()
{
    int i, j;
    for(i=1;i&lt;len1;i++)
        for (j = 1; j &lt; len2; j++)
        {
            if (s1[i - 1] == s2[j - 1])
            {
                c[i][j] = c[i - 1][j - 1] + 1;
                b[i][j] = 1;
            }
            else
            {
                if (c[i][j - 1] &gt;= c[i - 1][j])
                {
                    c[i][j] = c[i][j - 1];
                    b[i][j] = 2;
                }
                else
                {
                    c[i][j] = c[i - 1][j];
                    b[i][j] = 3;
                }
            }
        }
}

void print(int i, int j)
{
    if (i == 0 || j == 0)
        return;
    if (b[i][j] == 1)
    {
        print(i - 1, j - 1);
        cout &lt;&lt; s1[i - 1];
    }
    else if (b[i][j] == 2)
        print(i, j - 1);
    else
        print(i - 1, j);
}
</code></pre><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><h3 id="编辑距离和LCS的不同点"><a href="#编辑距离和LCS的不同点" class="headerlink" title="编辑距离和LCS的不同点"></a>编辑距离和LCS的不同点</h3><ol>
<li>编辑距离的d[][]取值公式如下：<br>（一个前提，若xi=yj，则diff=0；否则为1）<br>d[i][j]=min{<strong>d[i - 1][j] + 1</strong>, <strong>d[i][j - 1] + 1</strong>,<strong>d[i-1][j-1]+diff</strong>}</li>
<li>构造最优解：编辑距离是从右下角开始，逆向查找d[i][j]的来源：上面表示需要<strong>删除</strong>，左侧表示需要<strong>插入</strong>；左上角要判断字符是否相等，若相等，不做任何操作，若不相等，执行<strong>替换</strong>。</li>
<li>两者的时间复杂度都是O(n*m)。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>int min(int a, int b,int c)
{
    int temp = (a &lt; b) ? a : b;
    return (temp &lt; c) ? temp : c;
}

//编辑距离函数
int editdistance(char *str1, char *str2)
{
    int i, j;
    int len1 = strlen(str1);
    int len2 = strlen(str2);
    for (i = 0; i &lt;= len1; i++)
    {
        d[i][0] = i;
    }
    for (j = 0; j &lt;= len2; j++)
    {
        d[0][j] = j;
    }
    for (i = 1; i &lt;= len1; i++)
    {
        for (j = 1; j &lt;= len2; j++)
        {
            int diff;
            if (str1[i - 1] == str2[j - 1])
                diff = 0;
            else
                diff = 1;
            d[i][j] = min(d[i - 1][j] + 1, d[i][j - 1] + 1,d[i-1][j-1]+diff);
        }
    }
    return d[len1][len2];
}
</code></pre><h2 id="游艇租赁问题"><a href="#游艇租赁问题" class="headerlink" title="游艇租赁问题"></a>游艇租赁问题</h2><p>假设在一条河上有n个游艇出租站，游客可以在这些游艇出租站租游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到j之间的租金为r(i,j)，i&lt;=i&lt;=j&lt;=n。设计一个算法，计算从游艇出租站i到出租站j所需要的租金最少。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>（1）分析最优解的结构特征<br>（2）简历最优值的递归式<br>m[i][j]=<br>0(j=i);<br>r[i][j];j=i+1;<br>min{m[i][k]+m[k][j],r[i][j],j&gt;i+1。</p>
<h3 id="算法设计-1"><a href="#算法设计-1" class="headerlink" title="算法设计"></a>算法设计</h3><p>（1）确定合适的数据结构：采用二维数组r[][]输入数据，二维数组m[][]存放各个子问题的最优值，二维数组s[][]存放各个子问题的最优决策（停靠站点）。<br>（2）初始化：m[i][j]=r[i][j]，然后再找有没有比m[i][j]小的值，如果有，则记录该最优值和最优解即可，s[i][j]=0.<br>（3）循环阶段：</p>
<ul>
<li>按照递归关系式计算3个站点i,i+1,j(j=i+2)的最优值，并将其存入m[i][j]，同时将最优策略存入s[i][j]，i=1,2,…,n-2。</li>
<li>按照递归关系式计算4个站点i,i+1,i+2,j(j=i+3)的最优值，并将其存入m[i][j]，同时将最优策略存入s[i][j]，i=1,2,…,n-3。</li>
<li>以此类推，直到求出n个站点的最优值m[1][n]。</li>
</ul>
<p>（4）构造最优解。根据s[][]递归构造最优解。s[1][n]是第一个站点到底n个站点）1,2,…,n）的最优解的停靠站点，即停靠了第s[1][n]个站点，我们在递归构造两个子问题(1,2,…,k）和（k,k+1,…,n）的最优解停靠站点，一直递归到只包含一个站点为止。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>void rent()
{
    int i, j, k, d;
    for (d = 3; d &lt;= n; d++)
    {
        for (i = 1; i &lt;= n - d + 1; i++)
        {
            j = i + d - 1;
            for (k = i + 1; k &lt; j; k++)
            {
                int temp;
                temp = m[i][k] + m[k][j];
                if (temp &lt; m[i][j])
                {
                    m[i][j] = temp;
                    s[i][j] = k;
                }
            }
        }
    }
}

void print(int i, int j)
{
    if (s[i][j] == 0)
    {
        cout &lt;&lt; &quot;-- &quot; &lt;&lt; j;
        return;
    }
    print(i, s[i][j]);
    print(s[i][j], j);
}
</code></pre><h3 id="代码实现2：最贵的租金"><a href="#代码实现2：最贵的租金" class="headerlink" title="代码实现2：最贵的租金"></a>代码实现2：最贵的租金</h3><p>其实只是把总结的递归式中的j&gt;i+1的时候的min改为了max。所以只是修改了代码中的</p>
<pre><code>if (temp &lt; m[i][j])
</code></pre><p>将其改为了</p>
<pre><code>if (temp &gt; m[i][j])
</code></pre><h2 id="快速计算——矩阵连乘"><a href="#快速计算——矩阵连乘" class="headerlink" title="快速计算——矩阵连乘"></a>快速计算——矩阵连乘</h2><p>最优递归式：<br>当i=j时，只有一个矩阵，m[i][j]=0；<br>当i&lt;j的时候，m[i][j]=min{m[i][k]+m[k+1][j]+pip(k+1)qj}</p>
<h3 id="算法设计-2"><a href="#算法设计-2" class="headerlink" title="算法设计"></a>算法设计</h3><p>（1）确定合适的数据结构。用一维数组p[]记录矩阵的行和列，第i个矩阵的行数存在数组的第i-1位置，列存在第i位置。二维数组m[][]用来存放各个子问题的最优值，二维数组s[][]来存放各个子问题的最优决策（加括号的位置）。<br>（2）初始化。m[i][i]=0，s[i][i]=0。<br>（3）循环阶段。</p>
<ul>
<li>按照递归关系式计算2个矩阵Ai、Ai+1相乘时的最优值，j+i+1，并将其存入m[i][j]；同时将最优策略计入s[i][j]。i=1,2,3,..,n-1。</li>
<li>按照递归关系式计算3个矩阵相乘Ai、Ai+1、Ai+2,相乘时的最优值，j+i+2，并将其存入m[i][j]，同时将最优策略记入s[i][j]，i=1,2,3,…,n-2。</li>
<li>以此类推，直到求出n个矩阵相乘的最优值m[1][n]。</li>
</ul>
<p>（4）构造最优解<br> 根据最有决策信息数组s[][]递归构造最优解。s[1][n]表示A1A2…An最优解的加括号位置，我们在递归构造两个子问题的最优解加括号位置，一直低轨道子问题只包含一个矩阵为止。</p>
<h3 id="举例图解"><a href="#举例图解" class="headerlink" title="举例图解"></a>举例图解</h3><table>
<thead>
<tr>
<th>矩阵</th>
<th>A1</th>
<th>A2</th>
<th>A3</th>
<th>A4</th>
<th>A5</th>
</tr>
</thead>
<tbody>
<tr>
<td>规模</td>
<td>3*5</td>
<td>5*10</td>
<td>10*8</td>
<td>8*2</td>
<td>2*4</td>
</tr>
</tbody>
</table>
<p>（1）初始化<br>m[i][i]=0,s[i][i]=0<br>（2）计算两个矩阵相乘的最优值<br> m[][]如下：</p>
<table>
<thead>
<tr>
<th>m[][]</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>150</td>
<td>390</td>
<td>290</td>
<td>314</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>0</td>
<td>400</td>
<td>260</td>
<td>300</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>0</td>
<td>160</td>
<td>240</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>64</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
<p>s[][]如下：</p>
<table>
<thead>
<tr>
<th>s[][]</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>0</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
<p>（3）构造最优解<br>类似于游艇租赁</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>void matrixchain()
{
    int i,j,r,k;
    memset(m,0,sizeof(m));
    memset(s,0,sizeof(s));
    for(r = 2; r &lt;= n; r++)         //不同规模的子问题
    {
        for(i = 1; i &lt;= n-r+1; i++)
        {
           j = i + r - 1;
           m[i][j] = m[i+1][j] + p[i-1] * p[i] * p[j];  //决策为k=i的乘法次数
           s[i][j] = i;                     //子问题的最优策略是i;
           for(k = i+1; k &lt; j; k++) //对从i到j的所有决策，求最优值，记录最优策略
            {
                int t = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j];
                if(t &lt; m[i][j])
                {
                    m[i][j] = t;
                    s[i][j] = k;
                }
            }
        }
    }
}
void print(int i,int j)
{
    if( i == j )
    {
       cout &lt;&lt;&quot;A[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;
       return ;
    }
    cout &lt;&lt; &quot;(&quot;;
    print(i,s[i][j]);
    print(s[i][j]+1,j);
    cout &lt;&lt; &quot;)&quot;;
}
</code></pre><h2 id="最优三角剖分"><a href="#最优三角剖分" class="headerlink" title="最优三角剖分"></a>最优三角剖分</h2><h3 id="与矩阵连乘的不同点"><a href="#与矩阵连乘的不同点" class="headerlink" title="与矩阵连乘的不同点"></a>与矩阵连乘的不同点</h3><p>不同点就在于递归公式的不同，最优三角剖分的递归公式如下：<br>当i=j的时候，m[i][j]=0；<br>当i&lt;j的时候，m[i][j]=min{m[i][k]+m[k+1][j]+w(v(i-1)vkvj)}</p>
<h3 id="图解示例"><a href="#图解示例" class="headerlink" title="图解示例"></a>图解示例</h3><p>我们以一个凸多边形为例，其每条边的权重如下表所示<br>| g[][] | 0 | 1 |2 |3 |4|5<br>| —— | —— | —— | —— | —— | —— | —— |<br>|0| 0 | 2|3 | 1|5|6<br>|1|2 | 0|3 | 4|8|6<br>|2|3| 3|0 | 10|13|7<br>|3|1 | 4|10 | 0|12|5<br>|4|5 | 8|13 | 12|0|3<br>|5|6 | 6|7 | 5|3|0</p>
<p>（1）初始化：令m[i][i]=0，s[i][i]=0<br>（2）计算赋值如下：</p>
<table>
<thead>
<tr>
<th>m[][]</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>8</td>
<td>22</td>
<td>40</td>
<td>54</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>0</td>
<td>17</td>
<td>41</td>
<td>52</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>0</td>
<td>35</td>
<td>42</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>s[][]</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
<p>所以最优权值为m[1][5]=54<br>（3）构造最优解。过程与矩阵快速相乘类似，都是根据s[][]对应的位置来分成子问题，所以首先是看到s[1][5]=3，所以分为了v0~ v3 和 v3~v5。</p>
<ul>
<li>因为v0~v3中有结点，所以子问题1不为空，输出该弦v0v3；同理，输出v3v5。</li>
<li>对于子问题1进行递归，读取s[1][3]=2，因为v0~v2有结点，所以输出v0v2……</li>
<li><p>最后输出的最优解为v0v3,v3v5,v0v2。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>  void  Convexpolygontriangulation()<br>  {</p>
<pre><code>for(int i = 1 ;i &lt;= n ; i++)    // 初始化
{
    m[i][i] = 0 ;
    s[i][i] = 0 ;
}
for(int d = 2 ;d &lt;= n ; d++)         // 枚举点的个数
  for(int i = 1 ;i &lt;= n - d + 1 ; i++)  // 枚举起始点
  {
      int j = i + d - 1 ;         // 终点
      m[i][j] = m[i+1][j] + g[i-1][i] + g[i][j] + g[i-1][j] ;
      s[i][j] = i ;
      for(int k = i + 1 ;k &lt; j ; k++)     // 枚举中间点
      {
          double temp = m[i][k] + m[k+1][j] + g[i-1][k] + g[k][j] + g[i-1][j] ;
          if(m[i][j] &gt; temp)
          {
              m[i][j] = temp ;   // 更新最优值
              s[i][j] = k ;      // 记录中间点
          }
      }
  }
</code></pre><p>  }<br>  void print(int i , int j)  // 输出所有的弦<br>  {</p>
<pre><code>if(i == j)  return ;
if(s[i][j]&gt;i)
  cout&lt;&lt;&quot;{v&quot;&lt;&lt;i-1&lt;&lt;&quot;v&quot;&lt;&lt;s[i][j]&lt;&lt;&quot;}&quot;&lt;&lt;endl;
if(j&gt;s[i][j]+1)
  cout&lt;&lt;&quot;{v&quot;&lt;&lt;s[i][j]&lt;&lt;&quot;v&quot;&lt;&lt;j&lt;&lt;&quot;}&quot;&lt;&lt;endl;
print(i ,s[i][j]);
print(s[i][j]+1 ,j);
//cout&lt;&lt;&quot;{ v&quot;&lt;&lt;i-1&lt;&lt;&quot; , v&quot;&lt;&lt;s[i][j]&lt;&lt;&quot; , v&quot;&lt;&lt;j&lt;&lt;&quot; }&quot;&lt;&lt;endl; //输出所有剖分后的三角形
</code></pre><p>  }</p>
<h2 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h2></li>
</ul>
<h3 id="递归公式："><a href="#递归公式：" class="headerlink" title="递归公式："></a>递归公式：</h3><p>设Min[i][j]代表从第i堆石子到第j堆石子合并的最小花费，Min[i][k]代表从第i堆石子到底k堆石子合并的最小花费，Min[k+1][j]代表从第k+1堆石子到第j堆石子合并的最小花费。那么递推式如下：<br>Min[i][j]=0,i=j<br>Min[i][j]=min{m[i][k]+m[k+1][j]+w(i,j)} i&lt;j<br>同理，设Max[i][j]代表从第i堆石子到第j堆石子合并的最大花费，Max[i][k]代表从第i堆石子到底k堆石子合并的最大花费，Max[k+1][j]代表从第k+1堆石子到第j堆石子合并的最大花费。那么递推式如下：<br>Max[i][j]=0,i=j<br>Max[i][j]=max{m[i][k]+m[k+1][j]+w(i,j)} i&lt;j</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>void straight(int a[],int n)
{
    for(int i=1;i&lt;=n;i++)  // 初始化
        Min[i][i]=0, Max[i][i]=0;
    sum[0]=0;
    for(int i=1;i&lt;=n;i++)
       sum[i]=sum[i-1]+a[i];
    for(int v=2; v&lt;=n; v++) // 枚举合并的堆数规模
    {
        for(int i=1; i&lt;=n-v+1; i++) //枚举起始点i
        {
            int j = i + v-1; //枚举终点j
            Min[i][j] = INF; //初始化为最大值
            Max[i][j] = -1; //初始化为-1
            int tmp = sum[j]-sum[i-1];//记录i...j之间的石子数之和
            for(int k=i; k&lt;j; k++) {   //枚举中间分隔点
                Min[i][j] = min(Min[i][j], Min[i][k] + Min[k+1][j] + tmp);
                Max[i][j] = max(Max[i][j], Max[i][k] + Max[k+1][j] + tmp);
            }
        }
    }
}
void Circular(int a[],int n)
{
    for(int i=1;i&lt;=n-1;i++)
        a[n+i]=a[i];
    n=2*n-1;
    straight(a, n);
    n=(n+1)/2;
    min_Circular=Min[1][n];
    max_Circular=Max[1][n];
    for(int i=2;i&lt;=n;i++)
    {
        if(Min[i][n+i-1]&lt;min_Circular)
           min_Circular=Min[i][n+i-1];
        if(Max[i][n+i-1]&gt;max_Circular)
           max_Circular=Max[i][n+i-1];
    }
}
</code></pre><p>时间复杂度为O(n<sup>3</sup>)</p>
<h3 id="改进算法"><a href="#改进算法" class="headerlink" title="改进算法"></a>改进算法</h3><p>最小值可以用四边形不等式来优化。<br>复杂度为O(n<sup>2</sup>)</p>
<pre><code>void get_Min(int n)
{
    for(int v=2; v&lt;=n; v++) // 枚举合并的堆数规模
    {
        for(int i=1; i&lt;=n-v+1; i++) //枚举起始点i
        {
            int j = i + v-1; //枚举终点j
            int tmp = sum[j]-sum[i-1];//记录i...j之间的石子数之和
            int i1=s[i][j-1]&gt;i?s[i][j-1]:i;
            int j1=s[i+1][j]&lt;j?s[i+1][j]:j;
            Min[i][j]=Min[i][i1]+Min[i1+1][j];
            s[i][j]=i1;
            for(int k=i1+1; k&lt;=j1; k++) //枚举中间分隔点
                if(Min[i][k]+ Min[k+1][j]&lt;Min[i][j])
                {
                    Min[i][j]=Min[i][k]+Min[k+1][j];
                    s[i][j]=k;
                }
            Min[i][j]+=tmp;
        }
    }
}

void get_Max(int n)
{
    for(int v=2; v&lt;=n; v++) // 枚举合并的堆数规模
    {
        for(int i=1; i&lt;=n-v+1; i++) //枚举起始点i
        {
            int j = i + v-1; //枚举终点j
            Max[i][j] = -1; //初始化为-1
            int tmp = sum[j]-sum[i-1];//记录i...j之间的石子数之和
            if(Max[i+1][j]&gt;Max[i][j-1])
               Max[i][j]=Max[i+1][j]+tmp;
            else
               Max[i][j]=Max[i][j-1]+tmp;
        }
    }
}

void straight(int a[],int n)
{
    for(int i=1;i&lt;=n;i++)  // 初始化
        Min[i][i]=0, Max[i][i]=0, s[i][i]=0;
    sum[0]=0;
    for(int i=1;i&lt;=n;i++)
       sum[i]=sum[i-1]+a[i];
    get_Min(n);
    get_Max(n);
}
void Circular(int a[],int n)
{
    for(int i=1;i&lt;=n-1;i++)
        a[n+i]=a[i];
    n=2*n-1;
    straight(a, n);
    n=(n+1)/2;
    min_Circular=Min[1][n];
    max_Circular=Max[1][n];
    for(int i=2;i&lt;=n;i++)
    {
        if(Min[i][n+i-1]&lt;min_Circular)
           min_Circular=Min[i][n+i-1];
        if(Max[i][n+i-1]&gt;max_Circular)
           max_Circular=Max[i][n+i-1];
    }
}
</code></pre><h2 id="用动态分析解决0-1背包问题"><a href="#用动态分析解决0-1背包问题" class="headerlink" title="用动态分析解决0-1背包问题"></a>用动态分析解决0-1背包问题</h2><p>有n个物品，每个物品的重量为w[i]，价值为v[i]，购物车容量为W。选若干个物品放入购物车，在不超过容量的前提下使获得的价值最大。</p>
<h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>（1）分析最优解的结构特征<br>（2）建立具有最优值的递归式<br>可以对每个物品依次检查是否放入或者不放入，对于第i个物品的处理状态：用c[i][j]表示前i件物品放入一个容量为j的购物车可以获得的最大价值。</p>
<ul>
<li>不放入第i件物品，x<sub>i</sub>=0，装入购物车的价值不增加。那么问题就转化为“前i-1件物品放入容量为j的背包中”，最大价值为c[i-1][j]。</li>
<li>放入第i件物品，x<sub>i</sub>=1，装入购物车的价值增加v<sub>i</sub>。</li>
</ul>
<p>那么问题就转化为了“前i-1件物品放入容量为j-w[i]的购物车中”，此时能获得的最大价值就是c[i-1][j-w[i]]，再加上放入第i件物品获得的价值v[i]。即c[i-1][j-w[i]]+v[i]。<br>购物车容量不足，肯定不能放入；购物车容量组，我们要看放入、不放入哪种情况获得的价值更大。<br>所以，递归函数可以写为：<br>c[i][j]=c[i-1][j]（当j&lt;w<sub>i</sub>）；<br>c[i][j]=max{c[i-1][j-w[i]]+v[i],c[i-1][j]}（当j&gt;w<sub>i</sub>）</p>
<h3 id="算法设计-3"><a href="#算法设计-3" class="headerlink" title="算法设计"></a>算法设计</h3><p>（1）确定合适的数据结构<br>采用一维数组w[i]、v[i]分别记录第i个物品的重量和价值；二维数组用c[i][j]表示前i个物品放入一个容量为j的购物车可以获得的最大价值。<br>（2）初始化<br>初始化c[][]数组0行0列为0，其中i=01,2,…,n，j=0,1,2,…,W。<br>（3）循环阶段</p>
<ul>
<li>按照递归式计算第1个物品的处理情况，得到c[1][j]，j=1,2,…,W；</li>
<li>按照递归式计算第2个物品的处理情况，得到c[2][j]，j=1,2,…,W；</li>
<li>以此类推，按照递归式计算第n个物品的处理情况，得到c[n][j]，j=1,2,…,W。</li>
</ul>
<p>（4）构造最优解<br>c[n][W]就是不超过购物车容量能放入物品的最大价值。如果还想知道具体放入了哪些物品，就需要根据c[][]数组逆向构造最优解，我们可以用一维数组x[i]来存储解向量。</p>
<ul>
<li>首先i=n，j=W，如果c[i][j]&gt;c[i-1][j]，则说明第n个物品放入了购物车，令x[n]=1，j-=w[n]；如果c[i][j]≤c[i-1][j]，则说明第n个物品没有放入购物车，令x[n]=0.</li>
<li>i–，继续查找答案。</li>
<li>直到i=1处理完毕。</li>
</ul>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>假设现在有5个物品，每个物品重量为（2,5,4,2,3），价值为（6,3,5,4,6），购物车容量为10。<br>c[][]如下表：</p>
<table>
<thead>
<tr>
<th>c[][]</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td><strong>0</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>6</td>
<td><strong>6</strong></td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>6</td>
<td><strong>6</strong></td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>0</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>11</td>
<td><strong>11</strong></td>
<td>11</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>6</td>
<td>6</td>
<td>10</td>
<td>10</td>
<td>11</td>
<td><strong>11</strong></td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>0</td>
<td>6</td>
<td>6</td>
<td>10</td>
<td>12</td>
<td>12</td>
<td>16</td>
<td>16</td>
<td>17</td>
<td><strong>17</strong></td>
</tr>
</tbody>
</table>
<p>所以最大价值为c[n][W]=17。<br>首先读取c[5][10]&gt;c[4][10]，说明第5个物品装入了购物车，即x[5]=1，然后j=10-w[5]=10-3=7<br>然后去c[4][7]；<br>c[4][7]=c[3][7]，说明第4个物品没有装入购物车，即x[4]=0；<br>然后去找c[3][7]，依次类推。</p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>#include &lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define maxn 10000
#define M 105
int c[M][maxn];//c[i][j] 表示前i个物品放入容量为j购物车获得的最大价值
int w[M],v[M];//w[i] 表示第i个物品的重量，v[i] 表示第i个物品的价值
int x[M];  //x[i]表示第i个物品是否放入购物车
int main(){
    int i,j,n,W;//n表示n个物品，W表示购物车的容量
    cout &lt;&lt; &quot;请输入物品的个数 n:&quot;;
    cin &gt;&gt; n;
    cout &lt;&lt; &quot;请输入购物车的容量W:&quot;;
    cin &gt;&gt; W;
    cout &lt;&lt; &quot;请依次输入每个物品的重量w和价值v，用空格分开:&quot;;
    for(i=1;i&lt;=n;i++)
        cin&gt;&gt;w[i]&gt;&gt;v[i];
    for(i=1;i&lt;=n;i++)//初始化第0列为0
        c[i][0]=0;
    for(j=1;j&lt;=W;j++)//初始化第0行为0
        c[0][j]=0;
    for(i=1;i&lt;= n;i++)//计算c[i][j]
        for(j=1;j&lt;=W;j++)
            if(j&lt;w[i])  //当物品的重量大于购物车的容量，则不放此物品
                c[i][j] = c[i-1][j];
            else    //否则比较此物品放与不放是否能使得购物车内的价值最大
                c[i][j] = max(c[i-1][j],c[i-1][j-w[i]] + v[i]);
    cout&lt;&lt;&quot;装入购物车的最大价值为:&quot;&lt;&lt;c[n][W]&lt;&lt;endl;

    //用于测试
    for (i=1; i&lt;=n; i++ )
    {
        for (j=1; j&lt;=W; j++ )
          cout &lt;&lt; c[i][j]&lt;&lt;&quot;\t&quot; ;
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;

    //逆向构造最优解
    j=W;
    for(i=n;i&gt;0;i--)
        if(c[i][j]&gt;c[i-1][j])
        {
            x[i]=1;
            j-=w[i];
        }
        else
            x[i]=0;
    cout&lt;&lt;&quot;装入购物车的物品序号为:&quot;;
    for(i=1;i&lt;=n;i++)
        if(x[i]==1)
           cout&lt;&lt;i&lt;&lt;&quot;  &quot;;
    return 0;
}
</code></pre><h3 id="算法分析及改进"><a href="#算法分析及改进" class="headerlink" title="算法分析及改进"></a>算法分析及改进</h3><p>1.算法复杂度分析<br>（1）时间复杂度：O(n<em>W)<br>（2）空间复杂度O(n</em>W)<br>2.算法优化改进<br>使用一个数组dp[]保证第i次循环结束后dp[j]中表示的就是我们定义的c[i][j]。<br>所以代码如下：</p>
<pre><code>void opt1(int n,int W)
{
     for(i=1;i&lt;=n;i++)
        for(j=W;j&gt;0;j--)
            if(j&gt;=w[i])  //当物品的重量大于购物车的容量，比较此物品放与不放是否能使得购物车内的价值最大
              dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
}
</code></pre><p>我们可以缩小范围，因为只有当购物车的容量大于等于物品重量的时候才要更新，所以代码如下：</p>
<pre><code>void opt2(int n,int W)
{
     for(i=1;i&lt;= n;i++)
        for(j=W;j&gt;=w[i];j--)
      //当物品的重量大于购物车的容量
 //比较此物品放与不放是否能使得购物车内的价值最大
           dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
}
</code></pre><p>我们还可以再缩小范围，确定搜索的下界bound</p>
<pre><code>void opt3(int n,int W)
{
     int sum[n];//sum[i]表示从1...i的物品重量之和
     sum[0]=0;
     for(i=1;i&lt;=n;i++)
        sum[i]=sum[i-1]+w[i];
     for(i=1;i&lt;=n;i++)
     {
         int bound=max(w[i],W-(sum[n]-sum[i-1]));
         //w[i]与剩余容量取最大值,
         //sum[n]-sum[i-1]表示从i...n的物品重量之和
         for(j=W;j&gt;=bound;j--)
            //当物品的重量大于购物车的容量
            //比较此物品放与不放是否能使得购物车内的价值最大
           dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
     }
}
</code></pre><h2 id="快速定位—最优二叉搜索树（OBST）"><a href="#快速定位—最优二叉搜索树（OBST）" class="headerlink" title="快速定位—最优二叉搜索树（OBST）"></a>快速定位—最优二叉搜索树（OBST）</h2><h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><p>递归表达式：<br>c[i][j]=0（j=i-1）；<br>c[i][j]=min{c[i][k-1]+c[k+1][j]}+w[i][j]（j≥i）<br>w[i][j]=q<sub>i-1</sub>（j=i-1）；<br>w[i][j]=w[i][j-1]+p<sub>j</sub>+q<sub>j</sub></p>
<h3 id="算法设计-4"><a href="#算法设计-4" class="headerlink" title="算法设计"></a>算法设计</h3><p>（1）确定合适的数据结构<br>一维数组：p[]、q[]分别表示实结点和虚结点的搜索概率<br>二维数组：c[i][j]表示最优二叉搜索树T(i,j)的搜索成本，w[i][j]表示最优二叉搜索树T(i,j)中的所有实结点和虚结点的搜索概率之和，s[i][j]表示最优二叉搜索树T(i,j)的根节点序号。<br>（2）初始化。c[i][i-1]=0.0，w[i][i-1]=q[i-1]，其中i=1,2,3,…,n+1。<br>（3）循环阶段。</p>
<ul>
<li>按照递归式计算元素规模是1的{s<sub>i</sub>}（j=i）的最优二叉搜索树的搜索成本c[i][j]，并记录最优策略，即树根s[i][j]，i=1,2,3,..,n。</li>
<li>按照递归式计算元素规模是2的{s<sub>i</sub>,s<sub>i+1</sub>}（j=i）的最优二叉搜索树的搜索成本c[i][j]，并记录最优策略，即树根s[i][j]，i=1,2,3,..,n-1。</li>
<li>以此类推，直到求出所有元素{s<sub>1</sub>,s<sub>2</sub>,…,s<sub>n</sub>}的最优二叉搜索树的搜索成本c[1][n]和最优策略s[1][n]。</li>
</ul>
<p>（4）构造最优解。</p>
<ul>
<li>首先读取s[1][n]，令k=s[1][n]，输出s<sub>k</sub>为最优二叉搜索树的根。</li>
<li>判断如果k-1&lt;1，表示虚结点e<sub>k-1</sub>是s<sub>k</sub>的左子树；否则，递归求解左子树Construct_Optimal_BST(1,k-1,1)。</li>
<li>判断如果k≥n，表示虚结点e<sub>k</sub>是s<sub>k</sub>的右孩子。；否则，输出s[k+1][n]是s<sub>k</sub>的右孩子，递归求解右子树Construct_Optimal_BST(k+1,n,1)。</li>
</ul>
<table>
<thead>
<tr>
<th>w[][]</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0.06</td>
<td>0.18</td>
<td>0.37</td>
<td>0.52</td>
<td>0.59</td>
<td>0.76</td>
<td><strong>1.00</strong></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>0.08</td>
<td>0.27</td>
<td>0.42</td>
<td>0.49</td>
<td>0.66</td>
<td>0.90</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>0.10</td>
<td>0.25</td>
<td>0.32</td>
<td>0.49</td>
<td>0.73</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>0.07</td>
<td>0.14</td>
<td>0.31</td>
<td>0.55</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0.05</td>
<td>0.22</td>
<td>0.46</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0.05</td>
<td>0.29</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0.10</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>c[][]</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>0.18</td>
<td>0.55</td>
<td>0.95</td>
<td>1.23</td>
<td>1.76</td>
<td><strong>2.52</strong></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>0</td>
<td>0.27</td>
<td>0.67</td>
<td>0.90</td>
<td>1.38</td>
<td>2.09</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>0</td>
<td>0.25</td>
<td>0.46</td>
<td>0.94</td>
<td>1.48</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>0.14</td>
<td>0.45</td>
<td>0.98</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>0.22</td>
<td>0.68</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>0.29</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>s[][]</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td><strong>5</strong></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>void Optimal_BST()
{
    for(i=1;i&lt;=n+1;i++)
    {
        c[i][i-1]=0.0;
        w[i][i-1]=q[i-1];
    }
    for(int t=1;t&lt;=n;t++)//t为关键字的规模
        //从下标为i开始的关键字到下标为j的关键字
        for(i=1;i&lt;=n-t+1;i++)
        {
            j=i+t-1;
            w[i][j]=w[i][j-1]+p[j]+q[j];
            c[i][j]=c[i][i-1]+c[i+1][j];//初始化
            s[i][j]=i;//初始化
            //选取i+1到j之间的某个下标的关键字作为
            //从i到j的根，如果组成的树的期望值当前最小
            //则k为从i到j的根节点
            for(k=i+1;k&lt;=j;k++)
            {
                double temp=c[i][k-1]+c[k+1][j];
                if(temp&lt;c[i][j]&amp;&amp;fabs(temp-c[i][j])&gt;1E-6)
                //C++中浮点数因为精度问题不可以直接比较
                {
                    c[i][j]=temp;
                    s[i][j]=k;//k即为从下标i到j的根节点
                }
            }
            c[i][j]+=w[i][j];
        }
}
void Construct_Optimal_BST(int i,int j,bool flag)
{
    if(flag==0)
    {
        cout&lt;&lt;&quot;S&quot;&lt;&lt;s[i][j]&lt;&lt;&quot; 是根&quot;&lt;&lt;endl;
        flag=1;
    }
    int k=s[i][j];
    //如果左子树是叶子
    if(k-1&lt;i)
    {
        cout&lt;&lt;&quot;e&quot;&lt;&lt;k-1&lt;&lt;&quot; is the left child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl;
    }
    //如果左子树不是叶子
    else
    {
        cout&lt;&lt;&quot;S&quot;&lt;&lt;s[i][k-1]&lt;&lt;&quot; is the left child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl;
        Construct_Optimal_BST(i,k-1,1);
    }
    //如果右子树是叶子
    if(k&gt;=j)
    {
        cout&lt;&lt;&quot;e&quot;&lt;&lt;j&lt;&lt;&quot; is the right child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl;
    }
    //如果右子树不是叶子
    else
    {
        cout&lt;&lt;&quot;S&quot;&lt;&lt;s[k+1][j]&lt;&lt;&quot; is the right child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl;
        Construct_Optimal_BST(k+1,j,1);
    }
}
</code></pre><h3 id="复杂度分析及改进"><a href="#复杂度分析及改进" class="headerlink" title="复杂度分析及改进"></a>复杂度分析及改进</h3><p>时间复杂度为O(n<sup>3</sup>)，空间复杂度为O(n<sup>2</sup>)。<br>又可以用四边形不等式优化（后续研究一下）<br>时间复杂度减少到O(n<sup>2</sup>)。</p>
<pre><code>void Optimal_BST()
{
    for(i=1;i&lt;=n+1;i++)
    {
        c[i][i-1]=0.0;
        w[i][i-1]=q[i-1];
    }
    for(int t=1;t&lt;=n;t++)//t为关键字的规模
        //从下标为i开始的关键字到下标为j的关键字
        for(i=1;i&lt;=n-t+1;i++)
        {
            j=i+t-1;
            w[i][j]=w[i][j-1]+p[j]+q[j];
            int i1=s[i][j-1]&gt;i?s[i][j-1]:i;
            int j1=s[i+1][j]&lt;j?s[i+1][j]:j;
            c[i][j]=c[i][i1-1]+c[i1+1][j];//初始化
            s[i][j]=i1;//初始化
            //选取i1+1到j1之间的某个下标的关键字
            //作为从i到j的根，如果组成的树的期望值当前
            //最小，则k为从i到j的根节点
            for(k=i1+1;k&lt;=j1;k++)
            {
                double temp=c[i][k-1]+c[k+1][j];
                if(temp&lt;c[i][j]&amp;&amp;fabs(temp-c[i][j])&gt;1E-6)
                //C++中浮点数因为精度问题不可以直接比较
                {
                    c[i][j]=temp;
                    s[i][j]=k;//k即为从下标i到j的根节点
                }
            }
            c[i][j]+=w[i][j];
        }
}
void Construct_Optimal_BST(int i,int j,bool flag)
{
    if(flag==0)
    {
        cout&lt;&lt;&quot;S&quot;&lt;&lt;s[i][j]&lt;&lt;&quot; 是根&quot;&lt;&lt;endl;
        flag=1;
    }
    int k=s[i][j];
    //如果左子树是叶子
    if(k-1&lt;i)
    {
        cout&lt;&lt;&quot;e&quot;&lt;&lt;k-1&lt;&lt;&quot; is the left child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl;
    }
    //如果左子树不是叶子
    else
    {
        cout&lt;&lt;&quot;S&quot;&lt;&lt;s[i][k-1]&lt;&lt;&quot; is the left child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl;
        Construct_Optimal_BST(i,k-1,1);
    }
    //如果右子树是叶子
    if(k&gt;=j)
    {
        cout&lt;&lt;&quot;e&quot;&lt;&lt;j&lt;&lt;&quot; is the right child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl;
    }
    //如果右子树不是叶子
    else
    {
        cout&lt;&lt;&quot;S&quot;&lt;&lt;s[k+1][j]&lt;&lt;&quot; is the right child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl;
        Construct_Optimal_BST(k+1,j,1);
    }
}
</code></pre><h2 id="动态规划算法总结"><a href="#动态规划算法总结" class="headerlink" title="动态规划算法总结"></a>动态规划算法总结</h2><p>动态规划关键总结如下：</p>
<ol>
<li>最优子结构判定<ul>
<li>做出一个选择。</li>
<li>假定已经知道了哪种选择是最优的。</li>
<li>最优的会产生哪些子问题。</li>
<li>证明原问题的最优解包含其子问题的最优解。 </li>
</ul>
</li>
<li>如何得到最优解递归式<ul>
<li>分析原问题最优解和子问题最优解的关系。</li>
<li>考察有多少种选择。</li>
<li>得到最优解递归式。</li>
</ul>
</li>
</ol>

    </div>
    
        <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="http://www.yushuai.xyz/zjyt/alipay.jpg"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="http://www.yushuai.xyz/zjyt/weixin.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">感觉不错？欢迎给我 打个赏~我将不胜感激！</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">小奥</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/03/20/lineprograming1/" class="pre-post btn btn-default" title="线性规划1">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">线性规划1</span>
        </a>
    
    
        <a href="/2019/03/20/branchbound/" class="next-post btn btn-default" title="分支限界法">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">分支限界法</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
            appKey: 'erIpQac4azoCmgfBB7Dl9maa',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于最长公共子序列（LCS）"><span class="toc-text">关于最长公共子序列（LCS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#求解最长公共子序列"><span class="toc-text">求解最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法设计"><span class="toc-text">算法设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码演示"><span class="toc-text">代码演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编辑距离"><span class="toc-text">编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编辑距离和LCS的不同点"><span class="toc-text">编辑距离和LCS的不同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现"><span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#游艇租赁问题"><span class="toc-text">游艇租赁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题分析"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法设计-1"><span class="toc-text">算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-1"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现2：最贵的租金"><span class="toc-text">代码实现2：最贵的租金</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速计算——矩阵连乘"><span class="toc-text">快速计算——矩阵连乘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法设计-2"><span class="toc-text">算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举例图解"><span class="toc-text">举例图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-2"><span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最优三角剖分"><span class="toc-text">最优三角剖分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#与矩阵连乘的不同点"><span class="toc-text">与矩阵连乘的不同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解示例"><span class="toc-text">图解示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-3"><span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#石子合并"><span class="toc-text">石子合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#递归公式："><span class="toc-text">递归公式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-4"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改进算法"><span class="toc-text">改进算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用动态分析解决0-1背包问题"><span class="toc-text">用动态分析解决0-1背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题分析-1"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法设计-3"><span class="toc-text">算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解"><span class="toc-text">图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-5"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法分析及改进"><span class="toc-text">算法分析及改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速定位—最优二叉搜索树（OBST）"><span class="toc-text">快速定位—最优二叉搜索树（OBST）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题分析-2"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法设计-4"><span class="toc-text">算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-6"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂度分析及改进"><span class="toc-text">复杂度分析及改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划算法总结"><span class="toc-text">动态规划算法总结</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>