<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="小奥の部落格">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://tech.yushuai.xyz">
    <!--SEO-->

    <meta name="keywords" content="算法,回溯法">


    <meta name="description" content="回溯法回溯法的思想是：能进则进，进不了换，换不了退。隐约束指对能否得到问题的可行解和最优解做出的约束。隐约束包括约束函数和限界函数。关键步骤是：

定义解空间；
确定解空间的组织结构（子集树、排...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>回溯法 | 小奥の部落格</title>


    <link rel="alternate" href="/atom.xml" title="小奥の部落格" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1276822649 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1276822649%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="小奥">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 不忘初心，奋力前行！ </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://tech.yushuai.xyz">小奥の部落格</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/algorithm/"><i class="fa "></i>Algorithm</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Speech-Process-Notes/"><i class="fa "></i>Speech Process Notes</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/C-C/"><i class="fa "></i>C/C++</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/数据结构/"><i class="fa "></i>Data Structure</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Learning-Notes/"><i class="fa "></i>Learning Notes</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>Time Line</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="http://www.yushuai.xyz/cv"><i class="fa "></i>About</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="回溯法">
            
	            回溯法
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/algorithm/">algorithm</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/回溯法/">回溯法</a> <a class="tag-link" href="/tags/算法/">算法</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/03/20</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯法的思想是：<strong>能进则进，进不了换，换不了退</strong>。<br><strong>隐约束</strong>指对能否得到问题的可行解和最优解做出的约束。隐约束包括<strong>约束函数</strong>和<strong>限界函数</strong>。<br>关键步骤是：</p>
<ol>
<li>定义解空间；</li>
<li>确定解空间的组织结构（子集树、排列数、m叉树等）；</li>
<li>搜索解空间。</li>
</ol>
<p>回溯法阶梯的关键是设计有效的<strong>显约束</strong>和<strong>隐约束</strong>。</p>
<h2 id="大卖场购物（0-1背包问题）"><a href="#大卖场购物（0-1背包问题）" class="headerlink" title="大卖场购物（0-1背包问题）"></a>大卖场购物（0-1背包问题）</h2><h3 id="问题举例"><a href="#问题举例" class="headerlink" title="问题举例"></a>问题举例</h3><p>每个物品重量w和价值v如下表所示，购物车容量为W，求不超过购物车重量的最大价值。</p>
<table>
<thead>
<tr>
<th>w[]</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>2</td>
<td>5</td>
<td>4</td>
<td>2 </td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>w[]</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>6</td>
<td>3</td>
<td>5</td>
<td>4 </td>
</tr>
</tbody>
</table>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ol>
<li>解空间={x<sub>1</sub>,x<sub>2</sub>,…,x<sub>i</sub>,…,x<sub>n</sub>}的所有子集（包括{0,0,0}这种子集），你像这里面就是{0,0,0,0},{0,0,0,1},{0,0,1,0},{0,0,1,1},…{1,1,1,1}。<strong>显约束</strong>为x<sub>i</sub>=0或1。</li>
<li>确定解空间的组织结构。由于显约束的缘故，可以看出解空间为子集树。</li>
<li>搜索解空间</li>
</ol>
<ul>
<li>约束条件为：w<sub>i</sub>x<sub>i</sub>≤W（i=1~n）</li>
<li>限界条件：cp+rp&gt;bestp（cp为当前已经装入购物车的物品的总价值，rp为第t+1~第n种物品的总价值，bestp为最大价值）</li>
</ul>
<ol start="4">
<li>搜索过程见问题求解。</li>
</ol>
<h3 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h3><p>（1）首先初始化。w[]={2,5,4,2}，v[]={6,3,5,4}，sumw=2+5+4+2=13，sumv=6+3+5+4=18，因为<strong>sumw&gt;W</strong>，所以不能装完，所以需要进行后续的操作。此时定义一个cp=rp=bestp=0，x[i]=0，cw=0。<br><strong><font color="red">注意：在这里w[]和v[]的下标都是从1开始。并且以左子树为x<sub>i</sub>=1，右子树x<sub>i</sub>=0。</font></strong></p>
<p>（2）开始搜索第一层（t=1）。cw=cw+w[1]=2&lt;W，所以令x[1]=1，<br>cp=cp+v[1]=6，将2号结点加入<strong>左子树</strong>。(2号结点是第一个商品）</p>
<p>（3）拓展2号结点。考虑cw+w[2]=7&lt;W，所以令x[2]=1，cp=cp+v[2]=9，将3号结点加入<strong>左子树</strong>。（3号结点是第2个商品）</p>
<p>（4）拓展3号结点。考虑cw+w[3]=11&gt;W，所以x[3]=0，然后计算cp+rp=9+4=13&gt;bestp（此时bestp还是0），所以将4号结点加入<strong>右子树</strong>。（4号结点是第3个商品）</p>
<p>（5）拓展4号结点。考虑cw+w[4]=9&lt;W，所以x[4]=1，然后计算cp=cp+v[4]=13，所以将5号结点加入<strong>左子树</strong>。（5号结点是第4个商品）</p>
<p>（6）拓展5号结点。由于此时t&gt;n，故已经找到了一个当前的最优解，令bestp=cp（值为13），5号结点成为死结点。返回到上一结点。</p>
<p>（7）<strong>回溯</strong>拓展4号。此时cp=9，若将5号结点加入右子树，cp+rp=9&lt;bestp，故该结点不满足限界条件，成为死结点，继续回溯到3号结点。<strong>由于3号结点已经研究过，左子树不可行，所以回溯到2号结点。</strong></p>
<p>（8）扩展2号结点（t=2）。之前扩展了左子树，所以现在考虑右子树。此时cp=6，bound(t+1)=cp+rp=15&gt;bestp，因此满足限界条件，扩展右子树，令x[2]=0，生成6号结点。（也就是第2个商品不要了）</p>
<p>（9）扩展6号结点（t=3）。cw+w[3]=6&lt;W，满足约束条件，扩展左分支，令x[3]=1，cw=cw+w[3]=6，cp=cp+v[3]=11，生成7号结点加入<strong>左子树</strong>。（7号结点是第3件商品）。</p>
<p>（10）拓展7号结点（t=4）<br>cw+w[4]=8&lt;W，满足约束条件，扩展到<strong>左子树</strong>。令x[4]=1，cw=cw+w[4]=8，cp=cp+v[4]=15。（8号结点是第4件商品）</p>
<p>（11）拓展8号结点（t=5）。由于此时t&gt;n，故已经找到了一个当前的最优解，令bestp=cp（值为15），8号结点成为死结点。返回到上一结点。</p>
<p>（12）拓展7号结点（t=4）。考察bound(t+1)=cp+rp=11&lt;15，成为死结点。</p>
<p>（13）拓展6号结点（t=3）。bound(t+1)=cp+rp=10&lt;15，成为死结点。</p>
<p>（14）拓展1号结点（t=1），bound(t+1)=12&lt;15，成为死结点。算法结束。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>double Bound(int i)//计算上界
{
    int rp=0;//剩余重量
    while (i &lt;= n)
    {
        rp += v[i];
        i++;
    }
    return rp+cp;
}

void Backtrack(int t)//t当前在第t层
{
    if (t &gt; n)
    {
        for (i = 1; i &lt;= n; i++)
        {
            bestx[i] = x[i];
        }
        bestp = cp;
        return;
    }
    if (cw + w[t] &lt;= W)//还未到重量，可以搜索左子树
    {
        x[t] = true;
        cw += w[t];
        cp += v[t];
        Backtrack(t + 1);
        cw -= w[t];//回溯
        cp -= v[t];//回溯
    }
    //若左子树不满足，然后看右子树，判断限界条件
    if (Bound(t + 1) &gt; bestp)
    {
        x[t] = false;
        Backtrack(t + 1);
    }
}
void initial_parameter(double W, int n)
{
    cw = 0;//初始化当前重量为0
    cp = 0;//初始化当前价值为0
    bestp = 0;//初始化当前最好价值为0
    int sumw = 0;//统计所有物品的总重量
    int sumv = 0;//统计所有物品价值
    //这里上面两个参数可以根据具体情况确定为int或者double等
    for (i = 1; i &lt;= n; i++)
    {
        sumw += w[i];
        sumv += v[i];
    }
    if (sumw &lt;= W)
    {
        bestp = sumv;
        cout &lt;&lt; &quot;所有物品均放入购物车&quot;;
        cout &lt;&lt; &quot;放入购物车的最大价值为&quot; &lt;&lt; bestp &lt;&lt; &quot;元。&quot; &lt;&lt; endl;
        return;
    }
    Backtrack(1);
    cout &lt;&lt; &quot;放入购物车的最大价值为&quot; &lt;&lt; bestp &lt;&lt; &quot;元。&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;放入购物车的物品序号为：&quot;;
    for (i = 1; i &lt;= n; i++)
    {
        if (bestx[i] == true)
            cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}
</code></pre><h3 id="算法复杂度和改进"><a href="#算法复杂度和改进" class="headerlink" title="算法复杂度和改进"></a>算法复杂度和改进</h3><p>1.算法复杂度<br>（1）时间复杂度：O(1<em>2<sup>n</sup>+n </em> 2<sup>n</sup>)=O(n * 2<sup>n</sup>)。<br>（2）空间复杂度：O(n)。<br>2.算法优化<br>实际上，经常我们在计算bound()函数的时候对于rp多算太多了，因为很有可能rp到某一步就超过了购物车的中梁，所以我们可以缩小上界，从而加快剪枝速度，提高搜索效率。<br>上界函数bound()：当前价值cp+剩余容量可容纳的剩余物品的最大价值brp（为了能装最大价值，所以在计算上界函数的时候可以对商品分割，<strong>但实际的时候不允许</strong>），即修改为</p>
<pre><code>double bound(int i)
{
    //剩余物品为第i~n种物品
    double cleft=W-cw;//剩余容量
    while(i&lt;=n &amp;&amp; w[i]&lt;cleft)
    {
        cleft-=w[i];
        brp+=v[i];
        i++
    }
    //下面是采用切割的方式装满背包，这里是求上界，
    //所以可以这样做。实际是不允许的
    if(i&lt;=n)
    {
        brp+=v[i]/w[i]*cleft;
    }
    return cp+brp;
}
</code></pre><p>为了更好地计算和运用上界函数剪枝，先将物品按照其单位重量价值（价值/重量）从大到小排序，然后按照排序后的顺序考察各个物品。即定义这样一个结构体：</p>
<pre><code>struct Object
{
    int id;//物品序号
    double ;//单位重量价值
};

bool cmp(Object a1, Object a2)
{
    return a1.d&gt;a2.d;
}
</code></pre><p> 然后将 initial_parameter(double W, int n)的if(sumw&lt;=W)这个语段后面加入：</p>
<pre><code>sort(Q,Q+n,cmp);
for(i=1;i&lt;=n;i++)
{
    a[i]=w[Q[i-1].id];//把排序后的数据传递给辅助数组
    b[i]=v[Q[i-1].id];
}
for(i=1;i&lt;=n;i++)
{
    w[i]=a[i];
    v[i]=b[i];
}
</code></pre><p> 然后将</p>
<pre><code> for (i = 1; i &lt;= n; i++)
{
    if (bestx[i] == true)
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
}
</code></pre><p>修改为</p>
<pre><code>    for (i = 1; i &lt;= n; i++)
{
    if (bestx[i] == true)
        cout &lt;&lt; Q[i-1].id &lt;&lt; &quot; &quot;;
}
</code></pre><h2 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>部落酋长希望组织一支保卫部落的卫队，要在居民中选出最多的居民加入，并保证卫队中任何两个人都不是仇敌。编程计算构建部落护卫队的最佳方案。</p>
<h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>完全子图：给定无向图<strong>G</strong>(V,E)，其中V是结点集，E是边集。<strong>G’</strong>=(V’,E’)。如果结点集V’⊆V，E’⊆E，且<strong>G’*</strong>中的任意两个结点都有边相连，则成<strong>G’</strong>是<strong>G</strong>的完全子图。</li>
<li><strong>当且仅当</strong>G’不包含在G的更大的完全子图中时，<strong>G</strong>的完全子图<strong>G’</strong> 是 <strong>G</strong>的团，就是说<strong>G’</strong> 是 <strong>G</strong>的极大完全子图。</li>
<li>最大团：G的最大团是指G所有团中，含结点数最多的团。</li>
</ul>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ol>
<li>定义问题的解空间。问题的解空间为 {x<sub>1</sub>,x<sub>2</sub>,…,x<sub>i</sub>,…,x<sub>n</sub>}的所有子集（包括{0,0,0}这种子集），你像这里面就是{0,0,0,0},{0,0,0,1},{0,0,1,0},{0,0,1,1},…{1,1,1,1}。<strong>显约束</strong>为x<sub>i</sub>=0或1。</li>
<li>解空间的组织结构：子集树，深度为<em>n</em>。</li>
<li>搜索解空间：<ul>
<li>约束条件：假设当前扩展结点位于解空间树的第t层，那么从第1到第t-1层的结点情况都已经确定，接下来是按照扩展结点的左分支进行扩展，此时需要判断是否将第t个结点放到团里，只要第t和结点和前面t-1个结点中<strong>被选中的结点</strong>都有边连接，那么就能放到团里，即x[i]=1，否则不能放到团里，即x[i]=0。</li>
<li>限界条件：根据前t个结点的状态确定当前已经放入团中的结点个数（用cn表示），假想t+1个结点到第n结点全部放入团内，放入的节点个数（fn表示），fn=n-t，则cn+fn是所有从根出发的路径中经过中间结点z的可行解所包含结点个数的上界。若cn+fn&gt;bestn，则需要向子孙结点搜索，否则不需要。所以限界条件为<strong>cn+fn&gt;bestn</strong>。</li>
</ul>
</li>
</ol>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>bool isPlace(int t)
{
    bool status = true;
    for (int j = 1; j &lt; t; j++)
    {
        if (x[j] &amp;&amp; a[t][j] == 0)
        {
            status = false;
            break;
        }
    }
    return status;
}

//回溯法主体
void backtrack(int t)
{
    //到达叶结点
    if (t &gt; n)
    {
        for (int i = 1; i &lt;= n; i++)
            bestx[i] = x[i];
        bestn = cn;
        return;
    }

    if (isPlace(t))
    {
        x[t] = 1;
        cn++;
        backtrack(t + 1);
        cn--;
    }
    if (cn + n - t &gt; bestn)//这里可以进行优化
    {
        x[t] = 0;
        backtrack(t + 1);
    }
}
</code></pre><h3 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><p>1.时间复杂度：O(n* 2<sup>n</sup>)，空间复杂度为O(n)。</p>
<h2 id="着色问题"><a href="#着色问题" class="headerlink" title="着色问题"></a>着色问题</h2><h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><p>假设地图共有7个区域，分别是A/B/C/D/E/F/G，对上面顺序进行编号，每个区域用一个结点表示，相邻的区域有连线，那么地图就转化成一个无向连接图。</p>
<h3 id="算法设计-1"><a href="#算法设计-1" class="headerlink" title="算法设计"></a>算法设计</h3><ol>
<li>定义问题的解空间。图的m着色问题解空间形式为n元组{x<sub>1</sub>,x<sub>2</sub>,…,x<sub>i</sub>,…,x<sub>n</sub>}，每个分量取值为1,2,3,…,m，即问题的解是一个n元向量。由此可得，问题的解空间为{x<sub>1</sub>,x<sub>2</sub>,…,x<sub>i</sub>,…,x<sub>n</sub>}，其中显约束为x<sub>i</sub>=1,2,…,m。</li>
<li>确定解空间的组织结构：一颗满m叉树，树的深度为n。</li>
<li>搜索解空间<ul>
<li>约束条件：假设当前扩展结点位于解空间树的第t层，那么从第1到第t-1层的结点情况都已经确定，接下来是按照扩展结点的第一个分支进行扩展，此时需要判断是否将第t个结点着色情况。第t个结点的色号要与前t-1个结点中与其有边相连的结点颜色不同，如果有颜色相同的，则第t个结点不能用这个色号，换下一个色号尝试。</li>
<li>限界条件：无。</li>
<li>搜索过程：扩展结点沿着第一个分支扩展，判断约束条件，满足则进入深一层继续搜索；如果不满足，则扩展生成的结点被剪掉，换下一个色号尝试。如果所有色号都尝试完毕，该结点变成死结点，向上回溯到距离其最近的活结点，继续搜索。搜索到叶子结点时，找到一种着色方案，搜索过程直到全部活结点变成死结点为止。</li>
</ul>
</li>
</ol>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>地图7个区域，3种颜色。</p>
<ol>
<li>开始搜索第1层（t=1）。扩展A结点第一个分支，首先判断是否满足约束条件，因为之前还未着色任何结点，所以满足约束条件，扩展该分支，令1号结点着1号色，即x[1]=1，生成B。</li>
<li>拓展B结点（t=2）。扩展第一个分支x[2]=1，首先判断2号结点是否和前面已经确定色号的结点（1号）有边相连且色号相同，不满足约束条件，剪掉该分支，然后沿着x[2]=2扩展，2号结点和前面已经确定色号的结点（1号）有边相连，但色号不同，满足约束条件，扩展该分支，令x[2]=2。</li>
<li>扩展C结点（t=3）。扩展第一个分支x[3]=1，首先判断3号结点是否和前面已经确定色号的结点（1、2号）有边相连且色号相同，不满足约束条件，剪掉该分支；同理剪掉x[3]=2分支。然后沿着x[3]=3扩展，3号结点和前面已经确定色号的结点（1、2号）有边相连，但色号不同，满足约束条件，扩展该分支，令x[3]=3。生成D。</li>
<li>扩展D结点（t=4）。扩展第一个分支x[4]=1，首先判断4号结点是否和前面已经确定色号的结点（1、2、3号）有边相连且色号相同，不满足约束条件（4余1相连），剪掉该分支；然后令x[4]=2，符合条件，生成E。</li>
<li>扩展E结点（t=5）。扩展第一个分支x[5]=1，首先判断4号结点是否和前面已经确定色号的结点（1、2、3号）有边相连且色号相同，确定5与2、3、4相连但色号不同，满足约束条件，扩展该分支，生成F。</li>
<li>扩展F结点（t=6）。扩展第一个分支x[6]=1，同理不满足，剪掉分支；然后沿着x[6]=2扩展，6与5号有边相连但色号不同，故满足约束条件，扩展该分支，令x[6]=2，生成G。</li>
<li>扩展G结点（t=7）。扩展第一个分支x[7]=1，剪掉x[7]=1和x[7]=2的分支，然后令x[7]=3，符合要求，生成H。</li>
<li>扩展H结点（t=8）。t&gt;n，找到一个可行解，输出该可行解{1,2,3,2,1,2,3}，回溯到最近的活结点G。</li>
<li>重新扩展G结点（t=7）。G已经考察完毕，成为死结点，回溯到最近的活结点F。</li>
<li>继续搜索，又找到第二种着色方案，输出可行解{1,3,2,3,1,3,2}。 </li>
<li>继续搜索，又找到4个可行解。</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>//约束条件
bool isRight(int t)
{
    for (int j = 1; j &lt; t; j++)
    {
        if (map[t][j])
        {
            if (x[j] == x[t])
                return false;
        }
    }
    return true;
}

//回溯方法函数
void Backtrack(int t)
{
    if (t &gt; n)
    {
        sum++;
        cout &lt;&lt; &quot;第&quot; &lt;&lt; sum &lt;&lt; &quot;种方案：&quot;;
        for (int i = 1; i &lt;= n; i++)//输出该着色方案
        {
            cout &lt;&lt; x[i] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
    else {
        for (int i = 1; i &lt;= m; i++)
        {
            x[t] = i;
            if (isRight(t))
                Backtrack(t + 1);
        }
    }
}
</code></pre><h3 id="算法复杂度分析-1"><a href="#算法复杂度分析-1" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ol>
<li>时间复杂度：O(nm<sup>n</sup>)。</li>
<li>空间复杂度：O(n)。</li>
</ol>
<h2 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h2><h3 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>在n×n的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋规则，皇后可以攻击与之在同一行、同一列、同一斜线上的棋子。现在在n*n的棋盘上放置n个皇后，使其不受攻击。</p>
<h3 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h3><p> 求解策略：<br> 以行为主导：</p>
<ul>
<li>在第1行第1列放置第一个皇后。</li>
<li>在第2行放置第2个皇后。第2个皇后的位置不能和前面的皇后同列、同斜线，不用再判断同行了，因为每行我们本来就只放一个。</li>
<li>在第3行放置第3个皇后。第3个皇后的位置不能和前面的皇后同列、同斜线。</li>
<li>……</li>
<li>在第t行放置第t个皇后。第t个皇后的位置不能和前面的皇后同列、同斜线。</li>
<li>……</li>
<li>在第n行放置第n个皇后。第n个皇后的位置不能和前面的皇后同列、同斜线。</li>
</ul>
<h3 id="算法设计-2"><a href="#算法设计-2" class="headerlink" title="算法设计"></a>算法设计</h3><p>（1）定义问题的解空间。n皇后问题解的形式为n元组：{x<sub>1</sub>,x<sub>2</sub>,…,x<sub>i</sub>,…,x<sub>n</sub>}，分量x<sub>i</sub>表示第i个皇后放置在第i行第x<sub>i</sub>列，x<sub>i</sub>取值为1,2,3,…,n。显约束为不同行。</p>
<p>（2）解空间的组织结构：一颗m(m=n)叉树，树深度为n。</p>
<p>（3）搜索解空间。<br>约束条件：在第t行放置第t个皇后时，第t个皇后的位置不能和前t-1个皇后同列、同斜线。第i个皇后和第j个皇后不同列，即x<sub>i</sub>!=x<sub>j</sub>。</p>
<p>限界条件：不需要设置。</p>
<p>搜索过程：</p>
<p>从根开始，以DFS的方式进行搜索。根节点是活结点，并且是当前的扩展结点。在搜索过程中，当前的扩展结点沿纵深方向移向一个新结点，判断该新结点是否满足隐约束。如果满足，则该新结点成为活结点，并且成为当前的扩展结点，继续深一层的搜索；如果不满足，则换到该新结点的兄弟结点继续搜索；如果新结点没有兄弟结点，或其兄弟结点已全部搜索完毕，则扩展结点成为死结点，搜索回溯到其父结点处继续进行。搜索过程直到找到问题的根结点变成死结点为止。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>bool isPlace(int t)
{
    bool place = true;
    for (int j = 1; j &lt; t; j++)
    {
        if (x[t] == x[j] || t - j == fabs(x[t] - x[j]))//判断列、对角线是否冲突
        {
            place = false;
            break;
        }
    }
    return place;
}

void backtrack(int t)
{
    if (t &gt; n)
    {
        countn++;
        for (int i = 1; i &lt;= n; i++)
        {
            cout &lt;&lt; x[i] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
        cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;
    }
    else
    {//分别判断n个分支，特别注意i不要定义为全局变量，否则递归调用有问题
        for (int i = 1; i &lt;= n; i++)
        {
            x[t] = i;
            if (isPlace(t))
                backtrack(t + 1);
            //上面说的是不冲突就进行下一行搜索
        }
    }
}
</code></pre><h3 id="算法复杂度分析-2"><a href="#算法复杂度分析-2" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ol>
<li>时间复杂度：O(n<sup>n+1</sup>）。</li>
<li>空间复杂度：O(n)。</li>
</ol>
<h2 id="最优加工顺序"><a href="#最优加工顺序" class="headerlink" title="最优加工顺序"></a>最优加工顺序</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>现在有3个机器零件{J<sub>1</sub>,J<sub>2</sub>,J<sub>3</sub>}，在第一台机器上的加工时间分别为2、5、4，在第二台机器上的加工时间分别为3、1、6.如何安排零件加工顺序，使第一个零件从机器1上加工开始到最后一个零件在机器2上加工完成，所需的总加工时间最短？</p>
<h3 id="问题分析-4"><a href="#问题分析-4" class="headerlink" title="问题分析"></a>问题分析</h3><p>我们通过分析可以发现，第一台机器可以连续加工，而第二台机器开始加工的时间是<strong>当前第一台机器的下线时间</strong>和<strong>第二台机器下线时间</strong>的<font color="red"><strong>最大值</strong></font>。<br>实际上就是找到n个机器零件的一个排列，使总的加工时间最短。</p>
<h3 id="算法设计-3"><a href="#算法设计-3" class="headerlink" title="算法设计"></a>算法设计</h3><ol>
<li>定义问题的解空间。解的形式为n元组：{x<sub>1</sub>,x<sub>2</sub>,…,x<sub>i</sub>,…,x<sub>n</sub>}，分量x<sub>i</sub>表示第i个加工的零件号，n个零件组成的集合为S={1,2,…,n}，x<sub>i</sub>取值为S-{x<sub>1</sub>,x<sub>2</sub>,…,x<sub>i-1</sub>}。</li>
<li>解空间的组织形式为一颗排列数，深度为n。</li>
<li>搜索解空间。<ul>
<li>约束条件：无约束条件。</li>
<li>限界条件：用f<sub>2</sub>表示当前已完成的零件在第二台机器加工结束所用的时间，用bestf表示当前找到的最优加工方案的完成时间。显然，继续向深处搜索时，f<sub>2</sub>不会减少，只会增加。因此，当f<sub>2</sub>≥bestf时，没有继续向深处搜索的必要。限界条件可以描述为：<font color="red"><strong>f<sub>2</sub>&lt;bestf</strong></font>。f<sub>2</sub>初值为0，bestf的初值为无穷大。</li>
</ul>
</li>
<li>搜索过程。扩展结点沿着某个分支扩展时需要判断限界条件，如果满足，则进入深一层继续搜索；如果不满足，则剪掉该分支。搜索到叶子结点的时候，即找到当前最优解。搜索直到全部活结变成死结点为止。</li>
</ol>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.数据结构</p>
<pre><code>struct node
{
    //机器零件在第一台机器上的加工时间x和第二胎机器上的加工时间y
    int x,y;
}T[MAX];
</code></pre><p>2.按限界条件进行搜索求解：t表示当前扩展结点在第t层，f<sub>1</sub>表示当前第一台机器上加工的完成时间，f<sub>2</sub>表示当前第二台机器上加工的完成时间。如果t&gt;n表示已经到达叶子结点，记录最优值和最优解，返回。否则，分别判断每个分支是否满足约束条件，若满足则进入下一层backtrack(t+1)；如果不满足则反操作复位，考察下一个分支（兄弟结点）。</p>
<pre><code>void Backtrack(int t)
{
    if(t&gt;n)
    {
        for(int i=1;i&lt;=n;i++)
            bestx[i]=x[i];//记录最优队列
        bestf=f2;//更新最优值
        return ;
    }
    for(int i=t;i&lt;=n;i++)
    {
        f1+=T[x[i].x;
        int temp=f2;
        f2=max(f1,f2)+T[x[i]].y;
        if(f2&lt;bestf)//满足限界条件
        {
            swap(x[t],x[i]);//交换
            Backtrack(t+1);//继续搜索
            swap(x[t],x[i]);//复位，反操作
        }
        f1-=T[x[i]].x;//复位，反操作
        f2=temp;//复位，反操作
    }
}
</code></pre><h3 id="算法复杂度分析-3"><a href="#算法复杂度分析-3" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><p>时间复杂度为O(nn!)≈O((n+1)!)，空间复杂度为O(n)。</p>
<h3 id="算法优化改进"><a href="#算法优化改进" class="headerlink" title="算法优化改进"></a>算法优化改进</h3><p>新的算法的时间复杂度为O(nlogn)，空间复杂度为O(n)。利用贝尔曼规则，代码如下：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std ;
const int MX=10000+5 ;
int n;
struct node
{
    int id;
    int x,y;
}T[MX] ;
bool cmp(node a,node b)
{
    return min(b.x,a.y)&gt;=min(b.y,a.x);//按照贝尔曼规则排序
}
int main()
{
    cout&lt;&lt;&quot;请输入机器零件的个数 n:&quot;;
    cin&gt;&gt;n;
    cout&lt;&lt;&quot;请依次输入每个机器零件在第一台机器上的加工时间x和第二台机器上的加工时间y:&quot;;
    for(int i=0;i&lt;n;i++)
    {
        cin&gt;&gt;T[i].x&gt;&gt;T[i].y;
        T[i].id=i+1;
    }
    sort(T,T+n,cmp);   //排序
    int f1=0,f2=0;
    for(int i=0;i&lt;n;i++)  //计算总时间
    {
       f1+=T[i].x;
       f2=max(f1,f2)+T[i].y;
     }
    cout&lt;&lt;&quot;最优的机器零件加工顺序为:&quot;;
     for(int i=0;i&lt;n;i++) //输出最优加工顺序
       cout&lt;&lt;T[i].id&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
    cout&lt;&lt;&quot;最优的机器零件加工的时间为:&quot;;
    cout&lt;&lt;f2&lt;&lt;endl;
    return 0 ;
}
</code></pre><h2 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设有5个点，这五个点之间是用无向边来连接的，但是每一个边是有权重的，这实际上是一个无向带权图。我们希望在最小权重的情况下走过这5个点，且不重复，那应该怎样来实现呢？</p>
<h3 id="算法设计-4"><a href="#算法设计-4" class="headerlink" title="算法设计"></a>算法设计</h3><ol>
<li>定义问题的解空间：问题解的形式为n元组{x<sub>1</sub>,x<sub>2</sub>,…,x<sub>i</sub>,…,x<sub>n</sub>}，分量x<sub>i</sub>表示第i个要去的旅游景点编号，景点的集合为S={1,2,…,N}。因为景点不可重复走，因此在确定x<sub>i</sub>时，前面走过的景点{x<sub>1</sub>,x<sub>2</sub>,…,x<sub>i</sub>,…,x<sub>i-1</sub>}不能再走。x<sub>i</sub>的取值为S-{x<sub>1</sub>,x<sub>2</sub>,…,x<sub>i</sub>,…,x<sub>i-1</sub>}。</li>
<li>解空间的组织形式：解空间是一颗排列树，树的深度为n=5。除了开始结点1之外，一共有24种排列方式。</li>
<li>搜索解空间：约束条件：用二维数组g[][]储存无向带权图的邻接矩阵，如果g[i][j]≠无穷表示城市i和城市j又边相连，能走通。限界条件：cl&lt;bestl。cl的初始值为0，表示当前已经走过的城市所用的路径长度；bestl初始值为无穷，表示当前找到的最短路径的路径长度。</li>
<li>搜索过程：扩展结点沿着某个分支扩展时需要判断约束条件和限界条件，如果满足，则进入深一层继续搜索，如果不满足，则剪掉该分支。搜索到叶子结点时，即找到了当前最优解。搜索直到全部的活结点变成死结点为止。</li>
</ol>
<h3 id="完美图解"><a href="#完美图解" class="headerlink" title="完美图解"></a>完美图解</h3><p>（1）数据结构：如下表所示的邻接矩阵。</p>
<table>
<thead>
<tr>
<th></th>
<th>3</th>
<th></th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td></td>
<td>3</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td></td>
<td>3</td>
<td></td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>10</td>
<td>4</td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>9</td>
<td>5</td>
<td>3</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>（图中未填的就是无穷）</p>
<p>（2）初始化：cl=0,bestl=无穷，解分量x[i]和最优解bestx[i]初始化为：</p>
<table>
<thead>
<tr>
<th>i</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>x[i]</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>i</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>bestx[i]</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>（3）开始搜索第一层（t=1）</p>
<p>扩展A<sub>0</sub>结点，因为我们是从1号结点出发，所以x[1]=1，生成A结点。</p>
<p>（4）扩展A结点（t=2）<br>沿着x[2]=2分支扩展，因为1号结点和2号结点有边相连，且cl+g[1][2]=0+3&lt;bestl，满足限界条件，生成B结点。</p>
<p>（5）扩展B结点（t=3）<br>沿着x[3]=3分支扩展，因为2号结点和3号结点有边相连，且cl+g[2][3]=3+3=6&lt;bestl，满足限界条件，生成C结点。</p>
<p>（6）扩展C结点（t=4）<br>沿着x[4]=4分支扩展，因为3号结点和4号结点有边相连，且cl+g[3][4]=6+4=10&lt;bestl，满足限界条件，生成D结点。</p>
<p>（7）扩展D结点（t=5）<br>沿着x[5]=5分支扩展，因为4号结点和5号结点有边相连，且cl+g[3][4]=10+20=30&lt;bestl，满足限界条件，生成E结点。</p>
<p>（8）扩展E结点（t=6）<br>t&gt;n，判断5号结点是否和1号结点相连，确认有，且cl+g[5][1]=30+9=39&lt;bestl，找到一个当前最优解（1,2,3,4,5,1），更新bestl=39。</p>
<p>（9）向上回溯到D，D的孩子已经生成完毕，成为死结点，继续回溯到C，C结点还有一个孩子未生成。<br>（10）重新扩展C结点（t=4）。沿着x[4]=5分支扩展，因为3号结点和5号结点有边相连，且cl+g[3][5]=6+3=9&lt;bestl=39，满足限界条件，生成F结点。</p>
<p>（11）扩展F结点（t=5）。<br>沿着x[5]=4分支扩展，因为5号结点和4号结点有边相连，且cl+g[5][4]=9+20=29&lt;bestl=39，满足限界条件，生成G结点。</p>
<p>（12）扩展G结点（t=6）。t&gt;n，判断4号结点是否和1号结点相连，确认有，且cl+g[4][1]=29+8=37&lt;bestl=39，找到一个当前最优解（1,2,3,5,4,1），更新bestl=37。</p>
<p>不断搜索下去，到最后有以下组合和其值。</p>
<table>
<thead>
<tr>
<th>i</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>权值</th>
</tr>
</thead>
<tbody>
<tr>
<td>结点组合</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>39</td>
</tr>
<tr>
<td>结点组合</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>4</td>
<td>37</td>
</tr>
<tr>
<td>结点组合</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>3</td>
<td>5</td>
<td>29</td>
</tr>
<tr>
<td>结点组合</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>3</td>
<td>4</td>
<td>23</td>
</tr>
<tr>
<td>结点组合</td>
<td>1</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>5</td>
<td>29</td>
</tr>
<tr>
<td>结点组合</td>
<td>1</td>
<td>4</td>
<td>3</td>
<td>5</td>
<td>2</td>
<td>23</td>
</tr>
<tr>
<td>结点组合</td>
<td>1</td>
<td>5</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>29</td>
</tr>
</tbody>
</table>
<p>综上所述，bestl=23，路径为1-2-5-3-4-1。</p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>//初始化
void init()
{
    bestl = INF;
    cl = 0;
    for (int i = 1; i &lt;= n; i++)
        for (int j = i; j &lt;= n; j++)
            g[i][j] = g[j][i] = INF;
    for (int i = 0; i &lt;= n; i++)
    {
        x[i] = i;
        bestx[i] = 0;
    }
}
//邻接矩阵赋值
void createMatrix()
{
    int u, v, w;//结点u和v，权值w
    cout &lt;&lt; &quot;请依次输入两个结点u和v之间的权值w。&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;格式：结点u 结点v 距离w&quot; &lt;&lt; endl;
    for (int i = 1; i &lt;= m; i++)
    {
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        g[u][v] = g[v][u] = w;
    }
}
//回溯法核心
void backTrack(int t)
{
    if (t &gt; n)
        //到达叶子结点
        //最后一个结点与第一个结点有边相连且路径长度比当前最优值最小
        //说明找到了一条更优路径，记录相关信息
    {
        if (g[n][1] != INF &amp;&amp; (cl + g[x[n]][1] &lt; bestl))
        {
            for (int j = 1; j &lt;= n; j++)
                bestx[j] = x[j];
            bestl = cl + g[x[n]][1];
        }

    }
    else
    {
        //没有到达叶子结点
        for (int j = t; j &lt;= n; j++)
        {
            //搜索扩展结点的所有分支
            //如果第t-1个结点与第t个结点有边相连且可以得到更短路径
            if (g[x[t - 1]][x[j]] != INF &amp;&amp; (cl + g[x[t - 1]][x[j]] &lt; bestl))
            {
                //保存第t个结点到x[t]中，进入第t+1个
                swap(x[t], x[j]);//交换两个元素的值
                cl = cl + g[x[t - 1]][x[t]];
                backTrack(t + 1);
                cl = cl - g[x[t - 1]][x[t]];
                swap(x[t], x[j]);
            }
        }
    }
}

//打印路径
void print()
{
    cout &lt;&lt; &quot;最短路径：&quot; &lt;&lt; endl;
    for (int i = 1; i &lt;= n; i++)
        cout &lt;&lt; bestx[i] &lt;&lt; &quot;---&gt;&quot;;
    cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;最短路径长度：&quot; &lt;&lt; bestl &lt;&lt; endl;
}
</code></pre><h3 id="算法复杂度分析-4"><a href="#算法复杂度分析-4" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ol>
<li>时间复杂度：除了最后一层外，有1+(n-1)+…+(n-1)(n-2)…2&lt;=n(n-1)!个结点需要判断约束函数和限界函数，判断两个函数需要O(1)的时间，因此耗时O(n!)。在叶子节点处记录当前最优解需要耗时O(n)，在最坏情况下回搜索到每一个叶子结点，叶子数为(n-1)!，所以时间复杂度为O（n!）。</li>
<li>空间复杂度：O(n)。</li>
</ol>

    </div>
    
        <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="http://www.yushuai.xyz/zjyt/alipay.jpg"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="http://www.yushuai.xyz/zjyt/weixin.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">感觉不错？欢迎给我 打个赏~我将不胜感激！</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">小奥</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/03/20/branchbound/" class="pre-post btn btn-default" title="分支限界法">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">分支限界法</span>
        </a>
    
    
        <a href="/2019/03/10/e3-80-8a-e5-89-91-e6bc-8812-ef-bc-89/" class="next-post btn btn-default" title="《剑指Offer》题目解析（12）">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">《剑指Offer》题目解析（12）</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'hOdSKBj8pwPOvnaoxGQxFoFk-gzGzoHsz',
            appKey: '8HN1NJOGIMTIPAFWVXqcklB7',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#回溯法"><span class="toc-text">回溯法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大卖场购物（0-1背包问题）"><span class="toc-text">大卖场购物（0-1背包问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题举例"><span class="toc-text">问题举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题分析"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题求解"><span class="toc-text">问题求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法复杂度和改进"><span class="toc-text">算法复杂度和改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最大团"><span class="toc-text">最大团</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题描述"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题分析-1"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法设计"><span class="toc-text">算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-1"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法复杂度分析"><span class="toc-text">算法复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#着色问题"><span class="toc-text">着色问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题分析-2"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法设计-1"><span class="toc-text">算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解题过程"><span class="toc-text">解题过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-2"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法复杂度分析-1"><span class="toc-text">算法复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#n皇后问题"><span class="toc-text">n皇后问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题介绍"><span class="toc-text">问题介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题分析-3"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法设计-2"><span class="toc-text">算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-3"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法复杂度分析-2"><span class="toc-text">算法复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最优加工顺序"><span class="toc-text">最优加工顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题描述-1"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题分析-4"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法设计-3"><span class="toc-text">算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-4"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法复杂度分析-3"><span class="toc-text">算法复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法优化改进"><span class="toc-text">算法优化改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#旅行商问题"><span class="toc-text">旅行商问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题描述-2"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法设计-4"><span class="toc-text">算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完美图解"><span class="toc-text">完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-5"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法复杂度分析-4"><span class="toc-text">算法复杂度分析</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>