{"meta":{"title":"小奥の部落格","subtitle":"万丈高楼平地起，勿在浮沙筑高台","description":"life | c++ | python | java","author":"小奥","url":"http://tech.yushuai.xyz"},"pages":[{"title":"","date":"2019-04-09T04:06:18.418Z","updated":"2019-04-09T04:06:18.418Z","comments":true,"path":"cv/index.html","permalink":"http://tech.yushuai.xyz/cv/index.html","excerpt":"","text":"张玉帅(David Cheung) 我的博客（中文） English Version 旧版个人介绍 张玉帅 万丈高楼平地起，勿在浮沙筑高台 dqhplhzz2008@163.com 所在地：陕西省·西安市·雁塔区 家乡：山东省·莱芜市·莱城区 教育经历 活动经历 研究方向 技能 个人成果 教育经历 通信工程 山东科技大学 2013 - 2017 山东科技大学电子通信与物理学院通信工程专业毕业，工学学士学位。 通信与信息系统 西安电子科技大学 2017 - 2020 西安电子科技大学通信工程学院在读硕士。 活动经历 青岛世界园艺博览会 山东省青岛市 志愿者 2014.8.3~2014.8.24 待添加 全国大学生数学建模竞赛 山东省青岛市 山东省赛区二等奖 2014.9 待添加 美国大学生数学建模竞赛 山东省莱芜市 二等奖 2015.10 待添加 第四届高校机器人大赛暨国际水下机器人邀请赛 山东省青岛市 二等奖 2015.10 待添加 青岛高校数学建模联赛 山东省青岛市 特等奖 2016.4 待添加 “CETC-10\"杯第十届文献综述大赛 陕西省西安市 优秀奖 2017.5 待添加 技能 专业技能 60% C &amp; C++ C语言学习5年，C++半年 70% MATLAB 已经学习约4年 80% HTML &amp; CSS 已经学习约10年 其它技能 Python Java 计算机等级考试（二级、三级、四级） CET-4（579分） CET-6（456分） 个人成果 所有 专业作品 网站 字幕组作品 编码多载波CDMA通信系统的抗干扰性能研究 MATLAB LDPC/RS编码在不同环境下的性能测试。（本科毕业设计） 双足行走机器人2015年山东机器人大赛 C/Keil 双足行走机器人，可识别黑色边线和障碍物。（合作） 超声波测距装置（课程设计） C/Keil 根据超声回波测量仪器与目标物体之间的距离。（合作） 图书馆出入人员计数器（电子设计比赛） C/Keil 统计进出馆、在馆人数，并能对非法侵入警告。（合作） 小奥の部落格（个人博客） PHP/Wordpress 基于Wordpress搭建的个人博客，已运行10年。 山东科技大学国家精品课程通信原理网站 ASP.NET 基于ASP.NET制作的网站，使用Siteserver。 山东科技大学贫困生鉴定系统 JAVA 参与制作第一个版本系统的搭建和上线运营工作。 山东科技大学自强社（社团）网站 ASP.NET 基于ASP.NET制作的网站，使用Siteserver。 动画系列之名侦探柯南（部分剧集） 日本动漫字幕（TV版） 名侦探柯南剧场版：战栗的乐谱 日本动漫字幕（剧场版） 特摄系列之忍风战队（美国版） 美国特摄字幕（DVD版） 特摄系列之杰克奥特曼（部分剧集） 日本特摄字幕（DVD版） Copyright &copy; 2009-2018.小奥の部落格 All rights reserved"},{"title":"","date":"2018-11-04T13:50:32.951Z","updated":"2018-11-04T13:50:32.951Z","comments":true,"path":"cv/index_en.html","permalink":"http://tech.yushuai.xyz/cv/index_en.html","excerpt":"","text":"Yushuai Zhang(David Cheung) 我的博客（中文） 中文版 Old Verison Yushuai Zhang A Student for now, a programmer in the future dqhplhzz2008@163.com Location: Xi'an, Shaanxi Province, PRC Hometown: Laiwu, Shandong Province, PRC Education Activities Research Direction Skills Works Education Communication Engineering Shandong University of Science and Technology SEP 2013 - JUN 2017 Graduated in Communication Engineering from the School of Electronic Communications and Physics, Bachelor of Engineering. Communication and Information System Xidian University SEP 2017 - PRESENT Master Student, State Key Laboratory of Integrated Service Networks, Xidian University. Activities World Horticultural Exhibitions(Qingdao) Qingdao, Shandong Volunteer 2014.8.3~2014.8.24 To be added China Undergraduate Mathematical Contest in Modeling Qingdao, Shandong Second Prize(P) 2014.9 To be added Mathematical Contest in Modeling Laiwu, Shandong Honorable Mention 2015.10 To be added Shandong Robotics Competition Qingdao, Shandong Second Prize 2015.10 To be added Qingdao University Mathematical Modeling League Qingdao, Shandong Grand prize 2016.4 To be added “CETC-10\" 10th Paper Review Contest Xian, Shaanxi Excellence Award 2017.5 To be added Skills Professional Skills 60% C &amp; C++ C has been learning for 4 years, and C++ for half a year. 70% MATLAB Have been studying for 4 years. 80% HTML &amp; CSS Have been studying for 10 years. Other Skills Python Java NCRE（Grade II/III/IV） CET-4（579/710） CET-6（456/710） Works ALL Profession Websites Subtitle Research on Anti-jamming Performance of Coded Multi-Carrier CDMA System MATLAB Biped walking robot- 2015 Shandong Robotics Competition C/Keil Ultrasonic distance measuring device- Course Design C/Keil Library entry and exit counter- Electronic Design C/Keil David Cheung's Blog PHP/Wordpress Principle of Communication ASP.NET Poor Student Identification JAVA Self-Improvement Society ASP.NET Detective Conan Anime(TV series) Full Score of Fear Detective Conan(Movie) Power Rangers: Ninja Storm American Tokusatsu Ultraman Jack Tokusatsu Copyright &copy; 2009-2018.小奥の部落格 All rights reserved"},{"title":"","date":"2018-10-31T15:12:51.676Z","updated":"2018-10-08T08:16:30.342Z","comments":true,"path":"cv/old/index_en.html","permalink":"http://tech.yushuai.xyz/cv/old/index_en.html","excerpt":"","text":"Yushuai Zhang(David Cheung) addEventListener(\"load\", function() { setTimeout(hideURLbar, 0); }, false); function hideURLbar(){ window.scrollTo(0,1); } Yushuai Zhang EMAIL dqhplhzz2008@163.com Location Xi'an, Shaanxi, PRC Hometown Laiwu, Shandong, PRC Address No. 2, Taibai South Road, Yanta District My BLOG(Chinese) 中文版 Education Xidian University SEP 2017 - PRESENT Communication and Information System - Master Student Master Student, State Key Laboratory of Integrated Service Networks, Xidian University Shandong University of Science and TechnologySEP 2013 - JUN 2017 Communication Engineering - Bachelor of Engineering Graduated in Communication Engineering from the School of Electronic Communications and Physics. Research Direction None None Professional Skills Currently focused on C/C++ learning, interested in algorithms, speech processing, machine learning, etc.In the past, I have designed and written many websites. Software Visual Studio 2015 Anaconda Eclipse Dreamweaver MATLAB Programming Languages C/C++ MATLAB Python Java HTML/CSS Projects Research on Anti-jamming Performance of Coded Multi-Carrier CDMA Communication System Generation and elimination of echo signals based on MATLAB Copyright &copy; 2009-2018. Yushuai Zhang(WWW.YUSHUAI.ME) All rights reserved."},{"title":"","date":"2018-10-31T15:17:45.916Z","updated":"2018-10-13T02:45:13.638Z","comments":true,"path":"cv/old/index.html","permalink":"http://tech.yushuai.xyz/cv/old/index.html","excerpt":"","text":"张玉帅(David Cheung) addEventListener(\"load\", function() { setTimeout(hideURLbar, 0); }, false); function hideURLbar(){ window.scrollTo(0,1); } 张玉帅 EMAIL dqhplhzz2008@163.com 所在地 中国·陕西·西安 家乡 中国·山东·莱芜 地址 雁塔区 太白南路2号 个人博客 English Version 教育经历 西安电子科技大学 2017.9 - 通信与信息系统-硕士在读 通信工程学院在读硕士。 山东科技大学2013.9 - 2017.6 通信工程-工学学士 电子通信与物理学院通信工程专业毕业。 研究方向 暂无None None 专业技能 目前专注于基于C/C++的算法学习，对算法、语音处理、机器学习等领域感兴趣，计划未来研究机器学习在语音处理领域的应用等。曾在本科、研究生期间制作过多个网站，也曾在初中阶段创建字幕组并担任组长并制作过多部日本动画、特摄的字幕（承担过片源、时间轴、内嵌等任务），本科参加过国际级、国家级、省级和地市级数学建模比赛并取得优异成绩，参加山东省机器人大赛并取得二等奖。 获奖经历 全国大学生数学建模竞赛2014 美国大学生数学建模竞赛2015 山东省机器人大赛2015 青岛大学生数学建模竞赛2016 编程语言 C/C++ MATLAB Python Java HTML/CSS 项目 编码多载波CDMA通信系统的抗干扰性能研究（本科毕业设计） 基于MATLAB的回波信号的产生与消除 超声波测距装置 图书馆出入人员计数器 Copyright &copy; 2009-2018. Yushuai Zhang(WWW.YUSHUAI.ME) All rights reserved."},{"title":"","date":"2018-10-30T12:50:19.276Z","updated":"2016-09-30T02:46:13.870Z","comments":true,"path":"cv/assets/js/main.js","permalink":"http://tech.yushuai.xyz/cv/assets/js/main.js","excerpt":"","text":"$(document).ready(function() { /* ======= Scrollspy ======= */ $('body').scrollspy({ target: '#page-nav-wrapper', offset: 100}); /* ======= ScrollTo ======= */ $('.scrollto').on('click', function(e){ //store hash var target = this.hash; e.preventDefault(); $('body').scrollTo(target, 800, {offset: -60, 'axis':'y'}); }); /* ======= Fixed page nav when scrolled ======= */ $(window).on('scroll resize load', function() { $('#page-nav-wrapper').removeClass('fixed'); var scrollTop = $(this).scrollTop(); var topDistance = $('#page-nav-wrapper').offset().top; if ( (topDistance) > scrollTop ) { $('#page-nav-wrapper').removeClass('fixed'); $('body').removeClass('sticky-page-nav'); } else { $('#page-nav-wrapper').addClass('fixed'); $('body').addClass('sticky-page-nav'); } }); /* ======= Chart ========= */ $('.chart').easyPieChart({ barColor:'#00BCD4',//Pie chart colour trackColor: '#e8e8e8', scaleColor: false, lineWidth : 5, animate: 2000, onStep: function(from, to, percent) { $(this.el).find('span').text(Math.round(percent)); } }); /* ======= Isotope plugin ======= */ /* Ref: http://isotope.metafizzy.co/ */ // init Isotope var $container = $('.isotope'); $container.imagesLoaded(function () { $('.isotope').isotope({ itemSelector: '.item' }); }); // filter items on click $('#filters').on( 'click', '.type', function() { var filterValue = $(this).attr('data-filter'); $container.isotope({ filter: filterValue }); }); // change is-checked class on buttons $('.filters').each( function( i, typeGroup ) { var $typeGroup = $( typeGroup ); $typeGroup.on( 'click', '.type', function() { $typeGroup.find('.active').removeClass('active'); $( this ).addClass('active'); }); }); });"},{"title":"","date":"2018-11-04T13:54:56.849Z","updated":"2018-11-04T13:54:56.849Z","comments":true,"path":"cv/assets/css/styles.css","permalink":"http://tech.yushuai.xyz/cv/assets/css/styles.css","excerpt":"","text":"/* * Template Name: Sphere - Responsive website template for CV/Resume/Portfolio * Version: 1.0 * Author: Xiaoying Riley at 3rd Wave Media * Website: http://themes.3rdwavemedia.com/ * Twitter: @3rdwave_themes */ /* ======= Base ======= */ body { font-family: 'Roboto', sans-serif; color: #666; background: #f5f5f5; font-size: 14px; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; color: #444; } h1, h2, h3, h4, h5, h6 { font-weight: 500; } a { color: #00BCD4; -webkit-transition: all 0.4s ease-in-out; -moz-transition: all 0.4s ease-in-out; -ms-transition: all 0.4s ease-in-out; -o-transition: all 0.4s ease-in-out; } a:hover { text-decoration: underline; color: #007888; } a:focus { text-decoration: none; } p { line-height: 1.5; } .btn, a.btn { background: #008fa1; color: #fff; padding: 8px 15px; -webkit-border-radius: 2px; -moz-border-radius: 2px; -ms-border-radius: 2px; -o-border-radius: 2px; border-radius: 2px; -moz-background-clip: padding; -webkit-background-clip: padding-box; background-clip: padding-box; -webkit-box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.4); -moz-box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.4); box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.4); text-transform: uppercase; font-weight: 500; font-size: 14px; } .btn:hover, a.btn:hover { color: #fff; background: #00a5bb; } #topcontrol { -webkit-transition: all 0.4s ease-in-out; -moz-transition: all 0.4s ease-in-out; -ms-transition: all 0.4s ease-in-out; -o-transition: all 0.4s ease-in-out; background: #008fa1; color: #fff; text-align: center; display: inline-block; z-index: 30; width: 36px; height: 36px; -webkit-border-radius: 50%; -moz-border-radius: 50%; -ms-border-radius: 50%; -o-border-radius: 50%; border-radius: 50%; -moz-background-clip: padding; -webkit-background-clip: padding-box; background-clip: padding-box; -webkit-box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.3); box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.3); } .tlinks{text-indent:-9999px;height:0;line-height:0;font-size:0;overflow:hidden;} #topcontrol:hover { background: #007888; color: #fff; } #topcontrol .fa { position: relative; top: 3px; font-size: 25px; font-weight: normal; } .header { background: #00BCD4; color: #fff; } .header a { color: #fff; } .header .top-bar { position: relative; padding-top: 15px; padding-bottom: 20px; } .header .social { margin-bottom: 0; } .header .social a { color: rgba(255, 255, 255, 0.8); display: inline-block; text-align: center; width: 32px; height: 32px; -webkit-border-radius: 50%; -moz-border-radius: 50%; -ms-border-radius: 50%; -o-border-radius: 50%; border-radius: 50%; -moz-background-clip: padding; -webkit-background-clip: padding-box; background-clip: padding-box; padding-top: 2px; font-size: 16px; border: 2px solid rgba(255, 255, 255, 0.8); } .header .social a:hover { color: #fff; border-color: #fff; } .header .actions { position: absolute; right: 15px; top: 15px; } .header .actions .fa { margin-right: 5px; } .header .actions a { margin-right: 10px; color: #fff; } .header .actions a:last-child { margin-right: 0; } .header .profile-image { position: absolute; width: 160px; height: 160px; top: -80px; margin-left: -80px; } .header .name { font-size: 48px; margin-bottom: 15px; letter-spacing: 0.5px; } .header .title { font-size: 28px; font-weight: 300; color: rgba(255, 255, 255, 0.8); margin-bottom: 30px; } .header .intro { background: #00a5bb; padding-top: 30px; padding-bottom: 10px; position: relative; font-size: 16px; } .header .profile { max-width: 800px; margin: 0 auto; } .header .contact-info { background: #008fa1; padding-top: 15px; padding-bottom: 15px; font-size: 16px; } .header .contact-info ul { margin-bottom: 0; } .header .contact-info li { margin-right: 30px; color: rgba(255, 255, 255, 0.8); } .header .contact-info li a { color: rgba(255, 255, 255, 0.8); } .header .contact-info li a:hover { color: #fff; } .header .contact-info li:last-child { margin-right: 0; } .header .contact-info li .fa { margin-right: 10px; } /* Page Nav */ .page-nav-space-holder { height: 60px; position: relative; } .page-nav-wrapper { background: #007888; padding-top: 20px; padding-bottom: 20px; position: absolute; width: 100%; left: 0; -webkit-box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); -moz-box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); } .page-nav-wrapper.fixed { position: fixed; top: 0; left: 0; width: 100%; z-index: 100; background: #00BCD4; } .page-nav-wrapper a { color: rgba(255, 255, 255, 0.6); text-decoration: none; font-weight: 500; } .page-nav-wrapper .page-nav { margin: 0 auto; display: inline-block; } .page-nav-wrapper .page-nav li { margin-right: 30px; display: inline-block; background: none; } .page-nav-wrapper .page-nav li:hover, .page-nav-wrapper .page-nav li:active { background: none; } .page-nav-wrapper .page-nav li.active a { color: #fff; background: none; } .page-nav-wrapper .page-nav li a { color: rgba(255, 255, 255, 0.6); padding: inherit; } .page-nav-wrapper .page-nav li a:hover { color: #fff; } .page-nav-wrapper .page-nav li a:hover, .page-nav-wrapper .page-nav li a:active, .page-nav-wrapper .page-nav li a:focus { background: none; } .page-nav-wrapper .page-nav li:last-child { margin-right: 0; } .wrapper { padding-top: 60px; } .section { -webkit-box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.14); -moz-box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.14); box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.14); padding: 45px; background: #fff; margin-bottom: 45px; -webkit-border-radius: 2px; -moz-border-radius: 2px; -ms-border-radius: 2px; -o-border-radius: 2px; border-radius: 2px; -moz-background-clip: padding; -webkit-background-clip: padding-box; background-clip: padding-box; } .section:last-child { margin-bottom: 0; } .section-title { margin-top: 0; margin-bottom: 30px; font-size: 24px; text-align: center; } .timeline { border-left: 3px solid #00BCD4; border-bottom-right-radius: 2px; border-top-right-radius: 2px; position: relative; padding: 0 30px; margin-left: 280px; } .timeline .item { position: relative; margin-bottom: 45px; } .timeline .item:last-child { margin-bottom: 0; } .timeline .item:before { content: \"\"; position: absolute; left: -43px; top: 0; display: inline-block; width: 22px; height: 22px; -webkit-border-radius: 50%; -moz-border-radius: 50%; -ms-border-radius: 50%; -o-border-radius: 50%; border-radius: 50%; -moz-background-clip: padding; -webkit-background-clip: padding-box; background-clip: padding-box; background: #fff; border: 3px solid #00BCD4; } .timeline .item:after { content: \"\"; position: absolute; left: -37px; top: 6px; display: inline-block; width: 10px; height: 10px; -webkit-border-radius: 50%; -moz-border-radius: 50%; -ms-border-radius: 50%; -o-border-radius: 50%; border-radius: 50%; -moz-background-clip: padding; -webkit-background-clip: padding-box; background-clip: padding-box; background: #00BCD4; z-index: 10; } .timeline .work-place { position: relative; } .timeline .location { position: absolute; right: 0; top: 2px; color: #8a8a8a; } .timeline .location .fa { margin-right: 5px; } .timeline .place { margin-top: 0; margin-bottom: 15px; font-size: 20px; font-weight: 300; } .timeline .job-meta { position: absolute; left: -220px; top: 0; } .timeline .job-meta .title { font-size: 18px; color: #00BCD4; } .timeline .job-meta .time { color: #8a8a8a; } .timeline .job-desc { color: #666; } .education-section .item { } .education-section .item-inner { padding: 0 30px; } .education-section .degree { font-size: 18px; color: #00BCD4; margin-top: 0; margin-bottom: 0px; } .education-section .education-body { font-weight: 500; margin-bottom: 0px; font-size: 16px; font-weight: 300; } .education-section .time { color: #8a8a8a; margin-bottom: 15px; } .education-section .desc { color: #666; } .skills-section .subtitle { font-size: 18px; color: #8a8a8a; margin-top: 0; margin-bottom: 45px; font-weight: 300; } .skills-section .top-skills { } .skills-section .top-skills .item { margin-bottom: 45px; } .skills-section .level { color: #8a8a8a; margin-bottom: 15px; } .skills-section .desc { color: #666; } .skills-section .skill-tag { -webkit-box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.14); -moz-box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.14); box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.14); padding: 6px 30px; display: inline-block; margin-right: 10px; border: 1px solid #f5f5f5; font-weight: 500; margin-bottom: 15px; font-size: 16px; } .chart-easy-pie { positon: relative; } .chart { width: 110px; height: 110px; vertical-align: middle; position: relative; margin: 0 auto; text-align: center; font-size: 20px; font-weight: 300; margin-bottom: 30px; } .chart span { line-height: 110px; } .chart canvas { position: absolute; left: 0; top: 0; } .testimonials-section .testimonials-carousel { max-width: 800px; margin: 0 auto; } .testimonials-section .item { padding-left: 60px; margin-bottom: 45px; } .testimonials-section .quote { border-left: none; padding: 0; font-size: 22px; color: #666; font-weight: 300; position: relative; } .testimonials-section .source .name { font-size: 16px; } .testimonials-section .source .position { color: #8a8a8a; } .testimonials-section .fa-quote-left { position: absolute; left: -60px; top: 0; width: 36px; height: 36px; display: inline-block; background: #00BCD4; color: #fff; -webkit-border-radius: 50%; -moz-border-radius: 50%; -ms-border-radius: 50%; -o-border-radius: 50%; border-radius: 50%; -moz-background-clip: padding; -webkit-background-clip: padding-box; background-clip: padding-box; text-align: center; padding-top: 10px; font-size: 16px; } .testimonials-section .carousel-indicators { bottom: 0; margin-bottom: 0; } .testimonials-section .carousel-indicators li { background-color: #bdbdbd; border: none; width: 10px; height: 10px; margin: 0; margin-right: 5px; } .testimonials-section .carousel-indicators li.active { background-color: #00BCD4; width: 10px; height: 10px; margin: 0; margin-right: 5px; } .portfolio-section .filters { list-style: none; margin: 0 auto; margin-bottom: 60px; text-align: center; border-bottom: 1px solid #e8e8e8; } .portfolio-section .filters .type { margin-right: 30px; list-style: none; display: inline-block; padding: 8px 15px; color: #8a8a8a; cursor: pointer; font-size: 14px; text-transform: uppercase; font-weight: 500; } .portfolio-section .filters .type:last-child { margin-right: 0; } .portfolio-section .filters .type.active { color: #00BCD4; border-bottom: 2px solid #00BCD4; } .portfolio-section .item { margin-bottom: 30px; } .portfolio-section .item-inner { background: #00BCD4; color: #fff; -webkit-border-radius: 2px; -moz-border-radius: 2px; -ms-border-radius: 2px; -o-border-radius: 2px; border-radius: 2px; -moz-background-clip: padding; -webkit-background-clip: padding-box; background-clip: padding-box; position: relative; -webkit-box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.14); -moz-box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.14); box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.14); } .portfolio-section .item-inner:hover { background: #00c5de; } .portfolio-section .item-inner:hover img { -webkit-opacity: 0.9; -moz-opacity: 0.9; opacity: 0.9; } .portfolio-section .item-inner .content { padding: 30px; padding-bottom: 65px; position: relative; } .portfolio-section .item-inner .content a { color: #fff; } .portfolio-section .item-inner .content .sub-title { font-size: 16px; margin-top: 0; margin-bottom: 5px; } .portfolio-section .item-inner .content .meta { color: rgba(255, 255, 255, 0.8); font-size: 14px; } .portfolio-section .item-inner .content .action { position: absolute; top:100px; left: 25px; right: 25px; } /*英语定制版开始*/ .portfolio-section .item-inner .content_en { padding: 12px; padding-bottom: 10px; position: relative; } .portfolio-section .item-inner .content_en a { color: #fff; } .portfolio-section .item-inner .content_en .sub-title { font-size: 16px; margin-top: 0; margin-bottom: 5px; } .portfolio-section .item-inner .content_en .meta { color: rgba(255, 255, 255, 0.8); font-size: 14px; } .portfolio-section .item-inner .content_en .action { position: absolute; top:100px; left: 25px; right: 25px; } /*英语定制版结束*/ .portfolio-section .item-inner .link-mask { display: block; position: absolute; width: 100%; height: 100%; left: 0; top: 0; } .contact-section .intro { position: relative; padding: 30px; padding-left: 190px; font-size: 16px; color: #666; } .contact-section .intro .profile-image { width: 120px; height: 120px; position: absolute; left: 30px; } .contact-section .intro p { margin-bottom: 15px; } .contact-section .service-list { margin-left: 30px; margin-bottom: 15px; } .contact-section .service-list li { margin-bottom: 15px; } .contact-section .service-list .fa { color: #00BCD4; } .contact-section .social { margin-bottom: 0; } .contact-section .social li { margin-right: 10px; } .contact-section .social li:last-child { margin-right: 0; } .contact-section .social a { display: inline-block; text-align: center; font-size: 24px; color: #8a8a8a; } .contact-section .social a:hover { color: #00BCD4; } .footer .container { padding: 30px; color: #8a8a8a; letter-spacing: 0.5px; } .footer .container a { color: #8a8a8a; } /* Extra small devices (phones, less than 768px) */ @media (max-width: 767px) { .header .social { margin: 0 auto; text-align: center; } .header .actions { position: static; margin: 0 auto; margin-bottom: 30px; text-align: center; } .header .actions .btn { margin-bottom: 15px; font-size: 12px; display: inline-block; width: 100%; } .header .actions .btn:last-child { margin-bottom: 0; } .header .name { font-size: 36px; } .header .title { font-size: 22px; } .header .contact-info li { margin-right: 0; margin-bottom: 15px; font-size: 14px; width: 100%; display: inline-block; } .header .contact-info li:last-child { margin-bottom: 0; } .section { padding: 30px; } .section-title { font-size: 20px; } .timeline { margin-left: 0; padding-right: 0; } .timeline .place { margin-bottom: 5px; } .timeline .job-meta { position: static; margin-bottom: 15px; } .education-section .item { padding: 0; } .portfolio-section .filters .type { font-size: 12px; margin-right: 5px; padding: 8px 5px; } .portfolio-section .item-inner .content { padding: 15px; } .portfolio-section .item-inner .content .sub-title { font-size: 14px; max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .portfolio-section .item-inner .content .meta { margin-bottom: 30px; max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .portfolio-section .item-inner .content .action { position: static; font-size: 12px; } .contact-section .intro { padding: 0; text-align: center; } .contact-section .intro .profile-image { position: static; margin: 0 auto; margin-bottom: 30px; text-align: center; } .contact-section .service-list { margin-left: 0; } .contact-section .social { margin: 0 auto; } } /* Small devices (tablets, 768px and up) */ /* Medium devices (desktops, 992px and up) */ /* Large devices (large desktops, 1200px and up) */ /* X-Large devices (large desktops, 1400px and up) */ /* ======= Configure Style (Remove in production) ======= */ .config-trigger { position: absolute; top: 30px; left: -36px; width: 36px; height: 36px; background: #222; color: #fff; text-align: center; -webkit-border-top-right-radius: 0; -webkit-border-bottom-right-radius: 0; -webkit-border-bottom-left-radius: 4px; -webkit-border-top-left-radius: 4px; -moz-border-radius-topright: 0; -moz-border-radius-bottomright: 0; -moz-border-radius-bottomleft: 4px; -moz-border-radius-topleft: 4px; border-top-right-radius: 0; border-bottom-right-radius: 0; border-bottom-left-radius: 4px; border-top-left-radius: 4px; -moz-background-clip: padding; -webkit-background-clip: padding-box; background-clip: padding-box; text-decoration: none; } .config-trigger:hover { background: #000; text-decoration: none; } .config-trigger:hover .fa { color: #fff; } .config-trigger .fa { font-size: 22px; padding-top: 7px; display: block; color: rgba(255, 255, 255, 0.8); } .config-panel { position: absolute; top: 160px; right: -190px; z-index: 30; width: 190px; } .config-panel .panel-inner { position: relative; background: #222; color: #fff; padding: 15px; -webkit-border-top-right-radius: 0; -webkit-border-bottom-right-radius: 0; -webkit-border-bottom-left-radius: 4px; -webkit-border-top-left-radius: 4px; -moz-border-radius-topright: 0; -moz-border-radius-bottomright: 0; -moz-border-radius-bottomleft: 4px; -moz-border-radius-topleft: 4px; border-top-right-radius: 0; border-bottom-right-radius: 0; border-bottom-left-radius: 4px; border-top-left-radius: 4px; -moz-background-clip: padding; -webkit-background-clip: padding-box; background-clip: padding-box; } .config-panel .panel-title { font-weight: 600; margin-bottom: 15px; font-size: 14px; text-transform: uppercase; } .config-panel label { color: #fff; } .config-panel #color-options { margin-bottom: 0px; } .config-panel #color-options li a { display: block; width: 28px; height: 20px; border: 2px solid transparent; margin-bottom: 10px; } .config-panel #color-options li a:hover { -webkit-opacity: 0.9; -moz-opacity: 0.9; opacity: 0.9; border: 2px solid rgba(255, 255, 255, 0.8); } .config-panel #color-options li.active a { border: 2px solid #fff; } .config-panel #color-options li.theme-1 a { background: #00BCD4; } .config-panel #color-options li.theme-2 a { background-color: #03A9F4; } .config-panel #color-options li.theme-3 a { background-color: #009688; } .config-panel #color-options li.theme-4 a { background-color: #4CAF50; } .config-panel #color-options li.theme-5 a { background-color: #8BC34A; } .config-panel #color-options li.theme-6 a { background-color: #C0CA33; } .config-panel #color-options li.theme-7 a { background-color: #FFC107; } .config-panel #color-options li.theme-8 a { background-color: #FF9800; } .config-panel #color-options li.theme-9 a { background-color: #FF5722; } .config-panel #color-options li.theme-10 a { background-color: #795548; } .config-panel #color-options li.theme-11 a { background-color: #607D8B; } .config-panel #color-options li.theme-12 a { background-color: #673AB7; } .config-panel #color-options li.theme-13 a { background-color: #3F51B5; } .config-panel #color-options li.theme-14 a { background-color: #2196F3; } .config-panel #color-options li.theme-15 a { background-color: #9C27B0; } .config-panel #color-options li.theme-16 a { background-color: #E91E63; } .config-panel .close { position: absolute; right: 5px; top: 5px; color: #fff; } .config-panel .close .fa { color: #fff; }"},{"title":"","date":"2018-10-30T12:50:19.278Z","updated":"2016-09-30T02:46:11.591Z","comments":true,"path":"cv/assets/plugins/back-to-top.js","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/back-to-top.js","excerpt":"","text":"//** jQuery Scroll to Top Control script- (c) Dynamic Drive DHTML code library: http://www.dynamicdrive.com. //** Available/ usage terms at http://www.dynamicdrive.com (March 30th, 09') //** v1.1 (April 7th, 09'): //** 1) Adds ability to scroll to an absolute position (from top of page) or specific element on the page instead. //** 2) Fixes scroll animation not working in Opera. var scrolltotop={ //startline: Integer. Number of pixels from top of doc scrollbar is scrolled before showing control //scrollto: Keyword (Integer, or \"Scroll_to_Element_ID\"). How far to scroll document up when control is clicked on (0=top). setting: {startline:100, scrollto: 0, scrollduration:1000, fadeduration:[500, 100]}, controlHTML: '', //HTML for control, which is auto wrapped in DIV w/ ID=\"topcontrol\" controlattrs: {offsetx:5, offsety:5}, //offset of control relative to right/ bottom of window corner anchorkeyword: '#top', //Enter href value of HTML anchors on the page that should also act as \"Scroll Up\" links state: {isvisible:false, shouldvisible:false}, scrollup:function(){ if (!this.cssfixedsupport) //if control is positioned using JavaScript this.$control.css({opacity:0}) //hide control immediately after clicking it var dest=isNaN(this.setting.scrollto)? this.setting.scrollto : parseInt(this.setting.scrollto) if (typeof dest==\"string\" && jQuery('#'+dest).length==1) //check element set by string exists dest=jQuery('#'+dest).offset().top else dest=0 this.$body.animate({scrollTop: dest}, this.setting.scrollduration); }, keepfixed:function(){ var $window=jQuery(window) var controlx=$window.scrollLeft() + $window.width() - this.$control.width() - this.controlattrs.offsetx var controly=$window.scrollTop() + $window.height() - this.$control.height() - this.controlattrs.offsety this.$control.css({left:controlx+'px', top:controly+'px'}) }, togglecontrol:function(){ var scrolltop=jQuery(window).scrollTop() if (!this.cssfixedsupport) this.keepfixed() this.state.shouldvisible=(scrolltop>=this.setting.startline)? true : false if (this.state.shouldvisible && !this.state.isvisible){ this.$control.stop().animate({opacity:1}, this.setting.fadeduration[0]) this.state.isvisible=true } else if (this.state.shouldvisible==false && this.state.isvisible){ this.$control.stop().animate({opacity:0}, this.setting.fadeduration[1]) this.state.isvisible=false } }, init:function(){ jQuery(document).ready(function($){ var mainobj=scrolltotop var iebrws=document.all mainobj.cssfixedsupport=!iebrws || iebrws && document.compatMode==\"CSS1Compat\" && window.XMLHttpRequest //not IE or IE7+ browsers in standards mode mainobj.$body=(window.opera)? (document.compatMode==\"CSS1Compat\"? $('html') : $('body')) : $('html,body') mainobj.$control=$(''+mainobj.controlHTML+'') .css({position:mainobj.cssfixedsupport? 'fixed' : 'absolute', bottom:mainobj.controlattrs.offsety, right:mainobj.controlattrs.offsetx, opacity:0, cursor:'pointer'}) .attr({title:'Scroll Back to Top'}) .click(function(){mainobj.scrollup(); return false}) .appendTo('body') if (document.all && !window.XMLHttpRequest && mainobj.$control.text()!='') //loose check for IE6 and below, plus whether control contains any text mainobj.$control.css({width:mainobj.$control.width()}) //IE6- seems to require an explicit width on a DIV containing text mainobj.togglecontrol() $('a[href=\"' + mainobj.anchorkeyword +'\"]').click(function(){ mainobj.scrollup() return false }) $(window).bind('scroll resize', function(e){ mainobj.togglecontrol() }) }) } } scrolltotop.init()"},{"title":"","date":"2018-10-30T12:50:19.360Z","updated":"2016-09-30T02:46:13.595Z","comments":true,"path":"cv/assets/plugins/isotope.pkgd.min.js","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/isotope.pkgd.min.js","excerpt":"","text":"/*! * Isotope PACKAGED v2.1.0 * Filter & sort magical layouts * http://isotope.metafizzy.co */ (function(t){function e(){}function i(t){function i(e){e.prototype.option||(e.prototype.option=function(e){t.isPlainObject(e)&&(this.options=t.extend(!0,this.options,e))})}function n(e,i){t.fn[e]=function(n){if(\"string\"==typeof n){for(var s=o.call(arguments,1),a=0,u=this.length;u>a;a++){var p=this[a],h=t.data(p,e);if(h)if(t.isFunction(h[n])&&\"_\"!==n.charAt(0)){var f=h[n].apply(h,s);if(void 0!==f)return f}else r(\"no such method '\"+n+\"' for \"+e+\" instance\");else r(\"cannot call methods on \"+e+\" prior to initialization; \"+\"attempted to call '\"+n+\"'\")}return this}return this.each(function(){var o=t.data(this,e);o?(o.option(n),o._init()):(o=new i(this,n),t.data(this,e,o))})}}if(t){var r=\"undefined\"==typeof console?e:function(t){console.error(t)};return t.bridget=function(t,e){i(e),n(t,e)},t.bridget}}var o=Array.prototype.slice;\"function\"==typeof define&&define.amd?define(\"jquery-bridget/jquery.bridget\",[\"jquery\"],i):\"object\"==typeof exports?i(require(\"jquery\")):i(t.jQuery)})(window),function(t){function e(e){var i=t.event;return i.target=i.target||i.srcElement||e,i}var i=document.documentElement,o=function(){};i.addEventListener?o=function(t,e,i){t.addEventListener(e,i,!1)}:i.attachEvent&&(o=function(t,i,o){t[i+o]=o.handleEvent?function(){var i=e(t);o.handleEvent.call(o,i)}:function(){var i=e(t);o.call(t,i)},t.attachEvent(\"on\"+i,t[i+o])});var n=function(){};i.removeEventListener?n=function(t,e,i){t.removeEventListener(e,i,!1)}:i.detachEvent&&(n=function(t,e,i){t.detachEvent(\"on\"+e,t[e+i]);try{delete t[e+i]}catch(o){t[e+i]=void 0}});var r={bind:o,unbind:n};\"function\"==typeof define&&define.amd?define(\"eventie/eventie\",r):\"object\"==typeof exports?module.exports=r:t.eventie=r}(this),function(t){function e(t){\"function\"==typeof t&&(e.isReady?t():s.push(t))}function i(t){var i=\"readystatechange\"===t.type&&\"complete\"!==r.readyState;e.isReady||i||o()}function o(){e.isReady=!0;for(var t=0,i=s.length;i>t;t++){var o=s[t];o()}}function n(n){return\"complete\"===r.readyState?o():(n.bind(r,\"DOMContentLoaded\",i),n.bind(r,\"readystatechange\",i),n.bind(t,\"load\",i)),e}var r=t.document,s=[];e.isReady=!1,\"function\"==typeof define&&define.amd?define(\"doc-ready/doc-ready\",[\"eventie/eventie\"],n):\"object\"==typeof exports?module.exports=n(require(\"eventie\")):t.docReady=n(t.eventie)}(window),function(){function t(){}function e(t,e){for(var i=t.length;i--;)if(t[i].listener===e)return i;return-1}function i(t){return function(){return this[t].apply(this,arguments)}}var o=t.prototype,n=this,r=n.EventEmitter;o.getListeners=function(t){var e,i,o=this._getEvents();if(t instanceof RegExp){e={};for(i in o)o.hasOwnProperty(i)&&t.test(i)&&(e[i]=o[i])}else e=o[t]||(o[t]=[]);return e},o.flattenListeners=function(t){var e,i=[];for(e=0;t.length>e;e+=1)i.push(t[e].listener);return i},o.getListenersAsObject=function(t){var e,i=this.getListeners(t);return i instanceof Array&&(e={},e[t]=i),e||i},o.addListener=function(t,i){var o,n=this.getListenersAsObject(t),r=\"object\"==typeof i;for(o in n)n.hasOwnProperty(o)&&-1===e(n[o],i)&&n[o].push(r?i:{listener:i,once:!1});return this},o.on=i(\"addListener\"),o.addOnceListener=function(t,e){return this.addListener(t,{listener:e,once:!0})},o.once=i(\"addOnceListener\"),o.defineEvent=function(t){return this.getListeners(t),this},o.defineEvents=function(t){for(var e=0;t.length>e;e+=1)this.defineEvent(t[e]);return this},o.removeListener=function(t,i){var o,n,r=this.getListenersAsObject(t);for(n in r)r.hasOwnProperty(n)&&(o=e(r[n],i),-1!==o&&r[n].splice(o,1));return this},o.off=i(\"removeListener\"),o.addListeners=function(t,e){return this.manipulateListeners(!1,t,e)},o.removeListeners=function(t,e){return this.manipulateListeners(!0,t,e)},o.manipulateListeners=function(t,e,i){var o,n,r=t?this.removeListener:this.addListener,s=t?this.removeListeners:this.addListeners;if(\"object\"!=typeof e||e instanceof RegExp)for(o=i.length;o--;)r.call(this,e,i[o]);else for(o in e)e.hasOwnProperty(o)&&(n=e[o])&&(\"function\"==typeof n?r.call(this,o,n):s.call(this,o,n));return this},o.removeEvent=function(t){var e,i=typeof t,o=this._getEvents();if(\"string\"===i)delete o[t];else if(t instanceof RegExp)for(e in o)o.hasOwnProperty(e)&&t.test(e)&&delete o[e];else delete this._events;return this},o.removeAllListeners=i(\"removeEvent\"),o.emitEvent=function(t,e){var i,o,n,r,s=this.getListenersAsObject(t);for(n in s)if(s.hasOwnProperty(n))for(o=s[n].length;o--;)i=s[n][o],i.once===!0&&this.removeListener(t,i.listener),r=i.listener.apply(this,e||[]),r===this._getOnceReturnValue()&&this.removeListener(t,i.listener);return this},o.trigger=i(\"emitEvent\"),o.emit=function(t){var e=Array.prototype.slice.call(arguments,1);return this.emitEvent(t,e)},o.setOnceReturnValue=function(t){return this._onceReturnValue=t,this},o._getOnceReturnValue=function(){return this.hasOwnProperty(\"_onceReturnValue\")?this._onceReturnValue:!0},o._getEvents=function(){return this._events||(this._events={})},t.noConflict=function(){return n.EventEmitter=r,t},\"function\"==typeof define&&define.amd?define(\"eventEmitter/EventEmitter\",[],function(){return t}):\"object\"==typeof module&&module.exports?module.exports=t:n.EventEmitter=t}.call(this),function(t){function e(t){if(t){if(\"string\"==typeof o[t])return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e,n=0,r=i.length;r>n;n++)if(e=i[n]+t,\"string\"==typeof o[e])return e}}var i=\"Webkit Moz ms Ms O\".split(\" \"),o=document.documentElement.style;\"function\"==typeof define&&define.amd?define(\"get-style-property/get-style-property\",[],function(){return e}):\"object\"==typeof exports?module.exports=e:t.getStyleProperty=e}(window),function(t){function e(t){var e=parseFloat(t),i=-1===t.indexOf(\"%\")&&!isNaN(e);return i&&e}function i(){}function o(){for(var t={width:0,height:0,innerWidth:0,innerHeight:0,outerWidth:0,outerHeight:0},e=0,i=s.length;i>e;e++){var o=s[e];t[o]=0}return t}function n(i){function n(){if(!d){d=!0;var o=t.getComputedStyle;if(p=function(){var t=o?function(t){return o(t,null)}:function(t){return t.currentStyle};return function(e){var i=t(e);return i||r(\"Style returned \"+i+\". Are you running this code in a hidden iframe on Firefox? \"+\"See http://bit.ly/getsizebug1\"),i}}(),h=i(\"boxSizing\")){var n=document.createElement(\"div\");n.style.width=\"200px\",n.style.padding=\"1px 2px 3px 4px\",n.style.borderStyle=\"solid\",n.style.borderWidth=\"1px 2px 3px 4px\",n.style[h]=\"border-box\";var s=document.body||document.documentElement;s.appendChild(n);var a=p(n);f=200===e(a.width),s.removeChild(n)}}}function a(t){if(n(),\"string\"==typeof t&&(t=document.querySelector(t)),t&&\"object\"==typeof t&&t.nodeType){var i=p(t);if(\"none\"===i.display)return o();var r={};r.width=t.offsetWidth,r.height=t.offsetHeight;for(var a=r.isBorderBox=!(!h||!i[h]||\"border-box\"!==i[h]),d=0,l=s.length;l>d;d++){var c=s[d],y=i[c];y=u(t,y);var m=parseFloat(y);r[c]=isNaN(m)?0:m}var g=r.paddingLeft+r.paddingRight,v=r.paddingTop+r.paddingBottom,_=r.marginLeft+r.marginRight,I=r.marginTop+r.marginBottom,L=r.borderLeftWidth+r.borderRightWidth,z=r.borderTopWidth+r.borderBottomWidth,b=a&&f,x=e(i.width);x!==!1&&(r.width=x+(b?0:g+L));var S=e(i.height);return S!==!1&&(r.height=S+(b?0:v+z)),r.innerWidth=r.width-(g+L),r.innerHeight=r.height-(v+z),r.outerWidth=r.width+_,r.outerHeight=r.height+I,r}}function u(e,i){if(t.getComputedStyle||-1===i.indexOf(\"%\"))return i;var o=e.style,n=o.left,r=e.runtimeStyle,s=r&&r.left;return s&&(r.left=e.currentStyle.left),o.left=i,i=o.pixelLeft,o.left=n,s&&(r.left=s),i}var p,h,f,d=!1;return a}var r=\"undefined\"==typeof console?i:function(t){console.error(t)},s=[\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"paddingBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marginBottom\",\"borderLeftWidth\",\"borderRightWidth\",\"borderTopWidth\",\"borderBottomWidth\"];\"function\"==typeof define&&define.amd?define(\"get-size/get-size\",[\"get-style-property/get-style-property\"],n):\"object\"==typeof exports?module.exports=n(require(\"desandro-get-style-property\")):t.getSize=n(t.getStyleProperty)}(window),function(t){function e(t,e){return t[s](e)}function i(t){if(!t.parentNode){var e=document.createDocumentFragment();e.appendChild(t)}}function o(t,e){i(t);for(var o=t.parentNode.querySelectorAll(e),n=0,r=o.length;r>n;n++)if(o[n]===t)return!0;return!1}function n(t,o){return i(t),e(t,o)}var r,s=function(){if(t.matchesSelector)return\"matchesSelector\";for(var e=[\"webkit\",\"moz\",\"ms\",\"o\"],i=0,o=e.length;o>i;i++){var n=e[i],r=n+\"MatchesSelector\";if(t[r])return r}}();if(s){var a=document.createElement(\"div\"),u=e(a,\"div\");r=u?e:n}else r=o;\"function\"==typeof define&&define.amd?define(\"matches-selector/matches-selector\",[],function(){return r}):\"object\"==typeof exports?module.exports=r:window.matchesSelector=r}(Element.prototype),function(t){function e(t,e){for(var i in e)t[i]=e[i];return t}function i(t){for(var e in t)return!1;return e=null,!0}function o(t){return t.replace(/([A-Z])/g,function(t){return\"-\"+t.toLowerCase()})}function n(t,n,r){function a(t,e){t&&(this.element=t,this.layout=e,this.position={x:0,y:0},this._create())}var u=r(\"transition\"),p=r(\"transform\"),h=u&&p,f=!!r(\"perspective\"),d={WebkitTransition:\"webkitTransitionEnd\",MozTransition:\"transitionend\",OTransition:\"otransitionend\",transition:\"transitionend\"}[u],l=[\"transform\",\"transition\",\"transitionDuration\",\"transitionProperty\"],c=function(){for(var t={},e=0,i=l.length;i>e;e++){var o=l[e],n=r(o);n&&n!==o&&(t[o]=n)}return t}();e(a.prototype,t.prototype),a.prototype._create=function(){this._transn={ingProperties:{},clean:{},onEnd:{}},this.css({position:\"absolute\"})},a.prototype.handleEvent=function(t){var e=\"on\"+t.type;this[e]&&this[e](t)},a.prototype.getSize=function(){this.size=n(this.element)},a.prototype.css=function(t){var e=this.element.style;for(var i in t){var o=c[i]||i;e[o]=t[i]}},a.prototype.getPosition=function(){var t=s(this.element),e=this.layout.options,i=e.isOriginLeft,o=e.isOriginTop,n=parseInt(t[i?\"left\":\"right\"],10),r=parseInt(t[o?\"top\":\"bottom\"],10);n=isNaN(n)?0:n,r=isNaN(r)?0:r;var a=this.layout.size;n-=i?a.paddingLeft:a.paddingRight,r-=o?a.paddingTop:a.paddingBottom,this.position.x=n,this.position.y=r},a.prototype.layoutPosition=function(){var t=this.layout.size,e=this.layout.options,i={};e.isOriginLeft?(i.left=this.position.x+t.paddingLeft+\"px\",i.right=\"\"):(i.right=this.position.x+t.paddingRight+\"px\",i.left=\"\"),e.isOriginTop?(i.top=this.position.y+t.paddingTop+\"px\",i.bottom=\"\"):(i.bottom=this.position.y+t.paddingBottom+\"px\",i.top=\"\"),this.css(i),this.emitEvent(\"layout\",[this])};var y=f?function(t,e){return\"translate3d(\"+t+\"px, \"+e+\"px, 0)\"}:function(t,e){return\"translate(\"+t+\"px, \"+e+\"px)\"};a.prototype._transitionTo=function(t,e){this.getPosition();var i=this.position.x,o=this.position.y,n=parseInt(t,10),r=parseInt(e,10),s=n===this.position.x&&r===this.position.y;if(this.setPosition(t,e),s&&!this.isTransitioning)return this.layoutPosition(),void 0;var a=t-i,u=e-o,p={},h=this.layout.options;a=h.isOriginLeft?a:-a,u=h.isOriginTop?u:-u,p.transform=y(a,u),this.transition({to:p,onTransitionEnd:{transform:this.layoutPosition},isCleaning:!0})},a.prototype.goTo=function(t,e){this.setPosition(t,e),this.layoutPosition()},a.prototype.moveTo=h?a.prototype._transitionTo:a.prototype.goTo,a.prototype.setPosition=function(t,e){this.position.x=parseInt(t,10),this.position.y=parseInt(e,10)},a.prototype._nonTransition=function(t){this.css(t.to),t.isCleaning&&this._removeStyles(t.to);for(var e in t.onTransitionEnd)t.onTransitionEnd[e].call(this)},a.prototype._transition=function(t){if(!parseFloat(this.layout.options.transitionDuration))return this._nonTransition(t),void 0;var e=this._transn;for(var i in t.onTransitionEnd)e.onEnd[i]=t.onTransitionEnd[i];for(i in t.to)e.ingProperties[i]=!0,t.isCleaning&&(e.clean[i]=!0);if(t.from){this.css(t.from);var o=this.element.offsetHeight;o=null}this.enableTransition(t.to),this.css(t.to),this.isTransitioning=!0};var m=p&&o(p)+\",opacity\";a.prototype.enableTransition=function(){this.isTransitioning||(this.css({transitionProperty:m,transitionDuration:this.layout.options.transitionDuration}),this.element.addEventListener(d,this,!1))},a.prototype.transition=a.prototype[u?\"_transition\":\"_nonTransition\"],a.prototype.onwebkitTransitionEnd=function(t){this.ontransitionend(t)},a.prototype.onotransitionend=function(t){this.ontransitionend(t)};var g={\"-webkit-transform\":\"transform\",\"-moz-transform\":\"transform\",\"-o-transform\":\"transform\"};a.prototype.ontransitionend=function(t){if(t.target===this.element){var e=this._transn,o=g[t.propertyName]||t.propertyName;if(delete e.ingProperties[o],i(e.ingProperties)&&this.disableTransition(),o in e.clean&&(this.element.style[t.propertyName]=\"\",delete e.clean[o]),o in e.onEnd){var n=e.onEnd[o];n.call(this),delete e.onEnd[o]}this.emitEvent(\"transitionEnd\",[this])}},a.prototype.disableTransition=function(){this.removeTransitionStyles(),this.element.removeEventListener(d,this,!1),this.isTransitioning=!1},a.prototype._removeStyles=function(t){var e={};for(var i in t)e[i]=\"\";this.css(e)};var v={transitionProperty:\"\",transitionDuration:\"\"};return a.prototype.removeTransitionStyles=function(){this.css(v)},a.prototype.removeElem=function(){this.element.parentNode.removeChild(this.element),this.emitEvent(\"remove\",[this])},a.prototype.remove=function(){if(!u||!parseFloat(this.layout.options.transitionDuration))return this.removeElem(),void 0;var t=this;this.on(\"transitionEnd\",function(){return t.removeElem(),!0}),this.hide()},a.prototype.reveal=function(){delete this.isHidden,this.css({display:\"\"});var t=this.layout.options;this.transition({from:t.hiddenStyle,to:t.visibleStyle,isCleaning:!0})},a.prototype.hide=function(){this.isHidden=!0,this.css({display:\"\"});var t=this.layout.options;this.transition({from:t.visibleStyle,to:t.hiddenStyle,isCleaning:!0,onTransitionEnd:{opacity:function(){this.isHidden&&this.css({display:\"none\"})}}})},a.prototype.destroy=function(){this.css({position:\"\",left:\"\",right:\"\",top:\"\",bottom:\"\",transition:\"\",transform:\"\"})},a}var r=t.getComputedStyle,s=r?function(t){return r(t,null)}:function(t){return t.currentStyle};\"function\"==typeof define&&define.amd?define(\"outlayer/item\",[\"eventEmitter/EventEmitter\",\"get-size/get-size\",\"get-style-property/get-style-property\"],n):\"object\"==typeof exports?module.exports=n(require(\"wolfy87-eventemitter\"),require(\"get-size\"),require(\"desandro-get-style-property\")):(t.Outlayer={},t.Outlayer.Item=n(t.EventEmitter,t.getSize,t.getStyleProperty))}(window),function(t){function e(t,e){for(var i in e)t[i]=e[i];return t}function i(t){return\"[object Array]\"===f.call(t)}function o(t){var e=[];if(i(t))e=t;else if(t&&\"number\"==typeof t.length)for(var o=0,n=t.length;n>o;o++)e.push(t[o]);else e.push(t);return e}function n(t,e){var i=l(e,t);-1!==i&&e.splice(i,1)}function r(t){return t.replace(/(.)([A-Z])/g,function(t,e,i){return e+\"-\"+i}).toLowerCase()}function s(i,s,f,l,c,y){function m(t,i){if(\"string\"==typeof t&&(t=a.querySelector(t)),!t||!d(t))return u&&u.error(\"Bad \"+this.constructor.namespace+\" element: \"+t),void 0;this.element=t,this.options=e({},this.constructor.defaults),this.option(i);var o=++g;this.element.outlayerGUID=o,v[o]=this,this._create(),this.options.isInitLayout&&this.layout()}var g=0,v={};return m.namespace=\"outlayer\",m.Item=y,m.defaults={containerStyle:{position:\"relative\"},isInitLayout:!0,isOriginLeft:!0,isOriginTop:!0,isResizeBound:!0,isResizingContainer:!0,transitionDuration:\"0.4s\",hiddenStyle:{opacity:0,transform:\"scale(0.001)\"},visibleStyle:{opacity:1,transform:\"scale(1)\"}},e(m.prototype,f.prototype),m.prototype.option=function(t){e(this.options,t)},m.prototype._create=function(){this.reloadItems(),this.stamps=[],this.stamp(this.options.stamp),e(this.element.style,this.options.containerStyle),this.options.isResizeBound&&this.bindResize()},m.prototype.reloadItems=function(){this.items=this._itemize(this.element.children)},m.prototype._itemize=function(t){for(var e=this._filterFindItemElements(t),i=this.constructor.Item,o=[],n=0,r=e.length;r>n;n++){var s=e[n],a=new i(s,this);o.push(a)}return o},m.prototype._filterFindItemElements=function(t){t=o(t);for(var e=this.options.itemSelector,i=[],n=0,r=t.length;r>n;n++){var s=t[n];if(d(s))if(e){c(s,e)&&i.push(s);for(var a=s.querySelectorAll(e),u=0,p=a.length;p>u;u++)i.push(a[u])}else i.push(s)}return i},m.prototype.getItemElements=function(){for(var t=[],e=0,i=this.items.length;i>e;e++)t.push(this.items[e].element);return t},m.prototype.layout=function(){this._resetLayout(),this._manageStamps();var t=void 0!==this.options.isLayoutInstant?this.options.isLayoutInstant:!this._isLayoutInited;this.layoutItems(this.items,t),this._isLayoutInited=!0},m.prototype._init=m.prototype.layout,m.prototype._resetLayout=function(){this.getSize()},m.prototype.getSize=function(){this.size=l(this.element)},m.prototype._getMeasurement=function(t,e){var i,o=this.options[t];o?(\"string\"==typeof o?i=this.element.querySelector(o):d(o)&&(i=o),this[t]=i?l(i)[e]:o):this[t]=0},m.prototype.layoutItems=function(t,e){t=this._getItemsForLayout(t),this._layoutItems(t,e),this._postLayout()},m.prototype._getItemsForLayout=function(t){for(var e=[],i=0,o=t.length;o>i;i++){var n=t[i];n.isIgnored||e.push(n)}return e},m.prototype._layoutItems=function(t,e){function i(){o.emitEvent(\"layoutComplete\",[o,t])}var o=this;if(!t||!t.length)return i(),void 0;this._itemsOn(t,\"layout\",i);for(var n=[],r=0,s=t.length;s>r;r++){var a=t[r],u=this._getItemLayoutPosition(a);u.item=a,u.isInstant=e||a.isLayoutInstant,n.push(u)}this._processLayoutQueue(n)},m.prototype._getItemLayoutPosition=function(){return{x:0,y:0}},m.prototype._processLayoutQueue=function(t){for(var e=0,i=t.length;i>e;e++){var o=t[e];this._positionItem(o.item,o.x,o.y,o.isInstant)}},m.prototype._positionItem=function(t,e,i,o){o?t.goTo(e,i):t.moveTo(e,i)},m.prototype._postLayout=function(){this.resizeContainer()},m.prototype.resizeContainer=function(){if(this.options.isResizingContainer){var t=this._getContainerSize();t&&(this._setContainerMeasure(t.width,!0),this._setContainerMeasure(t.height,!1))}},m.prototype._getContainerSize=h,m.prototype._setContainerMeasure=function(t,e){if(void 0!==t){var i=this.size;i.isBorderBox&&(t+=e?i.paddingLeft+i.paddingRight+i.borderLeftWidth+i.borderRightWidth:i.paddingBottom+i.paddingTop+i.borderTopWidth+i.borderBottomWidth),t=Math.max(t,0),this.element.style[e?\"width\":\"height\"]=t+\"px\"}},m.prototype._itemsOn=function(t,e,i){function o(){return n++,n===r&&i.call(s),!0}for(var n=0,r=t.length,s=this,a=0,u=t.length;u>a;a++){var p=t[a];p.on(e,o)}},m.prototype.ignore=function(t){var e=this.getItem(t);e&&(e.isIgnored=!0)},m.prototype.unignore=function(t){var e=this.getItem(t);e&&delete e.isIgnored},m.prototype.stamp=function(t){if(t=this._find(t)){this.stamps=this.stamps.concat(t);for(var e=0,i=t.length;i>e;e++){var o=t[e];this.ignore(o)}}},m.prototype.unstamp=function(t){if(t=this._find(t))for(var e=0,i=t.length;i>e;e++){var o=t[e];n(o,this.stamps),this.unignore(o)}},m.prototype._find=function(t){return t?(\"string\"==typeof t&&(t=this.element.querySelectorAll(t)),t=o(t)):void 0},m.prototype._manageStamps=function(){if(this.stamps&&this.stamps.length){this._getBoundingRect();for(var t=0,e=this.stamps.length;e>t;t++){var i=this.stamps[t];this._manageStamp(i)}}},m.prototype._getBoundingRect=function(){var t=this.element.getBoundingClientRect(),e=this.size;this._boundingRect={left:t.left+e.paddingLeft+e.borderLeftWidth,top:t.top+e.paddingTop+e.borderTopWidth,right:t.right-(e.paddingRight+e.borderRightWidth),bottom:t.bottom-(e.paddingBottom+e.borderBottomWidth)}},m.prototype._manageStamp=h,m.prototype._getElementOffset=function(t){var e=t.getBoundingClientRect(),i=this._boundingRect,o=l(t),n={left:e.left-i.left-o.marginLeft,top:e.top-i.top-o.marginTop,right:i.right-e.right-o.marginRight,bottom:i.bottom-e.bottom-o.marginBottom};return n},m.prototype.handleEvent=function(t){var e=\"on\"+t.type;this[e]&&this[e](t)},m.prototype.bindResize=function(){this.isResizeBound||(i.bind(t,\"resize\",this),this.isResizeBound=!0)},m.prototype.unbindResize=function(){this.isResizeBound&&i.unbind(t,\"resize\",this),this.isResizeBound=!1},m.prototype.onresize=function(){function t(){e.resize(),delete e.resizeTimeout}this.resizeTimeout&&clearTimeout(this.resizeTimeout);var e=this;this.resizeTimeout=setTimeout(t,100)},m.prototype.resize=function(){this.isResizeBound&&this.needsResizeLayout()&&this.layout()},m.prototype.needsResizeLayout=function(){var t=l(this.element),e=this.size&&t;return e&&t.innerWidth!==this.size.innerWidth},m.prototype.addItems=function(t){var e=this._itemize(t);return e.length&&(this.items=this.items.concat(e)),e},m.prototype.appended=function(t){var e=this.addItems(t);e.length&&(this.layoutItems(e,!0),this.reveal(e))},m.prototype.prepended=function(t){var e=this._itemize(t);if(e.length){var i=this.items.slice(0);this.items=e.concat(i),this._resetLayout(),this._manageStamps(),this.layoutItems(e,!0),this.reveal(e),this.layoutItems(i)}},m.prototype.reveal=function(t){var e=t&&t.length;if(e)for(var i=0;e>i;i++){var o=t[i];o.reveal()}},m.prototype.hide=function(t){var e=t&&t.length;if(e)for(var i=0;e>i;i++){var o=t[i];o.hide()}},m.prototype.getItem=function(t){for(var e=0,i=this.items.length;i>e;e++){var o=this.items[e];if(o.element===t)return o}},m.prototype.getItems=function(t){if(t&&t.length){for(var e=[],i=0,o=t.length;o>i;i++){var n=t[i],r=this.getItem(n);r&&e.push(r)}return e}},m.prototype.remove=function(t){t=o(t);var e=this.getItems(t);if(e&&e.length){this._itemsOn(e,\"remove\",function(){this.emitEvent(\"removeComplete\",[this,e])});for(var i=0,r=e.length;r>i;i++){var s=e[i];s.remove(),n(s,this.items)}}},m.prototype.destroy=function(){var t=this.element.style;t.height=\"\",t.position=\"\",t.width=\"\";for(var e=0,i=this.items.length;i>e;e++){var o=this.items[e];o.destroy()}this.unbindResize();var n=this.element.outlayerGUID;delete v[n],delete this.element.outlayerGUID,p&&p.removeData(this.element,this.constructor.namespace)},m.data=function(t){var e=t&&t.outlayerGUID;return e&&v[e]},m.create=function(t,i){function o(){m.apply(this,arguments)}return Object.create?o.prototype=Object.create(m.prototype):e(o.prototype,m.prototype),o.prototype.constructor=o,o.defaults=e({},m.defaults),e(o.defaults,i),o.prototype.settings={},o.namespace=t,o.data=m.data,o.Item=function(){y.apply(this,arguments)},o.Item.prototype=new y,s(function(){for(var e=r(t),i=a.querySelectorAll(\".js-\"+e),n=\"data-\"+e+\"-options\",s=0,h=i.length;h>s;s++){var f,d=i[s],l=d.getAttribute(n);try{f=l&&JSON.parse(l)}catch(c){u&&u.error(\"Error parsing \"+n+\" on \"+d.nodeName.toLowerCase()+(d.id?\"#\"+d.id:\"\")+\": \"+c);continue}var y=new o(d,f);p&&p.data(d,t,y)}}),p&&p.bridget&&p.bridget(t,o),o},m.Item=y,m}var a=t.document,u=t.console,p=t.jQuery,h=function(){},f=Object.prototype.toString,d=\"function\"==typeof HTMLElement||\"object\"==typeof HTMLElement?function(t){return t instanceof HTMLElement}:function(t){return t&&\"object\"==typeof t&&1===t.nodeType&&\"string\"==typeof t.nodeName},l=Array.prototype.indexOf?function(t,e){return t.indexOf(e)}:function(t,e){for(var i=0,o=t.length;o>i;i++)if(t[i]===e)return i;return-1};\"function\"==typeof define&&define.amd?define(\"outlayer/outlayer\",[\"eventie/eventie\",\"doc-ready/doc-ready\",\"eventEmitter/EventEmitter\",\"get-size/get-size\",\"matches-selector/matches-selector\",\"./item\"],s):\"object\"==typeof exports?module.exports=s(require(\"eventie\"),require(\"doc-ready\"),require(\"wolfy87-eventemitter\"),require(\"get-size\"),require(\"desandro-matches-selector\"),require(\"./item\")):t.Outlayer=s(t.eventie,t.docReady,t.EventEmitter,t.getSize,t.matchesSelector,t.Outlayer.Item)}(window),function(t){function e(t){function e(){t.Item.apply(this,arguments)}e.prototype=new t.Item,e.prototype._create=function(){this.id=this.layout.itemGUID++,t.Item.prototype._create.call(this),this.sortData={}},e.prototype.updateSortData=function(){if(!this.isIgnored){this.sortData.id=this.id,this.sortData[\"original-order\"]=this.id,this.sortData.random=Math.random();var t=this.layout.options.getSortData,e=this.layout._sorters;for(var i in t){var o=e[i];this.sortData[i]=o(this.element,this)}}};var i=e.prototype.destroy;return e.prototype.destroy=function(){i.apply(this,arguments),this.css({display:\"\"})},e}\"function\"==typeof define&&define.amd?define(\"isotope/js/item\",[\"outlayer/outlayer\"],e):\"object\"==typeof exports?module.exports=e(require(\"outlayer\")):(t.Isotope=t.Isotope||{},t.Isotope.Item=e(t.Outlayer))}(window),function(t){function e(t,e){function i(t){this.isotope=t,t&&(this.options=t.options[this.namespace],this.element=t.element,this.items=t.filteredItems,this.size=t.size)}return function(){function t(t){return function(){return e.prototype[t].apply(this.isotope,arguments)}}for(var o=[\"_resetLayout\",\"_getItemLayoutPosition\",\"_manageStamp\",\"_getContainerSize\",\"_getElementOffset\",\"needsResizeLayout\"],n=0,r=o.length;r>n;n++){var s=o[n];i.prototype[s]=t(s)}}(),i.prototype.needsVerticalResizeLayout=function(){var e=t(this.isotope.element),i=this.isotope.size&&e;return i&&e.innerHeight!==this.isotope.size.innerHeight},i.prototype._getMeasurement=function(){this.isotope._getMeasurement.apply(this,arguments)},i.prototype.getColumnWidth=function(){this.getSegmentSize(\"column\",\"Width\")},i.prototype.getRowHeight=function(){this.getSegmentSize(\"row\",\"Height\")},i.prototype.getSegmentSize=function(t,e){var i=t+e,o=\"outer\"+e;if(this._getMeasurement(i,o),!this[i]){var n=this.getFirstItemSize();this[i]=n&&n[o]||this.isotope.size[\"inner\"+e]}},i.prototype.getFirstItemSize=function(){var e=this.isotope.filteredItems[0];return e&&e.element&&t(e.element)},i.prototype.layout=function(){this.isotope.layout.apply(this.isotope,arguments)},i.prototype.getSize=function(){this.isotope.getSize(),this.size=this.isotope.size},i.modes={},i.create=function(t,e){function o(){i.apply(this,arguments)}return o.prototype=new i,e&&(o.options=e),o.prototype.namespace=t,i.modes[t]=o,o},i}\"function\"==typeof define&&define.amd?define(\"isotope/js/layout-mode\",[\"get-size/get-size\",\"outlayer/outlayer\"],e):\"object\"==typeof exports?module.exports=e(require(\"get-size\"),require(\"outlayer\")):(t.Isotope=t.Isotope||{},t.Isotope.LayoutMode=e(t.getSize,t.Outlayer))}(window),function(t){function e(t,e){var o=t.create(\"masonry\");return o.prototype._resetLayout=function(){this.getSize(),this._getMeasurement(\"columnWidth\",\"outerWidth\"),this._getMeasurement(\"gutter\",\"outerWidth\"),this.measureColumns();var t=this.cols;for(this.colYs=[];t--;)this.colYs.push(0);this.maxY=0},o.prototype.measureColumns=function(){if(this.getContainerWidth(),!this.columnWidth){var t=this.items[0],i=t&&t.element;this.columnWidth=i&&e(i).outerWidth||this.containerWidth}this.columnWidth+=this.gutter,this.cols=Math.floor((this.containerWidth+this.gutter)/this.columnWidth),this.cols=Math.max(this.cols,1)},o.prototype.getContainerWidth=function(){var t=this.options.isFitWidth?this.element.parentNode:this.element,i=e(t);this.containerWidth=i&&i.innerWidth},o.prototype._getItemLayoutPosition=function(t){t.getSize();var e=t.size.outerWidth%this.columnWidth,o=e&&1>e?\"round\":\"ceil\",n=Math[o](t.size.outerWidth/this.columnWidth);n=Math.min(n,this.cols);for(var r=this._getColGroup(n),s=Math.min.apply(Math,r),a=i(r,s),u={x:this.columnWidth*a,y:s},p=s+t.size.outerHeight,h=this.cols+1-r.length,f=0;h>f;f++)this.colYs[a+f]=p;return u},o.prototype._getColGroup=function(t){if(2>t)return this.colYs;for(var e=[],i=this.cols+1-t,o=0;i>o;o++){var n=this.colYs.slice(o,o+t);e[o]=Math.max.apply(Math,n)}return e},o.prototype._manageStamp=function(t){var i=e(t),o=this._getElementOffset(t),n=this.options.isOriginLeft?o.left:o.right,r=n+i.outerWidth,s=Math.floor(n/this.columnWidth);s=Math.max(0,s);var a=Math.floor(r/this.columnWidth);a-=r%this.columnWidth?0:1,a=Math.min(this.cols-1,a);for(var u=(this.options.isOriginTop?o.top:o.bottom)+i.outerHeight,p=s;a>=p;p++)this.colYs[p]=Math.max(u,this.colYs[p])},o.prototype._getContainerSize=function(){this.maxY=Math.max.apply(Math,this.colYs);var t={height:this.maxY};return this.options.isFitWidth&&(t.width=this._getContainerFitWidth()),t},o.prototype._getContainerFitWidth=function(){for(var t=0,e=this.cols;--e&&0===this.colYs[e];)t++;return(this.cols-t)*this.columnWidth-this.gutter},o.prototype.needsResizeLayout=function(){var t=this.containerWidth;return this.getContainerWidth(),t!==this.containerWidth},o}var i=Array.prototype.indexOf?function(t,e){return t.indexOf(e)}:function(t,e){for(var i=0,o=t.length;o>i;i++){var n=t[i];if(n===e)return i}return-1};\"function\"==typeof define&&define.amd?define(\"masonry/masonry\",[\"outlayer/outlayer\",\"get-size/get-size\"],e):\"object\"==typeof exports?module.exports=e(require(\"outlayer\"),require(\"get-size\")):t.Masonry=e(t.Outlayer,t.getSize)}(window),function(t){function e(t,e){for(var i in e)t[i]=e[i];return t}function i(t,i){var o=t.create(\"masonry\"),n=o.prototype._getElementOffset,r=o.prototype.layout,s=o.prototype._getMeasurement;e(o.prototype,i.prototype),o.prototype._getElementOffset=n,o.prototype.layout=r,o.prototype._getMeasurement=s;var a=o.prototype.measureColumns;o.prototype.measureColumns=function(){this.items=this.isotope.filteredItems,a.call(this)};var u=o.prototype._manageStamp;return o.prototype._manageStamp=function(){this.options.isOriginLeft=this.isotope.options.isOriginLeft,this.options.isOriginTop=this.isotope.options.isOriginTop,u.apply(this,arguments)},o}\"function\"==typeof define&&define.amd?define(\"isotope/js/layout-modes/masonry\",[\"../layout-mode\",\"masonry/masonry\"],i):\"object\"==typeof exports?module.exports=i(require(\"../layout-mode\"),require(\"masonry-layout\")):i(t.Isotope.LayoutMode,t.Masonry)}(window),function(t){function e(t){var e=t.create(\"fitRows\");return e.prototype._resetLayout=function(){this.x=0,this.y=0,this.maxY=0,this._getMeasurement(\"gutter\",\"outerWidth\")},e.prototype._getItemLayoutPosition=function(t){t.getSize();var e=t.size.outerWidth+this.gutter,i=this.isotope.size.innerWidth+this.gutter;0!==this.x&&e+this.x>i&&(this.x=0,this.y=this.maxY);var o={x:this.x,y:this.y};return this.maxY=Math.max(this.maxY,this.y+t.size.outerHeight),this.x+=e,o},e.prototype._getContainerSize=function(){return{height:this.maxY}},e}\"function\"==typeof define&&define.amd?define(\"isotope/js/layout-modes/fit-rows\",[\"../layout-mode\"],e):\"object\"==typeof exports?module.exports=e(require(\"../layout-mode\")):e(t.Isotope.LayoutMode)}(window),function(t){function e(t){var e=t.create(\"vertical\",{horizontalAlignment:0});return e.prototype._resetLayout=function(){this.y=0},e.prototype._getItemLayoutPosition=function(t){t.getSize();var e=(this.isotope.size.innerWidth-t.size.outerWidth)*this.options.horizontalAlignment,i=this.y;return this.y+=t.size.outerHeight,{x:e,y:i}},e.prototype._getContainerSize=function(){return{height:this.y}},e}\"function\"==typeof define&&define.amd?define(\"isotope/js/layout-modes/vertical\",[\"../layout-mode\"],e):\"object\"==typeof exports?module.exports=e(require(\"../layout-mode\")):e(t.Isotope.LayoutMode)}(window),function(t){function e(t,e){for(var i in e)t[i]=e[i];return t}function i(t){return\"[object Array]\"===h.call(t)}function o(t){var e=[];if(i(t))e=t;else if(t&&\"number\"==typeof t.length)for(var o=0,n=t.length;n>o;o++)e.push(t[o]);else e.push(t);return e}function n(t,e){var i=f(e,t);-1!==i&&e.splice(i,1)}function r(t,i,r,u,h){function f(t,e){return function(i,o){for(var n=0,r=t.length;r>n;n++){var s=t[n],a=i.sortData[s],u=o.sortData[s];if(a>u||u>a){var p=void 0!==e[s]?e[s]:e,h=p?1:-1;return(a>u?1:-1)*h}}return 0}}var d=t.create(\"isotope\",{layoutMode:\"masonry\",isJQueryFiltering:!0,sortAscending:!0});d.Item=u,d.LayoutMode=h,d.prototype._create=function(){this.itemGUID=0,this._sorters={},this._getSorters(),t.prototype._create.call(this),this.modes={},this.filteredItems=this.items,this.sortHistory=[\"original-order\"];for(var e in h.modes)this._initLayoutMode(e)},d.prototype.reloadItems=function(){this.itemGUID=0,t.prototype.reloadItems.call(this)},d.prototype._itemize=function(){for(var e=t.prototype._itemize.apply(this,arguments),i=0,o=e.length;o>i;i++){var n=e[i];n.id=this.itemGUID++}return this._updateItemsSortData(e),e },d.prototype._initLayoutMode=function(t){var i=h.modes[t],o=this.options[t]||{};this.options[t]=i.options?e(i.options,o):o,this.modes[t]=new i(this)},d.prototype.layout=function(){return!this._isLayoutInited&&this.options.isInitLayout?(this.arrange(),void 0):(this._layout(),void 0)},d.prototype._layout=function(){var t=this._getIsInstant();this._resetLayout(),this._manageStamps(),this.layoutItems(this.filteredItems,t),this._isLayoutInited=!0},d.prototype.arrange=function(t){this.option(t),this._getIsInstant(),this.filteredItems=this._filter(this.items),this._sort(),this._layout()},d.prototype._init=d.prototype.arrange,d.prototype._getIsInstant=function(){var t=void 0!==this.options.isLayoutInstant?this.options.isLayoutInstant:!this._isLayoutInited;return this._isInstant=t,t},d.prototype._filter=function(t){function e(){f.reveal(n),f.hide(r)}var i=this.options.filter;i=i||\"*\";for(var o=[],n=[],r=[],s=this._getFilterTest(i),a=0,u=t.length;u>a;a++){var p=t[a];if(!p.isIgnored){var h=s(p);h&&o.push(p),h&&p.isHidden?n.push(p):h||p.isHidden||r.push(p)}}var f=this;return this._isInstant?this._noTransition(e):e(),o},d.prototype._getFilterTest=function(t){return s&&this.options.isJQueryFiltering?function(e){return s(e.element).is(t)}:\"function\"==typeof t?function(e){return t(e.element)}:function(e){return r(e.element,t)}},d.prototype.updateSortData=function(t){var e;t?(t=o(t),e=this.getItems(t)):e=this.items,this._getSorters(),this._updateItemsSortData(e)},d.prototype._getSorters=function(){var t=this.options.getSortData;for(var e in t){var i=t[e];this._sorters[e]=l(i)}},d.prototype._updateItemsSortData=function(t){for(var e=t&&t.length,i=0;e&&e>i;i++){var o=t[i];o.updateSortData()}};var l=function(){function t(t){if(\"string\"!=typeof t)return t;var i=a(t).split(\" \"),o=i[0],n=o.match(/^\\[(.+)\\]$/),r=n&&n[1],s=e(r,o),u=d.sortDataParsers[i[1]];return t=u?function(t){return t&&u(s(t))}:function(t){return t&&s(t)}}function e(t,e){var i;return i=t?function(e){return e.getAttribute(t)}:function(t){var i=t.querySelector(e);return i&&p(i)}}return t}();d.sortDataParsers={parseInt:function(t){return parseInt(t,10)},parseFloat:function(t){return parseFloat(t)}},d.prototype._sort=function(){var t=this.options.sortBy;if(t){var e=[].concat.apply(t,this.sortHistory),i=f(e,this.options.sortAscending);this.filteredItems.sort(i),t!==this.sortHistory[0]&&this.sortHistory.unshift(t)}},d.prototype._mode=function(){var t=this.options.layoutMode,e=this.modes[t];if(!e)throw Error(\"No layout mode: \"+t);return e.options=this.options[t],e},d.prototype._resetLayout=function(){t.prototype._resetLayout.call(this),this._mode()._resetLayout()},d.prototype._getItemLayoutPosition=function(t){return this._mode()._getItemLayoutPosition(t)},d.prototype._manageStamp=function(t){this._mode()._manageStamp(t)},d.prototype._getContainerSize=function(){return this._mode()._getContainerSize()},d.prototype.needsResizeLayout=function(){return this._mode().needsResizeLayout()},d.prototype.appended=function(t){var e=this.addItems(t);if(e.length){var i=this._filterRevealAdded(e);this.filteredItems=this.filteredItems.concat(i)}},d.prototype.prepended=function(t){var e=this._itemize(t);if(e.length){var i=this.items.slice(0);this.items=e.concat(i),this._resetLayout(),this._manageStamps();var o=this._filterRevealAdded(e);this.layoutItems(i),this.filteredItems=o.concat(this.filteredItems)}},d.prototype._filterRevealAdded=function(t){var e=this._noTransition(function(){return this._filter(t)});return this.layoutItems(e,!0),this.reveal(e),t},d.prototype.insert=function(t){var e=this.addItems(t);if(e.length){var i,o,n=e.length;for(i=0;n>i;i++)o=e[i],this.element.appendChild(o.element);var r=this._filter(e);for(this._noTransition(function(){this.hide(r)}),i=0;n>i;i++)e[i].isLayoutInstant=!0;for(this.arrange(),i=0;n>i;i++)delete e[i].isLayoutInstant;this.reveal(r)}};var c=d.prototype.remove;return d.prototype.remove=function(t){t=o(t);var e=this.getItems(t);if(c.call(this,t),e&&e.length)for(var i=0,r=e.length;r>i;i++){var s=e[i];n(s,this.filteredItems)}},d.prototype.shuffle=function(){for(var t=0,e=this.items.length;e>t;t++){var i=this.items[t];i.sortData.random=Math.random()}this.options.sortBy=\"random\",this._sort(),this._layout()},d.prototype._noTransition=function(t){var e=this.options.transitionDuration;this.options.transitionDuration=0;var i=t.call(this);return this.options.transitionDuration=e,i},d.prototype.getFilteredItemElements=function(){for(var t=[],e=0,i=this.filteredItems.length;i>e;e++)t.push(this.filteredItems[e].element);return t},d}var s=t.jQuery,a=String.prototype.trim?function(t){return t.trim()}:function(t){return t.replace(/^\\s+|\\s+$/g,\"\")},u=document.documentElement,p=u.textContent?function(t){return t.textContent}:function(t){return t.innerText},h=Object.prototype.toString,f=Array.prototype.indexOf?function(t,e){return t.indexOf(e)}:function(t,e){for(var i=0,o=t.length;o>i;i++)if(t[i]===e)return i;return-1};\"function\"==typeof define&&define.amd?define([\"outlayer/outlayer\",\"get-size/get-size\",\"matches-selector/matches-selector\",\"isotope/js/item\",\"isotope/js/layout-mode\",\"isotope/js/layout-modes/masonry\",\"isotope/js/layout-modes/fit-rows\",\"isotope/js/layout-modes/vertical\"],r):\"object\"==typeof exports?module.exports=r(require(\"outlayer\"),require(\"get-size\"),require(\"desandro-matches-selector\"),require(\"./item\"),require(\"./layout-mode\"),require(\"./layout-modes/masonry\"),require(\"./layout-modes/fit-rows\"),require(\"./layout-modes/vertical\")):t.Isotope=r(t.Outlayer,t.getSize,t.matchesSelector,t.Isotope.Item,t.Isotope.LayoutMode)}(window);"},{"title":"","date":"2018-09-12T03:25:45.344Z","updated":"2015-06-16T03:25:00.000Z","comments":true,"path":"cv/old/css/dashboard.css","permalink":"http://tech.yushuai.xyz/cv/old/css/dashboard.css","excerpt":"","text":"/* * Base structure */ /* Move down content because we have a fixed navbar that is 50px tall */ body { padding-top: 50px; } /* * Global add-ons */ .sub-header { padding-bottom: 10px; border-bottom: 1px solid #eee; } /* * Top navigation * Hide default border to remove 1px line. */ .navbar-fixed-top { border: 0; } /* * Sidebar */ /* Hide for mobile, show later */ .sidebar { display:block; } @media (min-width: 768px) { .sidebar { position: fixed; top: 51px; bottom: 0; left: 0; z-index: 1000; display: block; padding: 20px; overflow-x: hidden; overflow-y: auto; /* Scrollable contents if viewport is shorter than content. */ background-color: #f5f5f5; } } /* Sidebar navigation */ .nav-sidebar { margin-right: -21px; /* 20px padding + 1px border */ margin-bottom: 20px; margin-left: -20px; } .nav-sidebar > li > a { padding-right: 20px; padding-left: 20px; } .nav-sidebar > .active > a, .nav-sidebar > .active > a:hover, .nav-sidebar > .active > a:focus { color: #fff; background-color: #428bca; } /* * Main content */ .main { padding: 20px; } @media (min-width: 768px) { .main { padding-right: 40px; padding-left: 40px; } } .main .page-header { margin-top: 0; } /* * Placeholder dashboard ideas */ .placeholders { margin-bottom: 30px; text-align: center; } .placeholders h4 { margin-bottom: 0; } .placeholder { margin-bottom: 20px; } .placeholder img { display: inline-block; border-radius: 50%; }"},{"title":"","date":"2018-10-30T12:50:19.359Z","updated":"2016-09-30T02:46:12.392Z","comments":true,"path":"cv/assets/plugins/imagesloaded.pkgd.min.js","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/imagesloaded.pkgd.min.js","excerpt":"","text":"/*! * imagesLoaded PACKAGED v3.1.8 * JavaScript is all like \"You images are done yet or what?\" * MIT License */ (function(){function e(){}function t(e,t){for(var n=e.length;n--;)if(e[n].listener===t)return n;return-1}function n(e){return function(){return this[e].apply(this,arguments)}}var i=e.prototype,r=this,o=r.EventEmitter;i.getListeners=function(e){var t,n,i=this._getEvents();if(\"object\"==typeof e){t={};for(n in i)i.hasOwnProperty(n)&&e.test(n)&&(t[n]=i[n])}else t=i[e]||(i[e]=[]);return t},i.flattenListeners=function(e){var t,n=[];for(t=0;e.length>t;t+=1)n.push(e[t].listener);return n},i.getListenersAsObject=function(e){var t,n=this.getListeners(e);return n instanceof Array&&(t={},t[e]=n),t||n},i.addListener=function(e,n){var i,r=this.getListenersAsObject(e),o=\"object\"==typeof n;for(i in r)r.hasOwnProperty(i)&&-1===t(r[i],n)&&r[i].push(o?n:{listener:n,once:!1});return this},i.on=n(\"addListener\"),i.addOnceListener=function(e,t){return this.addListener(e,{listener:t,once:!0})},i.once=n(\"addOnceListener\"),i.defineEvent=function(e){return this.getListeners(e),this},i.defineEvents=function(e){for(var t=0;e.length>t;t+=1)this.defineEvent(e[t]);return this},i.removeListener=function(e,n){var i,r,o=this.getListenersAsObject(e);for(r in o)o.hasOwnProperty(r)&&(i=t(o[r],n),-1!==i&&o[r].splice(i,1));return this},i.off=n(\"removeListener\"),i.addListeners=function(e,t){return this.manipulateListeners(!1,e,t)},i.removeListeners=function(e,t){return this.manipulateListeners(!0,e,t)},i.manipulateListeners=function(e,t,n){var i,r,o=e?this.removeListener:this.addListener,s=e?this.removeListeners:this.addListeners;if(\"object\"!=typeof t||t instanceof RegExp)for(i=n.length;i--;)o.call(this,t,n[i]);else for(i in t)t.hasOwnProperty(i)&&(r=t[i])&&(\"function\"==typeof r?o.call(this,i,r):s.call(this,i,r));return this},i.removeEvent=function(e){var t,n=typeof e,i=this._getEvents();if(\"string\"===n)delete i[e];else if(\"object\"===n)for(t in i)i.hasOwnProperty(t)&&e.test(t)&&delete i[t];else delete this._events;return this},i.removeAllListeners=n(\"removeEvent\"),i.emitEvent=function(e,t){var n,i,r,o,s=this.getListenersAsObject(e);for(r in s)if(s.hasOwnProperty(r))for(i=s[r].length;i--;)n=s[r][i],n.once===!0&&this.removeListener(e,n.listener),o=n.listener.apply(this,t||[]),o===this._getOnceReturnValue()&&this.removeListener(e,n.listener);return this},i.trigger=n(\"emitEvent\"),i.emit=function(e){var t=Array.prototype.slice.call(arguments,1);return this.emitEvent(e,t)},i.setOnceReturnValue=function(e){return this._onceReturnValue=e,this},i._getOnceReturnValue=function(){return this.hasOwnProperty(\"_onceReturnValue\")?this._onceReturnValue:!0},i._getEvents=function(){return this._events||(this._events={})},e.noConflict=function(){return r.EventEmitter=o,e},\"function\"==typeof define&&define.amd?define(\"eventEmitter/EventEmitter\",[],function(){return e}):\"object\"==typeof module&&module.exports?module.exports=e:this.EventEmitter=e}).call(this),function(e){function t(t){var n=e.event;return n.target=n.target||n.srcElement||t,n}var n=document.documentElement,i=function(){};n.addEventListener?i=function(e,t,n){e.addEventListener(t,n,!1)}:n.attachEvent&&(i=function(e,n,i){e[n+i]=i.handleEvent?function(){var n=t(e);i.handleEvent.call(i,n)}:function(){var n=t(e);i.call(e,n)},e.attachEvent(\"on\"+n,e[n+i])});var r=function(){};n.removeEventListener?r=function(e,t,n){e.removeEventListener(t,n,!1)}:n.detachEvent&&(r=function(e,t,n){e.detachEvent(\"on\"+t,e[t+n]);try{delete e[t+n]}catch(i){e[t+n]=void 0}});var o={bind:i,unbind:r};\"function\"==typeof define&&define.amd?define(\"eventie/eventie\",o):e.eventie=o}(this),function(e,t){\"function\"==typeof define&&define.amd?define([\"eventEmitter/EventEmitter\",\"eventie/eventie\"],function(n,i){return t(e,n,i)}):\"object\"==typeof exports?module.exports=t(e,require(\"wolfy87-eventemitter\"),require(\"eventie\")):e.imagesLoaded=t(e,e.EventEmitter,e.eventie)}(window,function(e,t,n){function i(e,t){for(var n in t)e[n]=t[n];return e}function r(e){return\"[object Array]\"===d.call(e)}function o(e){var t=[];if(r(e))t=e;else if(\"number\"==typeof e.length)for(var n=0,i=e.length;i>n;n++)t.push(e[n]);else t.push(e);return t}function s(e,t,n){if(!(this instanceof s))return new s(e,t);\"string\"==typeof e&&(e=document.querySelectorAll(e)),this.elements=o(e),this.options=i({},this.options),\"function\"==typeof t?n=t:i(this.options,t),n&&this.on(\"always\",n),this.getImages(),a&&(this.jqDeferred=new a.Deferred);var r=this;setTimeout(function(){r.check()})}function f(e){this.img=e}function c(e){this.src=e,v[e]=this}var a=e.jQuery,u=e.console,h=u!==void 0,d=Object.prototype.toString;s.prototype=new t,s.prototype.options={},s.prototype.getImages=function(){this.images=[];for(var e=0,t=this.elements.length;t>e;e++){var n=this.elements[e];\"IMG\"===n.nodeName&&this.addImage(n);var i=n.nodeType;if(i&&(1===i||9===i||11===i))for(var r=n.querySelectorAll(\"img\"),o=0,s=r.length;s>o;o++){var f=r[o];this.addImage(f)}}},s.prototype.addImage=function(e){var t=new f(e);this.images.push(t)},s.prototype.check=function(){function e(e,r){return t.options.debug&&h&&u.log(\"confirm\",e,r),t.progress(e),n++,n===i&&t.complete(),!0}var t=this,n=0,i=this.images.length;if(this.hasAnyBroken=!1,!i)return this.complete(),void 0;for(var r=0;i>r;r++){var o=this.images[r];o.on(\"confirm\",e),o.check()}},s.prototype.progress=function(e){this.hasAnyBroken=this.hasAnyBroken||!e.isLoaded;var t=this;setTimeout(function(){t.emit(\"progress\",t,e),t.jqDeferred&&t.jqDeferred.notify&&t.jqDeferred.notify(t,e)})},s.prototype.complete=function(){var e=this.hasAnyBroken?\"fail\":\"done\";this.isComplete=!0;var t=this;setTimeout(function(){if(t.emit(e,t),t.emit(\"always\",t),t.jqDeferred){var n=t.hasAnyBroken?\"reject\":\"resolve\";t.jqDeferred[n](t)}})},a&&(a.fn.imagesLoaded=function(e,t){var n=new s(this,e,t);return n.jqDeferred.promise(a(this))}),f.prototype=new t,f.prototype.check=function(){var e=v[this.img.src]||new c(this.img.src);if(e.isConfirmed)return this.confirm(e.isLoaded,\"cached was confirmed\"),void 0;if(this.img.complete&&void 0!==this.img.naturalWidth)return this.confirm(0!==this.img.naturalWidth,\"naturalWidth\"),void 0;var t=this;e.on(\"confirm\",function(e,n){return t.confirm(e.isLoaded,n),!0}),e.check()},f.prototype.confirm=function(e,t){this.isLoaded=e,this.emit(\"confirm\",this,t)};var v={};return c.prototype=new t,c.prototype.check=function(){if(!this.isChecked){var e=new Image;n.bind(e,\"load\",this),n.bind(e,\"error\",this),e.src=this.src,this.isChecked=!0}},c.prototype.handleEvent=function(e){var t=\"on\"+e.type;this[t]&&this[t](e)},c.prototype.onload=function(e){this.confirm(!0,\"onload\"),this.unbindProxyEvents(e)},c.prototype.onerror=function(e){this.confirm(!1,\"onerror\"),this.unbindProxyEvents(e)},c.prototype.confirm=function(e,t){this.isConfirmed=!0,this.isLoaded=e,this.emit(\"confirm\",this,t)},c.prototype.unbindProxyEvents=function(e){n.unbind(e.target,\"load\",this),n.unbind(e.target,\"error\",this)},s});"},{"title":"","date":"2018-09-12T03:25:45.348Z","updated":"2015-06-11T01:52:08.000Z","comments":true,"path":"cv/old/css/popuo-box.css","permalink":"http://tech.yushuai.xyz/cv/old/css/popuo-box.css","excerpt":"","text":"/* Styles for dialog window */ #small-dialog,#small-dialog1{ padding:20px; text-align: left; max-width: 650px; margin: 40px auto; position: relative; text-align:center; } #small-dialog-it,#small-dialog-in,#small-dialog-fr,#small-dialog-sh,#small-dialog-sf,#small-dialog-su,#small-dialog-me,#small-dialog-ch,#small-dialog-pi,#small-dialog-am { background: white; padding:20px; text-align: left; max-width: 450px; margin: 40px auto; position: relative; text-align:center; } a.play-icon.popup-with-zoom-anim img:hover { opacity: 0.5; transition:0.5s all; -webkit-transition:0.5s all; -o-transition:0.5s all; -moz-transition:0.5s all; -ms-transition:0.5s all; } .portfolio-items{ text-align:center; margin:0 auto; } .portfolio-items img{ width:100%; } .portfolio-items h4{ margin:1em 0; font-size:25px; color:#a63d56; } .portfolio-items p{ text-align:justify; } /** /** * Fade-zoom animation for first dialog */ /* start state */ .my-mfp-zoom-in #small-dialog { opacity: 0; -webkit-transition: all 0.2s ease-in-out; -moz-transition: all 0.2s ease-in-out; -o-transition: all 0.2s ease-in-out; transition: all 0.2s ease-in-out; -webkit-transform: scale(0.8); -moz-transform: scale(0.8); -ms-transform: scale(0.8); -o-transform: scale(0.8); transform: scale(0.8); } /* animate in */ .my-mfp-zoom-in.mfp-ready #small-dialog { opacity: 1; -webkit-transform: scale(1); -moz-transform: scale(1); -ms-transform: scale(1); -o-transform: scale(1); transform: scale(1); } /* animate out */ .my-mfp-zoom-in.mfp-removing #small-dialog { -webkit-transform: scale(0.8); -moz-transform: scale(0.8); -ms-transform: scale(0.8); -o-transform: scale(0.8); transform: scale(0.8); opacity: 0; } /* Dark overlay, start state */ .my-mfp-zoom-in.mfp-bg { -webkit-transition: opacity 0.3s ease-out; -moz-transition: opacity 0.3s ease-out; -o-transition: opacity 0.3s ease-out; transition: opacity 0.3s ease-out; } /* animate out */ .my-mfp-zoom-in.mfp-removing.mfp-bg { opacity: 0; } /** /* Magnific Popup CSS */ .mfp-bg { top: 0; left: 0; width: 100%; height: 100%; z-index: 1042; overflow: hidden; position: fixed; background:#fff; } .mfp-wrap { top: 0; left: 0; width: 100%; height: 100%; z-index: 1043; position: fixed; outline: none !important; -webkit-backface-visibility: hidden; } .mfp-container { text-align: center; position: absolute; width: 100%; height: 100%; left: 0; top: 0; padding: 0 8px; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } .mfp-container:before { content: ''; display: inline-block; height: 100%; vertical-align: middle; } .mfp-align-top .mfp-container:before { display: none; } .mfp-content { position: relative; display: inline-block; vertical-align: middle; margin: 0 auto; text-align: left; z-index: 1045; } .mfp-inline-holder .mfp-content, .mfp-ajax-holder .mfp-content { width: 100%; cursor: auto; } .mfp-ajax-cur { cursor: progress; } .mfp-zoom-out-cur, .mfp-zoom-out-cur .mfp-image-holder .mfp-close { cursor: -moz-zoom-out; cursor: -webkit-zoom-out; cursor: zoom-out; } .mfp-zoom { cursor: pointer; cursor: -webkit-zoom-in; cursor: -moz-zoom-in; cursor: zoom-in; } .mfp-auto-cursor .mfp-content { cursor: auto; } .mfp-close, .mfp-arrow, .mfp-preloader, .mfp-counter { -webkit-user-select: none; -moz-user-select: none; user-select: none; } .mfp-loading.mfp-figure { display: none; } .mfp-hide { display: none !important; } .mfp-content iframe{ width:100%; min-height:500px; } .mfp-preloader { color: #cccccc; position: absolute; top: 50%; width: auto; text-align: center; margin-top: -0.8em; left: 8px; right: 8px; z-index: 1044; } .mfp-preloader a { color: #cccccc; } .mfp-preloader a:hover { color: white; } .mfp-s-ready .mfp-preloader { display: none; } .mfp-s-error .mfp-content { display: none; } button.mfp-close, button.mfp-arrow { overflow: visible; cursor: pointer; border: 0; background:#FFF; -webkit-appearance: none; display: block; padding: 0; z-index: 1046; } button::-moz-focus-inner { padding: 0; border: 0; } .mfp-close { width: 44px; height: 44px; line-height: 44px; position: absolute; right: 0px; top: -43px; text-decoration: none; text-align: center; padding: 0 0 18px 10px; color: white; font-style: normal; font-size: 28px; outline:none; font-family: 'Open Sans', sans-serif; } .mfp-close:hover, .mfp-close:focus { opacity: 1; } .mfp-close-btn-in .mfp-close { color: #333333; } .mfp-image-holder .mfp-close, .mfp-iframe-holder .mfp-close { color: white; right: -6px; text-align: right; padding-right: 6px; width: 100%; } /*----*/ .login{ border-bottom:2px solid #1c1c1c; } .login input[type=\"text\"] { outline: none; padding:6px ; background: none; width: 93%; border: none; font-size:1.8em; color:#1c1c1c; } .login input[type=\"submit\"] { width: 35px; height: 35px; background: url(../images/img-sprite.png) -622px -22px no-repeat ; padding: 0px 1px; border: none; cursor: pointer; outline: none; vertical-align: middle; } .search-top p{ color:#818181; font-size:1.2em; line-height:1.5em; width:33%; text-align:center; padding: 1em 0; } @media all and (max-width:480px){ .login input[type=\"text\"] { width: 88%; font-size: 1.4em; } .search-top p { width: 60%; } } @media all and (max-width:320px){ .login input[type=\"text\"] { width: 80%; font-size: 1.2em; } #small-dialog{ padding:15px; } .search-top p { width: 70%; font-size:1em; } }"},{"title":"","date":"2018-10-13T02:47:13.079Z","updated":"2018-10-13T02:47:13.074Z","comments":true,"path":"cv/old/css/style.css","permalink":"http://tech.yushuai.xyz/cv/old/css/style.css","excerpt":"","text":"h4, h5, h6, h1, h2, h3 {margin: 0;} ul, ol {margin: 0; padding:0;} p {margin: 0;} html, body{ font-family: 'Ubuntu', sans-serif; font-size: 100%; background: #ffffff; } body a{ transition:0.5s all; -webkit-transition:0.5s all; -moz-transition:0.5s all; -o-transition:0.5s all; -ms-transition:0.5s all; } body { padding-top:0px; } a:focus { outline: thin dotted; outline: 0px auto -webkit-focus-ring-color; outline-offset: 0px; text-decoration:none; } /*-- header_top --*/ .sidebar{ background:#005792; top: 0px; padding:2em 30px; } .sidebar h1{ font-size:1.5em; font-weight:700; margin-bottom:1em; COLOR:#fff; font-family: 'Varela Round', sans-serif; } .sidebar img{ border:1px solid #fff; padding:0.6em; width:100%; } .details{ margin-top:2em; } .details h3{ font-weight:600; font-size:1em; color:#fff; } .copyrights{text-indent:-9999px;height:0;line-height:0;font-size:0;overflow:hidden;} .details p{ color:#FFFFFF; font-size:0.9em; margin:5px 0 2em 0; } .details p a{ color:#101010; font-size:0.9em; } address h3{ margin-bottom:5px; } address span{ display:block; color:#FFFFFF; font-size:0.9em; line-height:1.5em; } /*----*/ .main{ padding:2em 0; } .content{ margin-right:3em; } .glyphicon { top:1px; } .glyphicon-file:before,.glyphicon-print:before,.glyphicon-envelope:before,.glyphicon-picture:before{ margin-right: 9px; font-size: 14px; color: #6ecadc; } .details_header{ padding: 0em 1em 0 2em; } .details_header ul li{ display:inline-block; } .details_header ul li a{ padding:0 1em; color:#333; } .details_header ul li a:hover{ color:#6ecadc; } .education { margin:2em 0; } .education h3{ color: #FFF; padding: 5px 41px 5px 30px; display: inline-block; } .skills h3{ color: #FFF; padding: 5px 98px 5px 30px; display: inline-block; } .education_details,.research_details { padding:1.5em 0 0em 2em; } .education_details h4,.research_details h4{ color:#333; font-weight:600; font-size:1.5em; margin-bottom:6px; font-family: 'Varela Round', sans-serif; } .education_details h4 span,.research_details h4 span{ font-size: 0.65em; margin-left: 5px; color: #999; font-weight:400; } .education_details h6,.research_details h6{ font-weight:400; margin-bottom:1.3em; font-size:0.9em; } .education_details p,.skill_info p,.research_details p{ color:#999; font-weight:300; line-height:1.7em; } .cmpny1{ border-bottom:3px dashed #999; padding-bottom:1em; } .skills{ margin:2em 0; } .skill_info { padding:1.5em 0 0 2em; } .skill_list{ padding:1.5em 0 0 2em; } .skill1,.skill2,.skill3{ float:left; width:30%; } .skill1 h4,.skill2 h4,.skill3 h4{ color:#333; font-weight:600; margin-bottom:1em; display:inline-block; } .skill1 ul,.skill2 ul,.skill3 ul{ padding-left:4em; } .skill1 ul li,.skill2 ul li,.skill3 ul li{ color:#333; } .research h3{ background: #999; color: #FFF; padding: 5px 190px 5px 30px; display: inline-block; } h3.clr1{ background:#005792; } h3.clr2{ background:#005792; } h3.clr3{ background:#005792; } .copywrite{ padding-left:2em; margin-top:1em; } .copywrite p{ color:#999; font-size:0.9em; } .copywrite p a{ color:#999; } .copywrite p a:hover{ color:#6ecadc; } .contact-grid form{ padding:2em 0 0 2em; } .contact-grid input[type=\"text\"], .contact-grid textarea { width: 80%; padding: 0.7em; margin: 0.5em 0; background: none; outline: none; border: 1px solid #A09F9F; font-size: 1em; color: #A09F9F; -webkit-appearance: none; } .send input[type=\"submit\"] { width: 14%; font-size: 1.1em; background:#e9a820; padding: 0.4em 0.8em; text-align: center; color: #fff; border: none; outline: none; -webkit-appearance: none; } .send input[type=\"submit\"]:hover { background: #6ecadc; } .contact-grid textarea { resize: none; } .map{ padding:2em 0 0 2em; } .map iframe { width: 100%; height: 350px; border: none; } /*--responsive--*/ @media (max-width: 1366px){ .sidebar h1 { font-size:1.5em; } } @media (max-width: 1024px){ .sidebar { padding: 2em 17px; width:20%; } .sidebar h1 { font-size: 1.3em; } .main { margin-left: 19.666667%; width: 80%; } } @media (max-width: 768px){ .sidebar { width: 22%; } .main { margin-left: 21.666667%; width: 78%; } .sidebar h1 { font-size: 1.4em; } .sidebar img { padding: 0.5em; width: 89%; } .details_header { padding: 0em 1em 0 1em; } .details_header ul li a { padding: 0 1em; font-size: 0.9em; } .education h3,.skills h3,.research h3{ font-size: 1.2em; } .education_details h4, .research_details h4 { font-size: 1.1em; } .education_details h6, .research_details h6 { font-size: 0.8em; } .education_details p, .skill_info p, .research_details p { font-size: 0.8em; } .cmpny1 { padding-bottom: 1.5em; } .skill1, .skill2, .skill3 { float: left; width: 50%; } .skill1 ul li,.skill2 ul li,.skill3 ul li{ font-size:0.85em; } .skill1 h4, .skill2 h4, .skill3 h4 { font-size: 1em; } .skill_list { padding: 0.7em 0 0 2em; } .details p { font-size: 0.75em; } address span { font-size: 0.8em; } .contact-grid input[type=\"text\"], .contact-grid textarea { width: 100%; font-size: 0.8em; } .send input[type=\"submit\"] { width: 20%; font-size:0.85em; } } @media (max-width: 736px){ .sidebar { width: 100%; } .main { margin-left: 0; width: 100%; } .sidebar_top{ width:30%; float:left; margin-right:5%; } .sidebar_top_en{ width:30%; float:left; margin-right:5%; } .details{ width:30%; float:right; } } @media (max-width: 640px){ .sidebar { width: 100%; } .main { margin-left: 0; width: 100%; } .details{ width:30%; float:right; } .sidebar img{ width:100%; } .details p { font-size: 0.9em; margin: 5px 0 1em 0; } .details h3 { font-size: 0.9em; } } @media (max-width: 600px){ address { margin-bottom:0px; } .sidebar_top { width: 32%; } .sidebar_top_en { width: 32%; } .sidebar img { width: 85%; } } @media (max-width: 568px){ .details_header ul li a { padding: 0 0.5em; font-size: 0.9em; } } @media (max-width: 480px){ .content { margin-right: 2em; } .glyphicon-save:before, .glyphicon-print:before, .glyphicon-envelope:before, .glyphicon-picture:before { margin-right: 6px; font-size: 12px; } .details_header ul li a { padding: 0 0.5em; font-size: 0.85em; } .details { width: 36%; } .sidebar h1 { font-size: 1.3em; } .sidebar_top { width: 38%; } .sidebar_top_en { width: 38%; } address { margin-bottom: 0px; } .copywrite{ padding-left:1em; } .map iframe { height: 246px; } } @media (max-width: 414px){ .sidebar_top { width: 45%; } .sidebar_top_en { width: 45%; } .sidebar img { width: 91%; } .details { width: 42%; } .details_header { padding: 0em 0em 0 1em; } .details_header ul li a { padding: 0 0.3em; font-size: 0.75em; } .skill1 ul, .skill2 ul, .skill3 ul { padding-left: 3em; } } @media (max-width: 384px){ .sidebar h1 { font-size: 1.2em; } .details { width: 45%; } .details_header ul { text-align: center; } .details_header ul li a { padding: 0 1em; font-size: 0.75em; } .main { padding: 1em 0 2em 0; } .education_details, .research_details,.skill_info { padding: 1em 0 0em 1em; } .education h3 { padding: 5px 41px 5px 16px; } .education_details h4, .research_details h4 { font-size: 0.9em; } .education_details h6, .research_details h6 { font-size: 0.6em; } .education { margin: 1em 0; } .skills { margin: 1em 0; } .education h3, .skills h3, .research h3 { font-size: 1em; } .skills h3 { padding: 5px 98px 5px 16px; } .skill1 ul, .skill2 ul, .skill3 ul { padding-left: 2em; } .skill1 ul li, .skill2 ul li, .skill3 ul li { font-size: 0.75em; } .skill_list { padding: 0.5em 0 0 1.5em; } .research h3 { padding: 5px 190px 5px 16px; } .copywrite p{ font-size:0.7em; } } @media (max-width: 375px){ .sidebar h1 { font-size: 1em; } .sidebar img { width: 70%; } .details h3 { font-size: 0.8em; } .details p { font-size: 0.75em; margin: 5px 0 0.5em 0; } address span { font-size: 0.7em; } .sidebar { padding: 1.5em 17px 1em 17px; } .details_header { padding: 0em 0em 0 1em; text-align: center; } .details_header ul li a { line-height: 2em; } } @media (max-width: 320px){ .sidebar_top { width: 50%; } .sidebar_top_en { width: 50%; } .sidebar img { width: 80%; } .details h3 { font-size: 0.7em; } .content { margin-right: 1em; } .details_header ul li a { padding: 0 0.5em; font-size: 0.75em; } .skill1 h4, .skill2 h4, .skill3 h4 { font-size: 0.85em; } .skill1 ul, .skill2 ul, .skill3 ul { padding-left: 1.5em; } }"},{"title":"","date":"2018-10-30T12:50:19.364Z","updated":"2016-09-30T02:46:09.497Z","comments":true,"path":"cv/assets/plugins/jquery-1.12.4.min.js","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/jquery-1.12.4.min.js","excerpt":"","text":"/*! jQuery v1.12.4 | (c) jQuery Foundation | jquery.org/license */ !function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=a.document,e=c.slice,f=c.concat,g=c.push,h=c.indexOf,i={},j=i.toString,k=i.hasOwnProperty,l={},m=\"1.12.4\",n=function(a,b){return new n.fn.init(a,b)},o=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,p=/^-ms-/,q=/-([\\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:\"\",length:0,toArray:function(){return e.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:e.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a){return n.each(this,a)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(e.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:g,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(n.isPlainObject(c)||(b=n.isArray(c)))?(b?(b=!1,f=a&&n.isArray(a)?a:[]):f=a&&n.isPlainObject(a)?a:{},g[d]=n.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},n.extend({expando:\"jQuery\"+(m+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===n.type(a)},isArray:Array.isArray||function(a){return\"array\"===n.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){var b=a&&a.toString();return!n.isArray(a)&&b-parseFloat(b)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||\"object\"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;try{if(a.constructor&&!k.call(a,\"constructor\")&&!k.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}if(!l.ownFirst)for(b in a)return k.call(a,b);for(b in a);return void 0===b||k.call(a,b)},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?i[j.call(a)]||\"object\":typeof a},globalEval:function(b){b&&n.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(p,\"ms-\").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(s(a)){for(c=a.length;c>d;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(o,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,\"string\"==typeof a?[a]:a):g.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(h)return h.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,g=0,h=[];if(s(a))for(d=a.length;d>g;g++)e=b(a[g],g,c),null!=e&&h.push(e);else for(g in a)e=b(a[g],g,c),null!=e&&h.push(e);return f.apply([],h)},guid:1,proxy:function(a,b){var c,d,f;return\"string\"==typeof b&&(f=a[b],b=a,a=f),n.isFunction(a)?(c=e.call(arguments,2),d=function(){return a.apply(b||this,c.concat(e.call(arguments)))},d.guid=a.guid=a.guid||n.guid++,d):void 0},now:function(){return+new Date},support:l}),\"function\"==typeof Symbol&&(n.fn[Symbol.iterator]=c[Symbol.iterator]),n.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(a,b){i[\"[object \"+b+\"]\"]=b.toLowerCase()});function s(a){var b=!!a&&\"length\"in a&&a.length,c=n.type(a);return\"function\"===c||n.isWindow(a)?!1:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=ga(),z=ga(),A=ga(),B=function(a,b){return a===b&&(l=!0),0},C=1"},{"title":"","date":"2018-09-12T03:25:45.426Z","updated":"2015-06-11T01:58:02.000Z","comments":true,"path":"cv/old/js/jquery.min.js","permalink":"http://tech.yushuai.xyz/cv/old/js/jquery.min.js","excerpt":"","text":"/*! jQuery v1.11.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */ !function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k=\"\".trim,l={},m=\"1.11.0\",n=function(a,b){return new n.fn.init(a,b)},o=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,p=/^-ms-/,q=/-([\\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:\"\",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(n.isPlainObject(c)||(b=n.isArray(c)))?(b?(b=!1,f=a&&n.isArray(a)?a:[]):f=a&&n.isPlainObject(a)?a:{},g[d]=n.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},n.extend({expando:\"jQuery\"+(m+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===n.type(a)},isArray:Array.isArray||function(a){return\"array\"===n.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return a-parseFloat(a)>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||\"object\"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,\"constructor\")&&!j.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}if(l.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?h[i.call(a)]||\"object\":typeof a},globalEval:function(b){b&&n.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(p,\"ms-\").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:k&&!k.call(\"\\ufeff\\xa0\")?function(a){return null==a?\"\":k.call(a)}:function(a){return null==a?\"\":(a+\"\").replace(o,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,\"string\"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return\"string\"==typeof b&&(f=a[b],b=a,a=f),n.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||n.guid++,e):void 0},now:function(){return+new Date},support:l}),n.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(a,b){h[\"[object \"+b+\"]\"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return\"function\"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s=\"sizzle\"+-new Date,t=a.document,u=0,v=0,w=eb(),x=eb(),y=eb(),z=function(a,b){return a===b&&(j=!0),0},A=\"undefined\",B=1"},{"title":"","date":"2018-09-12T03:25:45.420Z","updated":"2015-06-11T01:52:20.000Z","comments":true,"path":"cv/old/js/jquery.magnific-popup.js","permalink":"http://tech.yushuai.xyz/cv/old/js/jquery.magnific-popup.js","excerpt":"","text":"/*! Magnific Popup - v0.9.9 - 2013-11-15 * http://dimsemenov.com/plugins/magnific-popup/ * Copyright (c) 2013 Dmitry Semenov; */ ;(function($) { /*>>core*/ /** * * Magnific Popup Core JS file * */ /** * Private static constants */ var CLOSE_EVENT = 'Close', BEFORE_CLOSE_EVENT = 'BeforeClose', AFTER_CLOSE_EVENT = 'AfterClose', BEFORE_APPEND_EVENT = 'BeforeAppend', MARKUP_PARSE_EVENT = 'MarkupParse', OPEN_EVENT = 'Open', CHANGE_EVENT = 'Change', NS = 'mfp', EVENT_NS = '.' + NS, READY_CLASS = 'mfp-ready', REMOVING_CLASS = 'mfp-removing', PREVENT_CLOSE_CLASS = 'mfp-prevent-close'; /** * Private vars */ var mfp, // As we have only one instance of MagnificPopup object, we define it locally to not to use 'this' MagnificPopup = function(){}, _isJQ = !!(window.jQuery), _prevStatus, _window = $(window), _body, _document, _prevContentType, _wrapClasses, _currPopupType; /** * Private functions */ var _mfpOn = function(name, f) { mfp.ev.on(NS + name + EVENT_NS, f); }, _getEl = function(className, appendTo, html, raw) { var el = document.createElement('div'); el.className = 'mfp-'+className; if(html) { el.innerHTML = html; } if(!raw) { el = $(el); if(appendTo) { el.appendTo(appendTo); } } else if(appendTo) { appendTo.appendChild(el); } return el; }, _mfpTrigger = function(e, data) { mfp.ev.triggerHandler(NS + e, data); if(mfp.st.callbacks) { // converts \"mfpEventName\" to \"eventName\" callback and triggers it if it's present e = e.charAt(0).toLowerCase() + e.slice(1); if(mfp.st.callbacks[e]) { mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]); } } }, _getCloseBtn = function(type) { if(type !== _currPopupType || !mfp.currTemplate.closeBtn) { mfp.currTemplate.closeBtn = $( mfp.st.closeMarkup.replace('%title%', mfp.st.tClose ) ); _currPopupType = type; } return mfp.currTemplate.closeBtn; }, // Initialize Magnific Popup only when called at least once _checkInstance = function() { if(!$.magnificPopup.instance) { mfp = new MagnificPopup(); mfp.init(); $.magnificPopup.instance = mfp; } }, // CSS transition detection, http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr supportsTransitions = function() { var s = document.createElement('p').style, // 's' for style. better to create an element if body yet to exist v = ['ms','O','Moz','Webkit']; // 'v' for vendor if( s['transition'] !== undefined ) { return true; } while( v.length ) { if( v.pop() + 'Transition' in s ) { return true; } } return false; }; /** * Public functions */ MagnificPopup.prototype = { constructor: MagnificPopup, /** * Initializes Magnific Popup plugin. * This function is triggered only once when $.fn.magnificPopup or $.magnificPopup is executed */ init: function() { var appVersion = navigator.appVersion; mfp.isIE7 = appVersion.indexOf(\"MSIE 7.\") !== -1; mfp.isIE8 = appVersion.indexOf(\"MSIE 8.\") !== -1; mfp.isLowIE = mfp.isIE7 || mfp.isIE8; mfp.isAndroid = (/android/gi).test(appVersion); mfp.isIOS = (/iphone|ipad|ipod/gi).test(appVersion); mfp.supportsTransition = supportsTransitions(); // We disable fixed positioned lightbox on devices that don't handle it nicely. // If you know a better way of detecting this - let me know. mfp.probablyMobile = (mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent) ); _body = $(document.body); _document = $(document); mfp.popupsCache = {}; }, /** * Opens popup * @param data [description] */ open: function(data) { var i; if(data.isObj === false) { // convert jQuery collection to array to avoid conflicts later mfp.items = data.items.toArray(); mfp.index = 0; var items = data.items, item; for(i = 0; i < items.length; i++) { item = items[i]; if(item.parsed) { item = item.el[0]; } if(item === data.el[0]) { mfp.index = i; break; } } } else { mfp.items = $.isArray(data.items) ? data.items : [data.items]; mfp.index = data.index || 0; } // if popup is already opened - we just update the content if(mfp.isOpen) { mfp.updateItemHTML(); return; } mfp.types = []; _wrapClasses = ''; if(data.mainEl && data.mainEl.length) { mfp.ev = data.mainEl.eq(0); } else { mfp.ev = _document; } if(data.key) { if(!mfp.popupsCache[data.key]) { mfp.popupsCache[data.key] = {}; } mfp.currTemplate = mfp.popupsCache[data.key]; } else { mfp.currTemplate = {}; } mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data ); mfp.fixedContentPos = mfp.st.fixedContentPos === 'auto' ? !mfp.probablyMobile : mfp.st.fixedContentPos; if(mfp.st.modal) { mfp.st.closeOnContentClick = false; mfp.st.closeOnBgClick = false; mfp.st.showCloseBtn = false; mfp.st.enableEscapeKey = false; } // Building markup // main containers are created only once if(!mfp.bgOverlay) { // Dark overlay mfp.bgOverlay = _getEl('bg').on('click'+EVENT_NS, function() { mfp.close(); }); mfp.wrap = _getEl('wrap').attr('tabindex', -1).on('click'+EVENT_NS, function(e) { if(mfp._checkIfClose(e.target)) { mfp.close(); } }); mfp.container = _getEl('container', mfp.wrap); } mfp.contentContainer = _getEl('content'); if(mfp.st.preloader) { mfp.preloader = _getEl('preloader', mfp.container, mfp.st.tLoading); } // Initializing modules var modules = $.magnificPopup.modules; for(i = 0; i < modules.length; i++) { var n = modules[i]; n = n.charAt(0).toUpperCase() + n.slice(1); mfp['init'+n].call(mfp); } _mfpTrigger('BeforeOpen'); if(mfp.st.showCloseBtn) { // Close button if(!mfp.st.closeBtnInside) { mfp.wrap.append( _getCloseBtn() ); } else { _mfpOn(MARKUP_PARSE_EVENT, function(e, template, values, item) { values.close_replaceWith = _getCloseBtn(item.type); }); _wrapClasses += ' mfp-close-btn-in'; } } if(mfp.st.alignTop) { _wrapClasses += ' mfp-align-top'; } if(mfp.fixedContentPos) { mfp.wrap.css({ overflow: mfp.st.overflowY, overflowX: 'hidden', overflowY: mfp.st.overflowY }); } else { mfp.wrap.css({ top: _window.scrollTop(), position: 'absolute' }); } if( mfp.st.fixedBgPos === false || (mfp.st.fixedBgPos === 'auto' && !mfp.fixedContentPos) ) { mfp.bgOverlay.css({ height: _document.height(), position: 'absolute' }); } if(mfp.st.enableEscapeKey) { // Close on ESC key _document.on('keyup' + EVENT_NS, function(e) { if(e.keyCode === 27) { mfp.close(); } }); } _window.on('resize' + EVENT_NS, function() { mfp.updateSize(); }); if(!mfp.st.closeOnContentClick) { _wrapClasses += ' mfp-auto-cursor'; } if(_wrapClasses) mfp.wrap.addClass(_wrapClasses); // this triggers recalculation of layout, so we get it once to not to trigger twice var windowHeight = mfp.wH = _window.height(); var windowStyles = {}; if( mfp.fixedContentPos ) { if(mfp._hasScrollBar(windowHeight)){ var s = mfp._getScrollbarSize(); if(s) { windowStyles.marginRight = s; } } } if(mfp.fixedContentPos) { if(!mfp.isIE7) { windowStyles.overflow = 'hidden'; } else { // ie7 double-scroll bug $('body, html').css('overflow', 'hidden'); } } var classesToadd = mfp.st.mainClass; if(mfp.isIE7) { classesToadd += ' mfp-ie7'; } if(classesToadd) { mfp._addClassToMFP( classesToadd ); } // add content mfp.updateItemHTML(); _mfpTrigger('BuildControls'); // remove scrollbar, add margin e.t.c $('html').css(windowStyles); // add everything to DOM mfp.bgOverlay.add(mfp.wrap).prependTo( document.body ); // Save last focused element mfp._lastFocusedEl = document.activeElement; // Wait for next cycle to allow CSS transition setTimeout(function() { if(mfp.content) { mfp._addClassToMFP(READY_CLASS); mfp._setFocus(); } else { // if content is not defined (not loaded e.t.c) we add class only for BG mfp.bgOverlay.addClass(READY_CLASS); } // Trap the focus in popup _document.on('focusin' + EVENT_NS, mfp._onFocusIn); }, 16); mfp.isOpen = true; mfp.updateSize(windowHeight); _mfpTrigger(OPEN_EVENT); return data; }, /** * Closes the popup */ close: function() { if(!mfp.isOpen) return; _mfpTrigger(BEFORE_CLOSE_EVENT); mfp.isOpen = false; // for CSS3 animation if(mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition ) { mfp._addClassToMFP(REMOVING_CLASS); setTimeout(function() { mfp._close(); }, mfp.st.removalDelay); } else { mfp._close(); } }, /** * Helper for close() function */ _close: function() { _mfpTrigger(CLOSE_EVENT); var classesToRemove = REMOVING_CLASS + ' ' + READY_CLASS + ' '; mfp.bgOverlay.detach(); mfp.wrap.detach(); mfp.container.empty(); if(mfp.st.mainClass) { classesToRemove += mfp.st.mainClass + ' '; } mfp._removeClassFromMFP(classesToRemove); if(mfp.fixedContentPos) { var windowStyles = {marginRight: ''}; if(mfp.isIE7) { $('body, html').css('overflow', ''); } else { windowStyles.overflow = ''; } $('html').css(windowStyles); } _document.off('keyup' + EVENT_NS + ' focusin' + EVENT_NS); mfp.ev.off(EVENT_NS); // clean up DOM elements that aren't removed mfp.wrap.attr('class', 'mfp-wrap').removeAttr('style'); mfp.bgOverlay.attr('class', 'mfp-bg'); mfp.container.attr('class', 'mfp-container'); // remove close button from target element if(mfp.st.showCloseBtn && (!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) { if(mfp.currTemplate.closeBtn) mfp.currTemplate.closeBtn.detach(); } if(mfp._lastFocusedEl) { $(mfp._lastFocusedEl).focus(); // put tab focus back } mfp.currItem = null; mfp.content = null; mfp.currTemplate = null; mfp.prevHeight = 0; _mfpTrigger(AFTER_CLOSE_EVENT); }, updateSize: function(winHeight) { if(mfp.isIOS) { // fixes iOS nav bars https://github.com/dimsemenov/Magnific-Popup/issues/2 var zoomLevel = document.documentElement.clientWidth / window.innerWidth; var height = window.innerHeight * zoomLevel; mfp.wrap.css('height', height); mfp.wH = height; } else { mfp.wH = winHeight || _window.height(); } // Fixes #84: popup incorrectly positioned with position:relative on body if(!mfp.fixedContentPos) { mfp.wrap.css('height', mfp.wH); } _mfpTrigger('Resize'); }, /** * Set content of popup based on current index */ updateItemHTML: function() { var item = mfp.items[mfp.index]; // Detach and perform modifications mfp.contentContainer.detach(); if(mfp.content) mfp.content.detach(); if(!item.parsed) { item = mfp.parseEl( mfp.index ); } var type = item.type; _mfpTrigger('BeforeChange', [mfp.currItem ? mfp.currItem.type : '', type]); // BeforeChange event works like so: // _mfpOn('BeforeChange', function(e, prevType, newType) { }); mfp.currItem = item; if(!mfp.currTemplate[type]) { var markup = mfp.st[type] ? mfp.st[type].markup : false; // allows to modify markup _mfpTrigger('FirstMarkupParse', markup); if(markup) { mfp.currTemplate[type] = $(markup); } else { // if there is no markup found we just define that template is parsed mfp.currTemplate[type] = true; } } if(_prevContentType && _prevContentType !== item.type) { mfp.container.removeClass('mfp-'+_prevContentType+'-holder'); } var newContent = mfp['get' + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]); mfp.appendContent(newContent, type); item.preloaded = true; _mfpTrigger(CHANGE_EVENT, item); _prevContentType = item.type; // Append container back after its content changed mfp.container.prepend(mfp.contentContainer); _mfpTrigger('AfterChange'); }, /** * Set HTML content of popup */ appendContent: function(newContent, type) { mfp.content = newContent; if(newContent) { if(mfp.st.showCloseBtn && mfp.st.closeBtnInside && mfp.currTemplate[type] === true) { // if there is no markup, we just append close button element inside if(!mfp.content.find('.mfp-close').length) { mfp.content.append(_getCloseBtn()); } } else { mfp.content = newContent; } } else { mfp.content = ''; } _mfpTrigger(BEFORE_APPEND_EVENT); mfp.container.addClass('mfp-'+type+'-holder'); mfp.contentContainer.append(mfp.content); }, /** * Creates Magnific Popup data object based on given data * @param {int} index Index of item to parse */ parseEl: function(index) { var item = mfp.items[index], type = item.type; if(item.tagName) { item = { el: $(item) }; } else { item = { data: item, src: item.src }; } if(item.el) { var types = mfp.types; // check for 'mfp-TYPE' class for(var i = 0; i < types.length; i++) { if( item.el.hasClass('mfp-'+types[i]) ) { type = types[i]; break; } } item.src = item.el.attr('data-mfp-src'); if(!item.src) { item.src = item.el.attr('href'); } } item.type = type || mfp.st.type || 'inline'; item.index = index; item.parsed = true; mfp.items[index] = item; _mfpTrigger('ElementParse', item); return mfp.items[index]; }, /** * Initializes single popup or a group of popups */ addGroup: function(el, options) { var eHandler = function(e) { e.mfpEl = this; mfp._openClick(e, el, options); }; if(!options) { options = {}; } var eName = 'click.magnificPopup'; options.mainEl = el; if(options.items) { options.isObj = true; el.off(eName).on(eName, eHandler); } else { options.isObj = false; if(options.delegate) { el.off(eName).on(eName, options.delegate , eHandler); } else { options.items = el; el.off(eName).on(eName, eHandler); } } }, _openClick: function(e, el, options) { var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick; if(!midClick && ( e.which === 2 || e.ctrlKey || e.metaKey ) ) { return; } var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn; if(disableOn) { if($.isFunction(disableOn)) { if( !disableOn.call(mfp) ) { return true; } } else { // else it's number if( _window.width() < disableOn ) { return true; } } } if(e.type) { e.preventDefault(); // This will prevent popup from closing if element is inside and popup is already opened if(mfp.isOpen) { e.stopPropagation(); } } options.el = $(e.mfpEl); if(options.delegate) { options.items = el.find(options.delegate); } mfp.open(options); }, /** * Updates text on preloader */ updateStatus: function(status, text) { if(mfp.preloader) { if(_prevStatus !== status) { mfp.container.removeClass('mfp-s-'+_prevStatus); } if(!text && status === 'loading') { text = mfp.st.tLoading; } var data = { status: status, text: text }; // allows to modify status _mfpTrigger('UpdateStatus', data); status = data.status; text = data.text; mfp.preloader.html(text); mfp.preloader.find('a').on('click', function(e) { e.stopImmediatePropagation(); }); mfp.container.addClass('mfp-s-'+status); _prevStatus = status; } }, /* \"Private\" helpers that aren't private at all */ // Check to close popup or not // \"target\" is an element that was clicked _checkIfClose: function(target) { if($(target).hasClass(PREVENT_CLOSE_CLASS)) { return; } var closeOnContent = mfp.st.closeOnContentClick; var closeOnBg = mfp.st.closeOnBgClick; if(closeOnContent && closeOnBg) { return true; } else { // We close the popup if click is on close button or on preloader. Or if there is no content. if(!mfp.content || $(target).hasClass('mfp-close') || (mfp.preloader && target === mfp.preloader[0]) ) { return true; } // if click is outside the content if( (target !== mfp.content[0] && !$.contains(mfp.content[0], target)) ) { if(closeOnBg) { // last check, if the clicked element is in DOM, (in case it's removed onclick) if( $.contains(document, target) ) { return true; } } } else if(closeOnContent) { return true; } } return false; }, _addClassToMFP: function(cName) { mfp.bgOverlay.addClass(cName); mfp.wrap.addClass(cName); }, _removeClassFromMFP: function(cName) { this.bgOverlay.removeClass(cName); mfp.wrap.removeClass(cName); }, _hasScrollBar: function(winHeight) { return ( (mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height()) ); }, _setFocus: function() { (mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus(); }, _onFocusIn: function(e) { if( e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target) ) { mfp._setFocus(); return false; } }, _parseMarkup: function(template, values, item) { var arr; if(item.data) { values = $.extend(item.data, values); } _mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item] ); $.each(values, function(key, value) { if(value === undefined || value === false) { return true; } arr = key.split('_'); if(arr.length > 1) { var el = template.find(EVENT_NS + '-'+arr[0]); if(el.length > 0) { var attr = arr[1]; if(attr === 'replaceWith') { if(el[0] !== value[0]) { el.replaceWith(value); } } else if(attr === 'img') { if(el.is('img')) { el.attr('src', value); } else { el.replaceWith( '' ); } } else { el.attr(arr[1], value); } } } else { template.find(EVENT_NS + '-'+key).html(value); } }); }, _getScrollbarSize: function() { // thx David if(mfp.scrollbarSize === undefined) { var scrollDiv = document.createElement(\"div\"); scrollDiv.id = \"mfp-sbm\"; scrollDiv.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;'; document.body.appendChild(scrollDiv); mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth; document.body.removeChild(scrollDiv); } return mfp.scrollbarSize; } }; /* MagnificPopup core prototype end */ /** * Public static functions */ $.magnificPopup = { instance: null, proto: MagnificPopup.prototype, modules: [], open: function(options, index) { _checkInstance(); if(!options) { options = {}; } else { options = $.extend(true, {}, options); } options.isObj = true; options.index = index || 0; return this.instance.open(options); }, close: function() { return $.magnificPopup.instance && $.magnificPopup.instance.close(); }, registerModule: function(name, module) { if(module.options) { $.magnificPopup.defaults[name] = module.options; } $.extend(this.proto, module.proto); this.modules.push(name); }, defaults: { // Info about options is in docs: // http://dimsemenov.com/plugins/magnific-popup/documentation.html#options disableOn: 0, key: null, midClick: false, mainClass: '', preloader: true, focus: '', // CSS selector of input to focus after popup is opened closeOnContentClick: false, closeOnBgClick: true, closeBtnInside: true, showCloseBtn: true, enableEscapeKey: true, modal: false, alignTop: false, removalDelay: 0, fixedContentPos: 'auto', fixedBgPos: 'auto', overflowY: 'auto', closeMarkup: '&times;', tClose: 'Close (Esc)', tLoading: 'Loading...' } }; $.fn.magnificPopup = function(options) { _checkInstance(); var jqEl = $(this); // We call some API method of first param is a string if (typeof options === \"string\" ) { if(options === 'open') { var items, itemOpts = _isJQ ? jqEl.data('magnificPopup') : jqEl[0].magnificPopup, index = parseInt(arguments[1], 10) || 0; if(itemOpts.items) { items = itemOpts.items[index]; } else { items = jqEl; if(itemOpts.delegate) { items = items.find(itemOpts.delegate); } items = items.eq( index ); } mfp._openClick({mfpEl:items}, jqEl, itemOpts); } else { if(mfp.isOpen) mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1)); } } else { // clone options obj options = $.extend(true, {}, options); /* * As Zepto doesn't support .data() method for objects * and it works only in normal browsers * we assign \"options\" object directly to the DOM element. FTW! */ if(_isJQ) { jqEl.data('magnificPopup', options); } else { jqEl[0].magnificPopup = options; } mfp.addGroup(jqEl, options); } return jqEl; }; //Quick benchmark /* var start = performance.now(), i, rounds = 1000; for(i = 0; i < rounds; i++) { } console.log('Test #1:', performance.now() - start); start = performance.now(); for(i = 0; i < rounds; i++) { } console.log('Test #2:', performance.now() - start); */ /*>>core*/ /*>>inline*/ var INLINE_NS = 'inline', _hiddenClass, _inlinePlaceholder, _lastInlineElement, _putInlineElementsBack = function() { if(_lastInlineElement) { _inlinePlaceholder.after( _lastInlineElement.addClass(_hiddenClass) ).detach(); _lastInlineElement = null; } }; $.magnificPopup.registerModule(INLINE_NS, { options: { hiddenClass: 'hide', // will be appended with `mfp-` prefix markup: '', tNotFound: 'Content not found' }, proto: { initInline: function() { mfp.types.push(INLINE_NS); _mfpOn(CLOSE_EVENT+'.'+INLINE_NS, function() { _putInlineElementsBack(); }); }, getInline: function(item, template) { _putInlineElementsBack(); if(item.src) { var inlineSt = mfp.st.inline, el = $(item.src); if(el.length) { // If target element has parent - we replace it with placeholder and put it back after popup is closed var parent = el[0].parentNode; if(parent && parent.tagName) { if(!_inlinePlaceholder) { _hiddenClass = inlineSt.hiddenClass; _inlinePlaceholder = _getEl(_hiddenClass); _hiddenClass = 'mfp-'+_hiddenClass; } // replace target inline element with placeholder _lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass); } mfp.updateStatus('ready'); } else { mfp.updateStatus('error', inlineSt.tNotFound); el = $(''); } item.inlineElement = el; return el; } mfp.updateStatus('ready'); mfp._parseMarkup(template, {}, item); return template; } } }); /*>>inline*/ /*>>ajax*/ var AJAX_NS = 'ajax', _ajaxCur, _removeAjaxCursor = function() { if(_ajaxCur) { _body.removeClass(_ajaxCur); } }, _destroyAjaxRequest = function() { _removeAjaxCursor(); if(mfp.req) { mfp.req.abort(); } }; $.magnificPopup.registerModule(AJAX_NS, { options: { settings: null, cursor: 'mfp-ajax-cur', tError: 'The content could not be loaded.' }, proto: { initAjax: function() { mfp.types.push(AJAX_NS); _ajaxCur = mfp.st.ajax.cursor; _mfpOn(CLOSE_EVENT+'.'+AJAX_NS, _destroyAjaxRequest); _mfpOn('BeforeChange.' + AJAX_NS, _destroyAjaxRequest); }, getAjax: function(item) { if(_ajaxCur) _body.addClass(_ajaxCur); mfp.updateStatus('loading'); var opts = $.extend({ url: item.src, success: function(data, textStatus, jqXHR) { var temp = { data:data, xhr:jqXHR }; _mfpTrigger('ParseAjax', temp); mfp.appendContent( $(temp.data), AJAX_NS ); item.finished = true; _removeAjaxCursor(); mfp._setFocus(); setTimeout(function() { mfp.wrap.addClass(READY_CLASS); }, 16); mfp.updateStatus('ready'); _mfpTrigger('AjaxContentAdded'); }, error: function() { _removeAjaxCursor(); item.finished = item.loadError = true; mfp.updateStatus('error', mfp.st.ajax.tError.replace('%url%', item.src)); } }, mfp.st.ajax.settings); mfp.req = $.ajax(opts); return ''; } } }); /*>>ajax*/ /*>>image*/ var _imgInterval, _getTitle = function(item) { if(item.data && item.data.title !== undefined) return item.data.title; var src = mfp.st.image.titleSrc; if(src) { if($.isFunction(src)) { return src.call(mfp, item); } else if(item.el) { return item.el.attr(src) || ''; } } return ''; }; $.magnificPopup.registerModule('image', { options: { markup: ''+ ''+ ''+ ''+ ''+ ''+ ''+ ''+ ''+ ''+ ''+ '', cursor: 'mfp-zoom-out-cur', titleSrc: 'title', verticalFit: true, tError: 'The image could not be loaded.' }, proto: { initImage: function() { var imgSt = mfp.st.image, ns = '.image'; mfp.types.push('image'); _mfpOn(OPEN_EVENT+ns, function() { if(mfp.currItem.type === 'image' && imgSt.cursor) { _body.addClass(imgSt.cursor); } }); _mfpOn(CLOSE_EVENT+ns, function() { if(imgSt.cursor) { _body.removeClass(imgSt.cursor); } _window.off('resize' + EVENT_NS); }); _mfpOn('Resize'+ns, mfp.resizeImage); if(mfp.isLowIE) { _mfpOn('AfterChange', mfp.resizeImage); } }, resizeImage: function() { var item = mfp.currItem; if(!item || !item.img) return; if(mfp.st.image.verticalFit) { var decr = 0; // fix box-sizing in ie7/8 if(mfp.isLowIE) { decr = parseInt(item.img.css('padding-top'), 10) + parseInt(item.img.css('padding-bottom'),10); } item.img.css('max-height', mfp.wH-decr); } }, _onImageHasSize: function(item) { if(item.img) { item.hasSize = true; if(_imgInterval) { clearInterval(_imgInterval); } item.isCheckingImgSize = false; _mfpTrigger('ImageHasSize', item); if(item.imgHidden) { if(mfp.content) mfp.content.removeClass('mfp-loading'); item.imgHidden = false; } } }, /** * Function that loops until the image has size to display elements that rely on it asap */ findImageSize: function(item) { var counter = 0, img = item.img[0], mfpSetInterval = function(delay) { if(_imgInterval) { clearInterval(_imgInterval); } // decelerating interval that checks for size of an image _imgInterval = setInterval(function() { if(img.naturalWidth > 0) { mfp._onImageHasSize(item); return; } if(counter > 200) { clearInterval(_imgInterval); } counter++; if(counter === 3) { mfpSetInterval(10); } else if(counter === 40) { mfpSetInterval(50); } else if(counter === 100) { mfpSetInterval(500); } }, delay); }; mfpSetInterval(1); }, getImage: function(item, template) { var guard = 0, // image load complete handler onLoadComplete = function() { if(item) { if (item.img[0].complete) { item.img.off('.mfploader'); if(item === mfp.currItem){ mfp._onImageHasSize(item); mfp.updateStatus('ready'); } item.hasSize = true; item.loaded = true; _mfpTrigger('ImageLoadComplete'); } else { // if image complete check fails 200 times (20 sec), we assume that there was an error. guard++; if(guard < 200) { setTimeout(onLoadComplete,100); } else { onLoadError(); } } } }, // image error handler onLoadError = function() { if(item) { item.img.off('.mfploader'); if(item === mfp.currItem){ mfp._onImageHasSize(item); mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) ); } item.hasSize = true; item.loaded = true; item.loadError = true; } }, imgSt = mfp.st.image; var el = template.find('.mfp-img'); if(el.length) { var img = document.createElement('img'); img.className = 'mfp-img'; item.img = $(img).on('load.mfploader', onLoadComplete).on('error.mfploader', onLoadError); img.src = item.src; // without clone() \"error\" event is not firing when IMG is replaced by new IMG // TODO: find a way to avoid such cloning if(el.is('img')) { item.img = item.img.clone(); } if(item.img[0].naturalWidth > 0) { item.hasSize = true; } } mfp._parseMarkup(template, { title: _getTitle(item), img_replaceWith: item.img }, item); mfp.resizeImage(); if(item.hasSize) { if(_imgInterval) clearInterval(_imgInterval); if(item.loadError) { template.addClass('mfp-loading'); mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) ); } else { template.removeClass('mfp-loading'); mfp.updateStatus('ready'); } return template; } mfp.updateStatus('loading'); item.loading = true; if(!item.hasSize) { item.imgHidden = true; template.addClass('mfp-loading'); mfp.findImageSize(item); } return template; } } }); /*>>image*/ /*>>zoom*/ var hasMozTransform, getHasMozTransform = function() { if(hasMozTransform === undefined) { hasMozTransform = document.createElement('p').style.MozTransform !== undefined; } return hasMozTransform; }; $.magnificPopup.registerModule('zoom', { options: { enabled: false, easing: 'ease-in-out', duration: 300, opener: function(element) { return element.is('img') ? element : element.find('img'); } }, proto: { initZoom: function() { var zoomSt = mfp.st.zoom, ns = '.zoom', image; if(!zoomSt.enabled || !mfp.supportsTransition) { return; } var duration = zoomSt.duration, getElToAnimate = function(image) { var newImg = image.clone().removeAttr('style').removeAttr('class').addClass('mfp-animated-image'), transition = 'all '+(zoomSt.duration/1000)+'s ' + zoomSt.easing, cssObj = { position: 'fixed', zIndex: 9999, left: 0, top: 0, '-webkit-backface-visibility': 'hidden' }, t = 'transition'; cssObj['-webkit-'+t] = cssObj['-moz-'+t] = cssObj['-o-'+t] = cssObj[t] = transition; newImg.css(cssObj); return newImg; }, showMainContent = function() { mfp.content.css('visibility', 'visible'); }, openTimeout, animatedImg; _mfpOn('BuildControls'+ns, function() { if(mfp._allowZoom()) { clearTimeout(openTimeout); mfp.content.css('visibility', 'hidden'); // Basically, all code below does is clones existing image, puts in on top of the current one and animated it image = mfp._getItemToZoom(); if(!image) { showMainContent(); return; } animatedImg = getElToAnimate(image); animatedImg.css( mfp._getOffset() ); mfp.wrap.append(animatedImg); openTimeout = setTimeout(function() { animatedImg.css( mfp._getOffset( true ) ); openTimeout = setTimeout(function() { showMainContent(); setTimeout(function() { animatedImg.remove(); image = animatedImg = null; _mfpTrigger('ZoomAnimationEnded'); }, 16); // avoid blink when switching images }, duration); // this timeout equals animation duration }, 16); // by adding this timeout we avoid short glitch at the beginning of animation // Lots of timeouts... } }); _mfpOn(BEFORE_CLOSE_EVENT+ns, function() { if(mfp._allowZoom()) { clearTimeout(openTimeout); mfp.st.removalDelay = duration; if(!image) { image = mfp._getItemToZoom(); if(!image) { return; } animatedImg = getElToAnimate(image); } animatedImg.css( mfp._getOffset(true) ); mfp.wrap.append(animatedImg); mfp.content.css('visibility', 'hidden'); setTimeout(function() { animatedImg.css( mfp._getOffset() ); }, 16); } }); _mfpOn(CLOSE_EVENT+ns, function() { if(mfp._allowZoom()) { showMainContent(); if(animatedImg) { animatedImg.remove(); } image = null; } }); }, _allowZoom: function() { return mfp.currItem.type === 'image'; }, _getItemToZoom: function() { if(mfp.currItem.hasSize) { return mfp.currItem.img; } else { return false; } }, // Get element postion relative to viewport _getOffset: function(isLarge) { var el; if(isLarge) { el = mfp.currItem.img; } else { el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem); } var offset = el.offset(); var paddingTop = parseInt(el.css('padding-top'),10); var paddingBottom = parseInt(el.css('padding-bottom'),10); offset.top -= ( $(window).scrollTop() - paddingTop ); /* Animating left + top + width/height looks glitchy in Firefox, but perfect in Chrome. And vice-versa. */ var obj = { width: el.width(), // fix Zepto height+padding issue height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop }; // I hate to do this, but there is no another option if( getHasMozTransform() ) { obj['-moz-transform'] = obj['transform'] = 'translate(' + offset.left + 'px,' + offset.top + 'px)'; } else { obj.left = offset.left; obj.top = offset.top; } return obj; } } }); /*>>zoom*/ /*>>iframe*/ var IFRAME_NS = 'iframe', _emptyPage = '//about:blank', _fixIframeBugs = function(isShowing) { if(mfp.currTemplate[IFRAME_NS]) { var el = mfp.currTemplate[IFRAME_NS].find('iframe'); if(el.length) { // reset src after the popup is closed to avoid \"video keeps playing after popup is closed\" bug if(!isShowing) { el[0].src = _emptyPage; } // IE8 black screen bug fix if(mfp.isIE8) { el.css('display', isShowing ? 'block' : 'none'); } } } }; $.magnificPopup.registerModule(IFRAME_NS, { options: { markup: ''+ ''+ ''+ '', srcAction: 'iframe_src', // we don't care and support only one default type of URL by default patterns: { youtube: { index: 'youtube.com', id: 'v=', src: '//www.youtube.com/embed/%id%?autoplay=1' }, vimeo: { index: 'vimeo.com/', id: '/', src: '//player.vimeo.com/video/%id%?autoplay=1' }, gmaps: { index: '//maps.google.', src: '%id%&output=embed' } } }, proto: { initIframe: function() { mfp.types.push(IFRAME_NS); _mfpOn('BeforeChange', function(e, prevType, newType) { if(prevType !== newType) { if(prevType === IFRAME_NS) { _fixIframeBugs(); // iframe if removed } else if(newType === IFRAME_NS) { _fixIframeBugs(true); // iframe is showing } }// else { // iframe source is switched, don't do anything //} }); _mfpOn(CLOSE_EVENT + '.' + IFRAME_NS, function() { _fixIframeBugs(); }); }, getIframe: function(item, template) { var embedSrc = item.src; var iframeSt = mfp.st.iframe; $.each(iframeSt.patterns, function() { if(embedSrc.indexOf( this.index ) > -1) { if(this.id) { if(typeof this.id === 'string') { embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id)+this.id.length, embedSrc.length); } else { embedSrc = this.id.call( this, embedSrc ); } } embedSrc = this.src.replace('%id%', embedSrc ); return false; // break; } }); var dataObj = {}; if(iframeSt.srcAction) { dataObj[iframeSt.srcAction] = embedSrc; } mfp._parseMarkup(template, dataObj, item); mfp.updateStatus('ready'); return template; } } }); /*>>iframe*/ /*>>gallery*/ /** * Get looped index depending on number of slides */ var _getLoopedId = function(index) { var numSlides = mfp.items.length; if(index > numSlides - 1) { return index - numSlides; } else if(index < 0) { return numSlides + index; } return index; }, _replaceCurrTotal = function(text, curr, total) { return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total); }; $.magnificPopup.registerModule('gallery', { options: { enabled: false, arrowMarkup: '', preload: [0,2], navigateByImgClick: true, arrows: true, tPrev: 'Previous (Left arrow key)', tNext: 'Next (Right arrow key)', tCounter: '%curr% of %total%' }, proto: { initGallery: function() { var gSt = mfp.st.gallery, ns = '.mfp-gallery', supportsFastClick = Boolean($.fn.mfpFastClick); mfp.direction = true; // true - next, false - prev if(!gSt || !gSt.enabled ) return false; _wrapClasses += ' mfp-gallery'; _mfpOn(OPEN_EVENT+ns, function() { if(gSt.navigateByImgClick) { mfp.wrap.on('click'+ns, '.mfp-img', function() { if(mfp.items.length > 1) { mfp.next(); return false; } }); } _document.on('keydown'+ns, function(e) { if (e.keyCode === 37) { mfp.prev(); } else if (e.keyCode === 39) { mfp.next(); } }); }); _mfpOn('UpdateStatus'+ns, function(e, data) { if(data.text) { data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length); } }); _mfpOn(MARKUP_PARSE_EVENT+ns, function(e, element, values, item) { var l = mfp.items.length; values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : ''; }); _mfpOn('BuildControls' + ns, function() { if(mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) { var markup = gSt.arrowMarkup, arrowLeft = mfp.arrowLeft = $( markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, 'left') ).addClass(PREVENT_CLOSE_CLASS), arrowRight = mfp.arrowRight = $( markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, 'right') ).addClass(PREVENT_CLOSE_CLASS); var eName = supportsFastClick ? 'mfpFastClick' : 'click'; arrowLeft[eName](function() { mfp.prev(); }); arrowRight[eName](function() { mfp.next(); }); // Polyfill for :before and :after (adds elements with classes mfp-a and mfp-b) if(mfp.isIE7) { _getEl('b', arrowLeft[0], false, true); _getEl('a', arrowLeft[0], false, true); _getEl('b', arrowRight[0], false, true); _getEl('a', arrowRight[0], false, true); } mfp.container.append(arrowLeft.add(arrowRight)); } }); _mfpOn(CHANGE_EVENT+ns, function() { if(mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout); mfp._preloadTimeout = setTimeout(function() { mfp.preloadNearbyImages(); mfp._preloadTimeout = null; }, 16); }); _mfpOn(CLOSE_EVENT+ns, function() { _document.off(ns); mfp.wrap.off('click'+ns); if(mfp.arrowLeft && supportsFastClick) { mfp.arrowLeft.add(mfp.arrowRight).destroyMfpFastClick(); } mfp.arrowRight = mfp.arrowLeft = null; }); }, next: function() { mfp.direction = true; mfp.index = _getLoopedId(mfp.index + 1); mfp.updateItemHTML(); }, prev: function() { mfp.direction = false; mfp.index = _getLoopedId(mfp.index - 1); mfp.updateItemHTML(); }, goTo: function(newIndex) { mfp.direction = (newIndex >= mfp.index); mfp.index = newIndex; mfp.updateItemHTML(); }, preloadNearbyImages: function() { var p = mfp.st.gallery.preload, preloadBefore = Math.min(p[0], mfp.items.length), preloadAfter = Math.min(p[1], mfp.items.length), i; for(i = 1; i"},{"title":"","date":"2018-10-30T12:50:19.368Z","updated":"2016-09-30T02:46:11.861Z","comments":true,"path":"cv/assets/plugins/jquery-scrollTo/jquery.scrollTo.min.js","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/jquery-scrollTo/jquery.scrollTo.min.js","excerpt":"","text":"/** * Copyright (c) 2007-2015 Ariel Flesler - afleslergmailcom | http://flesler.blogspot.com * Licensed under MIT * @author Ariel Flesler * @version 2.1.1 */ ;(function(f){\"use strict\";\"function\"===typeof define&&define.amd?define([\"jquery\"],f):\"undefined\"!==typeof module&&module.exports?module.exports=f(require(\"jquery\")):f(jQuery)})(function($){\"use strict\";function n(a){return!a.nodeName||-1!==$.inArray(a.nodeName.toLowerCase(),[\"iframe\",\"#document\",\"html\",\"body\"])}function h(a){return $.isFunction(a)||$.isPlainObject(a)?a:{top:a,left:a}}var p=$.scrollTo=function(a,d,b){return $(window).scrollTo(a,d,b)};p.defaults={axis:\"xy\",duration:0,limit:!0};$.fn.scrollTo=function(a,d,b){\"object\"=== typeof d&&(b=d,d=0);\"function\"===typeof b&&(b={onAfter:b});\"max\"===a&&(a=9E9);b=$.extend({},p.defaults,b);d=d||b.duration;var u=b.queue&&1=f[g]?0:Math.min(f[g],n));!a&&1"},{"title":"","date":"2018-09-12T03:25:45.339Z","updated":"2015-06-10T03:04:12.000Z","comments":true,"path":"cv/old/css/bootstrap.min.css","permalink":"http://tech.yushuai.xyz/cv/old/css/bootstrap.min.css","excerpt":"","text":"/*! * Bootstrap v3.3.4 (http://getbootstrap.com) * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) *//*! normalize.css v3.0.2 | MIT License | git.io/normalize */html{font-family:sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0;font-size:2em}mark{color:#000;background:#ff0}small{font-size:80%}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{height:0;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{margin:0;font:inherit;color:inherit}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input{line-height:normal}input[type=checkbox],input[type=radio]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{padding:.35em .625em .75em;margin:0 2px;border:1px solid silver}legend{padding:0;border:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-spacing:0;border-collapse:collapse}td,th{padding:0}/*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */@media print{*,:after,:before{color:#000!important;text-shadow:none!important;background:0 0!important;-webkit-box-shadow:none!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href) \")\"}abbr[title]:after{content:\" (\" attr(title) \")\"}a[href^=\"javascript:\"]:after,a[href^=\"#\"]:after{content:\"\"}blockquote,pre{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}select{background:#fff!important}.navbar{display:none}.btn>.caret,.dropup>.btn>.caret{border-top-color:#000!important}.label{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #ddd!important}}@font-face{font-family:'Glyphicons Halflings';src:url(../fonts/glyphicons-halflings-regular.eot);src:url(../fonts/glyphicons-halflings-regular.eot?#iefix) format('embedded-opentype'),url(../fonts/glyphicons-halflings-regular.woff2) format('woff2'),url(../fonts/glyphicons-halflings-regular.woff) format('woff'),url(../fonts/glyphicons-halflings-regular.ttf) format('truetype'),url(../fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular) format('svg')}.glyphicon{position:relative;top:1px;display:inline-block;font-family:'Glyphicons Halflings';font-style:normal;font-weight:400;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.glyphicon-asterisk:before{content:\"\\2a\"}.glyphicon-plus:before{content:\"\\2b\"}.glyphicon-eur:before,.glyphicon-euro:before{content:\"\\20ac\"}.glyphicon-minus:before{content:\"\\2212\"}.glyphicon-cloud:before{content:\"\\2601\"}.glyphicon-envelope:before{content:\"\\2709\"}.glyphicon-pencil:before{content:\"\\270f\"}.glyphicon-glass:before{content:\"\\e001\"}.glyphicon-music:before{content:\"\\e002\"}.glyphicon-search:before{content:\"\\e003\"}.glyphicon-heart:before{content:\"\\e005\"}.glyphicon-star:before{content:\"\\e006\"}.glyphicon-star-empty:before{content:\"\\e007\"}.glyphicon-user:before{content:\"\\e008\"}.glyphicon-film:before{content:\"\\e009\"}.glyphicon-th-large:before{content:\"\\e010\"}.glyphicon-th:before{content:\"\\e011\"}.glyphicon-th-list:before{content:\"\\e012\"}.glyphicon-ok:before{content:\"\\e013\"}.glyphicon-remove:before{content:\"\\e014\"}.glyphicon-zoom-in:before{content:\"\\e015\"}.glyphicon-zoom-out:before{content:\"\\e016\"}.glyphicon-off:before{content:\"\\e017\"}.glyphicon-signal:before{content:\"\\e018\"}.glyphicon-cog:before{content:\"\\e019\"}.glyphicon-trash:before{content:\"\\e020\"}.glyphicon-home:before{content:\"\\e021\"}.glyphicon-file:before{content:\"\\e022\"}.glyphicon-time:before{content:\"\\e023\"}.glyphicon-road:before{content:\"\\e024\"}.glyphicon-download-alt:before{content:\"\\e025\"}.glyphicon-download:before{content:\"\\e026\"}.glyphicon-upload:before{content:\"\\e027\"}.glyphicon-inbox:before{content:\"\\e028\"}.glyphicon-play-circle:before{content:\"\\e029\"}.glyphicon-repeat:before{content:\"\\e030\"}.glyphicon-refresh:before{content:\"\\e031\"}.glyphicon-list-alt:before{content:\"\\e032\"}.glyphicon-lock:before{content:\"\\e033\"}.glyphicon-flag:before{content:\"\\e034\"}.glyphicon-headphones:before{content:\"\\e035\"}.glyphicon-volume-off:before{content:\"\\e036\"}.glyphicon-volume-down:before{content:\"\\e037\"}.glyphicon-volume-up:before{content:\"\\e038\"}.glyphicon-qrcode:before{content:\"\\e039\"}.glyphicon-barcode:before{content:\"\\e040\"}.glyphicon-tag:before{content:\"\\e041\"}.glyphicon-tags:before{content:\"\\e042\"}.glyphicon-book:before{content:\"\\e043\"}.glyphicon-bookmark:before{content:\"\\e044\"}.glyphicon-print:before{content:\"\\e045\"}.glyphicon-camera:before{content:\"\\e046\"}.glyphicon-font:before{content:\"\\e047\"}.glyphicon-bold:before{content:\"\\e048\"}.glyphicon-italic:before{content:\"\\e049\"}.glyphicon-text-height:before{content:\"\\e050\"}.glyphicon-text-width:before{content:\"\\e051\"}.glyphicon-align-left:before{content:\"\\e052\"}.glyphicon-align-center:before{content:\"\\e053\"}.glyphicon-align-right:before{content:\"\\e054\"}.glyphicon-align-justify:before{content:\"\\e055\"}.glyphicon-list:before{content:\"\\e056\"}.glyphicon-indent-left:before{content:\"\\e057\"}.glyphicon-indent-right:before{content:\"\\e058\"}.glyphicon-facetime-video:before{content:\"\\e059\"}.glyphicon-picture:before{content:\"\\e060\"}.glyphicon-map-marker:before{content:\"\\e062\"}.glyphicon-adjust:before{content:\"\\e063\"}.glyphicon-tint:before{content:\"\\e064\"}.glyphicon-edit:before{content:\"\\e065\"}.glyphicon-share:before{content:\"\\e066\"}.glyphicon-check:before{content:\"\\e067\"}.glyphicon-move:before{content:\"\\e068\"}.glyphicon-step-backward:before{content:\"\\e069\"}.glyphicon-fast-backward:before{content:\"\\e070\"}.glyphicon-backward:before{content:\"\\e071\"}.glyphicon-play:before{content:\"\\e072\"}.glyphicon-pause:before{content:\"\\e073\"}.glyphicon-stop:before{content:\"\\e074\"}.glyphicon-forward:before{content:\"\\e075\"}.glyphicon-fast-forward:before{content:\"\\e076\"}.glyphicon-step-forward:before{content:\"\\e077\"}.glyphicon-eject:before{content:\"\\e078\"}.glyphicon-chevron-left:before{content:\"\\e079\"}.glyphicon-chevron-right:before{content:\"\\e080\"}.glyphicon-plus-sign:before{content:\"\\e081\"}.glyphicon-minus-sign:before{content:\"\\e082\"}.glyphicon-remove-sign:before{content:\"\\e083\"}.glyphicon-ok-sign:before{content:\"\\e084\"}.glyphicon-question-sign:before{content:\"\\e085\"}.glyphicon-info-sign:before{content:\"\\e086\"}.glyphicon-screenshot:before{content:\"\\e087\"}.glyphicon-remove-circle:before{content:\"\\e088\"}.glyphicon-ok-circle:before{content:\"\\e089\"}.glyphicon-ban-circle:before{content:\"\\e090\"}.glyphicon-arrow-left:before{content:\"\\e091\"}.glyphicon-arrow-right:before{content:\"\\e092\"}.glyphicon-arrow-up:before{content:\"\\e093\"}.glyphicon-arrow-down:before{content:\"\\e094\"}.glyphicon-share-alt:before{content:\"\\e095\"}.glyphicon-resize-full:before{content:\"\\e096\"}.glyphicon-resize-small:before{content:\"\\e097\"}.glyphicon-exclamation-sign:before{content:\"\\e101\"}.glyphicon-gift:before{content:\"\\e102\"}.glyphicon-leaf:before{content:\"\\e103\"}.glyphicon-fire:before{content:\"\\e104\"}.glyphicon-eye-open:before{content:\"\\e105\"}.glyphicon-eye-close:before{content:\"\\e106\"}.glyphicon-warning-sign:before{content:\"\\e107\"}.glyphicon-plane:before{content:\"\\e108\"}.glyphicon-calendar:before{content:\"\\e109\"}.glyphicon-random:before{content:\"\\e110\"}.glyphicon-comment:before{content:\"\\e111\"}.glyphicon-magnet:before{content:\"\\e112\"}.glyphicon-chevron-up:before{content:\"\\e113\"}.glyphicon-chevron-down:before{content:\"\\e114\"}.glyphicon-retweet:before{content:\"\\e115\"}.glyphicon-shopping-cart:before{content:\"\\e116\"}.glyphicon-folder-close:before{content:\"\\e117\"}.glyphicon-folder-open:before{content:\"\\e118\"}.glyphicon-resize-vertical:before{content:\"\\e119\"}.glyphicon-resize-horizontal:before{content:\"\\e120\"}.glyphicon-hdd:before{content:\"\\e121\"}.glyphicon-bullhorn:before{content:\"\\e122\"}.glyphicon-bell:before{content:\"\\e123\"}.glyphicon-certificate:before{content:\"\\e124\"}.glyphicon-thumbs-up:before{content:\"\\e125\"}.glyphicon-thumbs-down:before{content:\"\\e126\"}.glyphicon-hand-right:before{content:\"\\e127\"}.glyphicon-hand-left:before{content:\"\\e128\"}.glyphicon-hand-up:before{content:\"\\e129\"}.glyphicon-hand-down:before{content:\"\\e130\"}.glyphicon-circle-arrow-right:before{content:\"\\e131\"}.glyphicon-circle-arrow-left:before{content:\"\\e132\"}.glyphicon-circle-arrow-up:before{content:\"\\e133\"}.glyphicon-circle-arrow-down:before{content:\"\\e134\"}.glyphicon-globe:before{content:\"\\e135\"}.glyphicon-wrench:before{content:\"\\e136\"}.glyphicon-tasks:before{content:\"\\e137\"}.glyphicon-filter:before{content:\"\\e138\"}.glyphicon-briefcase:before{content:\"\\e139\"}.glyphicon-fullscreen:before{content:\"\\e140\"}.glyphicon-dashboard:before{content:\"\\e141\"}.glyphicon-paperclip:before{content:\"\\e142\"}.glyphicon-heart-empty:before{content:\"\\e143\"}.glyphicon-link:before{content:\"\\e144\"}.glyphicon-phone:before{content:\"\\e145\"}.glyphicon-pushpin:before{content:\"\\e146\"}.glyphicon-usd:before{content:\"\\e148\"}.glyphicon-gbp:before{content:\"\\e149\"}.glyphicon-sort:before{content:\"\\e150\"}.glyphicon-sort-by-alphabet:before{content:\"\\e151\"}.glyphicon-sort-by-alphabet-alt:before{content:\"\\e152\"}.glyphicon-sort-by-order:before{content:\"\\e153\"}.glyphicon-sort-by-order-alt:before{content:\"\\e154\"}.glyphicon-sort-by-attributes:before{content:\"\\e155\"}.glyphicon-sort-by-attributes-alt:before{content:\"\\e156\"}.glyphicon-unchecked:before{content:\"\\e157\"}.glyphicon-expand:before{content:\"\\e158\"}.glyphicon-collapse-down:before{content:\"\\e159\"}.glyphicon-collapse-up:before{content:\"\\e160\"}.glyphicon-log-in:before{content:\"\\e161\"}.glyphicon-flash:before{content:\"\\e162\"}.glyphicon-log-out:before{content:\"\\e163\"}.glyphicon-new-window:before{content:\"\\e164\"}.glyphicon-record:before{content:\"\\e165\"}.glyphicon-save:before{content:\"\\e166\"}.glyphicon-open:before{content:\"\\e167\"}.glyphicon-saved:before{content:\"\\e168\"}.glyphicon-import:before{content:\"\\e169\"}.glyphicon-export:before{content:\"\\e170\"}.glyphicon-send:before{content:\"\\e171\"}.glyphicon-floppy-disk:before{content:\"\\e172\"}.glyphicon-floppy-saved:before{content:\"\\e173\"}.glyphicon-floppy-remove:before{content:\"\\e174\"}.glyphicon-floppy-save:before{content:\"\\e175\"}.glyphicon-floppy-open:before{content:\"\\e176\"}.glyphicon-credit-card:before{content:\"\\e177\"}.glyphicon-transfer:before{content:\"\\e178\"}.glyphicon-cutlery:before{content:\"\\e179\"}.glyphicon-header:before{content:\"\\e180\"}.glyphicon-compressed:before{content:\"\\e181\"}.glyphicon-earphone:before{content:\"\\e182\"}.glyphicon-phone-alt:before{content:\"\\e183\"}.glyphicon-tower:before{content:\"\\e184\"}.glyphicon-stats:before{content:\"\\e185\"}.glyphicon-sd-video:before{content:\"\\e186\"}.glyphicon-hd-video:before{content:\"\\e187\"}.glyphicon-subtitles:before{content:\"\\e188\"}.glyphicon-sound-stereo:before{content:\"\\e189\"}.glyphicon-sound-dolby:before{content:\"\\e190\"}.glyphicon-sound-5-1:before{content:\"\\e191\"}.glyphicon-sound-6-1:before{content:\"\\e192\"}.glyphicon-sound-7-1:before{content:\"\\e193\"}.glyphicon-copyright-mark:before{content:\"\\e194\"}.glyphicon-registration-mark:before{content:\"\\e195\"}.glyphicon-cloud-download:before{content:\"\\e197\"}.glyphicon-cloud-upload:before{content:\"\\e198\"}.glyphicon-tree-conifer:before{content:\"\\e199\"}.glyphicon-tree-deciduous:before{content:\"\\e200\"}.glyphicon-cd:before{content:\"\\e201\"}.glyphicon-save-file:before{content:\"\\e202\"}.glyphicon-open-file:before{content:\"\\e203\"}.glyphicon-level-up:before{content:\"\\e204\"}.glyphicon-copy:before{content:\"\\e205\"}.glyphicon-paste:before{content:\"\\e206\"}.glyphicon-alert:before{content:\"\\e209\"}.glyphicon-equalizer:before{content:\"\\e210\"}.glyphicon-king:before{content:\"\\e211\"}.glyphicon-queen:before{content:\"\\e212\"}.glyphicon-pawn:before{content:\"\\e213\"}.glyphicon-bishop:before{content:\"\\e214\"}.glyphicon-knight:before{content:\"\\e215\"}.glyphicon-baby-formula:before{content:\"\\e216\"}.glyphicon-tent:before{content:\"\\26fa\"}.glyphicon-blackboard:before{content:\"\\e218\"}.glyphicon-bed:before{content:\"\\e219\"}.glyphicon-apple:before{content:\"\\f8ff\"}.glyphicon-erase:before{content:\"\\e221\"}.glyphicon-hourglass:before{content:\"\\231b\"}.glyphicon-lamp:before{content:\"\\e223\"}.glyphicon-duplicate:before{content:\"\\e224\"}.glyphicon-piggy-bank:before{content:\"\\e225\"}.glyphicon-scissors:before{content:\"\\e226\"}.glyphicon-bitcoin:before{content:\"\\e227\"}.glyphicon-btc:before{content:\"\\e227\"}.glyphicon-xbt:before{content:\"\\e227\"}.glyphicon-yen:before{content:\"\\00a5\"}.glyphicon-jpy:before{content:\"\\00a5\"}.glyphicon-ruble:before{content:\"\\20bd\"}.glyphicon-rub:before{content:\"\\20bd\"}.glyphicon-scale:before{content:\"\\e230\"}.glyphicon-ice-lolly:before{content:\"\\e231\"}.glyphicon-ice-lolly-tasted:before{content:\"\\e232\"}.glyphicon-education:before{content:\"\\e233\"}.glyphicon-option-horizontal:before{content:\"\\e234\"}.glyphicon-option-vertical:before{content:\"\\e235\"}.glyphicon-menu-hamburger:before{content:\"\\e236\"}.glyphicon-modal-window:before{content:\"\\e237\"}.glyphicon-oil:before{content:\"\\e238\"}.glyphicon-grain:before{content:\"\\e239\"}.glyphicon-sunglasses:before{content:\"\\e240\"}.glyphicon-text-size:before{content:\"\\e241\"}.glyphicon-text-color:before{content:\"\\e242\"}.glyphicon-text-background:before{content:\"\\e243\"}.glyphicon-object-align-top:before{content:\"\\e244\"}.glyphicon-object-align-bottom:before{content:\"\\e245\"}.glyphicon-object-align-horizontal:before{content:\"\\e246\"}.glyphicon-object-align-left:before{content:\"\\e247\"}.glyphicon-object-align-vertical:before{content:\"\\e248\"}.glyphicon-object-align-right:before{content:\"\\e249\"}.glyphicon-triangle-right:before{content:\"\\e250\"}.glyphicon-triangle-left:before{content:\"\\e251\"}.glyphicon-triangle-bottom:before{content:\"\\e252\"}.glyphicon-triangle-top:before{content:\"\\e253\"}.glyphicon-console:before{content:\"\\e254\"}.glyphicon-superscript:before{content:\"\\e255\"}.glyphicon-subscript:before{content:\"\\e256\"}.glyphicon-menu-left:before{content:\"\\e257\"}.glyphicon-menu-right:before{content:\"\\e258\"}.glyphicon-menu-down:before{content:\"\\e259\"}.glyphicon-menu-up:before{content:\"\\e260\"}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}:after,:before{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}button,input,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#337ab7;text-decoration:none}a:focus,a:hover{color:#23527c;text-decoration:underline}a:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}figure{margin:0}img{vertical-align:middle}.carousel-inner>.item>a>img,.carousel-inner>.item>img,.img-responsive,.thumbnail a>img,.thumbnail>img{display:block;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{display:inline-block;max-width:100%;height:auto;padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.img-circle{border-radius:50%}hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}[role=button]{cursor:pointer}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{font-family:inherit;font-weight:500;line-height:1.1;color:inherit}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-weight:400;line-height:1;color:#777}.h1,.h2,.h3,h1,h2,h3{margin-top:20px;margin-bottom:10px}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small{font-size:65%}.h4,.h5,.h6,h4,h5,h6{margin-top:10px;margin-bottom:10px}.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-size:75%}.h1,h1{font-size:36px}.h2,h2{font-size:30px}.h3,h3{font-size:24px}.h4,h4{font-size:18px}.h5,h5{font-size:14px}.h6,h6{font-size:12px}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:16px;font-weight:300;line-height:1.4}@media (min-width:768px){.lead{font-size:21px}}.small,small{font-size:85%}.mark,mark{padding:.2em;background-color:#fcf8e3}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}.text-nowrap{white-space:nowrap}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.text-muted{color:#777}.text-primary{color:#337ab7}a.text-primary:hover{color:#286090}.text-success{color:#3c763d}a.text-success:hover{color:#2b542c}.text-info{color:#31708f}a.text-info:hover{color:#245269}.text-warning{color:#8a6d3b}a.text-warning:hover{color:#66512c}.text-danger{color:#a94442}a.text-danger:hover{color:#843534}.bg-primary{color:#fff;background-color:#337ab7}a.bg-primary:hover{background-color:#286090}.bg-success{background-color:#dff0d8}a.bg-success:hover{background-color:#c1e2b3}.bg-info{background-color:#d9edf7}a.bg-info:hover{background-color:#afd9ee}.bg-warning{background-color:#fcf8e3}a.bg-warning:hover{background-color:#f7ecb5}.bg-danger{background-color:#f2dede}a.bg-danger:hover{background-color:#e4b9b9}.page-header{padding-bottom:9px;margin:40px 0 20px;border-bottom:1px solid #eee}ol,ul{margin-top:0;margin-bottom:10px}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;margin-left:-5px;list-style:none}.list-inline>li{display:inline-block;padding-right:5px;padding-left:5px}dl{margin-top:0;margin-bottom:20px}dd,dt{line-height:1.42857143}dt{font-weight:700}dd{margin-left:0}@media (min-width:768px){.dl-horizontal dt{float:left;width:160px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}}abbr[data-original-title],abbr[title]{cursor:help;border-bottom:1px dotted #777}.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:10px 20px;margin:0 0 20px;font-size:17.5px;border-left:5px solid #eee}blockquote ol:last-child,blockquote p:last-child,blockquote ul:last-child{margin-bottom:0}blockquote .small,blockquote footer,blockquote small{display:block;font-size:80%;line-height:1.42857143;color:#777}blockquote .small:before,blockquote footer:before,blockquote small:before{content:'\\2014 \\00A0'}.blockquote-reverse,blockquote.pull-right{padding-right:15px;padding-left:0;text-align:right;border-right:5px solid #eee;border-left:0}.blockquote-reverse .small:before,.blockquote-reverse footer:before,.blockquote-reverse small:before,blockquote.pull-right .small:before,blockquote.pull-right footer:before,blockquote.pull-right small:before{content:''}.blockquote-reverse .small:after,.blockquote-reverse footer:after,.blockquote-reverse small:after,blockquote.pull-right .small:after,blockquote.pull-right footer:after,blockquote.pull-right small:after{content:'\\00A0 \\2014'}address{margin-bottom:20px;font-style:normal;line-height:1.42857143}code,kbd,pre,samp{font-family:Menlo,Monaco,Consolas,\"Courier New\",monospace}code{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px}kbd{padding:2px 4px;font-size:90%;color:#fff;background-color:#333;border-radius:3px;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.25);box-shadow:inset 0 -1px 0 rgba(0,0,0,.25)}kbd kbd{padding:0;font-size:100%;font-weight:700;-webkit-box-shadow:none;box-shadow:none}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:1.42857143;color:#333;word-break:break-all;word-wrap:break-word;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}.container{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1170px}}.container-fluid{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.row{margin-right:-15px;margin-left:-15px}.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{position:relative;min-height:1px;padding-right:15px;padding-left:15px}.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{float:left}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.col-xs-pull-12{right:100%}.col-xs-pull-11{right:91.66666667%}.col-xs-pull-10{right:83.33333333%}.col-xs-pull-9{right:75%}.col-xs-pull-8{right:66.66666667%}.col-xs-pull-7{right:58.33333333%}.col-xs-pull-6{right:50%}.col-xs-pull-5{right:41.66666667%}.col-xs-pull-4{right:33.33333333%}.col-xs-pull-3{right:25%}.col-xs-pull-2{right:16.66666667%}.col-xs-pull-1{right:8.33333333%}.col-xs-pull-0{right:auto}.col-xs-push-12{left:100%}.col-xs-push-11{left:91.66666667%}.col-xs-push-10{left:83.33333333%}.col-xs-push-9{left:75%}.col-xs-push-8{left:66.66666667%}.col-xs-push-7{left:58.33333333%}.col-xs-push-6{left:50%}.col-xs-push-5{left:41.66666667%}.col-xs-push-4{left:33.33333333%}.col-xs-push-3{left:25%}.col-xs-push-2{left:16.66666667%}.col-xs-push-1{left:8.33333333%}.col-xs-push-0{left:auto}.col-xs-offset-12{margin-left:100%}.col-xs-offset-11{margin-left:91.66666667%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-0{margin-left:0}@media (min-width:768px){.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9{float:left}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.col-sm-pull-12{right:100%}.col-sm-pull-11{right:91.66666667%}.col-sm-pull-10{right:83.33333333%}.col-sm-pull-9{right:75%}.col-sm-pull-8{right:66.66666667%}.col-sm-pull-7{right:58.33333333%}.col-sm-pull-6{right:50%}.col-sm-pull-5{right:41.66666667%}.col-sm-pull-4{right:33.33333333%}.col-sm-pull-3{right:25%}.col-sm-pull-2{right:16.66666667%}.col-sm-pull-1{right:8.33333333%}.col-sm-pull-0{right:auto}.col-sm-push-12{left:100%}.col-sm-push-11{left:91.66666667%}.col-sm-push-10{left:83.33333333%}.col-sm-push-9{left:75%}.col-sm-push-8{left:66.66666667%}.col-sm-push-7{left:58.33333333%}.col-sm-push-6{left:50%}.col-sm-push-5{left:41.66666667%}.col-sm-push-4{left:33.33333333%}.col-sm-push-3{left:25%}.col-sm-push-2{left:16.66666667%}.col-sm-push-1{left:8.33333333%}.col-sm-push-0{left:auto}.col-sm-offset-12{margin-left:100%}.col-sm-offset-11{margin-left:91.66666667%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-0{margin-left:0}}@media (min-width:992px){.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9{float:left}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.col-md-pull-12{right:100%}.col-md-pull-11{right:91.66666667%}.col-md-pull-10{right:83.33333333%}.col-md-pull-9{right:75%}.col-md-pull-8{right:66.66666667%}.col-md-pull-7{right:58.33333333%}.col-md-pull-6{right:50%}.col-md-pull-5{right:41.66666667%}.col-md-pull-4{right:33.33333333%}.col-md-pull-3{right:25%}.col-md-pull-2{right:16.66666667%}.col-md-pull-1{right:8.33333333%}.col-md-pull-0{right:auto}.col-md-push-12{left:100%}.col-md-push-11{left:91.66666667%}.col-md-push-10{left:83.33333333%}.col-md-push-9{left:75%}.col-md-push-8{left:66.66666667%}.col-md-push-7{left:58.33333333%}.col-md-push-6{left:50%}.col-md-push-5{left:41.66666667%}.col-md-push-4{left:33.33333333%}.col-md-push-3{left:25%}.col-md-push-2{left:16.66666667%}.col-md-push-1{left:8.33333333%}.col-md-push-0{left:auto}.col-md-offset-12{margin-left:100%}.col-md-offset-11{margin-left:91.66666667%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-9{margin-left:75%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-6{margin-left:50%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-3{margin-left:25%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-0{margin-left:0}}@media (min-width:1200px){.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9{float:left}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.col-lg-pull-12{right:100%}.col-lg-pull-11{right:91.66666667%}.col-lg-pull-10{right:83.33333333%}.col-lg-pull-9{right:75%}.col-lg-pull-8{right:66.66666667%}.col-lg-pull-7{right:58.33333333%}.col-lg-pull-6{right:50%}.col-lg-pull-5{right:41.66666667%}.col-lg-pull-4{right:33.33333333%}.col-lg-pull-3{right:25%}.col-lg-pull-2{right:16.66666667%}.col-lg-pull-1{right:8.33333333%}.col-lg-pull-0{right:auto}.col-lg-push-12{left:100%}.col-lg-push-11{left:91.66666667%}.col-lg-push-10{left:83.33333333%}.col-lg-push-9{left:75%}.col-lg-push-8{left:66.66666667%}.col-lg-push-7{left:58.33333333%}.col-lg-push-6{left:50%}.col-lg-push-5{left:41.66666667%}.col-lg-push-4{left:33.33333333%}.col-lg-push-3{left:25%}.col-lg-push-2{left:16.66666667%}.col-lg-push-1{left:8.33333333%}.col-lg-push-0{left:auto}.col-lg-offset-12{margin-left:100%}.col-lg-offset-11{margin-left:91.66666667%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-0{margin-left:0}}table{background-color:transparent}caption{padding-top:8px;padding-bottom:8px;color:#777;text-align:left}th{text-align:left}.table{width:100%;max-width:100%;margin-bottom:20px}.table>tbody>tr>td,.table>tbody>tr>th,.table>tfoot>tr>td,.table>tfoot>tr>th,.table>thead>tr>td,.table>thead>tr>th{padding:8px;line-height:1.42857143;vertical-align:top;border-top:1px solid #ddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #ddd}.table>caption+thead>tr:first-child>td,.table>caption+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>th,.table>thead:first-child>tr:first-child>td,.table>thead:first-child>tr:first-child>th{border-top:0}.table>tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed>tbody>tr>td,.table-condensed>tbody>tr>th,.table-condensed>tfoot>tr>td,.table-condensed>tfoot>tr>th,.table-condensed>thead>tr>td,.table-condensed>thead>tr>th{padding:5px}.table-bordered{border:1px solid #ddd}.table-bordered>tbody>tr>td,.table-bordered>tbody>tr>th,.table-bordered>tfoot>tr>td,.table-bordered>tfoot>tr>th,.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border:1px solid #ddd}.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border-bottom-width:2px}.table-striped>tbody>tr:nth-of-type(odd){background-color:#f9f9f9}.table-hover>tbody>tr:hover{background-color:#f5f5f5}table col[class*=col-]{position:static;display:table-column;float:none}table td[class*=col-],table th[class*=col-]{position:static;display:table-cell;float:none}.table>tbody>tr.active>td,.table>tbody>tr.active>th,.table>tbody>tr>td.active,.table>tbody>tr>th.active,.table>tfoot>tr.active>td,.table>tfoot>tr.active>th,.table>tfoot>tr>td.active,.table>tfoot>tr>th.active,.table>thead>tr.active>td,.table>thead>tr.active>th,.table>thead>tr>td.active,.table>thead>tr>th.active{background-color:#f5f5f5}.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr.active:hover>th,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover{background-color:#e8e8e8}.table>tbody>tr.success>td,.table>tbody>tr.success>th,.table>tbody>tr>td.success,.table>tbody>tr>th.success,.table>tfoot>tr.success>td,.table>tfoot>tr.success>th,.table>tfoot>tr>td.success,.table>tfoot>tr>th.success,.table>thead>tr.success>td,.table>thead>tr.success>th,.table>thead>tr>td.success,.table>thead>tr>th.success{background-color:#dff0d8}.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr.success:hover>th,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover{background-color:#d0e9c6}.table>tbody>tr.info>td,.table>tbody>tr.info>th,.table>tbody>tr>td.info,.table>tbody>tr>th.info,.table>tfoot>tr.info>td,.table>tfoot>tr.info>th,.table>tfoot>tr>td.info,.table>tfoot>tr>th.info,.table>thead>tr.info>td,.table>thead>tr.info>th,.table>thead>tr>td.info,.table>thead>tr>th.info{background-color:#d9edf7}.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr.info:hover>th,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover{background-color:#c4e3f3}.table>tbody>tr.warning>td,.table>tbody>tr.warning>th,.table>tbody>tr>td.warning,.table>tbody>tr>th.warning,.table>tfoot>tr.warning>td,.table>tfoot>tr.warning>th,.table>tfoot>tr>td.warning,.table>tfoot>tr>th.warning,.table>thead>tr.warning>td,.table>thead>tr.warning>th,.table>thead>tr>td.warning,.table>thead>tr>th.warning{background-color:#fcf8e3}.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr.warning:hover>th,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover{background-color:#faf2cc}.table>tbody>tr.danger>td,.table>tbody>tr.danger>th,.table>tbody>tr>td.danger,.table>tbody>tr>th.danger,.table>tfoot>tr.danger>td,.table>tfoot>tr.danger>th,.table>tfoot>tr>td.danger,.table>tfoot>tr>th.danger,.table>thead>tr.danger>td,.table>thead>tr.danger>th,.table>thead>tr>td.danger,.table>thead>tr>th.danger{background-color:#f2dede}.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr.danger:hover>th,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover{background-color:#ebcccc}.table-responsive{min-height:.01%;overflow-x:auto}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #ddd}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tfoot>tr>td,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>thead>tr>th{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}}fieldset{min-width:0;padding:0;margin:0;border:0}legend{display:block;width:100%;padding:0;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333;border:0;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}input[type=search]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}input[type=checkbox],input[type=radio]{margin:4px 0 0;margin-top:1px \\9;line-height:normal}input[type=file]{display:block}input[type=range]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type=file]:focus,input[type=checkbox]:focus,input[type=radio]:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{display:block;padding-top:7px;font-size:14px;line-height:1.42857143;color:#555}.form-control{display:block;width:100%;height:34px;padding:6px 12px;font-size:14px;line-height:1.42857143;color:#555;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075);-webkit-transition:border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;-o-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#999;opacity:1}.form-control:-ms-input-placeholder{color:#999}.form-control::-webkit-input-placeholder{color:#999}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{background-color:#eee;opacity:1}.form-control[disabled],fieldset[disabled] .form-control{cursor:not-allowed}textarea.form-control{height:auto}input[type=search]{-webkit-appearance:none}@media screen and (-webkit-min-device-pixel-ratio:0){input[type=date],input[type=time],input[type=datetime-local],input[type=month]{line-height:34px}.input-group-sm input[type=date],.input-group-sm input[type=time],.input-group-sm input[type=datetime-local],.input-group-sm input[type=month],input[type=date].input-sm,input[type=time].input-sm,input[type=datetime-local].input-sm,input[type=month].input-sm{line-height:30px}.input-group-lg input[type=date],.input-group-lg input[type=time],.input-group-lg input[type=datetime-local],.input-group-lg input[type=month],input[type=date].input-lg,input[type=time].input-lg,input[type=datetime-local].input-lg,input[type=month].input-lg{line-height:46px}}.form-group{margin-bottom:15px}.checkbox,.radio{position:relative;display:block;margin-top:10px;margin-bottom:10px}.checkbox label,.radio label{min-height:20px;padding-left:20px;margin-bottom:0;font-weight:400;cursor:pointer}.checkbox input[type=checkbox],.checkbox-inline input[type=checkbox],.radio input[type=radio],.radio-inline input[type=radio]{position:absolute;margin-top:4px \\9;margin-left:-20px}.checkbox+.checkbox,.radio+.radio{margin-top:-5px}.checkbox-inline,.radio-inline{position:relative;display:inline-block;padding-left:20px;margin-bottom:0;font-weight:400;vertical-align:middle;cursor:pointer}.checkbox-inline+.checkbox-inline,.radio-inline+.radio-inline{margin-top:0;margin-left:10px}fieldset[disabled] input[type=checkbox],fieldset[disabled] input[type=radio],input[type=checkbox].disabled,input[type=checkbox][disabled],input[type=radio].disabled,input[type=radio][disabled]{cursor:not-allowed}.checkbox-inline.disabled,.radio-inline.disabled,fieldset[disabled] .checkbox-inline,fieldset[disabled] .radio-inline{cursor:not-allowed}.checkbox.disabled label,.radio.disabled label,fieldset[disabled] .checkbox label,fieldset[disabled] .radio label{cursor:not-allowed}.form-control-static{min-height:34px;padding-top:7px;padding-bottom:7px;margin-bottom:0}.form-control-static.input-lg,.form-control-static.input-sm{padding-right:0;padding-left:0}.input-sm{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-sm{height:30px;line-height:30px}select[multiple].input-sm,textarea.input-sm{height:auto}.form-group-sm .form-control{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.form-group-sm .form-control{height:30px;line-height:30px}select[multiple].form-group-sm .form-control,textarea.form-group-sm .form-control{height:auto}.form-group-sm .form-control-static{height:30px;min-height:32px;padding:5px 10px;font-size:12px;line-height:1.5}.input-lg{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-lg{height:46px;line-height:46px}select[multiple].input-lg,textarea.input-lg{height:auto}.form-group-lg .form-control{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.form-group-lg .form-control{height:46px;line-height:46px}select[multiple].form-group-lg .form-control,textarea.form-group-lg .form-control{height:auto}.form-group-lg .form-control-static{height:46px;min-height:38px;padding:10px 16px;font-size:18px;line-height:1.3333333}.has-feedback{position:relative}.has-feedback .form-control{padding-right:42.5px}.form-control-feedback{position:absolute;top:0;right:0;z-index:2;display:block;width:34px;height:34px;line-height:34px;text-align:center;pointer-events:none}.input-lg+.form-control-feedback{width:46px;height:46px;line-height:46px}.input-sm+.form-control-feedback{width:30px;height:30px;line-height:30px}.has-success .checkbox,.has-success .checkbox-inline,.has-success .control-label,.has-success .help-block,.has-success .radio,.has-success .radio-inline,.has-success.checkbox label,.has-success.checkbox-inline label,.has-success.radio label,.has-success.radio-inline label{color:#3c763d}.has-success .form-control{border-color:#3c763d;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-success .form-control:focus{border-color:#2b542c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168}.has-success .input-group-addon{color:#3c763d;background-color:#dff0d8;border-color:#3c763d}.has-success .form-control-feedback{color:#3c763d}.has-warning .checkbox,.has-warning .checkbox-inline,.has-warning .control-label,.has-warning .help-block,.has-warning .radio,.has-warning .radio-inline,.has-warning.checkbox label,.has-warning.checkbox-inline label,.has-warning.radio label,.has-warning.radio-inline label{color:#8a6d3b}.has-warning .form-control{border-color:#8a6d3b;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-warning .form-control:focus{border-color:#66512c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b}.has-warning .input-group-addon{color:#8a6d3b;background-color:#fcf8e3;border-color:#8a6d3b}.has-warning .form-control-feedback{color:#8a6d3b}.has-error .checkbox,.has-error .checkbox-inline,.has-error .control-label,.has-error .help-block,.has-error .radio,.has-error .radio-inline,.has-error.checkbox label,.has-error.checkbox-inline label,.has-error.radio label,.has-error.radio-inline label{color:#a94442}.has-error .form-control{border-color:#a94442;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-error .form-control:focus{border-color:#843534;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483}.has-error .input-group-addon{color:#a94442;background-color:#f2dede;border-color:#a94442}.has-error .form-control-feedback{color:#a94442}.has-feedback label~.form-control-feedback{top:25px}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .form-control-static{display:inline-block}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .form-control,.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .checkbox,.form-inline .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .checkbox label,.form-inline .radio label{padding-left:0}.form-inline .checkbox input[type=checkbox],.form-inline .radio input[type=radio]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}}.form-horizontal .checkbox,.form-horizontal .checkbox-inline,.form-horizontal .radio,.form-horizontal .radio-inline{padding-top:7px;margin-top:0;margin-bottom:0}.form-horizontal .checkbox,.form-horizontal .radio{min-height:27px}.form-horizontal .form-group{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.form-horizontal .control-label{padding-top:7px;margin-bottom:0;text-align:right}}.form-horizontal .has-feedback .form-control-feedback{right:15px}@media (min-width:768px){.form-horizontal .form-group-lg .control-label{padding-top:14.33px}}@media (min-width:768px){.form-horizontal .form-group-sm .control-label{padding-top:6px}}.btn{display:inline-block;padding:6px 12px;margin-bottom:0;font-size:14px;font-weight:400;line-height:1.42857143;text-align:center;white-space:nowrap;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:1px solid transparent;border-radius:4px}.btn.active.focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn:active:focus,.btn:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.focus,.btn:focus,.btn:hover{color:#333;text-decoration:none}.btn.active,.btn:active{background-image:none;outline:0;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{pointer-events:none;cursor:not-allowed;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none;opacity:.65}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default.active,.btn-default.focus,.btn-default:active,.btn-default:focus,.btn-default:hover,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{background-image:none}.btn-default.disabled,.btn-default.disabled.active,.btn-default.disabled.focus,.btn-default.disabled:active,.btn-default.disabled:focus,.btn-default.disabled:hover,.btn-default[disabled],.btn-default[disabled].active,.btn-default[disabled].focus,.btn-default[disabled]:active,.btn-default[disabled]:focus,.btn-default[disabled]:hover,fieldset[disabled] .btn-default,fieldset[disabled] .btn-default.active,fieldset[disabled] .btn-default.focus,fieldset[disabled] .btn-default:active,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:hover{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#337ab7;border-color:#2e6da4}.btn-primary.active,.btn-primary.focus,.btn-primary:active,.btn-primary:focus,.btn-primary:hover,.open>.dropdown-toggle.btn-primary{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{background-image:none}.btn-primary.disabled,.btn-primary.disabled.active,.btn-primary.disabled.focus,.btn-primary.disabled:active,.btn-primary.disabled:focus,.btn-primary.disabled:hover,.btn-primary[disabled],.btn-primary[disabled].active,.btn-primary[disabled].focus,.btn-primary[disabled]:active,.btn-primary[disabled]:focus,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary,fieldset[disabled] .btn-primary.active,fieldset[disabled] .btn-primary.focus,fieldset[disabled] .btn-primary:active,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:hover{background-color:#337ab7;border-color:#2e6da4}.btn-primary .badge{color:#337ab7;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success.active,.btn-success.focus,.btn-success:active,.btn-success:focus,.btn-success:hover,.open>.dropdown-toggle.btn-success{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{background-image:none}.btn-success.disabled,.btn-success.disabled.active,.btn-success.disabled.focus,.btn-success.disabled:active,.btn-success.disabled:focus,.btn-success.disabled:hover,.btn-success[disabled],.btn-success[disabled].active,.btn-success[disabled].focus,.btn-success[disabled]:active,.btn-success[disabled]:focus,.btn-success[disabled]:hover,fieldset[disabled] .btn-success,fieldset[disabled] .btn-success.active,fieldset[disabled] .btn-success.focus,fieldset[disabled] .btn-success:active,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:hover{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info.active,.btn-info.focus,.btn-info:active,.btn-info:focus,.btn-info:hover,.open>.dropdown-toggle.btn-info{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{background-image:none}.btn-info.disabled,.btn-info.disabled.active,.btn-info.disabled.focus,.btn-info.disabled:active,.btn-info.disabled:focus,.btn-info.disabled:hover,.btn-info[disabled],.btn-info[disabled].active,.btn-info[disabled].focus,.btn-info[disabled]:active,.btn-info[disabled]:focus,.btn-info[disabled]:hover,fieldset[disabled] .btn-info,fieldset[disabled] .btn-info.active,fieldset[disabled] .btn-info.focus,fieldset[disabled] .btn-info:active,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:hover{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning.active,.btn-warning.focus,.btn-warning:active,.btn-warning:focus,.btn-warning:hover,.open>.dropdown-toggle.btn-warning{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{background-image:none}.btn-warning.disabled,.btn-warning.disabled.active,.btn-warning.disabled.focus,.btn-warning.disabled:active,.btn-warning.disabled:focus,.btn-warning.disabled:hover,.btn-warning[disabled],.btn-warning[disabled].active,.btn-warning[disabled].focus,.btn-warning[disabled]:active,.btn-warning[disabled]:focus,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning,fieldset[disabled] .btn-warning.active,fieldset[disabled] .btn-warning.focus,fieldset[disabled] .btn-warning:active,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:hover{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger.active,.btn-danger.focus,.btn-danger:active,.btn-danger:focus,.btn-danger:hover,.open>.dropdown-toggle.btn-danger{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{background-image:none}.btn-danger.disabled,.btn-danger.disabled.active,.btn-danger.disabled.focus,.btn-danger.disabled:active,.btn-danger.disabled:focus,.btn-danger.disabled:hover,.btn-danger[disabled],.btn-danger[disabled].active,.btn-danger[disabled].focus,.btn-danger[disabled]:active,.btn-danger[disabled]:focus,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger,fieldset[disabled] .btn-danger.active,fieldset[disabled] .btn-danger.focus,fieldset[disabled] .btn-danger:active,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:hover{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{font-weight:400;color:#337ab7;border-radius:0}.btn-link,.btn-link.active,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:active,.btn-link:focus,.btn-link:hover{border-color:transparent}.btn-link:focus,.btn-link:hover{color:#23527c;text-decoration:underline;background-color:transparent}.btn-link[disabled]:focus,.btn-link[disabled]:hover,fieldset[disabled] .btn-link:focus,fieldset[disabled] .btn-link:hover{color:#777;text-decoration:none}.btn-group-lg>.btn,.btn-lg{padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.btn-group-sm>.btn,.btn-sm{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.btn-group-xs>.btn,.btn-xs{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.fade{opacity:0;-webkit-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;-webkit-transition-timing-function:ease;-o-transition-timing-function:ease;transition-timing-function:ease;-webkit-transition-duration:.35s;-o-transition-duration:.35s;transition-duration:.35s;-webkit-transition-property:height,visibility;-o-transition-property:height,visibility;transition-property:height,visibility}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-right:4px solid transparent;border-left:4px solid transparent}.dropdown,.dropup{position:relative}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;font-size:14px;text-align:left;list-style:none;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.15);border-radius:4px;-webkit-box-shadow:0 6px 12px rgba(0,0,0,.175);box-shadow:0 6px 12px rgba(0,0,0,.175)}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857143;color:#333;white-space:nowrap}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{color:#262626;text-decoration:none;background-color:#f5f5f5}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{color:#fff;text-decoration:none;background-color:#337ab7;outline:0}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{color:#777}.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{text-decoration:none;cursor:not-allowed;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-right{right:0;left:auto}.dropdown-menu-left{right:auto;left:0}.dropdown-header{display:block;padding:3px 20px;font-size:12px;line-height:1.42857143;color:#777;white-space:nowrap}.dropdown-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:990}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{content:\"\";border-top:0;border-bottom:4px solid}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}@media (min-width:768px){.navbar-right .dropdown-menu{right:0;left:auto}.navbar-right .dropdown-menu-left{right:auto;left:0}}.btn-group,.btn-group-vertical{position:relative;display:inline-block;vertical-align:middle}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;float:left}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group-vertical>.btn:hover,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus,.btn-group>.btn:hover{z-index:2}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{margin-left:-5px}.btn-toolbar .btn-group,.btn-toolbar .input-group{float:left}.btn-toolbar>.btn,.btn-toolbar>.btn-group,.btn-toolbar>.input-group{margin-left:5px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.btn-group>.btn-group{float:left}.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding-right:8px;padding-left:8px}.btn-group>.btn-lg+.dropdown-toggle{padding-right:12px;padding-left:12px}.btn-group.open .dropdown-toggle{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-group.open .dropdown-toggle.btn-link{-webkit-box-shadow:none;box-shadow:none}.btn .caret{margin-left:0}.btn-lg .caret{border-width:5px 5px 0;border-bottom-width:0}.dropup .btn-lg .caret{border-width:0 5px 5px}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group,.btn-group-vertical>.btn-group>.btn{display:block;float:none;width:100%;max-width:100%}.btn-group-vertical>.btn-group>.btn{float:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:not(:first-child):not(:last-child){border-radius:0}.btn-group-vertical>.btn:first-child:not(:last-child){border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn:last-child:not(:first-child){border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:4px}.btn-group-vertical>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group-vertical>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group-vertical>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-top-right-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn,.btn-group-justified>.btn-group{display:table-cell;float:none;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.btn-group-justified>.btn-group .dropdown-menu{left:auto}[data-toggle=buttons]>.btn input[type=checkbox],[data-toggle=buttons]>.btn input[type=radio],[data-toggle=buttons]>.btn-group>.btn input[type=checkbox],[data-toggle=buttons]>.btn-group>.btn input[type=radio]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*=col-]{float:none;padding-right:0;padding-left:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group-lg>.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.btn{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-group-lg>.form-control,select.input-group-lg>.input-group-addon,select.input-group-lg>.input-group-btn>.btn{height:46px;line-height:46px}select[multiple].input-group-lg>.form-control,select[multiple].input-group-lg>.input-group-addon,select[multiple].input-group-lg>.input-group-btn>.btn,textarea.input-group-lg>.form-control,textarea.input-group-lg>.input-group-addon,textarea.input-group-lg>.input-group-btn>.btn{height:auto}.input-group-sm>.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.btn{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-group-sm>.form-control,select.input-group-sm>.input-group-addon,select.input-group-sm>.input-group-btn>.btn{height:30px;line-height:30px}select[multiple].input-group-sm>.form-control,select[multiple].input-group-sm>.input-group-addon,select[multiple].input-group-sm>.input-group-btn>.btn,textarea.input-group-sm>.form-control,textarea.input-group-sm>.input-group-addon,textarea.input-group-sm>.input-group-btn>.btn{height:auto}.input-group .form-control,.input-group-addon,.input-group-btn{display:table-cell}.input-group .form-control:not(:first-child):not(:last-child),.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child){border-radius:0}.input-group-addon,.input-group-btn{width:1%;white-space:nowrap;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;text-align:center;background-color:#eee;border:1px solid #ccc;border-radius:4px}.input-group-addon.input-sm{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type=checkbox],.input-group-addon input[type=radio]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn-group:not(:last-child)>.btn,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:first-child>.btn-group:not(:first-child)>.btn,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle{border-top-left-radius:0;border-bottom-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{position:relative;font-size:0;white-space:nowrap}.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:active,.input-group-btn>.btn:focus,.input-group-btn>.btn:hover{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{margin-left:-1px}.nav{padding-left:0;margin-bottom:0;list-style:none}.nav>li{position:relative;display:block}.nav>li>a{position:relative;display:block;padding:10px 15px}.nav>li>a:focus,.nav>li>a:hover{text-decoration:none;background-color:#eee}.nav>li.disabled>a{color:#777}.nav>li.disabled>a:focus,.nav>li.disabled>a:hover{color:#777;text-decoration:none;cursor:not-allowed;background-color:transparent}.nav .open>a,.nav .open>a:focus,.nav .open>a:hover{background-color:#eee;border-color:#337ab7}.nav .nav-divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.nav>li>a>img{max-width:none}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{float:left;margin-bottom:-1px}.nav-tabs>li>a{margin-right:2px;line-height:1.42857143;border:1px solid transparent;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover{border-color:#eee #eee #ddd}.nav-tabs>li.active>a,.nav-tabs>li.active>a:focus,.nav-tabs>li.active>a:hover{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-tabs.nav-justified{width:100%;border-bottom:0}.nav-tabs.nav-justified>li{float:none}.nav-tabs.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-tabs.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-tabs.nav-justified>li{display:table-cell;width:1%}.nav-tabs.nav-justified>li>a{margin-bottom:0}}.nav-tabs.nav-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs.nav-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border-bottom-color:#fff}}.nav-pills>li{float:left}.nav-pills>li>a{border-radius:4px}.nav-pills>li+li{margin-left:2px}.nav-pills>li.active>a,.nav-pills>li.active>a:focus,.nav-pills>li.active>a:hover{color:#fff;background-color:#337ab7}.nav-stacked>li{float:none}.nav-stacked>li+li{margin-top:2px;margin-left:0}.nav-justified{width:100%}.nav-justified>li{float:none}.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-justified>li{display:table-cell;width:1%}.nav-justified>li>a{margin-bottom:0}}.nav-tabs-justified{border-bottom:0}.nav-tabs-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border-bottom-color:#fff}}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-left-radius:0;border-top-right-radius:0}.navbar{position:relative;min-height:50px;margin-bottom:20px;border:1px solid transparent}@media (min-width:768px){.navbar{border-radius:4px}}@media (min-width:768px){.navbar-header{float:left}}.navbar-collapse{padding-right:15px;padding-left:15px;overflow-x:visible;-webkit-overflow-scrolling:touch;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1)}.navbar-collapse.in{overflow-y:auto}@media (min-width:768px){.navbar-collapse{width:auto;border-top:0;-webkit-box-shadow:none;box-shadow:none}.navbar-collapse.collapse{display:block!important;height:auto!important;padding-bottom:0;overflow:visible!important}.navbar-collapse.in{overflow-y:visible}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse,.navbar-static-top .navbar-collapse{padding-right:0;padding-left:0}}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:340px}@media (max-device-width:480px)and (orientation:landscape){.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:200px}}.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:0;margin-left:0}}.navbar-static-top{z-index:1000;border-width:0 0 1px}@media (min-width:768px){.navbar-static-top{border-radius:0}}.navbar-fixed-bottom,.navbar-fixed-top{position:fixed;right:0;left:0;z-index:1030}@media (min-width:768px){.navbar-fixed-bottom,.navbar-fixed-top{border-radius:0}}.navbar-fixed-top{top:0;border-width:0 0 1px}.navbar-fixed-bottom{bottom:0;margin-bottom:0;border-width:1px 0 0}.navbar-brand{float:left;height:50px;padding:15px 15px;font-size:18px;line-height:20px}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}.navbar-brand>img{display:block}@media (min-width:768px){.navbar>.container .navbar-brand,.navbar>.container-fluid .navbar-brand{margin-left:-15px}}.navbar-toggle{position:relative;float:right;padding:9px 10px;margin-top:8px;margin-right:15px;margin-bottom:8px;background-color:transparent;background-image:none;border:1px solid transparent;border-radius:4px}.navbar-toggle:focus{outline:0}.navbar-toggle .icon-bar{display:block;width:22px;height:2px;border-radius:1px}.navbar-toggle .icon-bar+.icon-bar{margin-top:4px}@media (min-width:768px){.navbar-toggle{display:none}}.navbar-nav{margin:7.5px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:20px}@media (max-width:767px){.navbar-nav .open .dropdown-menu{position:static;float:none;width:auto;margin-top:0;background-color:transparent;border:0;-webkit-box-shadow:none;box-shadow:none}.navbar-nav .open .dropdown-menu .dropdown-header,.navbar-nav .open .dropdown-menu>li>a{padding:5px 15px 5px 25px}.navbar-nav .open .dropdown-menu>li>a{line-height:20px}.navbar-nav .open .dropdown-menu>li>a:focus,.navbar-nav .open .dropdown-menu>li>a:hover{background-image:none}}@media (min-width:768px){.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:15px;padding-bottom:15px}}.navbar-form{padding:10px 15px;margin-top:8px;margin-right:-15px;margin-bottom:8px;margin-left:-15px;border-top:1px solid transparent;border-bottom:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1)}@media (min-width:768px){.navbar-form .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.navbar-form .form-control{display:inline-block;width:auto;vertical-align:middle}.navbar-form .form-control-static{display:inline-block}.navbar-form .input-group{display:inline-table;vertical-align:middle}.navbar-form .input-group .form-control,.navbar-form .input-group .input-group-addon,.navbar-form .input-group .input-group-btn{width:auto}.navbar-form .input-group>.form-control{width:100%}.navbar-form .control-label{margin-bottom:0;vertical-align:middle}.navbar-form .checkbox,.navbar-form .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.navbar-form .checkbox label,.navbar-form .radio label{padding-left:0}.navbar-form .checkbox input[type=checkbox],.navbar-form .radio input[type=radio]{position:relative;margin-left:0}.navbar-form .has-feedback .form-control-feedback{top:0}}@media (max-width:767px){.navbar-form .form-group{margin-bottom:5px}.navbar-form .form-group:last-child{margin-bottom:0}}@media (min-width:768px){.navbar-form{width:auto;padding-top:0;padding-bottom:0;margin-right:0;margin-left:0;border:0;-webkit-box-shadow:none;box-shadow:none}}.navbar-nav>li>.dropdown-menu{margin-top:0;border-top-left-radius:0;border-top-right-radius:0}.navbar-fixed-bottom .navbar-nav>li>.dropdown-menu{margin-bottom:0;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.navbar-btn{margin-top:8px;margin-bottom:8px}.navbar-btn.btn-sm{margin-top:10px;margin-bottom:10px}.navbar-btn.btn-xs{margin-top:14px;margin-bottom:14px}.navbar-text{margin-top:15px;margin-bottom:15px}@media (min-width:768px){.navbar-text{float:left;margin-right:15px;margin-left:15px}}@media (min-width:768px){.navbar-left{float:left!important}.navbar-right{float:right!important;margin-right:-15px}.navbar-right~.navbar-right{margin-right:0}}.navbar-default{background-color:#f8f8f8;border-color:#e7e7e7}.navbar-default .navbar-brand{color:#777}.navbar-default .navbar-brand:focus,.navbar-default .navbar-brand:hover{color:#5e5e5e;background-color:transparent}.navbar-default .navbar-text{color:#777}.navbar-default .navbar-nav>li>a{color:#777}.navbar-default .navbar-nav>li>a:focus,.navbar-default .navbar-nav>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.active>a:focus,.navbar-default .navbar-nav>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav>.disabled>a,.navbar-default .navbar-nav>.disabled>a:focus,.navbar-default .navbar-nav>.disabled>a:hover{color:#ccc;background-color:transparent}.navbar-default .navbar-toggle{border-color:#ddd}.navbar-default .navbar-toggle:focus,.navbar-default .navbar-toggle:hover{background-color:#ddd}.navbar-default .navbar-toggle .icon-bar{background-color:#888}.navbar-default .navbar-collapse,.navbar-default .navbar-form{border-color:#e7e7e7}.navbar-default .navbar-nav>.open>a,.navbar-default .navbar-nav>.open>a:focus,.navbar-default .navbar-nav>.open>a:hover{color:#555;background-color:#e7e7e7}@media (max-width:767px){.navbar-default .navbar-nav .open .dropdown-menu>li>a{color:#777}.navbar-default .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav .open .dropdown-menu>.active>a,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#ccc;background-color:transparent}}.navbar-default .navbar-link{color:#777}.navbar-default .navbar-link:hover{color:#333}.navbar-default .btn-link{color:#777}.navbar-default .btn-link:focus,.navbar-default .btn-link:hover{color:#333}.navbar-default .btn-link[disabled]:focus,.navbar-default .btn-link[disabled]:hover,fieldset[disabled] .navbar-default .btn-link:focus,fieldset[disabled] .navbar-default .btn-link:hover{color:#ccc}.navbar-inverse{background-color:#222;border-color:#080808}.navbar-inverse .navbar-brand{color:#9d9d9d}.navbar-inverse .navbar-brand:focus,.navbar-inverse .navbar-brand:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-text{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a:focus,.navbar-inverse .navbar-nav>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>.active>a,.navbar-inverse .navbar-nav>.active>a:focus,.navbar-inverse .navbar-nav>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav>.disabled>a,.navbar-inverse .navbar-nav>.disabled>a:focus,.navbar-inverse .navbar-nav>.disabled>a:hover{color:#444;background-color:transparent}.navbar-inverse .navbar-toggle{border-color:#333}.navbar-inverse .navbar-toggle:focus,.navbar-inverse .navbar-toggle:hover{background-color:#333}.navbar-inverse .navbar-toggle .icon-bar{background-color:#fff}.navbar-inverse .navbar-collapse,.navbar-inverse .navbar-form{border-color:#101010}.navbar-inverse .navbar-nav>.open>a,.navbar-inverse .navbar-nav>.open>a:focus,.navbar-inverse .navbar-nav>.open>a:hover{color:#fff;background-color:#080808}@media (max-width:767px){.navbar-inverse .navbar-nav .open .dropdown-menu>.dropdown-header{border-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu .divider{background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#444;background-color:transparent}}.navbar-inverse .navbar-link{color:#9d9d9d}.navbar-inverse .navbar-link:hover{color:#fff}.navbar-inverse .btn-link{color:#9d9d9d}.navbar-inverse .btn-link:focus,.navbar-inverse .btn-link:hover{color:#fff}.navbar-inverse .btn-link[disabled]:focus,.navbar-inverse .btn-link[disabled]:hover,fieldset[disabled] .navbar-inverse .btn-link:focus,fieldset[disabled] .navbar-inverse .btn-link:hover{color:#444}.breadcrumb{padding:8px 15px;margin-bottom:20px;list-style:none;background-color:#f5f5f5;border-radius:4px}.breadcrumb>li{display:inline-block}.breadcrumb>li+li:before{padding:0 5px;color:#ccc;content:\"/\\00a0\"}.breadcrumb>.active{color:#777}.pagination{display:inline-block;padding-left:0;margin:20px 0;border-radius:4px}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:6px 12px;margin-left:-1px;line-height:1.42857143;color:#337ab7;text-decoration:none;background-color:#fff;border:1px solid #ddd}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-top-left-radius:4px;border-bottom-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-top-right-radius:4px;border-bottom-right-radius:4px}.pagination>li>a:focus,.pagination>li>a:hover,.pagination>li>span:focus,.pagination>li>span:hover{color:#23527c;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:focus,.pagination>.active>a:hover,.pagination>.active>span,.pagination>.active>span:focus,.pagination>.active>span:hover{z-index:2;color:#fff;cursor:default;background-color:#337ab7;border-color:#337ab7}.pagination>.disabled>a,.pagination>.disabled>a:focus,.pagination>.disabled>a:hover,.pagination>.disabled>span,.pagination>.disabled>span:focus,.pagination>.disabled>span:hover{color:#777;cursor:not-allowed;background-color:#fff;border-color:#ddd}.pagination-lg>li>a,.pagination-lg>li>span{padding:10px 16px;font-size:18px}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-top-left-radius:6px;border-bottom-left-radius:6px}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-top-right-radius:6px;border-bottom-right-radius:6px}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:12px}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-top-left-radius:3px;border-bottom-left-radius:3px}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-top-right-radius:3px;border-bottom-right-radius:3px}.pager{padding-left:0;margin:20px 0;text-align:center;list-style:none}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;border-radius:15px}.pager li>a:focus,.pager li>a:hover{text-decoration:none;background-color:#eee}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:focus,.pager .disabled>a:hover,.pager .disabled>span{color:#777;cursor:not-allowed;background-color:#fff}.label{display:inline;padding:.2em .6em .3em;font-size:75%;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25em}a.label:focus,a.label:hover{color:#fff;text-decoration:none;cursor:pointer}.label:empty{display:none}.btn .label{position:relative;top:-1px}.label-default{background-color:#777}.label-default[href]:focus,.label-default[href]:hover{background-color:#5e5e5e}.label-primary{background-color:#337ab7}.label-primary[href]:focus,.label-primary[href]:hover{background-color:#286090}.label-success{background-color:#5cb85c}.label-success[href]:focus,.label-success[href]:hover{background-color:#449d44}.label-info{background-color:#5bc0de}.label-info[href]:focus,.label-info[href]:hover{background-color:#31b0d5}.label-warning{background-color:#f0ad4e}.label-warning[href]:focus,.label-warning[href]:hover{background-color:#ec971f}.label-danger{background-color:#d9534f}.label-danger[href]:focus,.label-danger[href]:hover{background-color:#c9302c}.badge{display:inline-block;min-width:10px;padding:3px 7px;font-size:12px;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;background-color:#777;border-radius:10px}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.btn-group-xs>.btn .badge,.btn-xs .badge{top:0;padding:1px 5px}a.badge:focus,a.badge:hover{color:#fff;text-decoration:none;cursor:pointer}.list-group-item.active>.badge,.nav-pills>.active>a>.badge{color:#337ab7;background-color:#fff}.list-group-item>.badge{float:right}.list-group-item>.badge+.badge{margin-right:5px}.nav-pills>li>a>.badge{margin-left:3px}.jumbotron{padding:30px 15px;margin-bottom:30px;color:inherit;background-color:#eee}.jumbotron .h1,.jumbotron h1{color:inherit}.jumbotron p{margin-bottom:15px;font-size:21px;font-weight:200}.jumbotron>hr{border-top-color:#d5d5d5}.container .jumbotron,.container-fluid .jumbotron{border-radius:6px}.jumbotron .container{max-width:100%}@media screen and (min-width:768px){.jumbotron{padding:48px 0}.container .jumbotron,.container-fluid .jumbotron{padding-right:60px;padding-left:60px}.jumbotron .h1,.jumbotron h1{font-size:63px}}.thumbnail{display:block;padding:4px;margin-bottom:20px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:border .2s ease-in-out;-o-transition:border .2s ease-in-out;transition:border .2s ease-in-out}.thumbnail a>img,.thumbnail>img{margin-right:auto;margin-left:auto}a.thumbnail.active,a.thumbnail:focus,a.thumbnail:hover{border-color:#337ab7}.thumbnail .caption{padding:9px;color:#333}.alert{padding:15px;margin-bottom:20px;border:1px solid transparent;border-radius:4px}.alert h4{margin-top:0;color:inherit}.alert .alert-link{font-weight:700}.alert>p,.alert>ul{margin-bottom:0}.alert>p+p{margin-top:5px}.alert-dismissable,.alert-dismissible{padding-right:35px}.alert-dismissable .close,.alert-dismissible .close{position:relative;top:-2px;right:-21px;color:inherit}.alert-success{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.alert-success hr{border-top-color:#c9e2b3}.alert-success .alert-link{color:#2b542c}.alert-info{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.alert-info hr{border-top-color:#a6e1ec}.alert-info .alert-link{color:#245269}.alert-warning{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.alert-warning hr{border-top-color:#f7e1b5}.alert-warning .alert-link{color:#66512c}.alert-danger{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.alert-danger hr{border-top-color:#e4b9c0}.alert-danger .alert-link{color:#843534}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:20px;margin-bottom:20px;overflow:hidden;background-color:#f5f5f5;border-radius:4px;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,.1);box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}.progress-bar{float:left;width:0;height:100%;font-size:12px;line-height:20px;color:#fff;text-align:center;background-color:#337ab7;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);-webkit-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress-bar-striped,.progress-striped .progress-bar{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;background-size:40px 40px}.progress-bar.active,.progress.active .progress-bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-bar-success{background-color:#5cb85c}.progress-striped .progress-bar-success{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-info{background-color:#5bc0de}.progress-striped .progress-bar-info{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-warning{background-color:#f0ad4e}.progress-striped .progress-bar-warning{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-danger{background-color:#d9534f}.progress-striped .progress-bar-danger{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.media{margin-top:15px}.media:first-child{margin-top:0}.media,.media-body{overflow:hidden;zoom:1}.media-body{width:10000px}.media-object{display:block}.media-right,.media>.pull-right{padding-left:10px}.media-left,.media>.pull-left{padding-right:10px}.media-body,.media-left,.media-right{display:table-cell;vertical-align:top}.media-middle{vertical-align:middle}.media-bottom{vertical-align:bottom}.media-heading{margin-top:0;margin-bottom:5px}.media-list{padding-left:0;list-style:none}.list-group{padding-left:0;margin-bottom:20px}.list-group-item{position:relative;display:block;padding:10px 15px;margin-bottom:-1px;background-color:#fff;border:1px solid #ddd}.list-group-item:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.list-group-item:last-child{margin-bottom:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}a.list-group-item{color:#555}a.list-group-item .list-group-item-heading{color:#333}a.list-group-item:focus,a.list-group-item:hover{color:#555;text-decoration:none;background-color:#f5f5f5}.list-group-item.disabled,.list-group-item.disabled:focus,.list-group-item.disabled:hover{color:#777;cursor:not-allowed;background-color:#eee}.list-group-item.disabled .list-group-item-heading,.list-group-item.disabled:focus .list-group-item-heading,.list-group-item.disabled:hover .list-group-item-heading{color:inherit}.list-group-item.disabled .list-group-item-text,.list-group-item.disabled:focus .list-group-item-text,.list-group-item.disabled:hover .list-group-item-text{color:#777}.list-group-item.active,.list-group-item.active:focus,.list-group-item.active:hover{z-index:2;color:#fff;background-color:#337ab7;border-color:#337ab7}.list-group-item.active .list-group-item-heading,.list-group-item.active .list-group-item-heading>.small,.list-group-item.active .list-group-item-heading>small,.list-group-item.active:focus .list-group-item-heading,.list-group-item.active:focus .list-group-item-heading>.small,.list-group-item.active:focus .list-group-item-heading>small,.list-group-item.active:hover .list-group-item-heading,.list-group-item.active:hover .list-group-item-heading>.small,.list-group-item.active:hover .list-group-item-heading>small{color:inherit}.list-group-item.active .list-group-item-text,.list-group-item.active:focus .list-group-item-text,.list-group-item.active:hover .list-group-item-text{color:#c7ddef}.list-group-item-success{color:#3c763d;background-color:#dff0d8}a.list-group-item-success{color:#3c763d}a.list-group-item-success .list-group-item-heading{color:inherit}a.list-group-item-success:focus,a.list-group-item-success:hover{color:#3c763d;background-color:#d0e9c6}a.list-group-item-success.active,a.list-group-item-success.active:focus,a.list-group-item-success.active:hover{color:#fff;background-color:#3c763d;border-color:#3c763d}.list-group-item-info{color:#31708f;background-color:#d9edf7}a.list-group-item-info{color:#31708f}a.list-group-item-info .list-group-item-heading{color:inherit}a.list-group-item-info:focus,a.list-group-item-info:hover{color:#31708f;background-color:#c4e3f3}a.list-group-item-info.active,a.list-group-item-info.active:focus,a.list-group-item-info.active:hover{color:#fff;background-color:#31708f;border-color:#31708f}.list-group-item-warning{color:#8a6d3b;background-color:#fcf8e3}a.list-group-item-warning{color:#8a6d3b}a.list-group-item-warning .list-group-item-heading{color:inherit}a.list-group-item-warning:focus,a.list-group-item-warning:hover{color:#8a6d3b;background-color:#faf2cc}a.list-group-item-warning.active,a.list-group-item-warning.active:focus,a.list-group-item-warning.active:hover{color:#fff;background-color:#8a6d3b;border-color:#8a6d3b}.list-group-item-danger{color:#a94442;background-color:#f2dede}a.list-group-item-danger{color:#a94442}a.list-group-item-danger .list-group-item-heading{color:inherit}a.list-group-item-danger:focus,a.list-group-item-danger:hover{color:#a94442;background-color:#ebcccc}a.list-group-item-danger.active,a.list-group-item-danger.active:focus,a.list-group-item-danger.active:hover{color:#fff;background-color:#a94442;border-color:#a94442}.list-group-item-heading{margin-top:0;margin-bottom:5px}.list-group-item-text{margin-bottom:0;line-height:1.3}.panel{margin-bottom:20px;background-color:#fff;border:1px solid transparent;border-radius:4px;-webkit-box-shadow:0 1px 1px rgba(0,0,0,.05);box-shadow:0 1px 1px rgba(0,0,0,.05)}.panel-body{padding:15px}.panel-heading{padding:10px 15px;border-bottom:1px solid transparent;border-top-left-radius:3px;border-top-right-radius:3px}.panel-heading>.dropdown .dropdown-toggle{color:inherit}.panel-title{margin-top:0;margin-bottom:0;font-size:16px;color:inherit}.panel-title>.small,.panel-title>.small>a,.panel-title>a,.panel-title>small,.panel-title>small>a{color:inherit}.panel-footer{padding:10px 15px;background-color:#f5f5f5;border-top:1px solid #ddd;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.list-group,.panel>.panel-collapse>.list-group{margin-bottom:0}.panel>.list-group .list-group-item,.panel>.panel-collapse>.list-group .list-group-item{border-width:1px 0;border-radius:0}.panel>.list-group:first-child .list-group-item:first-child,.panel>.panel-collapse>.list-group:first-child .list-group-item:first-child{border-top:0;border-top-left-radius:3px;border-top-right-radius:3px}.panel>.list-group:last-child .list-group-item:last-child,.panel>.panel-collapse>.list-group:last-child .list-group-item:last-child{border-bottom:0;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel-heading+.list-group .list-group-item:first-child{border-top-width:0}.list-group+.panel-footer{border-top-width:0}.panel>.panel-collapse>.table,.panel>.table,.panel>.table-responsive>.table{margin-bottom:0}.panel>.panel-collapse>.table caption,.panel>.table caption,.panel>.table-responsive>.table caption{padding-right:15px;padding-left:15px}.panel>.table-responsive:first-child>.table:first-child,.panel>.table:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child,.panel>.table:first-child>thead:first-child>tr:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table:first-child>thead:first-child>tr:first-child th:first-child{border-top-left-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table:first-child>thead:first-child>tr:first-child th:last-child{border-top-right-radius:3px}.panel>.table-responsive:last-child>.table:last-child,.panel>.table:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:first-child{border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:last-child{border-bottom-right-radius:3px}.panel>.panel-body+.table,.panel>.panel-body+.table-responsive,.panel>.table+.panel-body,.panel>.table-responsive+.panel-body{border-top:1px solid #ddd}.panel>.table>tbody:first-child>tr:first-child td,.panel>.table>tbody:first-child>tr:first-child th{border-top:0}.panel>.table-bordered,.panel>.table-responsive>.table-bordered{border:0}.panel>.table-bordered>tbody>tr>td:first-child,.panel>.table-bordered>tbody>tr>th:first-child,.panel>.table-bordered>tfoot>tr>td:first-child,.panel>.table-bordered>tfoot>tr>th:first-child,.panel>.table-bordered>thead>tr>td:first-child,.panel>.table-bordered>thead>tr>th:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:first-child,.panel>.table-responsive>.table-bordered>thead>tr>td:first-child,.panel>.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.panel>.table-bordered>tbody>tr>td:last-child,.panel>.table-bordered>tbody>tr>th:last-child,.panel>.table-bordered>tfoot>tr>td:last-child,.panel>.table-bordered>tfoot>tr>th:last-child,.panel>.table-bordered>thead>tr>td:last-child,.panel>.table-bordered>thead>tr>th:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:last-child,.panel>.table-responsive>.table-bordered>thead>tr>td:last-child,.panel>.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.panel>.table-bordered>tbody>tr:first-child>td,.panel>.table-bordered>tbody>tr:first-child>th,.panel>.table-bordered>thead>tr:first-child>td,.panel>.table-bordered>thead>tr:first-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>th,.panel>.table-responsive>.table-bordered>thead>tr:first-child>td,.panel>.table-responsive>.table-bordered>thead>tr:first-child>th{border-bottom:0}.panel>.table-bordered>tbody>tr:last-child>td,.panel>.table-bordered>tbody>tr:last-child>th,.panel>.table-bordered>tfoot>tr:last-child>td,.panel>.table-bordered>tfoot>tr:last-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>th,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>td,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}.panel>.table-responsive{margin-bottom:0;border:0}.panel-group{margin-bottom:20px}.panel-group .panel{margin-bottom:0;border-radius:4px}.panel-group .panel+.panel{margin-top:5px}.panel-group .panel-heading{border-bottom:0}.panel-group .panel-heading+.panel-collapse>.list-group,.panel-group .panel-heading+.panel-collapse>.panel-body{border-top:1px solid #ddd}.panel-group .panel-footer{border-top:0}.panel-group .panel-footer+.panel-collapse .panel-body{border-bottom:1px solid #ddd}.panel-default{border-color:#ddd}.panel-default>.panel-heading{color:#333;background-color:#f5f5f5;border-color:#ddd}.panel-default>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ddd}.panel-default>.panel-heading .badge{color:#f5f5f5;background-color:#333}.panel-default>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ddd}.panel-primary{border-color:#337ab7}.panel-primary>.panel-heading{color:#fff;background-color:#337ab7;border-color:#337ab7}.panel-primary>.panel-heading+.panel-collapse>.panel-body{border-top-color:#337ab7}.panel-primary>.panel-heading .badge{color:#337ab7;background-color:#fff}.panel-primary>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#337ab7}.panel-success{border-color:#d6e9c6}.panel-success>.panel-heading{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.panel-success>.panel-heading+.panel-collapse>.panel-body{border-top-color:#d6e9c6}.panel-success>.panel-heading .badge{color:#dff0d8;background-color:#3c763d}.panel-success>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#d6e9c6}.panel-info{border-color:#bce8f1}.panel-info>.panel-heading{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.panel-info>.panel-heading+.panel-collapse>.panel-body{border-top-color:#bce8f1}.panel-info>.panel-heading .badge{color:#d9edf7;background-color:#31708f}.panel-info>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#bce8f1}.panel-warning{border-color:#faebcc}.panel-warning>.panel-heading{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.panel-warning>.panel-heading+.panel-collapse>.panel-body{border-top-color:#faebcc}.panel-warning>.panel-heading .badge{color:#fcf8e3;background-color:#8a6d3b}.panel-warning>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#faebcc}.panel-danger{border-color:#ebccd1}.panel-danger>.panel-heading{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.panel-danger>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ebccd1}.panel-danger>.panel-heading .badge{color:#f2dede;background-color:#a94442}.panel-danger>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ebccd1}.embed-responsive{position:relative;display:block;height:0;padding:0;overflow:hidden}.embed-responsive .embed-responsive-item,.embed-responsive embed,.embed-responsive iframe,.embed-responsive object,.embed-responsive video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.embed-responsive-16by9{padding-bottom:56.25%}.embed-responsive-4by3{padding-bottom:75%}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.05);box-shadow:inset 0 1px 1px rgba(0,0,0,.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,.15)}.well-lg{padding:24px;border-radius:6px}.well-sm{padding:9px;border-radius:3px}.close{float:right;font-size:21px;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;filter:alpha(opacity=20);opacity:.2}.close:focus,.close:hover{color:#000;text-decoration:none;cursor:pointer;filter:alpha(opacity=50);opacity:.5}button.close{-webkit-appearance:none;padding:0;cursor:pointer;background:0 0;border:0}.modal-open{overflow:hidden}.modal{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;display:none;overflow:hidden;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{-webkit-transition:-webkit-transform .3s ease-out;-o-transition:-o-transform .3s ease-out;transition:transform .3s ease-out;-webkit-transform:translate(0,-25%);-ms-transform:translate(0,-25%);-o-transform:translate(0,-25%);transform:translate(0,-25%)}.modal.in .modal-dialog{-webkit-transform:translate(0,0);-ms-transform:translate(0,0);-o-transform:translate(0,0);transform:translate(0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;outline:0;-webkit-box-shadow:0 3px 9px rgba(0,0,0,.5);box-shadow:0 3px 9px rgba(0,0,0,.5)}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{filter:alpha(opacity=0);opacity:0}.modal-backdrop.in{filter:alpha(opacity=50);opacity:.5}.modal-header{min-height:16.43px;padding:15px;border-bottom:1px solid #e5e5e5}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.42857143}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}@media (min-width:768px){.modal-dialog{width:600px;margin:30px auto}.modal-content{-webkit-box-shadow:0 5px 15px rgba(0,0,0,.5);box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}.tooltip{position:absolute;z-index:1070;display:block;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:12px;font-weight:400;line-height:1.4;filter:alpha(opacity=0);opacity:0}.tooltip.in{filter:alpha(opacity=90);opacity:.9}.tooltip.top{padding:5px 0;margin-top:-3px}.tooltip.right{padding:0 5px;margin-left:3px}.tooltip.bottom{padding:5px 0;margin-top:3px}.tooltip.left{padding:0 5px;margin-left:-3px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;text-decoration:none;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-left .tooltip-arrow{right:5px;bottom:0;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-right .tooltip-arrow{bottom:0;left:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-left .tooltip-arrow{top:0;right:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-right .tooltip-arrow{top:0;left:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.popover{position:absolute;top:0;left:0;z-index:1060;display:none;max-width:276px;padding:1px;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;font-weight:400;line-height:1.42857143;text-align:left;white-space:normal;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.2);border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,.2);box-shadow:0 5px 10px rgba(0,0,0,.2)}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{padding:8px 14px;margin:0;font-size:14px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-radius:5px 5px 0 0}.popover-content{padding:9px 14px}.popover>.arrow,.popover>.arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.popover>.arrow{border-width:11px}.popover>.arrow:after{content:\"\";border-width:10px}.popover.top>.arrow{bottom:-11px;left:50%;margin-left:-11px;border-top-color:#999;border-top-color:rgba(0,0,0,.25);border-bottom-width:0}.popover.top>.arrow:after{bottom:1px;margin-left:-10px;content:\" \";border-top-color:#fff;border-bottom-width:0}.popover.right>.arrow{top:50%;left:-11px;margin-top:-11px;border-right-color:#999;border-right-color:rgba(0,0,0,.25);border-left-width:0}.popover.right>.arrow:after{bottom:-10px;left:1px;content:\" \";border-right-color:#fff;border-left-width:0}.popover.bottom>.arrow{top:-11px;left:50%;margin-left:-11px;border-top-width:0;border-bottom-color:#999;border-bottom-color:rgba(0,0,0,.25)}.popover.bottom>.arrow:after{top:1px;margin-left:-10px;content:\" \";border-top-width:0;border-bottom-color:#fff}.popover.left>.arrow{top:50%;right:-11px;margin-top:-11px;border-right-width:0;border-left-color:#999;border-left-color:rgba(0,0,0,.25)}.popover.left>.arrow:after{right:1px;bottom:-10px;content:\" \";border-right-width:0;border-left-color:#fff}.carousel{position:relative}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-inner>.item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel-inner>.item>a>img,.carousel-inner>.item>img{line-height:1}@media all and (transform-3d),(-webkit-transform-3d){.carousel-inner>.item{-webkit-transition:-webkit-transform .6s ease-in-out;-o-transition:-o-transform .6s ease-in-out;transition:transform .6s ease-in-out;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-perspective:1000;perspective:1000}.carousel-inner>.item.active.right,.carousel-inner>.item.next{left:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}.carousel-inner>.item.active.left,.carousel-inner>.item.prev{left:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}.carousel-inner>.item.active,.carousel-inner>.item.next.left,.carousel-inner>.item.prev.right{left:0;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:0;bottom:0;left:0;width:15%;font-size:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6);filter:alpha(opacity=50);opacity:.5}.carousel-control.left{background-image:-webkit-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,.0001)));background-image:linear-gradient(to right,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1);background-repeat:repeat-x}.carousel-control.right{right:0;left:auto;background-image:-webkit-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.0001)),to(rgba(0,0,0,.5)));background-image:linear-gradient(to right,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1);background-repeat:repeat-x}.carousel-control:focus,.carousel-control:hover{color:#fff;text-decoration:none;filter:alpha(opacity=90);outline:0;opacity:.9}.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{position:absolute;top:50%;z-index:5;display:inline-block}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{left:50%;margin-left:-10px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{right:50%;margin-right:-10px}.carousel-control .icon-next,.carousel-control .icon-prev{width:20px;height:20px;margin-top:-10px;font-family:serif;line-height:1}.carousel-control .icon-prev:before{content:'\\2039'}.carousel-control .icon-next:before{content:'\\203a'}.carousel-indicators{position:absolute;bottom:10px;left:50%;z-index:15;width:60%;padding-left:0;margin-left:-30%;text-align:center;list-style:none}.carousel-indicators li{display:inline-block;width:10px;height:10px;margin:1px;text-indent:-999px;cursor:pointer;background-color:#000 \\9;background-color:rgba(0,0,0,0);border:1px solid #fff;border-radius:10px}.carousel-indicators .active{width:12px;height:12px;margin:0;background-color:#fff}.carousel-caption{position:absolute;right:15%;bottom:20px;left:15%;z-index:10;padding-top:20px;padding-bottom:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6)}.carousel-caption .btn{text-shadow:none}@media screen and (min-width:768px){.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{width:30px;height:30px;margin-top:-15px;font-size:30px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{margin-left:-15px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{margin-right:-15px}.carousel-caption{right:20%;left:20%;padding-bottom:30px}.carousel-indicators{bottom:20px}}.btn-group-vertical>.btn-group:after,.btn-group-vertical>.btn-group:before,.btn-toolbar:after,.btn-toolbar:before,.clearfix:after,.clearfix:before,.container-fluid:after,.container-fluid:before,.container:after,.container:before,.dl-horizontal dd:after,.dl-horizontal dd:before,.form-horizontal .form-group:after,.form-horizontal .form-group:before,.modal-footer:after,.modal-footer:before,.nav:after,.nav:before,.navbar-collapse:after,.navbar-collapse:before,.navbar-header:after,.navbar-header:before,.navbar:after,.navbar:before,.pager:after,.pager:before,.panel-body:after,.panel-body:before,.row:after,.row:before{display:table;content:\" \"}.btn-group-vertical>.btn-group:after,.btn-toolbar:after,.clearfix:after,.container-fluid:after,.container:after,.dl-horizontal dd:after,.form-horizontal .form-group:after,.modal-footer:after,.nav:after,.navbar-collapse:after,.navbar-header:after,.navbar:after,.pager:after,.panel-body:after,.row:after{clear:both}.center-block{display:block;margin-right:auto;margin-left:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important}.affix{position:fixed}@-ms-viewport{width:device-width}.visible-lg,.visible-md,.visible-sm,.visible-xs{display:none!important}.visible-lg-block,.visible-lg-inline,.visible-lg-inline-block,.visible-md-block,.visible-md-inline,.visible-md-inline-block,.visible-sm-block,.visible-sm-inline,.visible-sm-inline-block,.visible-xs-block,.visible-xs-inline,.visible-xs-inline-block{display:none!important}@media (max-width:767px){.visible-xs{display:block!important}table.visible-xs{display:table}tr.visible-xs{display:table-row!important}td.visible-xs,th.visible-xs{display:table-cell!important}}@media (max-width:767px){.visible-xs-block{display:block!important}}@media (max-width:767px){.visible-xs-inline{display:inline!important}}@media (max-width:767px){.visible-xs-inline-block{display:inline-block!important}}@media (min-width:768px)and (max-width:991px){.visible-sm{display:block!important}table.visible-sm{display:table}tr.visible-sm{display:table-row!important}td.visible-sm,th.visible-sm{display:table-cell!important}}@media (min-width:768px)and (max-width:991px){.visible-sm-block{display:block!important}}@media (min-width:768px)and (max-width:991px){.visible-sm-inline{display:inline!important}}@media (min-width:768px)and (max-width:991px){.visible-sm-inline-block{display:inline-block!important}}@media (min-width:992px)and (max-width:1199px){.visible-md{display:block!important}table.visible-md{display:table}tr.visible-md{display:table-row!important}td.visible-md,th.visible-md{display:table-cell!important}}@media (min-width:992px)and (max-width:1199px){.visible-md-block{display:block!important}}@media (min-width:992px)and (max-width:1199px){.visible-md-inline{display:inline!important}}@media (min-width:992px)and (max-width:1199px){.visible-md-inline-block{display:inline-block!important}}@media (min-width:1200px){.visible-lg{display:block!important}table.visible-lg{display:table}tr.visible-lg{display:table-row!important}td.visible-lg,th.visible-lg{display:table-cell!important}}@media (min-width:1200px){.visible-lg-block{display:block!important}}@media (min-width:1200px){.visible-lg-inline{display:inline!important}}@media (min-width:1200px){.visible-lg-inline-block{display:inline-block!important}}@media (max-width:767px){.hidden-xs{display:none!important}}@media (min-width:768px)and (max-width:991px){.hidden-sm{display:none!important}}@media (min-width:992px)and (max-width:1199px){.hidden-md{display:none!important}}@media (min-width:1200px){.hidden-lg{display:none!important}}.visible-print{display:none!important}@media print{.visible-print{display:block!important}table.visible-print{display:table}tr.visible-print{display:table-row!important}td.visible-print,th.visible-print{display:table-cell!important}}.visible-print-block{display:none!important}@media print{.visible-print-block{display:block!important}}.visible-print-inline{display:none!important}@media print{.visible-print-inline{display:inline!important}}.visible-print-inline-block{display:none!important}@media print{.visible-print-inline-block{display:inline-block!important}}@media print{.hidden-print{display:none!important}}"},{"title":"","date":"2018-09-12T03:25:45.332Z","updated":"2014-06-16T08:02:34.000Z","comments":true,"path":"cv/old/css/bootstrap.css","permalink":"http://tech.yushuai.xyz/cv/old/css/bootstrap.css","excerpt":"","text":"/*! * Bootstrap v3.1.1 (http://getbootstrap.com) * Copyright 2011-2014 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) */ /*! normalize.css v3.0.0 | MIT License | git.io/normalize */ html { font-family: sans-serif; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; } body { margin: 0; } article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; } audio, canvas, progress, video { display: inline-block; vertical-align: baseline; } audio:not([controls]) { display: none; height: 0; } [hidden], template { display: none; } a { background: transparent; } a:active, a:hover { outline: 0; } abbr[title] { border-bottom: 1px dotted; } b, strong { font-weight: bold; } dfn { font-style: italic; } h1 { margin: .67em 0; font-size: 2em; } mark { color: #000; background: #ff0; } small { font-size: 80%; } sub, sup { position: relative; font-size: 75%; line-height: 0; vertical-align: baseline; } sup { top: -.5em; } sub { bottom: -.25em; } img { border: 0; } svg:not(:root) { overflow: hidden; } figure { margin: 1em 40px; } hr { height: 0; -moz-box-sizing: content-box; box-sizing: content-box; } pre { overflow: auto; } code, kbd, pre, samp { font-family: monospace, monospace; font-size: 1em; } button, input, optgroup, select, textarea { margin: 0; font: inherit; color: inherit; } button { overflow: visible; } button, select { text-transform: none; } button, html input[type=\"button\"], input[type=\"reset\"], input[type=\"submit\"] { -webkit-appearance: button; cursor: pointer; } button[disabled], html input[disabled] { cursor: default; } button::-moz-focus-inner, input::-moz-focus-inner { padding: 0; border: 0; } input { line-height: normal; } input[type=\"checkbox\"], input[type=\"radio\"] { box-sizing: border-box; padding: 0; } input[type=\"number\"]::-webkit-inner-spin-button, input[type=\"number\"]::-webkit-outer-spin-button { height: auto; } input[type=\"search\"] { -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; -webkit-appearance: textfield; } input[type=\"search\"]::-webkit-search-cancel-button, input[type=\"search\"]::-webkit-search-decoration { -webkit-appearance: none; } fieldset { padding: .35em .625em .75em; margin: 0 2px; border: 1px solid #c0c0c0; } legend { padding: 0; border: 0; } textarea { overflow: auto; } optgroup { font-weight: bold; } table { border-spacing: 0; border-collapse: collapse; } td, th { padding: 0; } @media print { * { color: #000 !important; text-shadow: none !important; background: transparent !important; box-shadow: none !important; } a, a:visited { text-decoration: underline; } a[href]:after { content: \" (\" attr(href) \")\"; } abbr[title]:after { content: \" (\" attr(title) \")\"; } a[href^=\"javascript:\"]:after, a[href^=\"#\"]:after { content: \"\"; } pre, blockquote { border: 1px solid #999; page-break-inside: avoid; } thead { display: table-header-group; } tr, img { page-break-inside: avoid; } img { max-width: 100% !important; } p, h2, h3 { orphans: 3; widows: 3; } h2, h3 { page-break-after: avoid; } select { background: #fff !important; } .navbar { display: none; } .table td, .table th { background-color: #fff !important; } .btn > .caret, .dropup > .btn > .caret { border-top-color: #000 !important; } .label { border: 1px solid #000; } .table { border-collapse: collapse !important; } .table-bordered th, .table-bordered td { border: 1px solid #ddd !important; } } * { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } *:before, *:after { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } html { font-size: 62.5%; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); } body { font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; font-size: 14px; line-height: 1.42857143; color: #333; background-color: #fff; } input, button, select, textarea { font-family: inherit; font-size: inherit; line-height: inherit; } a { color: #1B242F; text-decoration: none; } a:hover, a:focus { color: #E74C3C; text-decoration: underline; } a:focus { outline: thin dotted; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } figure { margin: 0; } img { vertical-align: middle; } .img-responsive, .thumbnail > img, .thumbnail a > img, .carousel-inner > .item > img, .carousel-inner > .item > a > img { display: block; max-width: 100%; height: auto; } .img-rounded { border-radius: 6px; } .img-thumbnail { display: inline-block; max-width: 100%; height: auto; padding: 4px; line-height: 1.42857143; background-color: #fff; border: 1px solid #ddd; border-radius: 4px; -webkit-transition: all .2s ease-in-out; transition: all .2s ease-in-out; } .img-circle { border-radius: 50%; } hr { margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid none; } .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; } h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 { font-family: inherit; font-weight: 500; line-height: 1.1; color: inherit; } h1 small, h2 small, h3 small, h4 small, h5 small, h6 small, .h1 small, .h2 small, .h3 small, .h4 small, .h5 small, .h6 small, h1 .small, h2 .small, h3 .small, h4 .small, h5 .small, h6 .small, .h1 .small, .h2 .small, .h3 .small, .h4 .small, .h5 .small, .h6 .small { font-weight: normal; line-height: 1; color: #999; } h1, .h1, h2, .h2, h3, .h3 { margin-top: 20px; margin-bottom: 10px; } h1 small, .h1 small, h2 small, .h2 small, h3 small, .h3 small, h1 .small, .h1 .small, h2 .small, .h2 .small, h3 .small, .h3 .small { font-size: 65%; } h4, .h4, h5, .h5, h6, .h6 { margin-top: 10px; margin-bottom: 10px; } h4 small, .h4 small, h5 small, .h5 small, h6 small, .h6 small, h4 .small, .h4 .small, h5 .small, .h5 .small, h6 .small, .h6 .small { font-size: 75%; } h1, .h1 { font-size: 36px; } h2, .h2 { font-size: 30px; } h3, .h3 { font-size: 24px; } h4, .h4 { font-size: 18px; } h5, .h5 { font-size: 14px; } h6, .h6 { font-size: 12px; } p { margin: 0 0 10px; } .lead { margin-bottom: 20px; font-size: 16px; font-weight: 200; line-height: 1.4; } @media (min-width: 768px) { .lead { font-size: 21px; } } small, .small { font-size: 85%; } cite { font-style: normal; } .text-left { text-align: left; } .text-right { text-align: right; } .text-center { text-align: center; } .text-justify { text-align: justify; } .text-muted { color: #999; } .text-primary { color: #1B242F; } a.text-primary:hover { color: #3071a9; } .text-success { color: #3c763d; } a.text-success:hover { color: #2b542c; } .text-info { color: #31708f; } a.text-info:hover { color: #245269; } .text-warning { color: #8a6d3b; } a.text-warning:hover { color: #66512c; } .text-danger { color: #a94442; } a.text-danger:hover { color: #843534; } .bg-primary { color: #fff; background-color: #1B242F; } a.bg-primary:hover { background-color: #3071a9; } .bg-success { background-color: #dff0d8; } a.bg-success:hover { background-color: #c1e2b3; } .bg-info { background-color: #d9edf7; } a.bg-info:hover { background-color: #afd9ee; } .bg-warning { background-color: #fcf8e3; } a.bg-warning:hover { background-color: #f7ecb5; } .bg-danger { background-color: #f2dede; } a.bg-danger:hover { background-color: #e4b9b9; } .page-header { padding-bottom: 9px; margin: 40px 0 20px; border-bottom: 1px solid none; } ul, ol { margin-top: 0; margin-bottom: 10px; } ul ul, ol ul, ul ol, ol ol { margin-bottom: 0; } .list-unstyled { padding-left: 0; list-style: none; } .list-inline { padding-left: 0; margin-left: -5px; list-style: none; } .list-inline > li { display: inline-block; padding-right: 5px; padding-left: 5px; } dl { margin-top: 0; margin-bottom: 20px; } dt, dd { line-height: 1.42857143; } dt { font-weight: bold; } dd { margin-left: 0; } @media (min-width: 768px) { .dl-horizontal dt { float: left; width: 160px; overflow: hidden; clear: left; text-align: right; text-overflow: ellipsis; white-space: nowrap; } .dl-horizontal dd { margin-left: 180px; } } abbr[title], abbr[data-original-title] { cursor: help; border-bottom: 1px dotted #999; } .initialism { font-size: 90%; text-transform: uppercase; } blockquote { padding: 10px 20px; margin: 0 0 20px; font-size: 17.5px; border-left: 5px solid none; } blockquote p:last-child, blockquote ul:last-child, blockquote ol:last-child { margin-bottom: 0; } blockquote footer, blockquote small, blockquote .small { display: block; font-size: 80%; line-height: 1.42857143; color: #999; } blockquote footer:before, blockquote small:before, blockquote .small:before { content: '\\2014 \\00A0'; } .blockquote-reverse, blockquote.pull-right { padding-right: 15px; padding-left: 0; text-align: right; border-right: 5px solid none; border-left: 0; } .blockquote-reverse footer:before, blockquote.pull-right footer:before, .blockquote-reverse small:before, blockquote.pull-right small:before, .blockquote-reverse .small:before, blockquote.pull-right .small:before { content: ''; } .blockquote-reverse footer:after, blockquote.pull-right footer:after, .blockquote-reverse small:after, blockquote.pull-right small:after, .blockquote-reverse .small:after, blockquote.pull-right .small:after { content: '\\00A0 \\2014'; } blockquote:before, blockquote:after { content: \"\"; } address { margin-bottom: 20px; font-style: normal; line-height: 1.42857143; } code, kbd, pre, samp { font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace; } code { padding: 2px 4px; font-size: 90%; color: #c7254e; white-space: nowrap; background-color: #f9f2f4; border-radius: 4px; } kbd { padding: 2px 4px; font-size: 90%; color: #fff; background-color: #333; border-radius: 3px; box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .25); } pre { display: block; padding: 9.5px; margin: 0 0 10px; font-size: 13px; line-height: 1.42857143; color: #333; word-break: break-all; word-wrap: break-word; background-color: #f5f5f5; border: 1px solid #ccc; border-radius: 4px; } pre code { padding: 0; font-size: inherit; color: inherit; white-space: pre-wrap; background-color: transparent; border-radius: 0; } .pre-scrollable { max-height: 340px; overflow-y: scroll; } .container { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } @media (min-width: 768px) { .container { width: 750px; } } @media (min-width: 992px) { .container { width: 970px; } } @media (min-width: 1200px) { .container { width: 1170px; } } .container-fluid { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } .row { margin-right: -15px; margin-left: -15px; } .col-xs-1, .col-sm-1, .col-md-1, .col-lg-1, .col-xs-2, .col-sm-2, .col-md-2, .col-lg-2, .col-xs-3, .col-sm-3, .col-md-3, .col-lg-3, .col-xs-4, .col-sm-4, .col-md-4, .col-lg-4, .col-xs-5, .col-sm-5, .col-md-5, .col-lg-5, .col-xs-6, .col-sm-6, .col-md-6, .col-lg-6, .col-xs-7, .col-sm-7, .col-md-7, .col-lg-7, .col-xs-8, .col-sm-8, .col-md-8, .col-lg-8, .col-xs-9, .col-sm-9, .col-md-9, .col-lg-9, .col-xs-10, .col-sm-10, .col-md-10, .col-lg-10, .col-xs-11, .col-sm-11, .col-md-11, .col-lg-11, .col-xs-12, .col-sm-12, .col-md-12, .col-lg-12 { position: relative; min-height: 1px; padding-right: 15px; padding-left: 15px; } .col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12 { float: left; } .col-xs-12 { width: 100%; } .col-xs-11 { width: 91.66666667%; } .col-xs-10 { width: 83.33333333%; } .col-xs-9 { width: 75%; } .col-xs-8 { width: 66.66666667%; } .col-xs-7 { width: 58.33333333%; } .col-xs-6 { width: 50%; } .col-xs-5 { width: 41.66666667%; } .col-xs-4 { width: 33.33333333%; } .col-xs-3 { width: 25%; } .col-xs-2 { width: 16.66666667%; } .col-xs-1 { width: 8.33333333%; } .col-xs-pull-12 { right: 100%; } .col-xs-pull-11 { right: 91.66666667%; } .col-xs-pull-10 { right: 83.33333333%; } .col-xs-pull-9 { right: 75%; } .col-xs-pull-8 { right: 66.66666667%; } .col-xs-pull-7 { right: 58.33333333%; } .col-xs-pull-6 { right: 50%; } .col-xs-pull-5 { right: 41.66666667%; } .col-xs-pull-4 { right: 33.33333333%; } .col-xs-pull-3 { right: 25%; } .col-xs-pull-2 { right: 16.66666667%; } .col-xs-pull-1 { right: 8.33333333%; } .col-xs-pull-0 { right: 0; } .col-xs-push-12 { left: 100%; } .col-xs-push-11 { left: 91.66666667%; } .col-xs-push-10 { left: 83.33333333%; } .col-xs-push-9 { left: 75%; } .col-xs-push-8 { left: 66.66666667%; } .col-xs-push-7 { left: 58.33333333%; } .col-xs-push-6 { left: 50%; } .col-xs-push-5 { left: 41.66666667%; } .col-xs-push-4 { left: 33.33333333%; } .col-xs-push-3 { left: 25%; } .col-xs-push-2 { left: 16.66666667%; } .col-xs-push-1 { left: 8.33333333%; } .col-xs-push-0 { left: 0; } .col-xs-offset-12 { margin-left: 100%; } .col-xs-offset-11 { margin-left: 91.66666667%; } .col-xs-offset-10 { margin-left: 83.33333333%; } .col-xs-offset-9 { margin-left: 75%; } .col-xs-offset-8 { margin-left: 66.66666667%; } .col-xs-offset-7 { margin-left: 58.33333333%; } .col-xs-offset-6 { margin-left: 50%; } .col-xs-offset-5 { margin-left: 41.66666667%; } .col-xs-offset-4 { margin-left: 33.33333333%; } .col-xs-offset-3 { margin-left: 25%; } .col-xs-offset-2 { margin-left: 16.66666667%; } .col-xs-offset-1 { margin-left: 8.33333333%; } .col-xs-offset-0 { margin-left: 0; } @media (min-width: 768px) { .col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11, .col-sm-12 { float: left; } .col-sm-12 { width: 100%; } .col-sm-11 { width: 91.66666667%; } .col-sm-10 { width: 83.33333333%; } .col-sm-9 { width: 75%; } .col-sm-8 { width: 66.66666667%; } .col-sm-7 { width: 58.33333333%; } .col-sm-6 { width: 50%; } .col-sm-5 { width: 41.66666667%; } .col-sm-4 { width: 33.33333333%; } .col-sm-3 { width: 25%; } .col-sm-2 { width: 16.66666667%; } .col-sm-1 { width: 8.33333333%; } .col-sm-pull-12 { right: 100%; } .col-sm-pull-11 { right: 91.66666667%; } .col-sm-pull-10 { right: 83.33333333%; } .col-sm-pull-9 { right: 75%; } .col-sm-pull-8 { right: 66.66666667%; } .col-sm-pull-7 { right: 58.33333333%; } .col-sm-pull-6 { right: 50%; } .col-sm-pull-5 { right: 41.66666667%; } .col-sm-pull-4 { right: 33.33333333%; } .col-sm-pull-3 { right: 25%; } .col-sm-pull-2 { right: 16.66666667%; } .col-sm-pull-1 { right: 8.33333333%; } .col-sm-pull-0 { right: 0; } .col-sm-push-12 { left: 100%; } .col-sm-push-11 { left: 91.66666667%; } .col-sm-push-10 { left: 83.33333333%; } .col-sm-push-9 { left: 75%; } .col-sm-push-8 { left: 66.66666667%; } .col-sm-push-7 { left: 58.33333333%; } .col-sm-push-6 { left: 50%; } .col-sm-push-5 { left: 41.66666667%; } .col-sm-push-4 { left: 33.33333333%; } .col-sm-push-3 { left: 25%; } .col-sm-push-2 { left: 16.66666667%; } .col-sm-push-1 { left: 8.33333333%; } .col-sm-push-0 { left: 0; } .col-sm-offset-12 { margin-left: 100%; } .col-sm-offset-11 { margin-left: 91.66666667%; } .col-sm-offset-10 { margin-left: 83.33333333%; } .col-sm-offset-9 { margin-left: 75%; } .col-sm-offset-8 { margin-left: 66.66666667%; } .col-sm-offset-7 { margin-left: 58.33333333%; } .col-sm-offset-6 { margin-left: 50%; } .col-sm-offset-5 { margin-left: 41.66666667%; } .col-sm-offset-4 { margin-left: 33.33333333%; } .col-sm-offset-3 { margin-left: 25%; } .col-sm-offset-2 { margin-left: 16.66666667%; } .col-sm-offset-1 { margin-left: 8.33333333%; } .col-sm-offset-0 { margin-left: 0; } } @media (min-width: 992px) { .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12 { float: left; } .col-md-12 { width: 100%; } .col-md-11 { width: 91.66666667%; } .col-md-10 { width: 83.33333333%; } .col-md-9 { width: 75%; } .col-md-8 { width: 66.66666667%; } .col-md-7 { width: 58.33333333%; } .col-md-6 { width: 50%; } .col-md-5 { width: 41.66666667%; } .col-md-4 { width: 33.33333333%; } .col-md-3 { width: 25%; } .col-md-2 { width: 16.66666667%; } .col-md-1 { width: 8.33333333%; } .col-md-pull-12 { right: 100%; } .col-md-pull-11 { right: 91.66666667%; } .col-md-pull-10 { right: 83.33333333%; } .col-md-pull-9 { right: 75%; } .col-md-pull-8 { right: 66.66666667%; } .col-md-pull-7 { right: 58.33333333%; } .col-md-pull-6 { right: 50%; } .col-md-pull-5 { right: 41.66666667%; } .col-md-pull-4 { right: 33.33333333%; } .col-md-pull-3 { right: 25%; } .col-md-pull-2 { right: 16.66666667%; } .col-md-pull-1 { right: 8.33333333%; } .col-md-pull-0 { right: 0; } .col-md-push-12 { left: 100%; } .col-md-push-11 { left: 91.66666667%; } .col-md-push-10 { left: 83.33333333%; } .col-md-push-9 { left: 75%; } .col-md-push-8 { left: 66.66666667%; } .col-md-push-7 { left: 58.33333333%; } .col-md-push-6 { left: 50%; } .col-md-push-5 { left: 41.66666667%; } .col-md-push-4 { left: 33.33333333%; } .col-md-push-3 { left: 25%; } .col-md-push-2 { left: 16.66666667%; } .col-md-push-1 { left: 8.33333333%; } .col-md-push-0 { left: 0; } .col-md-offset-12 { margin-left: 100%; } .col-md-offset-11 { margin-left: 91.66666667%; } .col-md-offset-10 { margin-left: 83.33333333%; } .col-md-offset-9 { margin-left: 75%; } .col-md-offset-8 { margin-left: 66.66666667%; } .col-md-offset-7 { margin-left: 58.33333333%; } .col-md-offset-6 { margin-left: 50%; } .col-md-offset-5 { margin-left: 41.66666667%; } .col-md-offset-4 { margin-left: 33.33333333%; } .col-md-offset-3 { margin-left: 25%; } .col-md-offset-2 { margin-left: 16.66666667%; } .col-md-offset-1 { margin-left: 8.33333333%; } .col-md-offset-0 { margin-left: 0; } } @media (min-width: 1200px) { .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12 { float: left; } .col-lg-12 { width: 100%; } .col-lg-11 { width: 91.66666667%; } .col-lg-10 { width: 83.33333333%; } .col-lg-9 { width: 75%; } .col-lg-8 { width: 66.66666667%; } .col-lg-7 { width: 58.33333333%; } .col-lg-6 { width: 50%; } .col-lg-5 { width: 41.66666667%; } .col-lg-4 { width: 33.33333333%; } .col-lg-3 { width: 25%; } .col-lg-2 { width: 16.66666667%; } .col-lg-1 { width: 8.33333333%; } .col-lg-pull-12 { right: 100%; } .col-lg-pull-11 { right: 91.66666667%; } .col-lg-pull-10 { right: 83.33333333%; } .col-lg-pull-9 { right: 75%; } .col-lg-pull-8 { right: 66.66666667%; } .col-lg-pull-7 { right: 58.33333333%; } .col-lg-pull-6 { right: 50%; } .col-lg-pull-5 { right: 41.66666667%; } .col-lg-pull-4 { right: 33.33333333%; } .col-lg-pull-3 { right: 25%; } .col-lg-pull-2 { right: 16.66666667%; } .col-lg-pull-1 { right: 8.33333333%; } .col-lg-pull-0 { right: 0; } .col-lg-push-12 { left: 100%; } .col-lg-push-11 { left: 91.66666667%; } .col-lg-push-10 { left: 83.33333333%; } .col-lg-push-9 { left: 75%; } .col-lg-push-8 { left: 66.66666667%; } .col-lg-push-7 { left: 58.33333333%; } .col-lg-push-6 { left: 50%; } .col-lg-push-5 { left: 41.66666667%; } .col-lg-push-4 { left: 33.33333333%; } .col-lg-push-3 { left: 25%; } .col-lg-push-2 { left: 16.66666667%; } .col-lg-push-1 { left: 8.33333333%; } .col-lg-push-0 { left: 0; } .col-lg-offset-12 { margin-left: 100%; } .col-lg-offset-11 { margin-left: 91.66666667%; } .col-lg-offset-10 { margin-left: 83.33333333%; } .col-lg-offset-9 { margin-left: 75%; } .col-lg-offset-8 { margin-left: 66.66666667%; } .col-lg-offset-7 { margin-left: 58.33333333%; } .col-lg-offset-6 { margin-left: 50%; } .col-lg-offset-5 { margin-left: 41.66666667%; } .col-lg-offset-4 { margin-left: 33.33333333%; } .col-lg-offset-3 { margin-left: 25%; } .col-lg-offset-2 { margin-left: 16.66666667%; } .col-lg-offset-1 { margin-left: 8.33333333%; } .col-lg-offset-0 { margin-left: 0; } } table { max-width: 100%; background-color: transparent; } th { text-align: left; } .table { width: 100%; margin-bottom: 20px; } .table > thead > tr > th, .table > tbody > tr > th, .table > tfoot > tr > th, .table > thead > tr > td, .table > tbody > tr > td, .table > tfoot > tr > td { padding: 8px; line-height: 1.42857143; vertical-align: top; border-top: 1px solid #ddd; } .table > thead > tr > th { vertical-align: bottom; border-bottom: 2px solid #ddd; } .table > caption + thead > tr:first-child > th, .table > colgroup + thead > tr:first-child > th, .table > thead:first-child > tr:first-child > th, .table > caption + thead > tr:first-child > td, .table > colgroup + thead > tr:first-child > td, .table > thead:first-child > tr:first-child > td { border-top: 0; } .table > tbody + tbody { border-top: 2px solid #ddd; } .table .table { background-color: #fff; } .table-condensed > thead > tr > th, .table-condensed > tbody > tr > th, .table-condensed > tfoot > tr > th, .table-condensed > thead > tr > td, .table-condensed > tbody > tr > td, .table-condensed > tfoot > tr > td { padding: 5px; } .table-bordered { border: 1px solid #ddd; } .table-bordered > thead > tr > th, .table-bordered > tbody > tr > th, .table-bordered > tfoot > tr > th, .table-bordered > thead > tr > td, .table-bordered > tbody > tr > td, .table-bordered > tfoot > tr > td { border: 1px solid #ddd; } .table-bordered > thead > tr > th, .table-bordered > thead > tr > td { border-bottom-width: 2px; } .table-striped > tbody > tr:nth-child(odd) > td, .table-striped > tbody > tr:nth-child(odd) > th { background-color: #f9f9f9; } .table-hover > tbody > tr:hover > td, .table-hover > tbody > tr:hover > th { background-color: #f5f5f5; } table col[class*=\"col-\"] { position: static; display: table-column; float: none; } table td[class*=\"col-\"], table th[class*=\"col-\"] { position: static; display: table-cell; float: none; } .table > thead > tr > td.active, .table > tbody > tr > td.active, .table > tfoot > tr > td.active, .table > thead > tr > th.active, .table > tbody > tr > th.active, .table > tfoot > tr > th.active, .table > thead > tr.active > td, .table > tbody > tr.active > td, .table > tfoot > tr.active > td, .table > thead > tr.active > th, .table > tbody > tr.active > th, .table > tfoot > tr.active > th { background-color: #f5f5f5; } .table-hover > tbody > tr > td.active:hover, .table-hover > tbody > tr > th.active:hover, .table-hover > tbody > tr.active:hover > td, .table-hover > tbody > tr.active:hover > th { background-color: #e8e8e8; } .table > thead > tr > td.success, .table > tbody > tr > td.success, .table > tfoot > tr > td.success, .table > thead > tr > th.success, .table > tbody > tr > th.success, .table > tfoot > tr > th.success, .table > thead > tr.success > td, .table > tbody > tr.success > td, .table > tfoot > tr.success > td, .table > thead > tr.success > th, .table > tbody > tr.success > th, .table > tfoot > tr.success > th { background-color: #dff0d8; } .table-hover > tbody > tr > td.success:hover, .table-hover > tbody > tr > th.success:hover, .table-hover > tbody > tr.success:hover > td, .table-hover > tbody > tr.success:hover > th { background-color: #d0e9c6; } .table > thead > tr > td.info, .table > tbody > tr > td.info, .table > tfoot > tr > td.info, .table > thead > tr > th.info, .table > tbody > tr > th.info, .table > tfoot > tr > th.info, .table > thead > tr.info > td, .table > tbody > tr.info > td, .table > tfoot > tr.info > td, .table > thead > tr.info > th, .table > tbody > tr.info > th, .table > tfoot > tr.info > th { background-color: #d9edf7; } .table-hover > tbody > tr > td.info:hover, .table-hover > tbody > tr > th.info:hover, .table-hover > tbody > tr.info:hover > td, .table-hover > tbody > tr.info:hover > th { background-color: #c4e3f3; } .table > thead > tr > td.warning, .table > tbody > tr > td.warning, .table > tfoot > tr > td.warning, .table > thead > tr > th.warning, .table > tbody > tr > th.warning, .table > tfoot > tr > th.warning, .table > thead > tr.warning > td, .table > tbody > tr.warning > td, .table > tfoot > tr.warning > td, .table > thead > tr.warning > th, .table > tbody > tr.warning > th, .table > tfoot > tr.warning > th { background-color: #fcf8e3; } .table-hover > tbody > tr > td.warning:hover, .table-hover > tbody > tr > th.warning:hover, .table-hover > tbody > tr.warning:hover > td, .table-hover > tbody > tr.warning:hover > th { background-color: #faf2cc; } .table > thead > tr > td.danger, .table > tbody > tr > td.danger, .table > tfoot > tr > td.danger, .table > thead > tr > th.danger, .table > tbody > tr > th.danger, .table > tfoot > tr > th.danger, .table > thead > tr.danger > td, .table > tbody > tr.danger > td, .table > tfoot > tr.danger > td, .table > thead > tr.danger > th, .table > tbody > tr.danger > th, .table > tfoot > tr.danger > th { background-color: #f2dede; } .table-hover > tbody > tr > td.danger:hover, .table-hover > tbody > tr > th.danger:hover, .table-hover > tbody > tr.danger:hover > td, .table-hover > tbody > tr.danger:hover > th { background-color: #ebcccc; } @media (max-width: 767px) { .table-responsive { width: 100%; margin-bottom: 15px; overflow-x: scroll; overflow-y: hidden; -webkit-overflow-scrolling: touch; -ms-overflow-style: -ms-autohiding-scrollbar; border: 1px solid #ddd; } .table-responsive > .table { margin-bottom: 0; } .table-responsive > .table > thead > tr > th, .table-responsive > .table > tbody > tr > th, .table-responsive > .table > tfoot > tr > th, .table-responsive > .table > thead > tr > td, .table-responsive > .table > tbody > tr > td, .table-responsive > .table > tfoot > tr > td { white-space: nowrap; } .table-responsive > .table-bordered { border: 0; } .table-responsive > .table-bordered > thead > tr > th:first-child, .table-responsive > .table-bordered > tbody > tr > th:first-child, .table-responsive > .table-bordered > tfoot > tr > th:first-child, .table-responsive > .table-bordered > thead > tr > td:first-child, .table-responsive > .table-bordered > tbody > tr > td:first-child, .table-responsive > .table-bordered > tfoot > tr > td:first-child { border-left: 0; } .table-responsive > .table-bordered > thead > tr > th:last-child, .table-responsive > .table-bordered > tbody > tr > th:last-child, .table-responsive > .table-bordered > tfoot > tr > th:last-child, .table-responsive > .table-bordered > thead > tr > td:last-child, .table-responsive > .table-bordered > tbody > tr > td:last-child, .table-responsive > .table-bordered > tfoot > tr > td:last-child { border-right: 0; } .table-responsive > .table-bordered > tbody > tr:last-child > th, .table-responsive > .table-bordered > tfoot > tr:last-child > th, .table-responsive > .table-bordered > tbody > tr:last-child > td, .table-responsive > .table-bordered > tfoot > tr:last-child > td { border-bottom: 0; } } fieldset { min-width: 0; padding: 0; margin: 0; border: 0; } legend { display: block; width: 100%; padding: 0; margin-bottom: 20px; font-size: 21px; line-height: inherit; color: #333; border: 0; border-bottom: 1px solid #e5e5e5; } label { display: inline-block; margin-bottom: 5px; font-weight: bold; } input[type=\"search\"] { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } input[type=\"radio\"], input[type=\"checkbox\"] { margin: 4px 0 0; margin-top: 1px \\9; /* IE8-9 */ line-height: normal; } input[type=\"file\"] { display: block; } input[type=\"range\"] { display: block; width: 100%; } select[multiple], select[size] { height: auto; } input[type=\"file\"]:focus, input[type=\"radio\"]:focus, input[type=\"checkbox\"]:focus { outline: thin dotted; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } output { display: block; padding-top: 7px; font-size: 14px; line-height: 1.42857143; color: #555; } .form-control { display: block; width: 100%; height: 34px; padding: 6px 12px; font-size: 14px; line-height: 1.42857143; color: #555; background-color: #fff; background-image: none; border: 1px solid #ccc; border-radius: 4px; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); -webkit-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s; transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s; } .form-control:focus { border-color: #66afe9; outline: 0; -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6); box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6); } .form-control::-moz-placeholder { color: #999; opacity: 1; } .form-control:-ms-input-placeholder { color: #999; } .form-control::-webkit-input-placeholder { color: #999; } .form-control[disabled], .form-control[readonly], fieldset[disabled] .form-control { cursor: not-allowed; background-color: none; opacity: 1; } textarea.form-control { height: auto; } input[type=\"search\"] { -webkit-appearance: none; } input[type=\"date\"] { line-height: 34px; } .form-group { margin-bottom: 15px; } .radio, .checkbox { display: block; min-height: 20px; padding-left: 20px; margin-top: 10px; margin-bottom: 10px; } .radio label, .checkbox label { display: inline; font-weight: normal; cursor: pointer; } .radio input[type=\"radio\"], .radio-inline input[type=\"radio\"], .checkbox input[type=\"checkbox\"], .checkbox-inline input[type=\"checkbox\"] { float: left; margin-left: -20px; } .radio + .radio, .checkbox + .checkbox { margin-top: -5px; } .radio-inline, .checkbox-inline { display: inline-block; padding-left: 20px; margin-bottom: 0; font-weight: normal; vertical-align: middle; cursor: pointer; } .radio-inline + .radio-inline, .checkbox-inline + .checkbox-inline { margin-top: 0; margin-left: 10px; } input[type=\"radio\"][disabled], input[type=\"checkbox\"][disabled], .radio[disabled], .radio-inline[disabled], .checkbox[disabled], .checkbox-inline[disabled], fieldset[disabled] input[type=\"radio\"], fieldset[disabled] input[type=\"checkbox\"], fieldset[disabled] .radio, fieldset[disabled] .radio-inline, fieldset[disabled] .checkbox, fieldset[disabled] .checkbox-inline { cursor: not-allowed; } .input-sm { height: 30px; padding: 5px 10px; font-size: 12px; line-height: 1.5; border-radius: 3px; } select.input-sm { height: 30px; line-height: 30px; } textarea.input-sm, select[multiple].input-sm { height: auto; } .input-lg { height: 46px; padding: 10px 16px; font-size: 18px; line-height: 1.33; border-radius: 6px; } select.input-lg { height: 46px; line-height: 46px; } textarea.input-lg, select[multiple].input-lg { height: auto; } .has-feedback { position: relative; } .has-feedback .form-control { padding-right: 42.5px; } .has-feedback .form-control-feedback { position: absolute; top: 25px; right: 0; display: block; width: 34px; height: 34px; line-height: 34px; text-align: center; } .has-success .help-block, .has-success .control-label, .has-success .radio, .has-success .checkbox, .has-success .radio-inline, .has-success .checkbox-inline { color: #3c763d; } .has-success .form-control { border-color: #3c763d; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); } .has-success .form-control:focus { border-color: #2b542c; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #67b168; box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #67b168; } .has-success .input-group-addon { color: #3c763d; background-color: #dff0d8; border-color: #3c763d; } .has-success .form-control-feedback { color: #3c763d; } .has-warning .help-block, .has-warning .control-label, .has-warning .radio, .has-warning .checkbox, .has-warning .radio-inline, .has-warning .checkbox-inline { color: #8a6d3b; } .has-warning .form-control { border-color: #8a6d3b; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); } .has-warning .form-control:focus { border-color: #66512c; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #c0a16b; box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #c0a16b; } .has-warning .input-group-addon { color: #8a6d3b; background-color: #fcf8e3; border-color: #8a6d3b; } .has-warning .form-control-feedback { color: #8a6d3b; } .has-error .help-block, .has-error .control-label, .has-error .radio, .has-error .checkbox, .has-error .radio-inline, .has-error .checkbox-inline { color: #a94442; } .has-error .form-control { border-color: #a94442; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); } .has-error .form-control:focus { border-color: #843534; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #ce8483; box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #ce8483; } .has-error .input-group-addon { color: #a94442; background-color: #f2dede; border-color: #a94442; } .has-error .form-control-feedback { color: #a94442; } .form-control-static { margin-bottom: 0; } .help-block { display: block; margin-top: 5px; margin-bottom: 10px; color: #737373; } @media (min-width: 768px) { .form-inline .form-group { display: inline-block; margin-bottom: 0; vertical-align: middle; } .form-inline .form-control { display: inline-block; width: auto; vertical-align: middle; } .form-inline .input-group > .form-control { width: 100%; } .form-inline .control-label { margin-bottom: 0; vertical-align: middle; } .form-inline .radio, .form-inline .checkbox { display: inline-block; padding-left: 0; margin-top: 0; margin-bottom: 0; vertical-align: middle; } .form-inline .radio input[type=\"radio\"], .form-inline .checkbox input[type=\"checkbox\"] { float: none; margin-left: 0; } .form-inline .has-feedback .form-control-feedback { top: 0; } } .form-horizontal .control-label, .form-horizontal .radio, .form-horizontal .checkbox, .form-horizontal .radio-inline, .form-horizontal .checkbox-inline { padding-top: 7px; margin-top: 0; margin-bottom: 0; } .form-horizontal .radio, .form-horizontal .checkbox { min-height: 27px; } .form-horizontal .form-group { margin-right: -15px; margin-left: -15px; } .form-horizontal .form-control-static { padding-top: 7px; } @media (min-width: 768px) { .form-horizontal .control-label { text-align: right; } } .form-horizontal .has-feedback .form-control-feedback { top: 0; right: 15px; } .btn { display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: normal; line-height: 1.42857143; text-align: center; white-space: nowrap; vertical-align: middle; cursor: pointer; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; background-image: none; border: 1px solid transparent; border-radius: 4px; } .btn:focus, .btn:active:focus, .btn.active:focus { outline: thin dotted; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } .btn:hover, .btn:focus { color: #333; text-decoration: none; } .btn:active, .btn.active { background-image: none; outline: 0; -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); } .btn.disabled, .btn[disabled], fieldset[disabled] .btn { pointer-events: none; cursor: not-allowed; filter: alpha(opacity=65); -webkit-box-shadow: none; box-shadow: none; opacity: .65; } .btn-default { color: #333; background-color: #fff; border-color: #ccc; } .btn-default:hover, .btn-default:focus, .btn-default:active, .btn-default.active, .open .dropdown-toggle.btn-default { color: #333; background-color: #ebebeb; border-color: #adadad; } .btn-default:active, .btn-default.active, .open .dropdown-toggle.btn-default { background-image: none; } .btn-default.disabled, .btn-default[disabled], fieldset[disabled] .btn-default, .btn-default.disabled:hover, .btn-default[disabled]:hover, fieldset[disabled] .btn-default:hover, .btn-default.disabled:focus, .btn-default[disabled]:focus, fieldset[disabled] .btn-default:focus, .btn-default.disabled:active, .btn-default[disabled]:active, fieldset[disabled] .btn-default:active, .btn-default.disabled.active, .btn-default[disabled].active, fieldset[disabled] .btn-default.active { background-color: #fff; border-color: #ccc; } .btn-default .badge { color: #fff; background-color: #333; } .btn-primary { color: #fff; background-color: #1B242F; border-color: #357ebd; } .btn-primary:hover, .btn-primary:focus, .btn-primary:active, .btn-primary.active, .open .dropdown-toggle.btn-primary { color: #fff; background-color: #3276b1; border-color: #285e8e; } .btn-primary:active, .btn-primary.active, .open .dropdown-toggle.btn-primary { background-image: none; } .btn-primary.disabled, .btn-primary[disabled], fieldset[disabled] .btn-primary, .btn-primary.disabled:hover, .btn-primary[disabled]:hover, fieldset[disabled] .btn-primary:hover, .btn-primary.disabled:focus, .btn-primary[disabled]:focus, fieldset[disabled] .btn-primary:focus, .btn-primary.disabled:active, .btn-primary[disabled]:active, fieldset[disabled] .btn-primary:active, .btn-primary.disabled.active, .btn-primary[disabled].active, fieldset[disabled] .btn-primary.active { background-color: #1B242F; border-color: #357ebd; } .btn-primary .badge { color: #1B242F; background-color: #fff; } .btn-success { color: #fff; background-color: #5cb85c; border-color: #4cae4c; } .btn-success:hover, .btn-success:focus, .btn-success:active, .btn-success.active, .open .dropdown-toggle.btn-success { color: #fff; background-color: #47a447; border-color: #398439; } .btn-success:active, .btn-success.active, .open .dropdown-toggle.btn-success { background-image: none; } .btn-success.disabled, .btn-success[disabled], fieldset[disabled] .btn-success, .btn-success.disabled:hover, .btn-success[disabled]:hover, fieldset[disabled] .btn-success:hover, .btn-success.disabled:focus, .btn-success[disabled]:focus, fieldset[disabled] .btn-success:focus, .btn-success.disabled:active, .btn-success[disabled]:active, fieldset[disabled] .btn-success:active, .btn-success.disabled.active, .btn-success[disabled].active, fieldset[disabled] .btn-success.active { background-color: #5cb85c; border-color: #4cae4c; } .btn-success .badge { color: #5cb85c; background-color: #fff; } .btn-info { color: #fff; background-color: #5bc0de; border-color: #46b8da; } .btn-info:hover, .btn-info:focus, .btn-info:active, .btn-info.active, .open .dropdown-toggle.btn-info { color: #fff; background-color: #39b3d7; border-color: #269abc; } .btn-info:active, .btn-info.active, .open .dropdown-toggle.btn-info { background-image: none; } .btn-info.disabled, .btn-info[disabled], fieldset[disabled] .btn-info, .btn-info.disabled:hover, .btn-info[disabled]:hover, fieldset[disabled] .btn-info:hover, .btn-info.disabled:focus, .btn-info[disabled]:focus, fieldset[disabled] .btn-info:focus, .btn-info.disabled:active, .btn-info[disabled]:active, fieldset[disabled] .btn-info:active, .btn-info.disabled.active, .btn-info[disabled].active, fieldset[disabled] .btn-info.active { background-color: #5bc0de; border-color: #46b8da; } .btn-info .badge { color: #5bc0de; background-color: #fff; } .btn-warning { color: #fff; background-color: #f0ad4e; border-color: #eea236; } .btn-warning:hover, .btn-warning:focus, .btn-warning:active, .btn-warning.active, .open .dropdown-toggle.btn-warning { color: #fff; background-color: #ed9c28; border-color: #d58512; } .btn-warning:active, .btn-warning.active, .open .dropdown-toggle.btn-warning { background-image: none; } .btn-warning.disabled, .btn-warning[disabled], fieldset[disabled] .btn-warning, .btn-warning.disabled:hover, .btn-warning[disabled]:hover, fieldset[disabled] .btn-warning:hover, .btn-warning.disabled:focus, .btn-warning[disabled]:focus, fieldset[disabled] .btn-warning:focus, .btn-warning.disabled:active, .btn-warning[disabled]:active, fieldset[disabled] .btn-warning:active, .btn-warning.disabled.active, .btn-warning[disabled].active, fieldset[disabled] .btn-warning.active { background-color: #f0ad4e; border-color: #eea236; } .btn-warning .badge { color: #f0ad4e; background-color: #fff; } .btn-danger { color: #fff; background-color: #d9534f; border-color: #d43f3a; } .btn-danger:hover, .btn-danger:focus, .btn-danger:active, .btn-danger.active, .open .dropdown-toggle.btn-danger { color: #fff; background-color: #d2322d; border-color: #ac2925; } .btn-danger:active, .btn-danger.active, .open .dropdown-toggle.btn-danger { background-image: none; } .btn-danger.disabled, .btn-danger[disabled], fieldset[disabled] .btn-danger, .btn-danger.disabled:hover, .btn-danger[disabled]:hover, fieldset[disabled] .btn-danger:hover, .btn-danger.disabled:focus, .btn-danger[disabled]:focus, fieldset[disabled] .btn-danger:focus, .btn-danger.disabled:active, .btn-danger[disabled]:active, fieldset[disabled] .btn-danger:active, .btn-danger.disabled.active, .btn-danger[disabled].active, fieldset[disabled] .btn-danger.active { background-color: #d9534f; border-color: #d43f3a; } .btn-danger .badge { color: #d9534f; background-color: #fff; } .btn-link { font-weight: normal; color: #1B242F; cursor: pointer; border-radius: 0; } .btn-link, .btn-link:active, .btn-link[disabled], fieldset[disabled] .btn-link { background-color: transparent; -webkit-box-shadow: none; box-shadow: none; } .btn-link, .btn-link:hover, .btn-link:focus, .btn-link:active { border-color: transparent; } .btn-link:hover, .btn-link:focus { color: #E74C3C; text-decoration: underline; background-color: transparent; } .btn-link[disabled]:hover, fieldset[disabled] .btn-link:hover, .btn-link[disabled]:focus, fieldset[disabled] .btn-link:focus { color: #999; text-decoration: none; } .btn-lg, .btn-group-lg > .btn { padding: 10px 16px; font-size: 18px; line-height: 1.33; border-radius: 6px; } .btn-sm, .btn-group-sm > .btn { padding: 5px 10px; font-size: 12px; line-height: 1.5; border-radius: 3px; } .btn-xs, .btn-group-xs > .btn { padding: 1px 5px; font-size: 12px; line-height: 1.5; border-radius: 3px; } .btn-block { display: block; width: 100%; padding-right: 0; padding-left: 0; } .btn-block + .btn-block { margin-top: 5px; } input[type=\"submit\"].btn-block, input[type=\"reset\"].btn-block, input[type=\"button\"].btn-block { width: 100%; } .fade { opacity: 0; -webkit-transition: opacity .15s linear; transition: opacity .15s linear; } .fade.in { opacity: 1; } .collapse { display: none; } .collapse.in { display: block; } .collapsing { position: relative; height: 0; overflow: hidden; -webkit-transition: height .35s ease; transition: height .35s ease; } @font-face { font-family: 'Glyphicons Halflings'; src: url('../fonts/glyphicons-halflings-regular.eot'); src: url('../fonts/glyphicons-halflings-regular.eot?#iefix') format('embedded-opentype'), url('../fonts/glyphicons-halflings-regular.woff') format('woff'), url('../fonts/glyphicons-halflings-regular.ttf') format('truetype'), url('../fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular') format('svg'); } .glyphicon { position: relative; top: 1px; display: inline-block; font-family: 'Glyphicons Halflings'; font-style: normal; font-weight: normal; line-height: 1; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .glyphicon-asterisk:before { content: \"\\2a\"; } .glyphicon-plus:before { content: \"\\2b\"; } .glyphicon-euro:before { content: \"\\20ac\"; } .glyphicon-minus:before { content: \"\\2212\"; } .glyphicon-cloud:before { content: \"\\2601\"; } .glyphicon-envelope:before { content: \"\\2709\"; } .glyphicon-pencil:before { content: \"\\270f\"; } .glyphicon-glass:before { content: \"\\e001\"; } .glyphicon-music:before { content: \"\\e002\"; } .glyphicon-search:before { content: \"\\e003\"; } .glyphicon-heart:before { content: \"\\e005\"; } .glyphicon-star:before { content: \"\\e006\"; } .glyphicon-star-empty:before { content: \"\\e007\"; } .glyphicon-user:before { content: \"\\e008\"; } .glyphicon-film:before { content: \"\\e009\"; } .glyphicon-th-large:before { content: \"\\e010\"; } .glyphicon-th:before { content: \"\\e011\"; } .glyphicon-th-list:before { content: \"\\e012\"; } .glyphicon-ok:before { content: \"\\e013\"; } .glyphicon-remove:before { content: \"\\e014\"; } .glyphicon-zoom-in:before { content: \"\\e015\"; } .glyphicon-zoom-out:before { content: \"\\e016\"; } .glyphicon-off:before { content: \"\\e017\"; } .glyphicon-signal:before { content: \"\\e018\"; } .glyphicon-cog:before { content: \"\\e019\"; } .glyphicon-trash:before { content: \"\\e020\"; } .glyphicon-home:before { content: \"\\e021\"; } .glyphicon-file:before { content: \"\\e022\"; } .glyphicon-time:before { content: \"\\e023\"; } .glyphicon-road:before { content: \"\\e024\"; } .glyphicon-download-alt:before { content: \"\\e025\"; } .glyphicon-download:before { content: \"\\e026\"; } .glyphicon-upload:before { content: \"\\e027\"; } .glyphicon-inbox:before { content: \"\\e028\"; } .glyphicon-play-circle:before { content: \"\\e029\"; } .glyphicon-repeat:before { content: \"\\e030\"; } .glyphicon-refresh:before { content: \"\\e031\"; } .glyphicon-list-alt:before { content: \"\\e032\"; } .glyphicon-lock:before { content: \"\\e033\"; } .glyphicon-flag:before { content: \"\\e034\"; } .glyphicon-headphones:before { content: \"\\e035\"; } .glyphicon-volume-off:before { content: \"\\e036\"; } .glyphicon-volume-down:before { content: \"\\e037\"; } .glyphicon-volume-up:before { content: \"\\e038\"; } .glyphicon-qrcode:before { content: \"\\e039\"; } .glyphicon-barcode:before { content: \"\\e040\"; } .glyphicon-tag:before { content: \"\\e041\"; } .glyphicon-tags:before { content: \"\\e042\"; } .glyphicon-book:before { content: \"\\e043\"; } .glyphicon-bookmark:before { content: \"\\e044\"; } .glyphicon-print:before { content: \"\\e045\"; } .glyphicon-camera:before { content: \"\\e046\"; } .glyphicon-font:before { content: \"\\e047\"; } .glyphicon-bold:before { content: \"\\e048\"; } .glyphicon-italic:before { content: \"\\e049\"; } .glyphicon-text-height:before { content: \"\\e050\"; } .glyphicon-text-width:before { content: \"\\e051\"; } .glyphicon-align-left:before { content: \"\\e052\"; } .glyphicon-align-center:before { content: \"\\e053\"; } .glyphicon-align-right:before { content: \"\\e054\"; } .glyphicon-align-justify:before { content: \"\\e055\"; } .glyphicon-list:before { content: \"\\e056\"; } .glyphicon-indent-left:before { content: \"\\e057\"; } .glyphicon-indent-right:before { content: \"\\e058\"; } .glyphicon-facetime-video:before { content: \"\\e059\"; } .glyphicon-picture:before { content: \"\\e060\"; } .glyphicon-map-marker:before { content: \"\\e062\"; } .glyphicon-adjust:before { content: \"\\e063\"; } .glyphicon-tint:before { content: \"\\e064\"; } .glyphicon-edit:before { content: \"\\e065\"; } .glyphicon-share:before { content: \"\\e066\"; } .glyphicon-check:before { content: \"\\e067\"; } .glyphicon-move:before { content: \"\\e068\"; } .glyphicon-step-backward:before { content: \"\\e069\"; } .glyphicon-fast-backward:before { content: \"\\e070\"; } .glyphicon-backward:before { content: \"\\e071\"; } .glyphicon-play:before { content: \"\\e072\"; } .glyphicon-pause:before { content: \"\\e073\"; } .glyphicon-stop:before { content: \"\\e074\"; } .glyphicon-forward:before { content: \"\\e075\"; } .glyphicon-fast-forward:before { content: \"\\e076\"; } .glyphicon-step-forward:before { content: \"\\e077\"; } .glyphicon-eject:before { content: \"\\e078\"; } .glyphicon-chevron-left:before { content: \"\\e079\"; } .glyphicon-chevron-right:before { content: \"\\e080\"; } .glyphicon-plus-sign:before { content: \"\\e081\"; } .glyphicon-minus-sign:before { content: \"\\e082\"; } .glyphicon-remove-sign:before { content: \"\\e083\"; } .glyphicon-ok-sign:before { content: \"\\e084\"; } .glyphicon-question-sign:before { content: \"\\e085\"; } .glyphicon-info-sign:before { content: \"\\e086\"; } .glyphicon-screenshot:before { content: \"\\e087\"; } .glyphicon-remove-circle:before { content: \"\\e088\"; } .glyphicon-ok-circle:before { content: \"\\e089\"; } .glyphicon-ban-circle:before { content: \"\\e090\"; } .glyphicon-arrow-left:before { content: \"\\e091\"; } .glyphicon-arrow-right:before { content: \"\\e092\"; } .glyphicon-arrow-up:before { content: \"\\e093\"; } .glyphicon-arrow-down:before { content: \"\\e094\"; } .glyphicon-share-alt:before { content: \"\\e095\"; } .glyphicon-resize-full:before { content: \"\\e096\"; } .glyphicon-resize-small:before { content: \"\\e097\"; } .glyphicon-exclamation-sign:before { content: \"\\e101\"; } .glyphicon-gift:before { content: \"\\e102\"; } .glyphicon-leaf:before { content: \"\\e103\"; } .glyphicon-fire:before { content: \"\\e104\"; } .glyphicon-eye-open:before { content: \"\\e105\"; } .glyphicon-eye-close:before { content: \"\\e106\"; } .glyphicon-warning-sign:before { content: \"\\e107\"; } .glyphicon-plane:before { content: \"\\e108\"; } .glyphicon-calendar:before { content: \"\\e109\"; } .glyphicon-random:before { content: \"\\e110\"; } .glyphicon-comment:before { content: \"\\e111\"; } .glyphicon-magnet:before { content: \"\\e112\"; } .glyphicon-chevron-up:before { content: \"\\e113\"; } .glyphicon-chevron-down:before { content: \"\\e114\"; } .glyphicon-retweet:before { content: \"\\e115\"; } .glyphicon-shopping-cart:before { content: \"\\e116\"; } .glyphicon-folder-close:before { content: \"\\e117\"; } .glyphicon-folder-open:before { content: \"\\e118\"; } .glyphicon-resize-vertical:before { content: \"\\e119\"; } .glyphicon-resize-horizontal:before { content: \"\\e120\"; } .glyphicon-hdd:before { content: \"\\e121\"; } .glyphicon-bullhorn:before { content: \"\\e122\"; } .glyphicon-bell:before { content: \"\\e123\"; } .glyphicon-certificate:before { content: \"\\e124\"; } .glyphicon-thumbs-up:before { content: \"\\e125\"; } .glyphicon-thumbs-down:before { content: \"\\e126\"; } .glyphicon-hand-right:before { content: \"\\e127\"; } .glyphicon-hand-left:before { content: \"\\e128\"; } .glyphicon-hand-up:before { content: \"\\e129\"; } .glyphicon-hand-down:before { content: \"\\e130\"; } .glyphicon-circle-arrow-right:before { content: \"\\e131\"; } .glyphicon-circle-arrow-left:before { content: \"\\e132\"; } .glyphicon-circle-arrow-up:before { content: \"\\e133\"; } .glyphicon-circle-arrow-down:before { content: \"\\e134\"; } .glyphicon-globe:before { content: \"\\e135\"; } .glyphicon-wrench:before { content: \"\\e136\"; } .glyphicon-tasks:before { content: \"\\e137\"; } .glyphicon-filter:before { content: \"\\e138\"; } .glyphicon-briefcase:before { content: \"\\e139\"; } .glyphicon-fullscreen:before { content: \"\\e140\"; } .glyphicon-dashboard:before { content: \"\\e141\"; } .glyphicon-paperclip:before { content: \"\\e142\"; } .glyphicon-heart-empty:before { content: \"\\e143\"; } .glyphicon-link:before { content: \"\\e144\"; } .glyphicon-phone:before { content: \"\\e145\"; } .glyphicon-pushpin:before { content: \"\\e146\"; } .glyphicon-usd:before { content: \"\\e148\"; } .glyphicon-gbp:before { content: \"\\e149\"; } .glyphicon-sort:before { content: \"\\e150\"; } .glyphicon-sort-by-alphabet:before { content: \"\\e151\"; } .glyphicon-sort-by-alphabet-alt:before { content: \"\\e152\"; } .glyphicon-sort-by-order:before { content: \"\\e153\"; } .glyphicon-sort-by-order-alt:before { content: \"\\e154\"; } .glyphicon-sort-by-attributes:before { content: \"\\e155\"; } .glyphicon-sort-by-attributes-alt:before { content: \"\\e156\"; } .glyphicon-unchecked:before { content: \"\\e157\"; } .glyphicon-expand:before { content: \"\\e158\"; } .glyphicon-collapse-down:before { content: \"\\e159\"; } .glyphicon-collapse-up:before { content: \"\\e160\"; } .glyphicon-log-in:before { content: \"\\e161\"; } .glyphicon-flash:before { content: \"\\e162\"; } .glyphicon-log-out:before { content: \"\\e163\"; } .glyphicon-new-window:before { content: \"\\e164\"; } .glyphicon-record:before { content: \"\\e165\"; } .glyphicon-save:before { content: \"\\e166\"; } .glyphicon-open:before { content: \"\\e167\"; } .glyphicon-saved:before { content: \"\\e168\"; } .glyphicon-import:before { content: \"\\e169\"; } .glyphicon-export:before { content: \"\\e170\"; } .glyphicon-send:before { content: \"\\e171\"; } .glyphicon-floppy-disk:before { content: \"\\e172\"; } .glyphicon-floppy-saved:before { content: \"\\e173\"; } .glyphicon-floppy-remove:before { content: \"\\e174\"; } .glyphicon-floppy-save:before { content: \"\\e175\"; } .glyphicon-floppy-open:before { content: \"\\e176\"; } .glyphicon-credit-card:before { content: \"\\e177\"; } .glyphicon-transfer:before { content: \"\\e178\"; } .glyphicon-cutlery:before { content: \"\\e179\"; } .glyphicon-header:before { content: \"\\e180\"; } .glyphicon-compressed:before { content: \"\\e181\"; } .glyphicon-earphone:before { content: \"\\e182\"; } .glyphicon-phone-alt:before { content: \"\\e183\"; } .glyphicon-tower:before { content: \"\\e184\"; } .glyphicon-stats:before { content: \"\\e185\"; } .glyphicon-sd-video:before { content: \"\\e186\"; } .glyphicon-hd-video:before { content: \"\\e187\"; } .glyphicon-subtitles:before { content: \"\\e188\"; } .glyphicon-sound-stereo:before { content: \"\\e189\"; } .glyphicon-sound-dolby:before { content: \"\\e190\"; } .glyphicon-sound-5-1:before { content: \"\\e191\"; } .glyphicon-sound-6-1:before { content: \"\\e192\"; } .glyphicon-sound-7-1:before { content: \"\\e193\"; } .glyphicon-copyright-mark:before { content: \"\\e194\"; } .glyphicon-registration-mark:before { content: \"\\e195\"; } .glyphicon-cloud-download:before { content: \"\\e197\"; } .glyphicon-cloud-upload:before { content: \"\\e198\"; } .glyphicon-tree-conifer:before { content: \"\\e199\"; } .glyphicon-tree-deciduous:before { content: \"\\e200\"; } .caret { display: inline-block; width: 0; height: 0; margin-left: 2px; vertical-align: middle; border-top: 4px solid; border-right: 4px solid transparent; border-left: 4px solid transparent; } .dropdown { position: relative; } .dropdown-toggle:focus { outline: 0; } .dropdown-menu { position: absolute; top: 100%; left: 0; z-index: 1000; display: none; float: left; min-width: 160px; padding: 5px 0; margin: 2px 0 0; font-size: 14px; list-style: none; background-color: #fff; background-clip: padding-box; border: 1px solid #ccc; border: 1px solid rgba(0, 0, 0, .15); border-radius: 4px; -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, .175); box-shadow: 0 6px 12px rgba(0, 0, 0, .175); } .dropdown-menu.pull-right { right: 0; left: auto; } .dropdown-menu .divider { height: 1px; margin: 9px 0; overflow: hidden; background-color: #e5e5e5; } .dropdown-menu > li > a { display: block; padding: 3px 20px; clear: both; font-weight: normal; line-height: 1.42857143; color: #333; white-space: nowrap; } .dropdown-menu > li > a:hover, .dropdown-menu > li > a:focus { color: #262626; text-decoration: none; background-color: #f5f5f5; } .dropdown-menu > .active > a, .dropdown-menu > .active > a:hover, .dropdown-menu > .active > a:focus { color: #fff; text-decoration: none; background-color: #1B242F; outline: 0; } .dropdown-menu > .disabled > a, .dropdown-menu > .disabled > a:hover, .dropdown-menu > .disabled > a:focus { color: #999; } .dropdown-menu > .disabled > a:hover, .dropdown-menu > .disabled > a:focus { text-decoration: none; cursor: not-allowed; background-color: transparent; background-image: none; filter: progid:DXImageTransform.Microsoft.gradient(enabled = false); } .open > .dropdown-menu { display: block; } .open > a { outline: 0; } .dropdown-menu-right { right: 0; left: auto; } .dropdown-menu-left { right: auto; left: 0; } .dropdown-header { display: block; padding: 3px 20px; font-size: 12px; line-height: 1.42857143; color: #999; } .dropdown-backdrop { position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 990; } .pull-right > .dropdown-menu { right: 0; left: auto; } .dropup .caret, .navbar-fixed-bottom .dropdown .caret { content: \"\"; border-top: 0; border-bottom: 4px solid; } .dropup .dropdown-menu, .navbar-fixed-bottom .dropdown .dropdown-menu { top: auto; bottom: 100%; margin-bottom: 1px; } @media (min-width: 768px) { .navbar-right .dropdown-menu { right: 0; left: auto; } .navbar-right .dropdown-menu-left { right: auto; left: 0; } } .btn-group, .btn-group-vertical { position: relative; display: inline-block; vertical-align: middle; } .btn-group > .btn, .btn-group-vertical > .btn { position: relative; float: left; } .btn-group > .btn:hover, .btn-group-vertical > .btn:hover, .btn-group > .btn:focus, .btn-group-vertical > .btn:focus, .btn-group > .btn:active, .btn-group-vertical > .btn:active, .btn-group > .btn.active, .btn-group-vertical > .btn.active { z-index: 2; } .btn-group > .btn:focus, .btn-group-vertical > .btn:focus { outline: none; } .btn-group .btn + .btn, .btn-group .btn + .btn-group, .btn-group .btn-group + .btn, .btn-group .btn-group + .btn-group { margin-left: -1px; } .btn-toolbar { margin-left: -5px; } .btn-toolbar .btn-group, .btn-toolbar .input-group { float: left; } .btn-toolbar > .btn, .btn-toolbar > .btn-group, .btn-toolbar > .input-group { margin-left: 5px; } .btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) { border-radius: 0; } .btn-group > .btn:first-child { margin-left: 0; } .btn-group > .btn:first-child:not(:last-child):not(.dropdown-toggle) { border-top-right-radius: 0; border-bottom-right-radius: 0; } .btn-group > .btn:last-child:not(:first-child), .btn-group > .dropdown-toggle:not(:first-child) { border-top-left-radius: 0; border-bottom-left-radius: 0; } .btn-group > .btn-group { float: left; } .btn-group > .btn-group:not(:first-child):not(:last-child) > .btn { border-radius: 0; } .btn-group > .btn-group:first-child > .btn:last-child, .btn-group > .btn-group:first-child > .dropdown-toggle { border-top-right-radius: 0; border-bottom-right-radius: 0; } .btn-group > .btn-group:last-child > .btn:first-child { border-top-left-radius: 0; border-bottom-left-radius: 0; } .btn-group .dropdown-toggle:active, .btn-group.open .dropdown-toggle { outline: 0; } .btn-group > .btn + .dropdown-toggle { padding-right: 8px; padding-left: 8px; } .btn-group > .btn-lg + .dropdown-toggle { padding-right: 12px; padding-left: 12px; } .btn-group.open .dropdown-toggle { -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); } .btn-group.open .dropdown-toggle.btn-link { -webkit-box-shadow: none; box-shadow: none; } .btn .caret { margin-left: 0; } .btn-lg .caret { border-width: 5px 5px 0; border-bottom-width: 0; } .dropup .btn-lg .caret { border-width: 0 5px 5px; } .btn-group-vertical > .btn, .btn-group-vertical > .btn-group, .btn-group-vertical > .btn-group > .btn { display: block; float: none; width: 100%; max-width: 100%; } .btn-group-vertical > .btn-group > .btn { float: none; } .btn-group-vertical > .btn + .btn, .btn-group-vertical > .btn + .btn-group, .btn-group-vertical > .btn-group + .btn, .btn-group-vertical > .btn-group + .btn-group { margin-top: -1px; margin-left: 0; } .btn-group-vertical > .btn:not(:first-child):not(:last-child) { border-radius: 0; } .btn-group-vertical > .btn:first-child:not(:last-child) { border-top-right-radius: 4px; border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .btn-group-vertical > .btn:last-child:not(:first-child) { border-top-left-radius: 0; border-top-right-radius: 0; border-bottom-left-radius: 4px; } .btn-group-vertical > .btn-group:not(:first-child):not(:last-child) > .btn { border-radius: 0; } .btn-group-vertical > .btn-group:first-child:not(:last-child) > .btn:last-child, .btn-group-vertical > .btn-group:first-child:not(:last-child) > .dropdown-toggle { border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .btn-group-vertical > .btn-group:last-child:not(:first-child) > .btn:first-child { border-top-left-radius: 0; border-top-right-radius: 0; } .btn-group-justified { display: table; width: 100%; table-layout: fixed; border-collapse: separate; } .btn-group-justified > .btn, .btn-group-justified > .btn-group { display: table-cell; float: none; width: 1%; } .btn-group-justified > .btn-group .btn { width: 100%; } [data-toggle=\"buttons\"] > .btn > input[type=\"radio\"], [data-toggle=\"buttons\"] > .btn > input[type=\"checkbox\"] { display: none; } .input-group { position: relative; display: table; border-collapse: separate; } .input-group[class*=\"col-\"] { float: none; padding-right: 0; padding-left: 0; } .input-group .form-control { position: relative; z-index: 2; float: left; width: 100%; margin-bottom: 0; } .input-group-lg > .form-control, .input-group-lg > .input-group-addon, .input-group-lg > .input-group-btn > .btn { height: 46px; padding: 10px 16px; font-size: 18px; line-height: 1.33; border-radius: 6px; } select.input-group-lg > .form-control, select.input-group-lg > .input-group-addon, select.input-group-lg > .input-group-btn > .btn { height: 46px; line-height: 46px; } textarea.input-group-lg > .form-control, textarea.input-group-lg > .input-group-addon, textarea.input-group-lg > .input-group-btn > .btn, select[multiple].input-group-lg > .form-control, select[multiple].input-group-lg > .input-group-addon, select[multiple].input-group-lg > .input-group-btn > .btn { height: auto; } .input-group-sm > .form-control, .input-group-sm > .input-group-addon, .input-group-sm > .input-group-btn > .btn { height: 30px; padding: 5px 10px; font-size: 12px; line-height: 1.5; border-radius: 3px; } select.input-group-sm > .form-control, select.input-group-sm > .input-group-addon, select.input-group-sm > .input-group-btn > .btn { height: 30px; line-height: 30px; } textarea.input-group-sm > .form-control, textarea.input-group-sm > .input-group-addon, textarea.input-group-sm > .input-group-btn > .btn, select[multiple].input-group-sm > .form-control, select[multiple].input-group-sm > .input-group-addon, select[multiple].input-group-sm > .input-group-btn > .btn { height: auto; } .input-group-addon, .input-group-btn, .input-group .form-control { display: table-cell; } .input-group-addon:not(:first-child):not(:last-child), .input-group-btn:not(:first-child):not(:last-child), .input-group .form-control:not(:first-child):not(:last-child) { border-radius: 0; } .input-group-addon, .input-group-btn { width: 1%; white-space: nowrap; vertical-align: middle; } .input-group-addon { padding: 6px 12px; font-size: 14px; font-weight: normal; line-height: 1; color: #555; text-align: center; background-color: none; border: 1px solid #ccc; border-radius: 4px; } .input-group-addon.input-sm { padding: 5px 10px; font-size: 12px; border-radius: 3px; } .input-group-addon.input-lg { padding: 10px 16px; font-size: 18px; border-radius: 6px; } .input-group-addon input[type=\"radio\"], .input-group-addon input[type=\"checkbox\"] { margin-top: 0; } .input-group .form-control:first-child, .input-group-addon:first-child, .input-group-btn:first-child > .btn, .input-group-btn:first-child > .btn-group > .btn, .input-group-btn:first-child > .dropdown-toggle, .input-group-btn:last-child > .btn:not(:last-child):not(.dropdown-toggle), .input-group-btn:last-child > .btn-group:not(:last-child) > .btn { border-top-right-radius: 0; border-bottom-right-radius: 0; } .input-group-addon:first-child { border-right: 0; } .input-group .form-control:last-child, .input-group-addon:last-child, .input-group-btn:last-child > .btn, .input-group-btn:last-child > .btn-group > .btn, .input-group-btn:last-child > .dropdown-toggle, .input-group-btn:first-child > .btn:not(:first-child), .input-group-btn:first-child > .btn-group:not(:first-child) > .btn { border-top-left-radius: 0; border-bottom-left-radius: 0; } .input-group-addon:last-child { border-left: 0; } .input-group-btn { position: relative; font-size: 0; white-space: nowrap; } .input-group-btn > .btn { position: relative; } .input-group-btn > .btn + .btn { margin-left: -1px; } .input-group-btn > .btn:hover, .input-group-btn > .btn:focus, .input-group-btn > .btn:active { z-index: 2; } .input-group-btn:first-child > .btn, .input-group-btn:first-child > .btn-group { margin-right: -1px; } .input-group-btn:last-child > .btn, .input-group-btn:last-child > .btn-group { margin-left: -1px; } .nav { padding-left: 0; margin-bottom: 0; list-style: none; } .nav > li { position: relative; display: block; } .nav > li > a { position: relative; display: block; padding: 10px 15px; } .nav > li > a:hover, .nav > li > a:focus { text-decoration: none; background-color: none; } .nav > li.disabled > a { color: #999; } .nav > li.disabled > a:hover, .nav > li.disabled > a:focus { color: #999; text-decoration: none; cursor: not-allowed; background-color: transparent; } .nav .open > a, .nav .open > a:hover, .nav .open > a:focus { background-color: none; border-color: #1B242F; } .nav .nav-divider { height: 1px; margin: 9px 0; overflow: hidden; background-color: #e5e5e5; } .nav > li > a > img { max-width: none; } .nav-tabs { border-bottom: 1px solid #ddd; } .nav-tabs > li { float: left; margin-bottom: -1px; } .nav-tabs > li > a { margin-right: 2px; line-height: 1.42857143; border: 1px solid transparent; border-radius: 4px 4px 0 0; } .nav-tabs > li > a:hover { border-color: none none #ddd; } .nav-tabs > li.active > a, .nav-tabs > li.active > a:hover, .nav-tabs > li.active > a:focus { color: #555; cursor: default; background-color: #fff; border: 1px solid #ddd; border-bottom-color: transparent; } .nav-tabs.nav-justified { width: 100%; border-bottom: 0; } .nav-tabs.nav-justified > li { float: none; } .nav-tabs.nav-justified > li > a { margin-bottom: 5px; text-align: center; } .nav-tabs.nav-justified > .dropdown .dropdown-menu { top: auto; left: auto; } @media (min-width: 768px) { .nav-tabs.nav-justified > li { display: table-cell; width: 1%; } .nav-tabs.nav-justified > li > a { margin-bottom: 0; } } .nav-tabs.nav-justified > li > a { margin-right: 0; border-radius: 4px; } .nav-tabs.nav-justified > .active > a, .nav-tabs.nav-justified > .active > a:hover, .nav-tabs.nav-justified > .active > a:focus { border: 1px solid #ddd; } @media (min-width: 768px) { .nav-tabs.nav-justified > li > a { border-bottom: 1px solid #ddd; border-radius: 4px 4px 0 0; } .nav-tabs.nav-justified > .active > a, .nav-tabs.nav-justified > .active > a:hover, .nav-tabs.nav-justified > .active > a:focus { border-bottom-color: #fff; } } .nav-pills > li { float: left; } .nav-pills > li > a { border-radius: 4px; } .nav-pills > li + li { margin-left: 2px; } .nav-pills > li.active > a, .nav-pills > li.active > a:hover, .nav-pills > li.active > a:focus { color: #fff; background-color: #1B242F; } .nav-stacked > li { float: none; } .nav-stacked > li + li { margin-top: 2px; margin-left: 0; } .nav-justified { width: 100%; } .nav-justified > li { float: none; } .nav-justified > li > a { margin-bottom: 5px; text-align: center; } .nav-justified > .dropdown .dropdown-menu { top: auto; left: auto; } @media (min-width: 768px) { .nav-justified > li { display: table-cell; width: 1%; } .nav-justified > li > a { margin-bottom: 0; } } .nav-tabs-justified { border-bottom: 0; } .nav-tabs-justified > li > a { margin-right: 0; border-radius: 4px; } .nav-tabs-justified > .active > a, .nav-tabs-justified > .active > a:hover, .nav-tabs-justified > .active > a:focus { border: 1px solid #ddd; } @media (min-width: 768px) { .nav-tabs-justified > li > a { border-bottom: 1px solid #ddd; border-radius: 4px 4px 0 0; } .nav-tabs-justified > .active > a, .nav-tabs-justified > .active > a:hover, .nav-tabs-justified > .active > a:focus { border-bottom-color: #fff; } } .tab-content > .tab-pane { display: none; } .tab-content > .active { display: block; } .nav-tabs .dropdown-menu { margin-top: -1px; border-top-left-radius: 0; border-top-right-radius: 0; } .navbar { position: relative; min-height: 50px; margin-bottom: 20px; border: 1px solid transparent; } @media (min-width: 768px) { .navbar { border-radius: 4px; } } @media (min-width: 768px) { .navbar-header { float: left; } } .navbar-collapse { max-height: 340px; padding-right: 15px; padding-left: 15px; overflow-x: visible; -webkit-overflow-scrolling: touch; border-top: 1px solid transparent; box-shadow: inset 0 1px 0 rgba(255, 255, 255, .1); } .navbar-collapse.in { overflow-y: auto; } @media (min-width: 768px) { .navbar-collapse { width: auto; border-top: 0; box-shadow: none; } .navbar-collapse.collapse { display: block !important; height: auto !important; padding-bottom: 0; overflow: visible !important; } .navbar-collapse.in { overflow-y: visible; } .navbar-fixed-top .navbar-collapse, .navbar-static-top .navbar-collapse, .navbar-fixed-bottom .navbar-collapse { padding-right: 0; padding-left: 0; } } .container > .navbar-header, .container-fluid > .navbar-header, .container > .navbar-collapse, .container-fluid > .navbar-collapse { margin-right: -15px; margin-left: -15px; } @media (min-width: 768px) { .container > .navbar-header, .container-fluid > .navbar-header, .container > .navbar-collapse, .container-fluid > .navbar-collapse { margin-right: 0; margin-left: 0; } } .navbar-static-top { z-index: 1000; border-width: 0 0 1px; } @media (min-width: 768px) { .navbar-static-top { border-radius: 0; } } .navbar-fixed-top, .navbar-fixed-bottom { position: fixed; right: 0; left: 0; z-index: 1030; } @media (min-width: 768px) { .navbar-fixed-top, .navbar-fixed-bottom { border-radius: 0; } } .navbar-fixed-top { top: 0; border-width: 0 0 1px; } .navbar-fixed-bottom { bottom: 0; margin-bottom: 0; border-width: 1px 0 0; } .navbar-brand { float: left; height: 50px; padding: 15px 15px; font-size: 18px; line-height: 20px; } .navbar-brand:hover, .navbar-brand:focus { text-decoration: none; } @media (min-width: 768px) { .navbar > .container .navbar-brand, .navbar > .container-fluid .navbar-brand { margin-left: -15px; } } .navbar-toggle { position: relative; float: right; padding: 9px 10px; margin-top: 8px; margin-right: 15px; margin-bottom: 8px; background-color: transparent; background-image: none; border: 1px solid transparent; border-radius: 4px; } .navbar-toggle:focus { outline: none; } .navbar-toggle .icon-bar { display: block; width: 22px; height: 2px; border-radius: 1px; } .navbar-toggle .icon-bar + .icon-bar { margin-top: 4px; } @media (min-width: 768px) { .navbar-toggle { display: none; } } .navbar-nav { margin: 7.5px -15px; } .navbar-nav > li > a { padding-top: 10px; padding-bottom: 10px; line-height: 20px; } @media (max-width: 767px) { .navbar-nav .open .dropdown-menu { position: static; float: none; width: auto; margin-top: 0; background-color: transparent; border: 0; box-shadow: none; } .navbar-nav .open .dropdown-menu > li > a, .navbar-nav .open .dropdown-menu .dropdown-header { padding: 5px 15px 5px 25px; } .navbar-nav .open .dropdown-menu > li > a { line-height: 20px; } .navbar-nav .open .dropdown-menu > li > a:hover, .navbar-nav .open .dropdown-menu > li > a:focus { background-image: none; } } @media (min-width: 768px) { .navbar-nav { float: left; margin: 0; } .navbar-nav > li { float: left; } .navbar-nav > li > a { padding-top: 15px; padding-bottom: 15px; } .navbar-nav.navbar-right:last-child { margin-right: -15px; } } @media (min-width: 768px) { .navbar-left { float: left !important; } .navbar-right { float: right !important; } } .navbar-form { padding: 10px 15px; margin-top: 8px; margin-right: -15px; margin-bottom: 8px; margin-left: -15px; border-top: 1px solid transparent; border-bottom: 1px solid transparent; -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, .1), 0 1px 0 rgba(255, 255, 255, .1); box-shadow: inset 0 1px 0 rgba(255, 255, 255, .1), 0 1px 0 rgba(255, 255, 255, .1); } @media (min-width: 768px) { .navbar-form .form-group { display: inline-block; margin-bottom: 0; vertical-align: middle; } .navbar-form .form-control { display: inline-block; width: auto; vertical-align: middle; } .navbar-form .input-group > .form-control { width: 100%; } .navbar-form .control-label { margin-bottom: 0; vertical-align: middle; } .navbar-form .radio, .navbar-form .checkbox { display: inline-block; padding-left: 0; margin-top: 0; margin-bottom: 0; vertical-align: middle; } .navbar-form .radio input[type=\"radio\"], .navbar-form .checkbox input[type=\"checkbox\"] { float: none; margin-left: 0; } .navbar-form .has-feedback .form-control-feedback { top: 0; } } @media (max-width: 767px) { .navbar-form .form-group { margin-bottom: 5px; } } @media (min-width: 768px) { .navbar-form { width: auto; padding-top: 0; padding-bottom: 0; margin-right: 0; margin-left: 0; border: 0; -webkit-box-shadow: none; box-shadow: none; } .navbar-form.navbar-right:last-child { margin-right: -15px; } } .navbar-nav > li > .dropdown-menu { margin-top: 0; border-top-left-radius: 0; border-top-right-radius: 0; } .navbar-fixed-bottom .navbar-nav > li > .dropdown-menu { border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .navbar-btn { margin-top: 8px; margin-bottom: 8px; } .navbar-btn.btn-sm { margin-top: 10px; margin-bottom: 10px; } .navbar-btn.btn-xs { margin-top: 14px; margin-bottom: 14px; } .navbar-text { margin-top: 15px; margin-bottom: 15px; } @media (min-width: 768px) { .navbar-text { float: left; margin-right: 15px; margin-left: 15px; } .navbar-text.navbar-right:last-child { margin-right: 0; } } .navbar-default { background-color: #f8f8f8; border-color: #e7e7e7; } .navbar-default .navbar-brand { color: #777; } .navbar-default .navbar-brand:hover, .navbar-default .navbar-brand:focus { color: #5e5e5e; background-color: transparent; } .navbar-default .navbar-text { color: #777; } .navbar-default .navbar-nav > li > a { color: #777; } .navbar-default .navbar-nav > li > a:hover, .navbar-default .navbar-nav > li > a:focus { color: #333; background-color: transparent; } .navbar-default .navbar-nav > .active > a, .navbar-default .navbar-nav > .active > a:hover, .navbar-default .navbar-nav > .active > a:focus { color: #555; background-color: #e7e7e7; } .navbar-default .navbar-nav > .disabled > a, .navbar-default .navbar-nav > .disabled > a:hover, .navbar-default .navbar-nav > .disabled > a:focus { color: #ccc; background-color: transparent; } .navbar-default .navbar-toggle { border-color: #ddd; } .navbar-default .navbar-toggle:hover, .navbar-default .navbar-toggle:focus { background-color: #ddd; } .navbar-default .navbar-toggle .icon-bar { background-color: #888; } .navbar-default .navbar-collapse, .navbar-default .navbar-form { border-color: #e7e7e7; } .navbar-default .navbar-nav > .open > a, .navbar-default .navbar-nav > .open > a:hover, .navbar-default .navbar-nav > .open > a:focus { color: #555; background-color: #e7e7e7; } @media (max-width: 767px) { .navbar-default .navbar-nav .open .dropdown-menu > li > a { color: #777; } .navbar-default .navbar-nav .open .dropdown-menu > li > a:hover, .navbar-default .navbar-nav .open .dropdown-menu > li > a:focus { color: #333; background-color: transparent; } .navbar-default .navbar-nav .open .dropdown-menu > .active > a, .navbar-default .navbar-nav .open .dropdown-menu > .active > a:hover, .navbar-default .navbar-nav .open .dropdown-menu > .active > a:focus { color: #555; background-color: #e7e7e7; } .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a, .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:hover, .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:focus { color: #ccc; background-color: transparent; } } .navbar-default .navbar-link { color: #777; } .navbar-default .navbar-link:hover { color: #333; } .navbar-inverse { background-color: #222; border-color: #080808; } .navbar-inverse .navbar-brand { color: #999; } .navbar-inverse .navbar-brand:hover, .navbar-inverse .navbar-brand:focus { color: #fff; background-color: transparent; } .navbar-inverse .navbar-text { color: #999; } .navbar-inverse .navbar-nav > li > a { color: #999; } .navbar-inverse .navbar-nav > li > a:hover, .navbar-inverse .navbar-nav > li > a:focus { color: #fff; background-color: transparent; } .navbar-inverse .navbar-nav > .active > a, .navbar-inverse .navbar-nav > .active > a:hover, .navbar-inverse .navbar-nav > .active > a:focus { color: #fff; background-color: #080808; } .navbar-inverse .navbar-nav > .disabled > a, .navbar-inverse .navbar-nav > .disabled > a:hover, .navbar-inverse .navbar-nav > .disabled > a:focus { color: #444; background-color: transparent; } .navbar-inverse .navbar-toggle { border-color: #333; } .navbar-inverse .navbar-toggle:hover, .navbar-inverse .navbar-toggle:focus { background-color: #333; } .navbar-inverse .navbar-toggle .icon-bar { background-color: #fff; } .navbar-inverse .navbar-collapse, .navbar-inverse .navbar-form { border-color: #101010; } .navbar-inverse .navbar-nav > .open > a, .navbar-inverse .navbar-nav > .open > a:hover, .navbar-inverse .navbar-nav > .open > a:focus { color: #fff; background-color: #080808; } @media (max-width: 767px) { .navbar-inverse .navbar-nav .open .dropdown-menu > .dropdown-header { border-color: #080808; } .navbar-inverse .navbar-nav .open .dropdown-menu .divider { background-color: #080808; } .navbar-inverse .navbar-nav .open .dropdown-menu > li > a { color: #999; } .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:hover, .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:focus { color: #fff; background-color: transparent; } .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a, .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:hover, .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:focus { color: #fff; background-color: #080808; } .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a, .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:hover, .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:focus { color: #444; background-color: transparent; } } .navbar-inverse .navbar-link { color: #999; } .navbar-inverse .navbar-link:hover { color: #fff; } .breadcrumb { padding: 8px 15px; margin-bottom: 20px; list-style: none; background-color: #f5f5f5; border-radius: 4px; } .breadcrumb > li { display: inline-block; } .breadcrumb > li + li:before { padding: 0 5px; color: #ccc; content: \"/\\00a0\"; } .breadcrumb > .active { color: #999; } .pagination { display: inline-block; padding-left: 0; margin: 20px 0; border-radius: 4px; } .pagination > li { display: inline; } .pagination > li > a, .pagination > li > span { position: relative; float: left; padding: 6px 12px; margin-left: -1px; line-height: 1.42857143; color: #1B242F; text-decoration: none; background-color: #fff; border: 1px solid #ddd; } .pagination > li:first-child > a, .pagination > li:first-child > span { margin-left: 0; border-top-left-radius: 4px; border-bottom-left-radius: 4px; } .pagination > li:last-child > a, .pagination > li:last-child > span { border-top-right-radius: 4px; border-bottom-right-radius: 4px; } .pagination > li > a:hover, .pagination > li > span:hover, .pagination > li > a:focus, .pagination > li > span:focus { color: #E74C3C; background-color: none; border-color: #ddd; } .pagination > .active > a, .pagination > .active > span, .pagination > .active > a:hover, .pagination > .active > span:hover, .pagination > .active > a:focus, .pagination > .active > span:focus { z-index: 2; color: #fff; cursor: default; background-color: #1B242F; border-color: #1B242F; } .pagination > .disabled > span, .pagination > .disabled > span:hover, .pagination > .disabled > span:focus, .pagination > .disabled > a, .pagination > .disabled > a:hover, .pagination > .disabled > a:focus { color: #999; cursor: not-allowed; background-color: #fff; border-color: #ddd; } .pagination-lg > li > a, .pagination-lg > li > span { padding: 10px 16px; font-size: 18px; } .pagination-lg > li:first-child > a, .pagination-lg > li:first-child > span { border-top-left-radius: 6px; border-bottom-left-radius: 6px; } .pagination-lg > li:last-child > a, .pagination-lg > li:last-child > span { border-top-right-radius: 6px; border-bottom-right-radius: 6px; } .pagination-sm > li > a, .pagination-sm > li > span { padding: 5px 10px; font-size: 12px; } .pagination-sm > li:first-child > a, .pagination-sm > li:first-child > span { border-top-left-radius: 3px; border-bottom-left-radius: 3px; } .pagination-sm > li:last-child > a, .pagination-sm > li:last-child > span { border-top-right-radius: 3px; border-bottom-right-radius: 3px; } .pager { padding-left: 0; margin: 20px 0; text-align: center; list-style: none; } .pager li { display: inline; } .pager li > a, .pager li > span { display: inline-block; padding: 5px 14px; background-color: #fff; border: 1px solid #ddd; border-radius: 15px; } .pager li > a:hover, .pager li > a:focus { text-decoration: none; background-color: none; } .pager .next > a, .pager .next > span { float: right; } .pager .previous > a, .pager .previous > span { float: left; } .pager .disabled > a, .pager .disabled > a:hover, .pager .disabled > a:focus, .pager .disabled > span { color: #999; cursor: not-allowed; background-color: #fff; } .label { display: inline; padding: .2em .6em .3em; font-size: 75%; font-weight: bold; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: .25em; } .label[href]:hover, .label[href]:focus { color: #fff; text-decoration: none; cursor: pointer; } .label:empty { display: none; } .btn .label { position: relative; top: -1px; } .label-default { background-color: #999; } .label-default[href]:hover, .label-default[href]:focus { background-color: #808080; } .label-primary { background-color: #1B242F; } .label-primary[href]:hover, .label-primary[href]:focus { background-color: #3071a9; } .label-success { background-color: #5cb85c; } .label-success[href]:hover, .label-success[href]:focus { background-color: #449d44; } .label-info { background-color: #5bc0de; } .label-info[href]:hover, .label-info[href]:focus { background-color: #31b0d5; } .label-warning { background-color: #f0ad4e; } .label-warning[href]:hover, .label-warning[href]:focus { background-color: #ec971f; } .label-danger { background-color: #d9534f; } .label-danger[href]:hover, .label-danger[href]:focus { background-color: #c9302c; } .badge { display: inline-block; min-width: 10px; padding: 3px 7px; font-size: 12px; font-weight: bold; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; background-color: #999; border-radius: 10px; } .badge:empty { display: none; } .btn .badge { position: relative; top: -1px; } .btn-xs .badge { top: 0; padding: 1px 5px; } a.badge:hover, a.badge:focus { color: #fff; text-decoration: none; cursor: pointer; } a.list-group-item.active > .badge, .nav-pills > .active > a > .badge { color: #1B242F; background-color: #fff; } .nav-pills > li > a > .badge { margin-left: 3px; } .jumbotron { padding: 30px; margin-bottom: 30px; color: inherit; background-color: none; } .jumbotron h1, .jumbotron .h1 { color: inherit; } .jumbotron p { margin-bottom: 15px; font-size: 21px; font-weight: 200; } .container .jumbotron { border-radius: 6px; } .jumbotron .container { max-width: 100%; } @media screen and (min-width: 768px) { .jumbotron { padding-top: 48px; padding-bottom: 48px; } .container .jumbotron { padding-right: 60px; padding-left: 60px; } .jumbotron h1, .jumbotron .h1 { font-size: 63px; } } .thumbnail { display: block; padding: 4px; margin-bottom: 20px; line-height: 1.42857143; background-color: #fff; border: 1px solid #ddd; border-radius: 4px; -webkit-transition: all .2s ease-in-out; transition: all .2s ease-in-out; } .thumbnail > img, .thumbnail a > img { margin-right: auto; margin-left: auto; } a.thumbnail:hover, a.thumbnail:focus, a.thumbnail.active { border-color: #1B242F; } .thumbnail .caption { padding: 9px; color: #333; } .alert { padding: 15px; margin-bottom: 20px; border: 1px solid transparent; border-radius: 4px; } .alert h4 { margin-top: 0; color: inherit; } .alert .alert-link { font-weight: bold; } .alert > p, .alert > ul { margin-bottom: 0; } .alert > p + p { margin-top: 5px; } .alert-dismissable { padding-right: 35px; } .alert-dismissable .close { position: relative; top: -2px; right: -21px; color: inherit; } .alert-success { color: #3c763d; background-color: #dff0d8; border-color: #d6e9c6; } .alert-success hr { border-top-color: #c9e2b3; } .alert-success .alert-link { color: #2b542c; } .alert-info { color: #31708f; background-color: #d9edf7; border-color: #bce8f1; } .alert-info hr { border-top-color: #a6e1ec; } .alert-info .alert-link { color: #245269; } .alert-warning { color: #8a6d3b; background-color: #fcf8e3; border-color: #faebcc; } .alert-warning hr { border-top-color: #f7e1b5; } .alert-warning .alert-link { color: #66512c; } .alert-danger { color: #a94442; background-color: #f2dede; border-color: #ebccd1; } .alert-danger hr { border-top-color: #e4b9c0; } .alert-danger .alert-link { color: #843534; } @-webkit-keyframes progress-bar-stripes { from { background-position: 40px 0; } to { background-position: 0 0; } } @keyframes progress-bar-stripes { from { background-position: 40px 0; } to { background-position: 0 0; } } .progress { height: 20px; margin-bottom: 20px; overflow: hidden; background-color: #f5f5f5; border-radius: 4px; -webkit-box-shadow: inset 0 1px 2px rgba(0, 0, 0, .1); box-shadow: inset 0 1px 2px rgba(0, 0, 0, .1); } .progress-bar { float: left; width: 0; height: 100%; font-size: 12px; line-height: 20px; color: #fff; text-align: center; background-color: #1B242F; -webkit-box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .15); box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .15); -webkit-transition: width .6s ease; transition: width .6s ease; } .progress-striped .progress-bar { background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-size: 40px 40px; } .progress.active .progress-bar { -webkit-animation: progress-bar-stripes 2s linear infinite; animation: progress-bar-stripes 2s linear infinite; } .progress-bar-success { background-color: #5cb85c; } .progress-striped .progress-bar-success { background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); } .progress-bar-info { background-color: #5bc0de; } .progress-striped .progress-bar-info { background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); } .progress-bar-warning { background-color: #f0ad4e; } .progress-striped .progress-bar-warning { background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); } .progress-bar-danger { background-color: #d9534f; } .progress-striped .progress-bar-danger { background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); } .media, .media-body { overflow: hidden; zoom: 1; } .media, .media .media { margin-top: 15px; } .media:first-child { margin-top: 0; } .media-object { display: block; } .media-heading { margin: 0 0 5px; } .media > .pull-left { margin-right: 10px; } .media > .pull-right { margin-left: 10px; } .media-list { padding-left: 0; list-style: none; } .list-group { padding-left: 0; margin-bottom: 20px; } .list-group-item { position: relative; display: block; padding: 10px 15px; margin-bottom: -1px; background-color: #fff; border: 1px solid #ddd; } .list-group-item:first-child { border-top-left-radius: 4px; border-top-right-radius: 4px; } .list-group-item:last-child { margin-bottom: 0; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; } .list-group-item > .badge { float: right; } .list-group-item > .badge + .badge { margin-right: 5px; } a.list-group-item { color: #555; } a.list-group-item .list-group-item-heading { color: #333; } a.list-group-item:hover, a.list-group-item:focus { text-decoration: none; background-color: #f5f5f5; } a.list-group-item.active, a.list-group-item.active:hover, a.list-group-item.active:focus { z-index: 2; color: #fff; background-color: #1B242F; border-color: #1B242F; } a.list-group-item.active .list-group-item-heading, a.list-group-item.active:hover .list-group-item-heading, a.list-group-item.active:focus .list-group-item-heading { color: inherit; } a.list-group-item.active .list-group-item-text, a.list-group-item.active:hover .list-group-item-text, a.list-group-item.active:focus .list-group-item-text { color: #e1edf7; } .list-group-item-success { color: #3c763d; background-color: #dff0d8; } a.list-group-item-success { color: #3c763d; } a.list-group-item-success .list-group-item-heading { color: inherit; } a.list-group-item-success:hover, a.list-group-item-success:focus { color: #3c763d; background-color: #d0e9c6; } a.list-group-item-success.active, a.list-group-item-success.active:hover, a.list-group-item-success.active:focus { color: #fff; background-color: #3c763d; border-color: #3c763d; } .list-group-item-info { color: #31708f; background-color: #d9edf7; } a.list-group-item-info { color: #31708f; } a.list-group-item-info .list-group-item-heading { color: inherit; } a.list-group-item-info:hover, a.list-group-item-info:focus { color: #31708f; background-color: #c4e3f3; } a.list-group-item-info.active, a.list-group-item-info.active:hover, a.list-group-item-info.active:focus { color: #fff; background-color: #31708f; border-color: #31708f; } .list-group-item-warning { color: #8a6d3b; background-color: #fcf8e3; } a.list-group-item-warning { color: #8a6d3b; } a.list-group-item-warning .list-group-item-heading { color: inherit; } a.list-group-item-warning:hover, a.list-group-item-warning:focus { color: #8a6d3b; background-color: #faf2cc; } a.list-group-item-warning.active, a.list-group-item-warning.active:hover, a.list-group-item-warning.active:focus { color: #fff; background-color: #8a6d3b; border-color: #8a6d3b; } .list-group-item-danger { color: #a94442; background-color: #f2dede; } a.list-group-item-danger { color: #a94442; } a.list-group-item-danger .list-group-item-heading { color: inherit; } a.list-group-item-danger:hover, a.list-group-item-danger:focus { color: #a94442; background-color: #ebcccc; } a.list-group-item-danger.active, a.list-group-item-danger.active:hover, a.list-group-item-danger.active:focus { color: #fff; background-color: #a94442; border-color: #a94442; } .list-group-item-heading { margin-top: 0; margin-bottom: 5px; } .list-group-item-text { margin-bottom: 0; line-height: 1.3; } .panel { margin-bottom: 20px; background-color: #fff; border: 1px solid transparent; border-radius: 4px; -webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, .05); box-shadow: 0 1px 1px rgba(0, 0, 0, .05); } .panel-body { padding: 15px; } .panel-heading { padding: 10px 15px; border-bottom: 1px solid transparent; border-top-left-radius: 3px; border-top-right-radius: 3px; } .panel-heading > .dropdown .dropdown-toggle { color: inherit; } .panel-title { margin-top: 0; margin-bottom: 0; font-size: 16px; color: inherit; } .panel-title > a { color: inherit; } .panel-footer { padding: 10px 15px; background-color: #f5f5f5; border-top: 1px solid #ddd; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; } .panel > .list-group { margin-bottom: 0; } .panel > .list-group .list-group-item { border-width: 1px 0; border-radius: 0; } .panel > .list-group:first-child .list-group-item:first-child { border-top: 0; border-top-left-radius: 3px; border-top-right-radius: 3px; } .panel > .list-group:last-child .list-group-item:last-child { border-bottom: 0; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; } .panel-heading + .list-group .list-group-item:first-child { border-top-width: 0; } .panel > .table, .panel > .table-responsive > .table { margin-bottom: 0; } .panel > .table:first-child, .panel > .table-responsive:first-child > .table:first-child { border-top-left-radius: 3px; border-top-right-radius: 3px; } .panel > .table:first-child > thead:first-child > tr:first-child td:first-child, .panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child td:first-child, .panel > .table:first-child > tbody:first-child > tr:first-child td:first-child, .panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child td:first-child, .panel > .table:first-child > thead:first-child > tr:first-child th:first-child, .panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child th:first-child, .panel > .table:first-child > tbody:first-child > tr:first-child th:first-child, .panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child th:first-child { border-top-left-radius: 3px; } .panel > .table:first-child > thead:first-child > tr:first-child td:last-child, .panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child td:last-child, .panel > .table:first-child > tbody:first-child > tr:first-child td:last-child, .panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child td:last-child, .panel > .table:first-child > thead:first-child > tr:first-child th:last-child, .panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child th:last-child, .panel > .table:first-child > tbody:first-child > tr:first-child th:last-child, .panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child th:last-child { border-top-right-radius: 3px; } .panel > .table:last-child, .panel > .table-responsive:last-child > .table:last-child { border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; } .panel > .table:last-child > tbody:last-child > tr:last-child td:first-child, .panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child td:first-child, .panel > .table:last-child > tfoot:last-child > tr:last-child td:first-child, .panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child td:first-child, .panel > .table:last-child > tbody:last-child > tr:last-child th:first-child, .panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child th:first-child, .panel > .table:last-child > tfoot:last-child > tr:last-child th:first-child, .panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child th:first-child { border-bottom-left-radius: 3px; } .panel > .table:last-child > tbody:last-child > tr:last-child td:last-child, .panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child td:last-child, .panel > .table:last-child > tfoot:last-child > tr:last-child td:last-child, .panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child td:last-child, .panel > .table:last-child > tbody:last-child > tr:last-child th:last-child, .panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child th:last-child, .panel > .table:last-child > tfoot:last-child > tr:last-child th:last-child, .panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child th:last-child { border-bottom-right-radius: 3px; } .panel > .panel-body + .table, .panel > .panel-body + .table-responsive { border-top: 1px solid #ddd; } .panel > .table > tbody:first-child > tr:first-child th, .panel > .table > tbody:first-child > tr:first-child td { border-top: 0; } .panel > .table-bordered, .panel > .table-responsive > .table-bordered { border: 0; } .panel > .table-bordered > thead > tr > th:first-child, .panel > .table-responsive > .table-bordered > thead > tr > th:first-child, .panel > .table-bordered > tbody > tr > th:first-child, .panel > .table-responsive > .table-bordered > tbody > tr > th:first-child, .panel > .table-bordered > tfoot > tr > th:first-child, .panel > .table-responsive > .table-bordered > tfoot > tr > th:first-child, .panel > .table-bordered > thead > tr > td:first-child, .panel > .table-responsive > .table-bordered > thead > tr > td:first-child, .panel > .table-bordered > tbody > tr > td:first-child, .panel > .table-responsive > .table-bordered > tbody > tr > td:first-child, .panel > .table-bordered > tfoot > tr > td:first-child, .panel > .table-responsive > .table-bordered > tfoot > tr > td:first-child { border-left: 0; } .panel > .table-bordered > thead > tr > th:last-child, .panel > .table-responsive > .table-bordered > thead > tr > th:last-child, .panel > .table-bordered > tbody > tr > th:last-child, .panel > .table-responsive > .table-bordered > tbody > tr > th:last-child, .panel > .table-bordered > tfoot > tr > th:last-child, .panel > .table-responsive > .table-bordered > tfoot > tr > th:last-child, .panel > .table-bordered > thead > tr > td:last-child, .panel > .table-responsive > .table-bordered > thead > tr > td:last-child, .panel > .table-bordered > tbody > tr > td:last-child, .panel > .table-responsive > .table-bordered > tbody > tr > td:last-child, .panel > .table-bordered > tfoot > tr > td:last-child, .panel > .table-responsive > .table-bordered > tfoot > tr > td:last-child { border-right: 0; } .panel > .table-bordered > thead > tr:first-child > td, .panel > .table-responsive > .table-bordered > thead > tr:first-child > td, .panel > .table-bordered > tbody > tr:first-child > td, .panel > .table-responsive > .table-bordered > tbody > tr:first-child > td, .panel > .table-bordered > thead > tr:first-child > th, .panel > .table-responsive > .table-bordered > thead > tr:first-child > th, .panel > .table-bordered > tbody > tr:first-child > th, .panel > .table-responsive > .table-bordered > tbody > tr:first-child > th { border-bottom: 0; } .panel > .table-bordered > tbody > tr:last-child > td, .panel > .table-responsive > .table-bordered > tbody > tr:last-child > td, .panel > .table-bordered > tfoot > tr:last-child > td, .panel > .table-responsive > .table-bordered > tfoot > tr:last-child > td, .panel > .table-bordered > tbody > tr:last-child > th, .panel > .table-responsive > .table-bordered > tbody > tr:last-child > th, .panel > .table-bordered > tfoot > tr:last-child > th, .panel > .table-responsive > .table-bordered > tfoot > tr:last-child > th { border-bottom: 0; } .panel > .table-responsive { margin-bottom: 0; border: 0; } .panel-group { margin-bottom: 20px; } .panel-group .panel { margin-bottom: 0; overflow: hidden; border-radius: 4px; } .panel-group .panel + .panel { margin-top: 5px; } .panel-group .panel-heading { border-bottom: 0; } .panel-group .panel-heading + .panel-collapse .panel-body { border-top: 1px solid #ddd; } .panel-group .panel-footer { border-top: 0; } .panel-group .panel-footer + .panel-collapse .panel-body { border-bottom: 1px solid #ddd; } .panel-default { border-color: #ddd; } .panel-default > .panel-heading { color: #333; background-color: #f5f5f5; border-color: #ddd; } .panel-default > .panel-heading + .panel-collapse .panel-body { border-top-color: #ddd; } .panel-default > .panel-footer + .panel-collapse .panel-body { border-bottom-color: #ddd; } .panel-primary { border-color: #1B242F; } .panel-primary > .panel-heading { color: #fff; background-color: #1B242F; border-color: #1B242F; } .panel-primary > .panel-heading + .panel-collapse .panel-body { border-top-color: #1B242F; } .panel-primary > .panel-footer + .panel-collapse .panel-body { border-bottom-color: #1B242F; } .panel-success { border-color: #d6e9c6; } .panel-success > .panel-heading { color: #3c763d; background-color: #dff0d8; border-color: #d6e9c6; } .panel-success > .panel-heading + .panel-collapse .panel-body { border-top-color: #d6e9c6; } .panel-success > .panel-footer + .panel-collapse .panel-body { border-bottom-color: #d6e9c6; } .panel-info { border-color: #bce8f1; } .panel-info > .panel-heading { color: #31708f; background-color: #d9edf7; border-color: #bce8f1; } .panel-info > .panel-heading + .panel-collapse .panel-body { border-top-color: #bce8f1; } .panel-info > .panel-footer + .panel-collapse .panel-body { border-bottom-color: #bce8f1; } .panel-warning { border-color: #faebcc; } .panel-warning > .panel-heading { color: #8a6d3b; background-color: #fcf8e3; border-color: #faebcc; } .panel-warning > .panel-heading + .panel-collapse .panel-body { border-top-color: #faebcc; } .panel-warning > .panel-footer + .panel-collapse .panel-body { border-bottom-color: #faebcc; } .panel-danger { border-color: #ebccd1; } .panel-danger > .panel-heading { color: #a94442; background-color: #f2dede; border-color: #ebccd1; } .panel-danger > .panel-heading + .panel-collapse .panel-body { border-top-color: #ebccd1; } .panel-danger > .panel-footer + .panel-collapse .panel-body { border-bottom-color: #ebccd1; } .well { min-height: 20px; padding: 19px; margin-bottom: 20px; background-color: #f5f5f5; border: 1px solid #e3e3e3; border-radius: 4px; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .05); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .05); } .well blockquote { border-color: #ddd; border-color: rgba(0, 0, 0, .15); } .well-lg { padding: 24px; border-radius: 6px; } .well-sm { padding: 9px; border-radius: 3px; } .close { float: right; font-size: 21px; font-weight: bold; line-height: 1; color: #000; text-shadow: 0 1px 0 #fff; filter: alpha(opacity=20); opacity: .2; } .close:hover, .close:focus { color: #000; text-decoration: none; cursor: pointer; filter: alpha(opacity=50); opacity: .5; } button.close { -webkit-appearance: none; padding: 0; cursor: pointer; background: transparent; border: 0; } .modal-open { overflow: hidden; } .modal { position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1050; display: none; overflow: auto; overflow-y: scroll; -webkit-overflow-scrolling: touch; outline: 0; } .modal.fade .modal-dialog { -webkit-transition: -webkit-transform .3s ease-out; -moz-transition: -moz-transform .3s ease-out; -o-transition: -o-transform .3s ease-out; transition: transform .3s ease-out; -webkit-transform: translate(0, -25%); -ms-transform: translate(0, -25%); transform: translate(0, -25%); } .modal.in .modal-dialog { -webkit-transform: translate(0, 0); -ms-transform: translate(0, 0); transform: translate(0, 0); } .modal-dialog { position: relative; width: auto; margin: 10px; } .modal-content { position: relative; background-color: #fff; background-clip: padding-box; border: 1px solid #999; border: 1px solid rgba(0, 0, 0, .2); border-radius: 6px; outline: none; -webkit-box-shadow: 0 3px 9px rgba(0, 0, 0, .5); box-shadow: 0 3px 9px rgba(0, 0, 0, .5); } .modal-backdrop { position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1040; background-color: #000; } .modal-backdrop.fade { filter: alpha(opacity=0); opacity: 0; } .modal-backdrop.in { filter: alpha(opacity=50); opacity: .5; } .modal-header { min-height: 16.42857143px; padding: 15px; border-bottom: 1px solid #e5e5e5; } .modal-header .close { margin-top: -2px; } .modal-title { margin: 0; line-height: 1.42857143; } .modal-body { position: relative; padding: 20px; } .modal-footer { padding: 19px 20px 20px; margin-top: 15px; text-align: right; border-top: 1px solid #e5e5e5; } .modal-footer .btn + .btn { margin-bottom: 0; margin-left: 5px; } .modal-footer .btn-group .btn + .btn { margin-left: -1px; } .modal-footer .btn-block + .btn-block { margin-left: 0; } @media (min-width: 768px) { .modal-dialog { width: 600px; margin: 30px auto; } .modal-content { -webkit-box-shadow: 0 5px 15px rgba(0, 0, 0, .5); box-shadow: 0 5px 15px rgba(0, 0, 0, .5); } .modal-sm { width: 300px; } } @media (min-width: 992px) { .modal-lg { width: 900px; } } .tooltip { position: absolute; z-index: 1030; display: block; font-size: 12px; line-height: 1.4; visibility: visible; filter: alpha(opacity=0); opacity: 0; } .tooltip.in { filter: alpha(opacity=90); opacity: .9; } .tooltip.top { padding: 5px 0; margin-top: -3px; } .tooltip.right { padding: 0 5px; margin-left: 3px; } .tooltip.bottom { padding: 5px 0; margin-top: 3px; } .tooltip.left { padding: 0 5px; margin-left: -3px; } .tooltip-inner { max-width: 200px; padding: 3px 8px; color: #fff; text-align: center; text-decoration: none; background-color: #000; border-radius: 4px; } .tooltip-arrow { position: absolute; width: 0; height: 0; border-color: transparent; border-style: solid; } .tooltip.top .tooltip-arrow { bottom: 0; left: 50%; margin-left: -5px; border-width: 5px 5px 0; border-top-color: #000; } .tooltip.top-left .tooltip-arrow { bottom: 0; left: 5px; border-width: 5px 5px 0; border-top-color: #000; } .tooltip.top-right .tooltip-arrow { right: 5px; bottom: 0; border-width: 5px 5px 0; border-top-color: #000; } .tooltip.right .tooltip-arrow { top: 50%; left: 0; margin-top: -5px; border-width: 5px 5px 5px 0; border-right-color: #000; } .tooltip.left .tooltip-arrow { top: 50%; right: 0; margin-top: -5px; border-width: 5px 0 5px 5px; border-left-color: #000; } .tooltip.bottom .tooltip-arrow { top: 0; left: 50%; margin-left: -5px; border-width: 0 5px 5px; border-bottom-color: #000; } .tooltip.bottom-left .tooltip-arrow { top: 0; left: 5px; border-width: 0 5px 5px; border-bottom-color: #000; } .tooltip.bottom-right .tooltip-arrow { top: 0; right: 5px; border-width: 0 5px 5px; border-bottom-color: #000; } .popover { position: absolute; top: 0; left: 0; z-index: 1010; display: none; max-width: 276px; padding: 1px; text-align: left; white-space: normal; background-color: #fff; background-clip: padding-box; border: 1px solid #ccc; border: 1px solid rgba(0, 0, 0, .2); border-radius: 6px; -webkit-box-shadow: 0 5px 10px rgba(0, 0, 0, .2); box-shadow: 0 5px 10px rgba(0, 0, 0, .2); } .popover.top { margin-top: -10px; } .popover.right { margin-left: 10px; } .popover.bottom { margin-top: 10px; } .popover.left { margin-left: -10px; } .popover-title { padding: 8px 14px; margin: 0; font-size: 14px; font-weight: normal; line-height: 18px; background-color: #f7f7f7; border-bottom: 1px solid #ebebeb; border-radius: 5px 5px 0 0; } .popover-content { padding: 9px 14px; } .popover > .arrow, .popover > .arrow:after { position: absolute; display: block; width: 0; height: 0; border-color: transparent; border-style: solid; } .popover > .arrow { border-width: 11px; } .popover > .arrow:after { content: \"\"; border-width: 10px; } .popover.top > .arrow { bottom: -11px; left: 50%; margin-left: -11px; border-top-color: #999; border-top-color: rgba(0, 0, 0, .25); border-bottom-width: 0; } .popover.top > .arrow:after { bottom: 1px; margin-left: -10px; content: \" \"; border-top-color: #fff; border-bottom-width: 0; } .popover.right > .arrow { top: 50%; left: -11px; margin-top: -11px; border-right-color: #999; border-right-color: rgba(0, 0, 0, .25); border-left-width: 0; } .popover.right > .arrow:after { bottom: -10px; left: 1px; content: \" \"; border-right-color: #fff; border-left-width: 0; } .popover.bottom > .arrow { top: -11px; left: 50%; margin-left: -11px; border-top-width: 0; border-bottom-color: #999; border-bottom-color: rgba(0, 0, 0, .25); } .popover.bottom > .arrow:after { top: 1px; margin-left: -10px; content: \" \"; border-top-width: 0; border-bottom-color: #fff; } .popover.left > .arrow { top: 50%; right: -11px; margin-top: -11px; border-right-width: 0; border-left-color: #999; border-left-color: rgba(0, 0, 0, .25); } .popover.left > .arrow:after { right: 1px; bottom: -10px; content: \" \"; border-right-width: 0; border-left-color: #fff; } .carousel { position: relative; } .carousel-inner { position: relative; width: 100%; overflow: hidden; } .carousel-inner > .item { position: relative; display: none; -webkit-transition: .6s ease-in-out left; transition: .6s ease-in-out left; } .carousel-inner > .item > img, .carousel-inner > .item > a > img { line-height: 1; } .carousel-inner > .active, .carousel-inner > .next, .carousel-inner > .prev { display: block; } .carousel-inner > .active { left: 0; } .carousel-inner > .next, .carousel-inner > .prev { position: absolute; top: 0; width: 100%; } .carousel-inner > .next { left: 100%; } .carousel-inner > .prev { left: -100%; } .carousel-inner > .next.left, .carousel-inner > .prev.right { left: 0; } .carousel-inner > .active.left { left: -100%; } .carousel-inner > .active.right { left: 100%; } .carousel-control { position: absolute; top: 0; bottom: 0; left: 0; width: 15%; font-size: 20px; color: #fff; text-align: center; text-shadow: 0 1px 2px rgba(0, 0, 0, .6); filter: alpha(opacity=50); opacity: .5; } .carousel-control.left { background-image: -webkit-linear-gradient(left, color-stop(rgba(0, 0, 0, .5) 0%), color-stop(rgba(0, 0, 0, .0001) 100%)); background-image: linear-gradient(to right, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1); background-repeat: repeat-x; } .carousel-control.right { right: 0; left: auto; background-image: -webkit-linear-gradient(left, color-stop(rgba(0, 0, 0, .0001) 0%), color-stop(rgba(0, 0, 0, .5) 100%)); background-image: linear-gradient(to right, rgba(0, 0, 0, .0001) 0%, rgba(0, 0, 0, .5) 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1); background-repeat: repeat-x; } .carousel-control:hover, .carousel-control:focus { color: #fff; text-decoration: none; filter: alpha(opacity=90); outline: none; opacity: .9; } .carousel-control .icon-prev, .carousel-control .icon-next, .carousel-control .glyphicon-chevron-left, .carousel-control .glyphicon-chevron-right { position: absolute; top: 50%; z-index: 5; display: inline-block; } .carousel-control .icon-prev, .carousel-control .glyphicon-chevron-left { left: 50%; } .carousel-control .icon-next, .carousel-control .glyphicon-chevron-right { right: 50%; } .carousel-control .icon-prev, .carousel-control .icon-next { width: 20px; height: 20px; margin-top: -10px; margin-left: -10px; font-family: serif; } .carousel-control .icon-prev:before { content: '\\2039'; } .carousel-control .icon-next:before { content: '\\203a'; } .carousel-indicators { position: absolute; bottom: 10px; left: 50%; z-index: 15; width: 60%; padding-left: 0; margin-left: -30%; text-align: center; list-style: none; } .carousel-indicators li { display: inline-block; width: 10px; height: 10px; margin: 1px; text-indent: -999px; cursor: pointer; background-color: #000 \\9; background-color: rgba(0, 0, 0, 0); border: 1px solid #fff; border-radius: 10px; } .carousel-indicators .active { width: 12px; height: 12px; margin: 0; background-color: url(../images/pagenate.png) no-repeat 0px 0px; } .carousel-caption { position: absolute; right: 15%; bottom: 20px; left: 15%; z-index: 10; padding-top: 20px; padding-bottom: 20px; color: #fff; text-align: center; text-shadow: 0 1px 2px rgba(0, 0, 0, .6); } .carousel-caption .btn { text-shadow: none; } @media screen and (min-width: 768px) { .carousel-control .glyphicon-chevron-left, .carousel-control .glyphicon-chevron-right, .carousel-control .icon-prev, .carousel-control .icon-next { width: 30px; height: 30px; margin-top: -15px; margin-left: -15px; font-size: 30px; } .carousel-caption { right: 20%; left: 20%; padding-bottom: 30px; } .carousel-indicators { bottom: 20px; } } .clearfix:before, .clearfix:after, .container:before, .container:after, .container-fluid:before, .container-fluid:after, .row:before, .row:after, .form-horizontal .form-group:before, .form-horizontal .form-group:after, .btn-toolbar:before, .btn-toolbar:after, .btn-group-vertical > .btn-group:before, .btn-group-vertical > .btn-group:after, .nav:before, .nav:after, .navbar:before, .navbar:after, .navbar-header:before, .navbar-header:after, .navbar-collapse:before, .navbar-collapse:after, .pager:before, .pager:after, .panel-body:before, .panel-body:after, .modal-footer:before, .modal-footer:after { display: table; content: \" \"; } .clearfix:after, .container:after, .container-fluid:after, .row:after, .form-horizontal .form-group:after, .btn-toolbar:after, .btn-group-vertical > .btn-group:after, .nav:after, .navbar:after, .navbar-header:after, .navbar-collapse:after, .pager:after, .panel-body:after, .modal-footer:after { clear: both; } .center-block { display: block; margin-right: auto; margin-left: auto; } .pull-right { float: right !important; } .pull-left { float: left !important; } .hide { display: none !important; } .show { display: block !important; } .invisible { visibility: hidden; } .text-hide { font: 0/0 a; color: transparent; text-shadow: none; background-color: transparent; border: 0; } .hidden { display: none !important; visibility: hidden !important; } .affix { position: fixed; } @-ms-viewport { width: device-width; } .visible-xs, .visible-sm, .visible-md, .visible-lg { display: none !important; } @media (max-width: 767px) { .visible-xs { display: block !important; } table.visible-xs { display: table; } tr.visible-xs { display: table-row !important; } th.visible-xs, td.visible-xs { display: table-cell !important; } } @media (min-width: 768px) and (max-width: 991px) { .visible-sm { display: block !important; } table.visible-sm { display: table; } tr.visible-sm { display: table-row !important; } th.visible-sm, td.visible-sm { display: table-cell !important; } } @media (min-width: 992px) and (max-width: 1199px) { .visible-md { display: block !important; } table.visible-md { display: table; } tr.visible-md { display: table-row !important; } th.visible-md, td.visible-md { display: table-cell !important; } } @media (min-width: 1200px) { .visible-lg { display: block !important; } table.visible-lg { display: table; } tr.visible-lg { display: table-row !important; } th.visible-lg, td.visible-lg { display: table-cell !important; } } @media (max-width: 767px) { .hidden-xs { display: none !important; } } @media (min-width: 768px) and (max-width: 991px) { .hidden-sm { display: none !important; } } @media (min-width: 992px) and (max-width: 1199px) { .hidden-md { display: none !important; } } @media (min-width: 1200px) { .hidden-lg { display: none !important; } } .visible-print { display: none !important; } @media print { .visible-print { display: block !important; } table.visible-print { display: table; } tr.visible-print { display: table-row !important; } th.visible-print, td.visible-print { display: table-cell !important; } } @media print { .hidden-print { display: none !important; } } /*# sourceMappingURL=bootstrap.css.map */"},{"title":"","date":"2018-10-30T12:50:19.274Z","updated":"2016-09-30T02:46:14.159Z","comments":true,"path":"cv/assets/js/demo/style-switcher.js","permalink":"http://tech.yushuai.xyz/cv/assets/js/demo/style-switcher.js","excerpt":"","text":"$(document).ready(function() { /* ======= DEMO THEME CONFIG ====== */ $('#config-trigger').click(function(e){ e.preventDefault(); //$(\"#config-panel\").toggleClass('config-panel-open'); if($(this).hasClass('config-panel-open')){ $(\"#config-panel\").animate({ right: \"-=190\" //same as the panel width }, 500); $(this).removeClass('config-panel-open').addClass('config-panel-hide'); } else { $(\"#config-panel\").animate({ right: \"+=190\" //same as the panel width }, 500); $(this).removeClass('config-panel-hide').addClass('config-panel-open'); } }); $('#config-close').on('click', function(e) { e.preventDefault(); $('#config-trigger').click(); }); $('#color-options a').on('click', function(e) { var $styleSheet = $(this).attr('data-style'); var $chartColor = $(this).attr('data-chart'); $('#theme-style').attr('href', $styleSheet); var $listItem = $(this).closest('li'); $listItem.addClass('active'); $listItem.siblings().removeClass('active'); e.preventDefault(); // On click destory the current pie chart $('.chart').data('easy-pie-chart', null); //Create a new pie chart with a new colour $('.chart').easyPieChart({ barColor: $chartColor, trackColor: '#e8e8e8', scaleColor: false, lineWidth : 5, animate: 2000, onStep: function(from, to, percent) { $(this.el).find('span').text(Math.round(percent)); } }); }); });"},{"title":"","date":"2018-10-30T12:50:19.286Z","updated":"2015-11-24T03:37:04.000Z","comments":true,"path":"cv/assets/plugins/bootstrap/css/bootstrap-theme.min.css","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/bootstrap/css/bootstrap-theme.min.css","excerpt":"","text":"/*! * Bootstrap v3.3.6 (http://getbootstrap.com) * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) */.btn-danger,.btn-default,.btn-info,.btn-primary,.btn-success,.btn-warning{text-shadow:0 -1px 0 rgba(0,0,0,.2);-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.15),0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 0 rgba(255,255,255,.15),0 1px 1px rgba(0,0,0,.075)}.btn-danger.active,.btn-danger:active,.btn-default.active,.btn-default:active,.btn-info.active,.btn-info:active,.btn-primary.active,.btn-primary:active,.btn-success.active,.btn-success:active,.btn-warning.active,.btn-warning:active{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-danger.disabled,.btn-danger[disabled],.btn-default.disabled,.btn-default[disabled],.btn-info.disabled,.btn-info[disabled],.btn-primary.disabled,.btn-primary[disabled],.btn-success.disabled,.btn-success[disabled],.btn-warning.disabled,.btn-warning[disabled],fieldset[disabled] .btn-danger,fieldset[disabled] .btn-default,fieldset[disabled] .btn-info,fieldset[disabled] .btn-primary,fieldset[disabled] .btn-success,fieldset[disabled] .btn-warning{-webkit-box-shadow:none;box-shadow:none}.btn-danger .badge,.btn-default .badge,.btn-info .badge,.btn-primary .badge,.btn-success .badge,.btn-warning .badge{text-shadow:none}.btn.active,.btn:active{background-image:none}.btn-default{text-shadow:0 1px 0 #fff;background-image:-webkit-linear-gradient(top,#fff 0,#e0e0e0 100%);background-image:-o-linear-gradient(top,#fff 0,#e0e0e0 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#fff),to(#e0e0e0));background-image:linear-gradient(to bottom,#fff 0,#e0e0e0 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff', endColorstr='#ffe0e0e0', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#dbdbdb;border-color:#ccc}.btn-default:focus,.btn-default:hover{background-color:#e0e0e0;background-position:0 -15px}.btn-default.active,.btn-default:active{background-color:#e0e0e0;border-color:#dbdbdb}.btn-default.disabled,.btn-default.disabled.active,.btn-default.disabled.focus,.btn-default.disabled:active,.btn-default.disabled:focus,.btn-default.disabled:hover,.btn-default[disabled],.btn-default[disabled].active,.btn-default[disabled].focus,.btn-default[disabled]:active,.btn-default[disabled]:focus,.btn-default[disabled]:hover,fieldset[disabled] .btn-default,fieldset[disabled] .btn-default.active,fieldset[disabled] .btn-default.focus,fieldset[disabled] .btn-default:active,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:hover{background-color:#e0e0e0;background-image:none}.btn-primary{background-image:-webkit-linear-gradient(top,#337ab7 0,#265a88 100%);background-image:-o-linear-gradient(top,#337ab7 0,#265a88 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#337ab7),to(#265a88));background-image:linear-gradient(to bottom,#337ab7 0,#265a88 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff265a88', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#245580}.btn-primary:focus,.btn-primary:hover{background-color:#265a88;background-position:0 -15px}.btn-primary.active,.btn-primary:active{background-color:#265a88;border-color:#245580}.btn-primary.disabled,.btn-primary.disabled.active,.btn-primary.disabled.focus,.btn-primary.disabled:active,.btn-primary.disabled:focus,.btn-primary.disabled:hover,.btn-primary[disabled],.btn-primary[disabled].active,.btn-primary[disabled].focus,.btn-primary[disabled]:active,.btn-primary[disabled]:focus,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary,fieldset[disabled] .btn-primary.active,fieldset[disabled] .btn-primary.focus,fieldset[disabled] .btn-primary:active,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:hover{background-color:#265a88;background-image:none}.btn-success{background-image:-webkit-linear-gradient(top,#5cb85c 0,#419641 100%);background-image:-o-linear-gradient(top,#5cb85c 0,#419641 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#5cb85c),to(#419641));background-image:linear-gradient(to bottom,#5cb85c 0,#419641 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5cb85c', endColorstr='#ff419641', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#3e8f3e}.btn-success:focus,.btn-success:hover{background-color:#419641;background-position:0 -15px}.btn-success.active,.btn-success:active{background-color:#419641;border-color:#3e8f3e}.btn-success.disabled,.btn-success.disabled.active,.btn-success.disabled.focus,.btn-success.disabled:active,.btn-success.disabled:focus,.btn-success.disabled:hover,.btn-success[disabled],.btn-success[disabled].active,.btn-success[disabled].focus,.btn-success[disabled]:active,.btn-success[disabled]:focus,.btn-success[disabled]:hover,fieldset[disabled] .btn-success,fieldset[disabled] .btn-success.active,fieldset[disabled] .btn-success.focus,fieldset[disabled] .btn-success:active,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:hover{background-color:#419641;background-image:none}.btn-info{background-image:-webkit-linear-gradient(top,#5bc0de 0,#2aabd2 100%);background-image:-o-linear-gradient(top,#5bc0de 0,#2aabd2 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#5bc0de),to(#2aabd2));background-image:linear-gradient(to bottom,#5bc0de 0,#2aabd2 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de', endColorstr='#ff2aabd2', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#28a4c9}.btn-info:focus,.btn-info:hover{background-color:#2aabd2;background-position:0 -15px}.btn-info.active,.btn-info:active{background-color:#2aabd2;border-color:#28a4c9}.btn-info.disabled,.btn-info.disabled.active,.btn-info.disabled.focus,.btn-info.disabled:active,.btn-info.disabled:focus,.btn-info.disabled:hover,.btn-info[disabled],.btn-info[disabled].active,.btn-info[disabled].focus,.btn-info[disabled]:active,.btn-info[disabled]:focus,.btn-info[disabled]:hover,fieldset[disabled] .btn-info,fieldset[disabled] .btn-info.active,fieldset[disabled] .btn-info.focus,fieldset[disabled] .btn-info:active,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:hover{background-color:#2aabd2;background-image:none}.btn-warning{background-image:-webkit-linear-gradient(top,#f0ad4e 0,#eb9316 100%);background-image:-o-linear-gradient(top,#f0ad4e 0,#eb9316 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f0ad4e),to(#eb9316));background-image:linear-gradient(to bottom,#f0ad4e 0,#eb9316 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff0ad4e', endColorstr='#ffeb9316', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#e38d13}.btn-warning:focus,.btn-warning:hover{background-color:#eb9316;background-position:0 -15px}.btn-warning.active,.btn-warning:active{background-color:#eb9316;border-color:#e38d13}.btn-warning.disabled,.btn-warning.disabled.active,.btn-warning.disabled.focus,.btn-warning.disabled:active,.btn-warning.disabled:focus,.btn-warning.disabled:hover,.btn-warning[disabled],.btn-warning[disabled].active,.btn-warning[disabled].focus,.btn-warning[disabled]:active,.btn-warning[disabled]:focus,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning,fieldset[disabled] .btn-warning.active,fieldset[disabled] .btn-warning.focus,fieldset[disabled] .btn-warning:active,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:hover{background-color:#eb9316;background-image:none}.btn-danger{background-image:-webkit-linear-gradient(top,#d9534f 0,#c12e2a 100%);background-image:-o-linear-gradient(top,#d9534f 0,#c12e2a 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#d9534f),to(#c12e2a));background-image:linear-gradient(to bottom,#d9534f 0,#c12e2a 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9534f', endColorstr='#ffc12e2a', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#b92c28}.btn-danger:focus,.btn-danger:hover{background-color:#c12e2a;background-position:0 -15px}.btn-danger.active,.btn-danger:active{background-color:#c12e2a;border-color:#b92c28}.btn-danger.disabled,.btn-danger.disabled.active,.btn-danger.disabled.focus,.btn-danger.disabled:active,.btn-danger.disabled:focus,.btn-danger.disabled:hover,.btn-danger[disabled],.btn-danger[disabled].active,.btn-danger[disabled].focus,.btn-danger[disabled]:active,.btn-danger[disabled]:focus,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger,fieldset[disabled] .btn-danger.active,fieldset[disabled] .btn-danger.focus,fieldset[disabled] .btn-danger:active,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:hover{background-color:#c12e2a;background-image:none}.img-thumbnail,.thumbnail{-webkit-box-shadow:0 1px 2px rgba(0,0,0,.075);box-shadow:0 1px 2px rgba(0,0,0,.075)}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{background-color:#e8e8e8;background-image:-webkit-linear-gradient(top,#f5f5f5 0,#e8e8e8 100%);background-image:-o-linear-gradient(top,#f5f5f5 0,#e8e8e8 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#e8e8e8));background-image:linear-gradient(to bottom,#f5f5f5 0,#e8e8e8 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5', endColorstr='#ffe8e8e8', GradientType=0);background-repeat:repeat-x}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{background-color:#2e6da4;background-image:-webkit-linear-gradient(top,#337ab7 0,#2e6da4 100%);background-image:-o-linear-gradient(top,#337ab7 0,#2e6da4 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#337ab7),to(#2e6da4));background-image:linear-gradient(to bottom,#337ab7 0,#2e6da4 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff2e6da4', GradientType=0);background-repeat:repeat-x}.navbar-default{background-image:-webkit-linear-gradient(top,#fff 0,#f8f8f8 100%);background-image:-o-linear-gradient(top,#fff 0,#f8f8f8 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#fff),to(#f8f8f8));background-image:linear-gradient(to bottom,#fff 0,#f8f8f8 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff', endColorstr='#fff8f8f8', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-radius:4px;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.15),0 1px 5px rgba(0,0,0,.075);box-shadow:inset 0 1px 0 rgba(255,255,255,.15),0 1px 5px rgba(0,0,0,.075)}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.open>a{background-image:-webkit-linear-gradient(top,#dbdbdb 0,#e2e2e2 100%);background-image:-o-linear-gradient(top,#dbdbdb 0,#e2e2e2 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#dbdbdb),to(#e2e2e2));background-image:linear-gradient(to bottom,#dbdbdb 0,#e2e2e2 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdbdbdb', endColorstr='#ffe2e2e2', GradientType=0);background-repeat:repeat-x;-webkit-box-shadow:inset 0 3px 9px rgba(0,0,0,.075);box-shadow:inset 0 3px 9px rgba(0,0,0,.075)}.navbar-brand,.navbar-nav>li>a{text-shadow:0 1px 0 rgba(255,255,255,.25)}.navbar-inverse{background-image:-webkit-linear-gradient(top,#3c3c3c 0,#222 100%);background-image:-o-linear-gradient(top,#3c3c3c 0,#222 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#3c3c3c),to(#222));background-image:linear-gradient(to bottom,#3c3c3c 0,#222 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff3c3c3c', endColorstr='#ff222222', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-radius:4px}.navbar-inverse .navbar-nav>.active>a,.navbar-inverse .navbar-nav>.open>a{background-image:-webkit-linear-gradient(top,#080808 0,#0f0f0f 100%);background-image:-o-linear-gradient(top,#080808 0,#0f0f0f 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#080808),to(#0f0f0f));background-image:linear-gradient(to bottom,#080808 0,#0f0f0f 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff080808', endColorstr='#ff0f0f0f', GradientType=0);background-repeat:repeat-x;-webkit-box-shadow:inset 0 3px 9px rgba(0,0,0,.25);box-shadow:inset 0 3px 9px rgba(0,0,0,.25)}.navbar-inverse .navbar-brand,.navbar-inverse .navbar-nav>li>a{text-shadow:0 -1px 0 rgba(0,0,0,.25)}.navbar-fixed-bottom,.navbar-fixed-top,.navbar-static-top{border-radius:0}@media (max-width:767px){.navbar .navbar-nav .open .dropdown-menu>.active>a,.navbar .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar .navbar-nav .open .dropdown-menu>.active>a:hover{color:#fff;background-image:-webkit-linear-gradient(top,#337ab7 0,#2e6da4 100%);background-image:-o-linear-gradient(top,#337ab7 0,#2e6da4 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#337ab7),to(#2e6da4));background-image:linear-gradient(to bottom,#337ab7 0,#2e6da4 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff2e6da4', GradientType=0);background-repeat:repeat-x}}.alert{text-shadow:0 1px 0 rgba(255,255,255,.2);-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.25),0 1px 2px rgba(0,0,0,.05);box-shadow:inset 0 1px 0 rgba(255,255,255,.25),0 1px 2px rgba(0,0,0,.05)}.alert-success{background-image:-webkit-linear-gradient(top,#dff0d8 0,#c8e5bc 100%);background-image:-o-linear-gradient(top,#dff0d8 0,#c8e5bc 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#dff0d8),to(#c8e5bc));background-image:linear-gradient(to bottom,#dff0d8 0,#c8e5bc 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdff0d8', endColorstr='#ffc8e5bc', GradientType=0);background-repeat:repeat-x;border-color:#b2dba1}.alert-info{background-image:-webkit-linear-gradient(top,#d9edf7 0,#b9def0 100%);background-image:-o-linear-gradient(top,#d9edf7 0,#b9def0 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#d9edf7),to(#b9def0));background-image:linear-gradient(to bottom,#d9edf7 0,#b9def0 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9edf7', endColorstr='#ffb9def0', GradientType=0);background-repeat:repeat-x;border-color:#9acfea}.alert-warning{background-image:-webkit-linear-gradient(top,#fcf8e3 0,#f8efc0 100%);background-image:-o-linear-gradient(top,#fcf8e3 0,#f8efc0 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#fcf8e3),to(#f8efc0));background-image:linear-gradient(to bottom,#fcf8e3 0,#f8efc0 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffcf8e3', endColorstr='#fff8efc0', GradientType=0);background-repeat:repeat-x;border-color:#f5e79e}.alert-danger{background-image:-webkit-linear-gradient(top,#f2dede 0,#e7c3c3 100%);background-image:-o-linear-gradient(top,#f2dede 0,#e7c3c3 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f2dede),to(#e7c3c3));background-image:linear-gradient(to bottom,#f2dede 0,#e7c3c3 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff2dede', endColorstr='#ffe7c3c3', GradientType=0);background-repeat:repeat-x;border-color:#dca7a7}.progress{background-image:-webkit-linear-gradient(top,#ebebeb 0,#f5f5f5 100%);background-image:-o-linear-gradient(top,#ebebeb 0,#f5f5f5 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#ebebeb),to(#f5f5f5));background-image:linear-gradient(to bottom,#ebebeb 0,#f5f5f5 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffebebeb', endColorstr='#fff5f5f5', GradientType=0);background-repeat:repeat-x}.progress-bar{background-image:-webkit-linear-gradient(top,#337ab7 0,#286090 100%);background-image:-o-linear-gradient(top,#337ab7 0,#286090 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#337ab7),to(#286090));background-image:linear-gradient(to bottom,#337ab7 0,#286090 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff286090', GradientType=0);background-repeat:repeat-x}.progress-bar-success{background-image:-webkit-linear-gradient(top,#5cb85c 0,#449d44 100%);background-image:-o-linear-gradient(top,#5cb85c 0,#449d44 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#5cb85c),to(#449d44));background-image:linear-gradient(to bottom,#5cb85c 0,#449d44 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5cb85c', endColorstr='#ff449d44', GradientType=0);background-repeat:repeat-x}.progress-bar-info{background-image:-webkit-linear-gradient(top,#5bc0de 0,#31b0d5 100%);background-image:-o-linear-gradient(top,#5bc0de 0,#31b0d5 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#5bc0de),to(#31b0d5));background-image:linear-gradient(to bottom,#5bc0de 0,#31b0d5 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de', endColorstr='#ff31b0d5', GradientType=0);background-repeat:repeat-x}.progress-bar-warning{background-image:-webkit-linear-gradient(top,#f0ad4e 0,#ec971f 100%);background-image:-o-linear-gradient(top,#f0ad4e 0,#ec971f 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f0ad4e),to(#ec971f));background-image:linear-gradient(to bottom,#f0ad4e 0,#ec971f 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff0ad4e', endColorstr='#ffec971f', GradientType=0);background-repeat:repeat-x}.progress-bar-danger{background-image:-webkit-linear-gradient(top,#d9534f 0,#c9302c 100%);background-image:-o-linear-gradient(top,#d9534f 0,#c9302c 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#d9534f),to(#c9302c));background-image:linear-gradient(to bottom,#d9534f 0,#c9302c 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9534f', endColorstr='#ffc9302c', GradientType=0);background-repeat:repeat-x}.progress-bar-striped{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.list-group{border-radius:4px;-webkit-box-shadow:0 1px 2px rgba(0,0,0,.075);box-shadow:0 1px 2px rgba(0,0,0,.075)}.list-group-item.active,.list-group-item.active:focus,.list-group-item.active:hover{text-shadow:0 -1px 0 #286090;background-image:-webkit-linear-gradient(top,#337ab7 0,#2b669a 100%);background-image:-o-linear-gradient(top,#337ab7 0,#2b669a 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#337ab7),to(#2b669a));background-image:linear-gradient(to bottom,#337ab7 0,#2b669a 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff2b669a', GradientType=0);background-repeat:repeat-x;border-color:#2b669a}.list-group-item.active .badge,.list-group-item.active:focus .badge,.list-group-item.active:hover .badge{text-shadow:none}.panel{-webkit-box-shadow:0 1px 2px rgba(0,0,0,.05);box-shadow:0 1px 2px rgba(0,0,0,.05)}.panel-default>.panel-heading{background-image:-webkit-linear-gradient(top,#f5f5f5 0,#e8e8e8 100%);background-image:-o-linear-gradient(top,#f5f5f5 0,#e8e8e8 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#e8e8e8));background-image:linear-gradient(to bottom,#f5f5f5 0,#e8e8e8 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5', endColorstr='#ffe8e8e8', GradientType=0);background-repeat:repeat-x}.panel-primary>.panel-heading{background-image:-webkit-linear-gradient(top,#337ab7 0,#2e6da4 100%);background-image:-o-linear-gradient(top,#337ab7 0,#2e6da4 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#337ab7),to(#2e6da4));background-image:linear-gradient(to bottom,#337ab7 0,#2e6da4 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff2e6da4', GradientType=0);background-repeat:repeat-x}.panel-success>.panel-heading{background-image:-webkit-linear-gradient(top,#dff0d8 0,#d0e9c6 100%);background-image:-o-linear-gradient(top,#dff0d8 0,#d0e9c6 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#dff0d8),to(#d0e9c6));background-image:linear-gradient(to bottom,#dff0d8 0,#d0e9c6 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdff0d8', endColorstr='#ffd0e9c6', GradientType=0);background-repeat:repeat-x}.panel-info>.panel-heading{background-image:-webkit-linear-gradient(top,#d9edf7 0,#c4e3f3 100%);background-image:-o-linear-gradient(top,#d9edf7 0,#c4e3f3 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#d9edf7),to(#c4e3f3));background-image:linear-gradient(to bottom,#d9edf7 0,#c4e3f3 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9edf7', endColorstr='#ffc4e3f3', GradientType=0);background-repeat:repeat-x}.panel-warning>.panel-heading{background-image:-webkit-linear-gradient(top,#fcf8e3 0,#faf2cc 100%);background-image:-o-linear-gradient(top,#fcf8e3 0,#faf2cc 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#fcf8e3),to(#faf2cc));background-image:linear-gradient(to bottom,#fcf8e3 0,#faf2cc 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffcf8e3', endColorstr='#fffaf2cc', GradientType=0);background-repeat:repeat-x}.panel-danger>.panel-heading{background-image:-webkit-linear-gradient(top,#f2dede 0,#ebcccc 100%);background-image:-o-linear-gradient(top,#f2dede 0,#ebcccc 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f2dede),to(#ebcccc));background-image:linear-gradient(to bottom,#f2dede 0,#ebcccc 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff2dede', endColorstr='#ffebcccc', GradientType=0);background-repeat:repeat-x}.well{background-image:-webkit-linear-gradient(top,#e8e8e8 0,#f5f5f5 100%);background-image:-o-linear-gradient(top,#e8e8e8 0,#f5f5f5 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#e8e8e8),to(#f5f5f5));background-image:linear-gradient(to bottom,#e8e8e8 0,#f5f5f5 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffe8e8e8', endColorstr='#fff5f5f5', GradientType=0);background-repeat:repeat-x;border-color:#dcdcdc;-webkit-box-shadow:inset 0 1px 3px rgba(0,0,0,.05),0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 3px rgba(0,0,0,.05),0 1px 0 rgba(255,255,255,.1)} /*# sourceMappingURL=bootstrap-theme.min.css.map */"},{"title":"","date":"2018-10-30T12:50:19.281Z","updated":"2015-11-24T03:37:04.000Z","comments":true,"path":"cv/assets/plugins/bootstrap/css/bootstrap-theme.css","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/bootstrap/css/bootstrap-theme.css","excerpt":"","text":"/*! * Bootstrap v3.3.6 (http://getbootstrap.com) * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) */ .btn-default, .btn-primary, .btn-success, .btn-info, .btn-warning, .btn-danger { text-shadow: 0 -1px 0 rgba(0, 0, 0, .2); -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, .15), 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 0 rgba(255, 255, 255, .15), 0 1px 1px rgba(0, 0, 0, .075); } .btn-default:active, .btn-primary:active, .btn-success:active, .btn-info:active, .btn-warning:active, .btn-danger:active, .btn-default.active, .btn-primary.active, .btn-success.active, .btn-info.active, .btn-warning.active, .btn-danger.active { -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); } .btn-default.disabled, .btn-primary.disabled, .btn-success.disabled, .btn-info.disabled, .btn-warning.disabled, .btn-danger.disabled, .btn-default[disabled], .btn-primary[disabled], .btn-success[disabled], .btn-info[disabled], .btn-warning[disabled], .btn-danger[disabled], fieldset[disabled] .btn-default, fieldset[disabled] .btn-primary, fieldset[disabled] .btn-success, fieldset[disabled] .btn-info, fieldset[disabled] .btn-warning, fieldset[disabled] .btn-danger { -webkit-box-shadow: none; box-shadow: none; } .btn-default .badge, .btn-primary .badge, .btn-success .badge, .btn-info .badge, .btn-warning .badge, .btn-danger .badge { text-shadow: none; } .btn:active, .btn.active { background-image: none; } .btn-default { text-shadow: 0 1px 0 #fff; background-image: -webkit-linear-gradient(top, #fff 0%, #e0e0e0 100%); background-image: -o-linear-gradient(top, #fff 0%, #e0e0e0 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#e0e0e0)); background-image: linear-gradient(to bottom, #fff 0%, #e0e0e0 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff', endColorstr='#ffe0e0e0', GradientType=0); filter: progid:DXImageTransform.Microsoft.gradient(enabled = false); background-repeat: repeat-x; border-color: #dbdbdb; border-color: #ccc; } .btn-default:hover, .btn-default:focus { background-color: #e0e0e0; background-position: 0 -15px; } .btn-default:active, .btn-default.active { background-color: #e0e0e0; border-color: #dbdbdb; } .btn-default.disabled, .btn-default[disabled], fieldset[disabled] .btn-default, .btn-default.disabled:hover, .btn-default[disabled]:hover, fieldset[disabled] .btn-default:hover, .btn-default.disabled:focus, .btn-default[disabled]:focus, fieldset[disabled] .btn-default:focus, .btn-default.disabled.focus, .btn-default[disabled].focus, fieldset[disabled] .btn-default.focus, .btn-default.disabled:active, .btn-default[disabled]:active, fieldset[disabled] .btn-default:active, .btn-default.disabled.active, .btn-default[disabled].active, fieldset[disabled] .btn-default.active { background-color: #e0e0e0; background-image: none; } .btn-primary { background-image: -webkit-linear-gradient(top, #337ab7 0%, #265a88 100%); background-image: -o-linear-gradient(top, #337ab7 0%, #265a88 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#337ab7), to(#265a88)); background-image: linear-gradient(to bottom, #337ab7 0%, #265a88 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff265a88', GradientType=0); filter: progid:DXImageTransform.Microsoft.gradient(enabled = false); background-repeat: repeat-x; border-color: #245580; } .btn-primary:hover, .btn-primary:focus { background-color: #265a88; background-position: 0 -15px; } .btn-primary:active, .btn-primary.active { background-color: #265a88; border-color: #245580; } .btn-primary.disabled, .btn-primary[disabled], fieldset[disabled] .btn-primary, .btn-primary.disabled:hover, .btn-primary[disabled]:hover, fieldset[disabled] .btn-primary:hover, .btn-primary.disabled:focus, .btn-primary[disabled]:focus, fieldset[disabled] .btn-primary:focus, .btn-primary.disabled.focus, .btn-primary[disabled].focus, fieldset[disabled] .btn-primary.focus, .btn-primary.disabled:active, .btn-primary[disabled]:active, fieldset[disabled] .btn-primary:active, .btn-primary.disabled.active, .btn-primary[disabled].active, fieldset[disabled] .btn-primary.active { background-color: #265a88; background-image: none; } .btn-success { background-image: -webkit-linear-gradient(top, #5cb85c 0%, #419641 100%); background-image: -o-linear-gradient(top, #5cb85c 0%, #419641 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#5cb85c), to(#419641)); background-image: linear-gradient(to bottom, #5cb85c 0%, #419641 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5cb85c', endColorstr='#ff419641', GradientType=0); filter: progid:DXImageTransform.Microsoft.gradient(enabled = false); background-repeat: repeat-x; border-color: #3e8f3e; } .btn-success:hover, .btn-success:focus { background-color: #419641; background-position: 0 -15px; } .btn-success:active, .btn-success.active { background-color: #419641; border-color: #3e8f3e; } .btn-success.disabled, .btn-success[disabled], fieldset[disabled] .btn-success, .btn-success.disabled:hover, .btn-success[disabled]:hover, fieldset[disabled] .btn-success:hover, .btn-success.disabled:focus, .btn-success[disabled]:focus, fieldset[disabled] .btn-success:focus, .btn-success.disabled.focus, .btn-success[disabled].focus, fieldset[disabled] .btn-success.focus, .btn-success.disabled:active, .btn-success[disabled]:active, fieldset[disabled] .btn-success:active, .btn-success.disabled.active, .btn-success[disabled].active, fieldset[disabled] .btn-success.active { background-color: #419641; background-image: none; } .btn-info { background-image: -webkit-linear-gradient(top, #5bc0de 0%, #2aabd2 100%); background-image: -o-linear-gradient(top, #5bc0de 0%, #2aabd2 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#5bc0de), to(#2aabd2)); background-image: linear-gradient(to bottom, #5bc0de 0%, #2aabd2 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de', endColorstr='#ff2aabd2', GradientType=0); filter: progid:DXImageTransform.Microsoft.gradient(enabled = false); background-repeat: repeat-x; border-color: #28a4c9; } .btn-info:hover, .btn-info:focus { background-color: #2aabd2; background-position: 0 -15px; } .btn-info:active, .btn-info.active { background-color: #2aabd2; border-color: #28a4c9; } .btn-info.disabled, .btn-info[disabled], fieldset[disabled] .btn-info, .btn-info.disabled:hover, .btn-info[disabled]:hover, fieldset[disabled] .btn-info:hover, .btn-info.disabled:focus, .btn-info[disabled]:focus, fieldset[disabled] .btn-info:focus, .btn-info.disabled.focus, .btn-info[disabled].focus, fieldset[disabled] .btn-info.focus, .btn-info.disabled:active, .btn-info[disabled]:active, fieldset[disabled] .btn-info:active, .btn-info.disabled.active, .btn-info[disabled].active, fieldset[disabled] .btn-info.active { background-color: #2aabd2; background-image: none; } .btn-warning { background-image: -webkit-linear-gradient(top, #f0ad4e 0%, #eb9316 100%); background-image: -o-linear-gradient(top, #f0ad4e 0%, #eb9316 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#f0ad4e), to(#eb9316)); background-image: linear-gradient(to bottom, #f0ad4e 0%, #eb9316 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff0ad4e', endColorstr='#ffeb9316', GradientType=0); filter: progid:DXImageTransform.Microsoft.gradient(enabled = false); background-repeat: repeat-x; border-color: #e38d13; } .btn-warning:hover, .btn-warning:focus { background-color: #eb9316; background-position: 0 -15px; } .btn-warning:active, .btn-warning.active { background-color: #eb9316; border-color: #e38d13; } .btn-warning.disabled, .btn-warning[disabled], fieldset[disabled] .btn-warning, .btn-warning.disabled:hover, .btn-warning[disabled]:hover, fieldset[disabled] .btn-warning:hover, .btn-warning.disabled:focus, .btn-warning[disabled]:focus, fieldset[disabled] .btn-warning:focus, .btn-warning.disabled.focus, .btn-warning[disabled].focus, fieldset[disabled] .btn-warning.focus, .btn-warning.disabled:active, .btn-warning[disabled]:active, fieldset[disabled] .btn-warning:active, .btn-warning.disabled.active, .btn-warning[disabled].active, fieldset[disabled] .btn-warning.active { background-color: #eb9316; background-image: none; } .btn-danger { background-image: -webkit-linear-gradient(top, #d9534f 0%, #c12e2a 100%); background-image: -o-linear-gradient(top, #d9534f 0%, #c12e2a 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#d9534f), to(#c12e2a)); background-image: linear-gradient(to bottom, #d9534f 0%, #c12e2a 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9534f', endColorstr='#ffc12e2a', GradientType=0); filter: progid:DXImageTransform.Microsoft.gradient(enabled = false); background-repeat: repeat-x; border-color: #b92c28; } .btn-danger:hover, .btn-danger:focus { background-color: #c12e2a; background-position: 0 -15px; } .btn-danger:active, .btn-danger.active { background-color: #c12e2a; border-color: #b92c28; } .btn-danger.disabled, .btn-danger[disabled], fieldset[disabled] .btn-danger, .btn-danger.disabled:hover, .btn-danger[disabled]:hover, fieldset[disabled] .btn-danger:hover, .btn-danger.disabled:focus, .btn-danger[disabled]:focus, fieldset[disabled] .btn-danger:focus, .btn-danger.disabled.focus, .btn-danger[disabled].focus, fieldset[disabled] .btn-danger.focus, .btn-danger.disabled:active, .btn-danger[disabled]:active, fieldset[disabled] .btn-danger:active, .btn-danger.disabled.active, .btn-danger[disabled].active, fieldset[disabled] .btn-danger.active { background-color: #c12e2a; background-image: none; } .thumbnail, .img-thumbnail { -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, .075); box-shadow: 0 1px 2px rgba(0, 0, 0, .075); } .dropdown-menu > li > a:hover, .dropdown-menu > li > a:focus { background-color: #e8e8e8; background-image: -webkit-linear-gradient(top, #f5f5f5 0%, #e8e8e8 100%); background-image: -o-linear-gradient(top, #f5f5f5 0%, #e8e8e8 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#f5f5f5), to(#e8e8e8)); background-image: linear-gradient(to bottom, #f5f5f5 0%, #e8e8e8 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5', endColorstr='#ffe8e8e8', GradientType=0); background-repeat: repeat-x; } .dropdown-menu > .active > a, .dropdown-menu > .active > a:hover, .dropdown-menu > .active > a:focus { background-color: #2e6da4; background-image: -webkit-linear-gradient(top, #337ab7 0%, #2e6da4 100%); background-image: -o-linear-gradient(top, #337ab7 0%, #2e6da4 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#337ab7), to(#2e6da4)); background-image: linear-gradient(to bottom, #337ab7 0%, #2e6da4 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff2e6da4', GradientType=0); background-repeat: repeat-x; } .navbar-default { background-image: -webkit-linear-gradient(top, #fff 0%, #f8f8f8 100%); background-image: -o-linear-gradient(top, #fff 0%, #f8f8f8 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#f8f8f8)); background-image: linear-gradient(to bottom, #fff 0%, #f8f8f8 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff', endColorstr='#fff8f8f8', GradientType=0); filter: progid:DXImageTransform.Microsoft.gradient(enabled = false); background-repeat: repeat-x; border-radius: 4px; -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, .15), 0 1px 5px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 0 rgba(255, 255, 255, .15), 0 1px 5px rgba(0, 0, 0, .075); } .navbar-default .navbar-nav > .open > a, .navbar-default .navbar-nav > .active > a { background-image: -webkit-linear-gradient(top, #dbdbdb 0%, #e2e2e2 100%); background-image: -o-linear-gradient(top, #dbdbdb 0%, #e2e2e2 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#dbdbdb), to(#e2e2e2)); background-image: linear-gradient(to bottom, #dbdbdb 0%, #e2e2e2 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdbdbdb', endColorstr='#ffe2e2e2', GradientType=0); background-repeat: repeat-x; -webkit-box-shadow: inset 0 3px 9px rgba(0, 0, 0, .075); box-shadow: inset 0 3px 9px rgba(0, 0, 0, .075); } .navbar-brand, .navbar-nav > li > a { text-shadow: 0 1px 0 rgba(255, 255, 255, .25); } .navbar-inverse { background-image: -webkit-linear-gradient(top, #3c3c3c 0%, #222 100%); background-image: -o-linear-gradient(top, #3c3c3c 0%, #222 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#3c3c3c), to(#222)); background-image: linear-gradient(to bottom, #3c3c3c 0%, #222 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff3c3c3c', endColorstr='#ff222222', GradientType=0); filter: progid:DXImageTransform.Microsoft.gradient(enabled = false); background-repeat: repeat-x; border-radius: 4px; } .navbar-inverse .navbar-nav > .open > a, .navbar-inverse .navbar-nav > .active > a { background-image: -webkit-linear-gradient(top, #080808 0%, #0f0f0f 100%); background-image: -o-linear-gradient(top, #080808 0%, #0f0f0f 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#080808), to(#0f0f0f)); background-image: linear-gradient(to bottom, #080808 0%, #0f0f0f 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff080808', endColorstr='#ff0f0f0f', GradientType=0); background-repeat: repeat-x; -webkit-box-shadow: inset 0 3px 9px rgba(0, 0, 0, .25); box-shadow: inset 0 3px 9px rgba(0, 0, 0, .25); } .navbar-inverse .navbar-brand, .navbar-inverse .navbar-nav > li > a { text-shadow: 0 -1px 0 rgba(0, 0, 0, .25); } .navbar-static-top, .navbar-fixed-top, .navbar-fixed-bottom { border-radius: 0; } @media (max-width: 767px) { .navbar .navbar-nav .open .dropdown-menu > .active > a, .navbar .navbar-nav .open .dropdown-menu > .active > a:hover, .navbar .navbar-nav .open .dropdown-menu > .active > a:focus { color: #fff; background-image: -webkit-linear-gradient(top, #337ab7 0%, #2e6da4 100%); background-image: -o-linear-gradient(top, #337ab7 0%, #2e6da4 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#337ab7), to(#2e6da4)); background-image: linear-gradient(to bottom, #337ab7 0%, #2e6da4 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff2e6da4', GradientType=0); background-repeat: repeat-x; } } .alert { text-shadow: 0 1px 0 rgba(255, 255, 255, .2); -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, .25), 0 1px 2px rgba(0, 0, 0, .05); box-shadow: inset 0 1px 0 rgba(255, 255, 255, .25), 0 1px 2px rgba(0, 0, 0, .05); } .alert-success { background-image: -webkit-linear-gradient(top, #dff0d8 0%, #c8e5bc 100%); background-image: -o-linear-gradient(top, #dff0d8 0%, #c8e5bc 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#dff0d8), to(#c8e5bc)); background-image: linear-gradient(to bottom, #dff0d8 0%, #c8e5bc 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdff0d8', endColorstr='#ffc8e5bc', GradientType=0); background-repeat: repeat-x; border-color: #b2dba1; } .alert-info { background-image: -webkit-linear-gradient(top, #d9edf7 0%, #b9def0 100%); background-image: -o-linear-gradient(top, #d9edf7 0%, #b9def0 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#d9edf7), to(#b9def0)); background-image: linear-gradient(to bottom, #d9edf7 0%, #b9def0 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9edf7', endColorstr='#ffb9def0', GradientType=0); background-repeat: repeat-x; border-color: #9acfea; } .alert-warning { background-image: -webkit-linear-gradient(top, #fcf8e3 0%, #f8efc0 100%); background-image: -o-linear-gradient(top, #fcf8e3 0%, #f8efc0 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#fcf8e3), to(#f8efc0)); background-image: linear-gradient(to bottom, #fcf8e3 0%, #f8efc0 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffcf8e3', endColorstr='#fff8efc0', GradientType=0); background-repeat: repeat-x; border-color: #f5e79e; } .alert-danger { background-image: -webkit-linear-gradient(top, #f2dede 0%, #e7c3c3 100%); background-image: -o-linear-gradient(top, #f2dede 0%, #e7c3c3 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#f2dede), to(#e7c3c3)); background-image: linear-gradient(to bottom, #f2dede 0%, #e7c3c3 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff2dede', endColorstr='#ffe7c3c3', GradientType=0); background-repeat: repeat-x; border-color: #dca7a7; } .progress { background-image: -webkit-linear-gradient(top, #ebebeb 0%, #f5f5f5 100%); background-image: -o-linear-gradient(top, #ebebeb 0%, #f5f5f5 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#ebebeb), to(#f5f5f5)); background-image: linear-gradient(to bottom, #ebebeb 0%, #f5f5f5 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffebebeb', endColorstr='#fff5f5f5', GradientType=0); background-repeat: repeat-x; } .progress-bar { background-image: -webkit-linear-gradient(top, #337ab7 0%, #286090 100%); background-image: -o-linear-gradient(top, #337ab7 0%, #286090 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#337ab7), to(#286090)); background-image: linear-gradient(to bottom, #337ab7 0%, #286090 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff286090', GradientType=0); background-repeat: repeat-x; } .progress-bar-success { background-image: -webkit-linear-gradient(top, #5cb85c 0%, #449d44 100%); background-image: -o-linear-gradient(top, #5cb85c 0%, #449d44 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#5cb85c), to(#449d44)); background-image: linear-gradient(to bottom, #5cb85c 0%, #449d44 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5cb85c', endColorstr='#ff449d44', GradientType=0); background-repeat: repeat-x; } .progress-bar-info { background-image: -webkit-linear-gradient(top, #5bc0de 0%, #31b0d5 100%); background-image: -o-linear-gradient(top, #5bc0de 0%, #31b0d5 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#5bc0de), to(#31b0d5)); background-image: linear-gradient(to bottom, #5bc0de 0%, #31b0d5 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de', endColorstr='#ff31b0d5', GradientType=0); background-repeat: repeat-x; } .progress-bar-warning { background-image: -webkit-linear-gradient(top, #f0ad4e 0%, #ec971f 100%); background-image: -o-linear-gradient(top, #f0ad4e 0%, #ec971f 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#f0ad4e), to(#ec971f)); background-image: linear-gradient(to bottom, #f0ad4e 0%, #ec971f 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff0ad4e', endColorstr='#ffec971f', GradientType=0); background-repeat: repeat-x; } .progress-bar-danger { background-image: -webkit-linear-gradient(top, #d9534f 0%, #c9302c 100%); background-image: -o-linear-gradient(top, #d9534f 0%, #c9302c 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#d9534f), to(#c9302c)); background-image: linear-gradient(to bottom, #d9534f 0%, #c9302c 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9534f', endColorstr='#ffc9302c', GradientType=0); background-repeat: repeat-x; } .progress-bar-striped { background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); } .list-group { border-radius: 4px; -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, .075); box-shadow: 0 1px 2px rgba(0, 0, 0, .075); } .list-group-item.active, .list-group-item.active:hover, .list-group-item.active:focus { text-shadow: 0 -1px 0 #286090; background-image: -webkit-linear-gradient(top, #337ab7 0%, #2b669a 100%); background-image: -o-linear-gradient(top, #337ab7 0%, #2b669a 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#337ab7), to(#2b669a)); background-image: linear-gradient(to bottom, #337ab7 0%, #2b669a 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff2b669a', GradientType=0); background-repeat: repeat-x; border-color: #2b669a; } .list-group-item.active .badge, .list-group-item.active:hover .badge, .list-group-item.active:focus .badge { text-shadow: none; } .panel { -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, .05); box-shadow: 0 1px 2px rgba(0, 0, 0, .05); } .panel-default > .panel-heading { background-image: -webkit-linear-gradient(top, #f5f5f5 0%, #e8e8e8 100%); background-image: -o-linear-gradient(top, #f5f5f5 0%, #e8e8e8 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#f5f5f5), to(#e8e8e8)); background-image: linear-gradient(to bottom, #f5f5f5 0%, #e8e8e8 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5', endColorstr='#ffe8e8e8', GradientType=0); background-repeat: repeat-x; } .panel-primary > .panel-heading { background-image: -webkit-linear-gradient(top, #337ab7 0%, #2e6da4 100%); background-image: -o-linear-gradient(top, #337ab7 0%, #2e6da4 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#337ab7), to(#2e6da4)); background-image: linear-gradient(to bottom, #337ab7 0%, #2e6da4 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff2e6da4', GradientType=0); background-repeat: repeat-x; } .panel-success > .panel-heading { background-image: -webkit-linear-gradient(top, #dff0d8 0%, #d0e9c6 100%); background-image: -o-linear-gradient(top, #dff0d8 0%, #d0e9c6 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#dff0d8), to(#d0e9c6)); background-image: linear-gradient(to bottom, #dff0d8 0%, #d0e9c6 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdff0d8', endColorstr='#ffd0e9c6', GradientType=0); background-repeat: repeat-x; } .panel-info > .panel-heading { background-image: -webkit-linear-gradient(top, #d9edf7 0%, #c4e3f3 100%); background-image: -o-linear-gradient(top, #d9edf7 0%, #c4e3f3 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#d9edf7), to(#c4e3f3)); background-image: linear-gradient(to bottom, #d9edf7 0%, #c4e3f3 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9edf7', endColorstr='#ffc4e3f3', GradientType=0); background-repeat: repeat-x; } .panel-warning > .panel-heading { background-image: -webkit-linear-gradient(top, #fcf8e3 0%, #faf2cc 100%); background-image: -o-linear-gradient(top, #fcf8e3 0%, #faf2cc 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#fcf8e3), to(#faf2cc)); background-image: linear-gradient(to bottom, #fcf8e3 0%, #faf2cc 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffcf8e3', endColorstr='#fffaf2cc', GradientType=0); background-repeat: repeat-x; } .panel-danger > .panel-heading { background-image: -webkit-linear-gradient(top, #f2dede 0%, #ebcccc 100%); background-image: -o-linear-gradient(top, #f2dede 0%, #ebcccc 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#f2dede), to(#ebcccc)); background-image: linear-gradient(to bottom, #f2dede 0%, #ebcccc 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff2dede', endColorstr='#ffebcccc', GradientType=0); background-repeat: repeat-x; } .well { background-image: -webkit-linear-gradient(top, #e8e8e8 0%, #f5f5f5 100%); background-image: -o-linear-gradient(top, #e8e8e8 0%, #f5f5f5 100%); background-image: -webkit-gradient(linear, left top, left bottom, from(#e8e8e8), to(#f5f5f5)); background-image: linear-gradient(to bottom, #e8e8e8 0%, #f5f5f5 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffe8e8e8', endColorstr='#fff5f5f5', GradientType=0); background-repeat: repeat-x; border-color: #dcdcdc; -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, .05), 0 1px 0 rgba(255, 255, 255, .1); box-shadow: inset 0 1px 3px rgba(0, 0, 0, .05), 0 1px 0 rgba(255, 255, 255, .1); } /*# sourceMappingURL=bootstrap-theme.css.map */"},{"title":"","date":"2018-10-30T12:50:19.321Z","updated":"2016-09-30T02:46:11.340Z","comments":true,"path":"cv/assets/plugins/bootstrap/js/bootstrap.min.js","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/bootstrap/js/bootstrap.min.js","excerpt":"","text":"/*! * Bootstrap v3.3.7 (http://getbootstrap.com) * Copyright 2011-2016 Twitter, Inc. * Licensed under the MIT license */ if(\"undefined\"==typeof jQuery)throw new Error(\"Bootstrap's JavaScript requires jQuery\");+function(a){\"use strict\";var b=a.fn.jquery.split(\" \")[0].split(\".\");if(b[0]0&&j--,40==c.which&&j',trigger:\"hover focus\",title:\"\",delay:0,html:!1,container:!1,viewport:{selector:\"body\",padding:0}},c.prototype.init=function(b,c,d){if(this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(a.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error(\"`selector` option must be specified when initializing \"+this.type+\" on the window.document object!\");for(var e=this.options.trigger.split(\" \"),f=e.length;f--;){var g=e[f];if(\"click\"==g)this.$element.on(\"click.\"+this.type,this.options.selector,a.proxy(this.toggle,this));else if(\"manual\"!=g){var h=\"hover\"==g?\"mouseenter\":\"focusin\",i=\"hover\"==g?\"mouseleave\":\"focusout\";this.$element.on(h+\".\"+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+\".\"+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:\"manual\",selector:\"\"}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&\"number\"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data(\"bs.\"+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data(\"bs.\"+this.type,c)),b instanceof a.Event&&(c.inState[\"focusin\"==b.type?\"focus\":\"hover\"]=!0),c.tip().hasClass(\"in\")||\"in\"==c.hoverState?void(c.hoverState=\"in\"):(clearTimeout(c.timeout),c.hoverState=\"in\",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){\"in\"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.isInStateTrue=function(){for(var a in this.inState)if(this.inState[a])return!0;return!1},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data(\"bs.\"+this.type);if(c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data(\"bs.\"+this.type,c)),b instanceof a.Event&&(c.inState[\"focusout\"==b.type?\"focus\":\"hover\"]=!1),!c.isInStateTrue())return clearTimeout(c.timeout),c.hoverState=\"out\",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){\"out\"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide()},c.prototype.show=function(){var b=a.Event(\"show.bs.\"+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr(\"id\",g),this.$element.attr(\"aria-describedby\",g),this.options.animation&&f.addClass(\"fade\");var h=\"function\"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\\s?auto?\\s?/i,j=i.test(h);j&&(h=h.replace(i,\"\")||\"top\"),f.detach().css({top:0,left:0,display:\"block\"}).addClass(h).data(\"bs.\"+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element),this.$element.trigger(\"inserted.bs.\"+this.type);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.getPosition(this.$viewport);h=\"bottom\"==h&&k.bottom+m>o.bottom?\"top\":\"top\"==h&&k.top-mo.width?\"left\":\"left\"==h&&k.left-l .dropdown-menu > .active\").removeClass(\"active\").end().find('[data-toggle=\"tab\"]').attr(\"aria-expanded\",!1),b.addClass(\"active\").find('[data-toggle=\"tab\"]').attr(\"aria-expanded\",!0),h?(b[0].offsetWidth,b.addClass(\"in\")):b.removeClass(\"fade\"),b.parent(\".dropdown-menu\").length&&b.closest(\"li.dropdown\").addClass(\"active\").end().find('[data-toggle=\"tab\"]').attr(\"aria-expanded\",!0),e&&e()}var g=d.find(\"> .active\"),h=e&&a.support.transition&&(g.length&&g.hasClass(\"fade\")||!!d.find(\"> .fade\").length);g.length&&h?g.one(\"bsTransitionEnd\",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass(\"in\")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),\"show\")};a(document).on(\"click.bs.tab.data-api\",'[data-toggle=\"tab\"]',e).on(\"click.bs.tab.data-api\",'[data-toggle=\"pill\"]',e)}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.affix\"),f=\"object\"==typeof b&&b;e||d.data(\"bs.affix\",e=new c(this,f)),\"string\"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on(\"scroll.bs.affix.data-api\",a.proxy(this.checkPosition,this)).on(\"click.bs.affix.data-api\",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION=\"3.3.7\",c.RESET=\"affix affix-top affix-bottom\",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&\"top\"==this.affixed)return e=a-d&&\"bottom\"},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass(\"affix\");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(\":visible\")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=Math.max(a(document).height(),a(document.body).height());\"object\"!=typeof d&&(f=e=d),\"function\"==typeof e&&(e=d.top(this.$element)),\"function\"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css(\"top\",\"\");var i=\"affix\"+(h?\"-\"+h:\"\"),j=a.Event(i+\".bs.affix\");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin=\"bottom\"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace(\"affix\",\"affixed\")+\".bs.affix\")}\"bottom\"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on(\"load\",function(){a('[data-spy=\"affix\"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);"},{"title":"","date":"2018-10-30T12:50:19.326Z","updated":"2016-09-30T02:46:12.119Z","comments":true,"path":"cv/assets/plugins/easy-pie-chart/dist/jquery.easypiechart.min.js","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/easy-pie-chart/dist/jquery.easypiechart.min.js","excerpt":"","text":"/**! * easy-pie-chart * Lightweight plugin to render simple, animated and retina optimized pie charts * * @license * @author Robert Fleischmann (http://robert-fleischmann.de) * @version 2.1.7 **/ !function(a,b){\"function\"==typeof define&&define.amd?define([\"jquery\"],function(a){return b(a)}):\"object\"==typeof exports?module.exports=b(require(\"jquery\")):b(jQuery)}(this,function(a){var b=function(a,b){var c,d=document.createElement(\"canvas\");a.appendChild(d),\"object\"==typeof G_vmlCanvasManager&&G_vmlCanvasManager.initElement(d);var e=d.getContext(\"2d\");d.width=d.height=b.size;var f=1;window.devicePixelRatio>1&&(f=window.devicePixelRatio,d.style.width=d.style.height=[b.size,\"px\"].join(\"\"),d.width=d.height=b.size*f,e.scale(f,f)),e.translate(b.size/2,b.size/2),e.rotate((-0.5+b.rotate/180)*Math.PI);var g=(b.size-b.lineWidth)/2;b.scaleColor&&b.scaleLength&&(g-=b.scaleLength+2),Date.now=Date.now||function(){return+new Date};var h=function(a,b,c){c=Math.min(Math.max(-1,c||0),1);var d=0>=c?!0:!1;e.beginPath(),e.arc(0,0,g,0,2*Math.PI*c,d),e.strokeStyle=a,e.lineWidth=b,e.stroke()},i=function(){var a,c;e.lineWidth=1,e.fillStyle=b.scaleColor,e.save();for(var d=24;d>0;--d)d%6===0?(c=b.scaleLength,a=0):(c=.6*b.scaleLength,a=b.scaleLength-c),e.fillRect(-b.size/2+a,0,c,1),e.rotate(Math.PI/12);e.restore()},j=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(a){window.setTimeout(a,1e3/60)}}(),k=function(){b.scaleColor&&i(),b.trackColor&&h(b.trackColor,b.trackWidth||b.lineWidth,1)};this.getCanvas=function(){return d},this.getCtx=function(){return e},this.clear=function(){e.clearRect(b.size/-2,b.size/-2,b.size,b.size)},this.draw=function(a){b.scaleColor||b.trackColor?e.getImageData&&e.putImageData?c?e.putImageData(c,0,0):(k(),c=e.getImageData(0,0,b.size*f,b.size*f)):(this.clear(),k()):this.clear(),e.lineCap=b.lineCap;var d;d=\"function\"==typeof b.barColor?b.barColor(a):b.barColor,h(d,b.lineWidth,a/100)}.bind(this),this.animate=function(a,c){var d=Date.now();b.onStart(a,c);var e=function(){var f=Math.min(Date.now()-d,b.animate.duration),g=b.easing(this,f,a,c-a,b.animate.duration);this.draw(g),b.onStep(a,c,g),f>=b.animate.duration?b.onStop(a,c):j(e)}.bind(this);j(e)}.bind(this)},c=function(a,c){var d={barColor:\"#ef1e25\",trackColor:\"#f9f9f9\",scaleColor:\"#dfe0e0\",scaleLength:5,lineCap:\"round\",lineWidth:3,trackWidth:void 0,size:110,rotate:0,animate:{duration:1e3,enabled:!0},easing:function(a,b,c,d,e){return b/=e/2,1>b?d/2*b*b+c:-d/2*(--b*(b-2)-1)+c},onStart:function(a,b){},onStep:function(a,b,c){},onStop:function(a,b){}};if(\"undefined\"!=typeof b)d.renderer=b;else{if(\"undefined\"==typeof SVGRenderer)throw new Error(\"Please load either the SVG- or the CanvasRenderer\");d.renderer=SVGRenderer}var e={},f=0,g=function(){this.el=a,this.options=e;for(var b in d)d.hasOwnProperty(b)&&(e[b]=c&&\"undefined\"!=typeof c[b]?c[b]:d[b],\"function\"==typeof e[b]&&(e[b]=e[b].bind(this)));\"string\"==typeof e.easing&&\"undefined\"!=typeof jQuery&&jQuery.isFunction(jQuery.easing[e.easing])?e.easing=jQuery.easing[e.easing]:e.easing=d.easing,\"number\"==typeof e.animate&&(e.animate={duration:e.animate,enabled:!0}),\"boolean\"!=typeof e.animate||e.animate||(e.animate={duration:1e3,enabled:e.animate}),this.renderer=new e.renderer(a,e),this.renderer.draw(f),a.dataset&&a.dataset.percent?this.update(parseFloat(a.dataset.percent)):a.getAttribute&&a.getAttribute(\"data-percent\")&&this.update(parseFloat(a.getAttribute(\"data-percent\")))}.bind(this);this.update=function(a){return a=parseFloat(a),e.animate.enabled?this.renderer.animate(f,a):this.renderer.draw(a),f=a,this}.bind(this),this.disableAnimation=function(){return e.animate.enabled=!1,this},this.enableAnimation=function(){return e.animate.enabled=!0,this},g()};a.fn.easyPieChart=function(b){return this.each(function(){var d;a.data(this,\"easyPieChart\")||(d=a.extend({},b,a(this).data()),a.data(this,\"easyPieChart\",new c(this,d)))})}});"},{"title":"","date":"2018-10-30T12:50:19.323Z","updated":"2015-11-24T03:37:04.000Z","comments":true,"path":"cv/assets/plugins/bootstrap/js/npm.js","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/bootstrap/js/npm.js","excerpt":"","text":"// This file is autogenerated via the `commonjs` Grunt task. You can require() this file in a CommonJS environment. require('../../js/transition.js') require('../../js/alert.js') require('../../js/button.js') require('../../js/carousel.js') require('../../js/collapse.js') require('../../js/dropdown.js') require('../../js/modal.js') require('../../js/tooltip.js') require('../../js/popover.js') require('../../js/scrollspy.js') require('../../js/tab.js') require('../../js/affix.js')"},{"title":"","date":"2018-10-30T12:50:19.330Z","updated":"2016-09-30T02:46:07.068Z","comments":true,"path":"cv/assets/plugins/font-awesome/css/font-awesome.css","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/font-awesome/css/font-awesome.css","excerpt":"","text":"/*! * Font Awesome 4.6.3 by @davegandy - http://fontawesome.io - @fontawesome * License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License) */ /* FONT PATH * -------------------------- */ @font-face { font-family: 'FontAwesome'; src: url('../fonts/fontawesome-webfont.eot?v=4.6.3'); src: url('../fonts/fontawesome-webfont.eot?#iefix&v=4.6.3') format('embedded-opentype'), url('../fonts/fontawesome-webfont.woff2?v=4.6.3') format('woff2'), url('../fonts/fontawesome-webfont.woff?v=4.6.3') format('woff'), url('../fonts/fontawesome-webfont.ttf?v=4.6.3') format('truetype'), url('../fonts/fontawesome-webfont.svg?v=4.6.3#fontawesomeregular') format('svg'); font-weight: normal; font-style: normal; } .fa { display: inline-block; font: normal normal normal 14px/1 FontAwesome; font-size: inherit; text-rendering: auto; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } /* makes the font 33% larger relative to the icon container */ .fa-lg { font-size: 1.33333333em; line-height: 0.75em; vertical-align: -15%; } .fa-2x { font-size: 2em; } .fa-3x { font-size: 3em; } .fa-4x { font-size: 4em; } .fa-5x { font-size: 5em; } .fa-fw { width: 1.28571429em; text-align: center; } .fa-ul { padding-left: 0; margin-left: 2.14285714em; list-style-type: none; } .fa-ul > li { position: relative; } .fa-li { position: absolute; left: -2.14285714em; width: 2.14285714em; top: 0.14285714em; text-align: center; } .fa-li.fa-lg { left: -1.85714286em; } .fa-border { padding: .2em .25em .15em; border: solid 0.08em #eeeeee; border-radius: .1em; } .fa-pull-left { float: left; } .fa-pull-right { float: right; } .fa.fa-pull-left { margin-right: .3em; } .fa.fa-pull-right { margin-left: .3em; } /* Deprecated as of 4.4.0 */ .pull-right { float: right; } .pull-left { float: left; } .fa.pull-left { margin-right: .3em; } .fa.pull-right { margin-left: .3em; } .fa-spin { -webkit-animation: fa-spin 2s infinite linear; animation: fa-spin 2s infinite linear; } .fa-pulse { -webkit-animation: fa-spin 1s infinite steps(8); animation: fa-spin 1s infinite steps(8); } @-webkit-keyframes fa-spin { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(359deg); transform: rotate(359deg); } } @keyframes fa-spin { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(359deg); transform: rotate(359deg); } } .fa-rotate-90 { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\"; -webkit-transform: rotate(90deg); -ms-transform: rotate(90deg); transform: rotate(90deg); } .fa-rotate-180 { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\"; -webkit-transform: rotate(180deg); -ms-transform: rotate(180deg); transform: rotate(180deg); } .fa-rotate-270 { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\"; -webkit-transform: rotate(270deg); -ms-transform: rotate(270deg); transform: rotate(270deg); } .fa-flip-horizontal { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\"; -webkit-transform: scale(-1, 1); -ms-transform: scale(-1, 1); transform: scale(-1, 1); } .fa-flip-vertical { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\"; -webkit-transform: scale(1, -1); -ms-transform: scale(1, -1); transform: scale(1, -1); } :root .fa-rotate-90, :root .fa-rotate-180, :root .fa-rotate-270, :root .fa-flip-horizontal, :root .fa-flip-vertical { filter: none; } .fa-stack { position: relative; display: inline-block; width: 2em; height: 2em; line-height: 2em; vertical-align: middle; } .fa-stack-1x, .fa-stack-2x { position: absolute; left: 0; width: 100%; text-align: center; } .fa-stack-1x { line-height: inherit; } .fa-stack-2x { font-size: 2em; } .fa-inverse { color: #ffffff; } /* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen readers do not read off random characters that represent icons */ .fa-glass:before { content: \"\\f000\"; } .fa-music:before { content: \"\\f001\"; } .fa-search:before { content: \"\\f002\"; } .fa-envelope-o:before { content: \"\\f003\"; } .fa-heart:before { content: \"\\f004\"; } .fa-star:before { content: \"\\f005\"; } .fa-star-o:before { content: \"\\f006\"; } .fa-user:before { content: \"\\f007\"; } .fa-film:before { content: \"\\f008\"; } .fa-th-large:before { content: \"\\f009\"; } .fa-th:before { content: \"\\f00a\"; } .fa-th-list:before { content: \"\\f00b\"; } .fa-check:before { content: \"\\f00c\"; } .fa-remove:before, .fa-close:before, .fa-times:before { content: \"\\f00d\"; } .fa-search-plus:before { content: \"\\f00e\"; } .fa-search-minus:before { content: \"\\f010\"; } .fa-power-off:before { content: \"\\f011\"; } .fa-signal:before { content: \"\\f012\"; } .fa-gear:before, .fa-cog:before { content: \"\\f013\"; } .fa-trash-o:before { content: \"\\f014\"; } .fa-home:before { content: \"\\f015\"; } .fa-file-o:before { content: \"\\f016\"; } .fa-clock-o:before { content: \"\\f017\"; } .fa-road:before { content: \"\\f018\"; } .fa-download:before { content: \"\\f019\"; } .fa-arrow-circle-o-down:before { content: \"\\f01a\"; } .fa-arrow-circle-o-up:before { content: \"\\f01b\"; } .fa-inbox:before { content: \"\\f01c\"; } .fa-play-circle-o:before { content: \"\\f01d\"; } .fa-rotate-right:before, .fa-repeat:before { content: \"\\f01e\"; } .fa-refresh:before { content: \"\\f021\"; } .fa-list-alt:before { content: \"\\f022\"; } .fa-lock:before { content: \"\\f023\"; } .fa-flag:before { content: \"\\f024\"; } .fa-headphones:before { content: \"\\f025\"; } .fa-volume-off:before { content: \"\\f026\"; } .fa-volume-down:before { content: \"\\f027\"; } .fa-volume-up:before { content: \"\\f028\"; } .fa-qrcode:before { content: \"\\f029\"; } .fa-barcode:before { content: \"\\f02a\"; } .fa-tag:before { content: \"\\f02b\"; } .fa-tags:before { content: \"\\f02c\"; } .fa-book:before { content: \"\\f02d\"; } .fa-bookmark:before { content: \"\\f02e\"; } .fa-print:before { content: \"\\f02f\"; } .fa-camera:before { content: \"\\f030\"; } .fa-font:before { content: \"\\f031\"; } .fa-bold:before { content: \"\\f032\"; } .fa-italic:before { content: \"\\f033\"; } .fa-text-height:before { content: \"\\f034\"; } .fa-text-width:before { content: \"\\f035\"; } .fa-align-left:before { content: \"\\f036\"; } .fa-align-center:before { content: \"\\f037\"; } .fa-align-right:before { content: \"\\f038\"; } .fa-align-justify:before { content: \"\\f039\"; } .fa-list:before { content: \"\\f03a\"; } .fa-dedent:before, .fa-outdent:before { content: \"\\f03b\"; } .fa-indent:before { content: \"\\f03c\"; } .fa-video-camera:before { content: \"\\f03d\"; } .fa-photo:before, .fa-image:before, .fa-picture-o:before { content: \"\\f03e\"; } .fa-pencil:before { content: \"\\f040\"; } .fa-map-marker:before { content: \"\\f041\"; } .fa-adjust:before { content: \"\\f042\"; } .fa-tint:before { content: \"\\f043\"; } .fa-edit:before, .fa-pencil-square-o:before { content: \"\\f044\"; } .fa-share-square-o:before { content: \"\\f045\"; } .fa-check-square-o:before { content: \"\\f046\"; } .fa-arrows:before { content: \"\\f047\"; } .fa-step-backward:before { content: \"\\f048\"; } .fa-fast-backward:before { content: \"\\f049\"; } .fa-backward:before { content: \"\\f04a\"; } .fa-play:before { content: \"\\f04b\"; } .fa-pause:before { content: \"\\f04c\"; } .fa-stop:before { content: \"\\f04d\"; } .fa-forward:before { content: \"\\f04e\"; } .fa-fast-forward:before { content: \"\\f050\"; } .fa-step-forward:before { content: \"\\f051\"; } .fa-eject:before { content: \"\\f052\"; } .fa-chevron-left:before { content: \"\\f053\"; } .fa-chevron-right:before { content: \"\\f054\"; } .fa-plus-circle:before { content: \"\\f055\"; } .fa-minus-circle:before { content: \"\\f056\"; } .fa-times-circle:before { content: \"\\f057\"; } .fa-check-circle:before { content: \"\\f058\"; } .fa-question-circle:before { content: \"\\f059\"; } .fa-info-circle:before { content: \"\\f05a\"; } .fa-crosshairs:before { content: \"\\f05b\"; } .fa-times-circle-o:before { content: \"\\f05c\"; } .fa-check-circle-o:before { content: \"\\f05d\"; } .fa-ban:before { content: \"\\f05e\"; } .fa-arrow-left:before { content: \"\\f060\"; } .fa-arrow-right:before { content: \"\\f061\"; } .fa-arrow-up:before { content: \"\\f062\"; } .fa-arrow-down:before { content: \"\\f063\"; } .fa-mail-forward:before, .fa-share:before { content: \"\\f064\"; } .fa-expand:before { content: \"\\f065\"; } .fa-compress:before { content: \"\\f066\"; } .fa-plus:before { content: \"\\f067\"; } .fa-minus:before { content: \"\\f068\"; } .fa-asterisk:before { content: \"\\f069\"; } .fa-exclamation-circle:before { content: \"\\f06a\"; } .fa-gift:before { content: \"\\f06b\"; } .fa-leaf:before { content: \"\\f06c\"; } .fa-fire:before { content: \"\\f06d\"; } .fa-eye:before { content: \"\\f06e\"; } .fa-eye-slash:before { content: \"\\f070\"; } .fa-warning:before, .fa-exclamation-triangle:before { content: \"\\f071\"; } .fa-plane:before { content: \"\\f072\"; } .fa-calendar:before { content: \"\\f073\"; } .fa-random:before { content: \"\\f074\"; } .fa-comment:before { content: \"\\f075\"; } .fa-magnet:before { content: \"\\f076\"; } .fa-chevron-up:before { content: \"\\f077\"; } .fa-chevron-down:before { content: \"\\f078\"; } .fa-retweet:before { content: \"\\f079\"; } .fa-shopping-cart:before { content: \"\\f07a\"; } .fa-folder:before { content: \"\\f07b\"; } .fa-folder-open:before { content: \"\\f07c\"; } .fa-arrows-v:before { content: \"\\f07d\"; } .fa-arrows-h:before { content: \"\\f07e\"; } .fa-bar-chart-o:before, .fa-bar-chart:before { content: \"\\f080\"; } .fa-twitter-square:before { content: \"\\f081\"; } .fa-facebook-square:before { content: \"\\f082\"; } .fa-camera-retro:before { content: \"\\f083\"; } .fa-key:before { content: \"\\f084\"; } .fa-gears:before, .fa-cogs:before { content: \"\\f085\"; } .fa-comments:before { content: \"\\f086\"; } .fa-thumbs-o-up:before { content: \"\\f087\"; } .fa-thumbs-o-down:before { content: \"\\f088\"; } .fa-star-half:before { content: \"\\f089\"; } .fa-heart-o:before { content: \"\\f08a\"; } .fa-sign-out:before { content: \"\\f08b\"; } .fa-linkedin-square:before { content: \"\\f08c\"; } .fa-thumb-tack:before { content: \"\\f08d\"; } .fa-external-link:before { content: \"\\f08e\"; } .fa-sign-in:before { content: \"\\f090\"; } .fa-trophy:before { content: \"\\f091\"; } .fa-github-square:before { content: \"\\f092\"; } .fa-upload:before { content: \"\\f093\"; } .fa-lemon-o:before { content: \"\\f094\"; } .fa-phone:before { content: \"\\f095\"; } .fa-square-o:before { content: \"\\f096\"; } .fa-bookmark-o:before { content: \"\\f097\"; } .fa-phone-square:before { content: \"\\f098\"; } .fa-twitter:before { content: \"\\f099\"; } .fa-facebook-f:before, .fa-facebook:before { content: \"\\f09a\"; } .fa-github:before { content: \"\\f09b\"; } .fa-unlock:before { content: \"\\f09c\"; } .fa-credit-card:before { content: \"\\f09d\"; } .fa-feed:before, .fa-rss:before { content: \"\\f09e\"; } .fa-hdd-o:before { content: \"\\f0a0\"; } .fa-bullhorn:before { content: \"\\f0a1\"; } .fa-bell:before { content: \"\\f0f3\"; } .fa-certificate:before { content: \"\\f0a3\"; } .fa-hand-o-right:before { content: \"\\f0a4\"; } .fa-hand-o-left:before { content: \"\\f0a5\"; } .fa-hand-o-up:before { content: \"\\f0a6\"; } .fa-hand-o-down:before { content: \"\\f0a7\"; } .fa-arrow-circle-left:before { content: \"\\f0a8\"; } .fa-arrow-circle-right:before { content: \"\\f0a9\"; } .fa-arrow-circle-up:before { content: \"\\f0aa\"; } .fa-arrow-circle-down:before { content: \"\\f0ab\"; } .fa-globe:before { content: \"\\f0ac\"; } .fa-wrench:before { content: \"\\f0ad\"; } .fa-tasks:before { content: \"\\f0ae\"; } .fa-filter:before { content: \"\\f0b0\"; } .fa-briefcase:before { content: \"\\f0b1\"; } .fa-arrows-alt:before { content: \"\\f0b2\"; } .fa-group:before, .fa-users:before { content: \"\\f0c0\"; } .fa-chain:before, .fa-link:before { content: \"\\f0c1\"; } .fa-cloud:before { content: \"\\f0c2\"; } .fa-flask:before { content: \"\\f0c3\"; } .fa-cut:before, .fa-scissors:before { content: \"\\f0c4\"; } .fa-copy:before, .fa-files-o:before { content: \"\\f0c5\"; } .fa-paperclip:before { content: \"\\f0c6\"; } .fa-save:before, .fa-floppy-o:before { content: \"\\f0c7\"; } .fa-square:before { content: \"\\f0c8\"; } .fa-navicon:before, .fa-reorder:before, .fa-bars:before { content: \"\\f0c9\"; } .fa-list-ul:before { content: \"\\f0ca\"; } .fa-list-ol:before { content: \"\\f0cb\"; } .fa-strikethrough:before { content: \"\\f0cc\"; } .fa-underline:before { content: \"\\f0cd\"; } .fa-table:before { content: \"\\f0ce\"; } .fa-magic:before { content: \"\\f0d0\"; } .fa-truck:before { content: \"\\f0d1\"; } .fa-pinterest:before { content: \"\\f0d2\"; } .fa-pinterest-square:before { content: \"\\f0d3\"; } .fa-google-plus-square:before { content: \"\\f0d4\"; } .fa-google-plus:before { content: \"\\f0d5\"; } .fa-money:before { content: \"\\f0d6\"; } .fa-caret-down:before { content: \"\\f0d7\"; } .fa-caret-up:before { content: \"\\f0d8\"; } .fa-caret-left:before { content: \"\\f0d9\"; } .fa-caret-right:before { content: \"\\f0da\"; } .fa-columns:before { content: \"\\f0db\"; } .fa-unsorted:before, .fa-sort:before { content: \"\\f0dc\"; } .fa-sort-down:before, .fa-sort-desc:before { content: \"\\f0dd\"; } .fa-sort-up:before, .fa-sort-asc:before { content: \"\\f0de\"; } .fa-envelope:before { content: \"\\f0e0\"; } .fa-linkedin:before { content: \"\\f0e1\"; } .fa-rotate-left:before, .fa-undo:before { content: \"\\f0e2\"; } .fa-legal:before, .fa-gavel:before { content: \"\\f0e3\"; } .fa-dashboard:before, .fa-tachometer:before { content: \"\\f0e4\"; } .fa-comment-o:before { content: \"\\f0e5\"; } .fa-comments-o:before { content: \"\\f0e6\"; } .fa-flash:before, .fa-bolt:before { content: \"\\f0e7\"; } .fa-sitemap:before { content: \"\\f0e8\"; } .fa-umbrella:before { content: \"\\f0e9\"; } .fa-paste:before, .fa-clipboard:before { content: \"\\f0ea\"; } .fa-lightbulb-o:before { content: \"\\f0eb\"; } .fa-exchange:before { content: \"\\f0ec\"; } .fa-cloud-download:before { content: \"\\f0ed\"; } .fa-cloud-upload:before { content: \"\\f0ee\"; } .fa-user-md:before { content: \"\\f0f0\"; } .fa-stethoscope:before { content: \"\\f0f1\"; } .fa-suitcase:before { content: \"\\f0f2\"; } .fa-bell-o:before { content: \"\\f0a2\"; } .fa-coffee:before { content: \"\\f0f4\"; } .fa-cutlery:before { content: \"\\f0f5\"; } .fa-file-text-o:before { content: \"\\f0f6\"; } .fa-building-o:before { content: \"\\f0f7\"; } .fa-hospital-o:before { content: \"\\f0f8\"; } .fa-ambulance:before { content: \"\\f0f9\"; } .fa-medkit:before { content: \"\\f0fa\"; } .fa-fighter-jet:before { content: \"\\f0fb\"; } .fa-beer:before { content: \"\\f0fc\"; } .fa-h-square:before { content: \"\\f0fd\"; } .fa-plus-square:before { content: \"\\f0fe\"; } .fa-angle-double-left:before { content: \"\\f100\"; } .fa-angle-double-right:before { content: \"\\f101\"; } .fa-angle-double-up:before { content: \"\\f102\"; } .fa-angle-double-down:before { content: \"\\f103\"; } .fa-angle-left:before { content: \"\\f104\"; } .fa-angle-right:before { content: \"\\f105\"; } .fa-angle-up:before { content: \"\\f106\"; } .fa-angle-down:before { content: \"\\f107\"; } .fa-desktop:before { content: \"\\f108\"; } .fa-laptop:before { content: \"\\f109\"; } .fa-tablet:before { content: \"\\f10a\"; } .fa-mobile-phone:before, .fa-mobile:before { content: \"\\f10b\"; } .fa-circle-o:before { content: \"\\f10c\"; } .fa-quote-left:before { content: \"\\f10d\"; } .fa-quote-right:before { content: \"\\f10e\"; } .fa-spinner:before { content: \"\\f110\"; } .fa-circle:before { content: \"\\f111\"; } .fa-mail-reply:before, .fa-reply:before { content: \"\\f112\"; } .fa-github-alt:before { content: \"\\f113\"; } .fa-folder-o:before { content: \"\\f114\"; } .fa-folder-open-o:before { content: \"\\f115\"; } .fa-smile-o:before { content: \"\\f118\"; } .fa-frown-o:before { content: \"\\f119\"; } .fa-meh-o:before { content: \"\\f11a\"; } .fa-gamepad:before { content: \"\\f11b\"; } .fa-keyboard-o:before { content: \"\\f11c\"; } .fa-flag-o:before { content: \"\\f11d\"; } .fa-flag-checkered:before { content: \"\\f11e\"; } .fa-terminal:before { content: \"\\f120\"; } .fa-code:before { content: \"\\f121\"; } .fa-mail-reply-all:before, .fa-reply-all:before { content: \"\\f122\"; } .fa-star-half-empty:before, .fa-star-half-full:before, .fa-star-half-o:before { content: \"\\f123\"; } .fa-location-arrow:before { content: \"\\f124\"; } .fa-crop:before { content: \"\\f125\"; } .fa-code-fork:before { content: \"\\f126\"; } .fa-unlink:before, .fa-chain-broken:before { content: \"\\f127\"; } .fa-question:before { content: \"\\f128\"; } .fa-info:before { content: \"\\f129\"; } .fa-exclamation:before { content: \"\\f12a\"; } .fa-superscript:before { content: \"\\f12b\"; } .fa-subscript:before { content: \"\\f12c\"; } .fa-eraser:before { content: \"\\f12d\"; } .fa-puzzle-piece:before { content: \"\\f12e\"; } .fa-microphone:before { content: \"\\f130\"; } .fa-microphone-slash:before { content: \"\\f131\"; } .fa-shield:before { content: \"\\f132\"; } .fa-calendar-o:before { content: \"\\f133\"; } .fa-fire-extinguisher:before { content: \"\\f134\"; } .fa-rocket:before { content: \"\\f135\"; } .fa-maxcdn:before { content: \"\\f136\"; } .fa-chevron-circle-left:before { content: \"\\f137\"; } .fa-chevron-circle-right:before { content: \"\\f138\"; } .fa-chevron-circle-up:before { content: \"\\f139\"; } .fa-chevron-circle-down:before { content: \"\\f13a\"; } .fa-html5:before { content: \"\\f13b\"; } .fa-css3:before { content: \"\\f13c\"; } .fa-anchor:before { content: \"\\f13d\"; } .fa-unlock-alt:before { content: \"\\f13e\"; } .fa-bullseye:before { content: \"\\f140\"; } .fa-ellipsis-h:before { content: \"\\f141\"; } .fa-ellipsis-v:before { content: \"\\f142\"; } .fa-rss-square:before { content: \"\\f143\"; } .fa-play-circle:before { content: \"\\f144\"; } .fa-ticket:before { content: \"\\f145\"; } .fa-minus-square:before { content: \"\\f146\"; } .fa-minus-square-o:before { content: \"\\f147\"; } .fa-level-up:before { content: \"\\f148\"; } .fa-level-down:before { content: \"\\f149\"; } .fa-check-square:before { content: \"\\f14a\"; } .fa-pencil-square:before { content: \"\\f14b\"; } .fa-external-link-square:before { content: \"\\f14c\"; } .fa-share-square:before { content: \"\\f14d\"; } .fa-compass:before { content: \"\\f14e\"; } .fa-toggle-down:before, .fa-caret-square-o-down:before { content: \"\\f150\"; } .fa-toggle-up:before, .fa-caret-square-o-up:before { content: \"\\f151\"; } .fa-toggle-right:before, .fa-caret-square-o-right:before { content: \"\\f152\"; } .fa-euro:before, .fa-eur:before { content: \"\\f153\"; } .fa-gbp:before { content: \"\\f154\"; } .fa-dollar:before, .fa-usd:before { content: \"\\f155\"; } .fa-rupee:before, .fa-inr:before { content: \"\\f156\"; } .fa-cny:before, .fa-rmb:before, .fa-yen:before, .fa-jpy:before { content: \"\\f157\"; } .fa-ruble:before, .fa-rouble:before, .fa-rub:before { content: \"\\f158\"; } .fa-won:before, .fa-krw:before { content: \"\\f159\"; } .fa-bitcoin:before, .fa-btc:before { content: \"\\f15a\"; } .fa-file:before { content: \"\\f15b\"; } .fa-file-text:before { content: \"\\f15c\"; } .fa-sort-alpha-asc:before { content: \"\\f15d\"; } .fa-sort-alpha-desc:before { content: \"\\f15e\"; } .fa-sort-amount-asc:before { content: \"\\f160\"; } .fa-sort-amount-desc:before { content: \"\\f161\"; } .fa-sort-numeric-asc:before { content: \"\\f162\"; } .fa-sort-numeric-desc:before { content: \"\\f163\"; } .fa-thumbs-up:before { content: \"\\f164\"; } .fa-thumbs-down:before { content: \"\\f165\"; } .fa-youtube-square:before { content: \"\\f166\"; } .fa-youtube:before { content: \"\\f167\"; } .fa-xing:before { content: \"\\f168\"; } .fa-xing-square:before { content: \"\\f169\"; } .fa-youtube-play:before { content: \"\\f16a\"; } .fa-dropbox:before { content: \"\\f16b\"; } .fa-stack-overflow:before { content: \"\\f16c\"; } .fa-instagram:before { content: \"\\f16d\"; } .fa-flickr:before { content: \"\\f16e\"; } .fa-adn:before { content: \"\\f170\"; } .fa-bitbucket:before { content: \"\\f171\"; } .fa-bitbucket-square:before { content: \"\\f172\"; } .fa-tumblr:before { content: \"\\f173\"; } .fa-tumblr-square:before { content: \"\\f174\"; } .fa-long-arrow-down:before { content: \"\\f175\"; } .fa-long-arrow-up:before { content: \"\\f176\"; } .fa-long-arrow-left:before { content: \"\\f177\"; } .fa-long-arrow-right:before { content: \"\\f178\"; } .fa-apple:before { content: \"\\f179\"; } .fa-windows:before { content: \"\\f17a\"; } .fa-android:before { content: \"\\f17b\"; } .fa-linux:before { content: \"\\f17c\"; } .fa-dribbble:before { content: \"\\f17d\"; } .fa-skype:before { content: \"\\f17e\"; } .fa-foursquare:before { content: \"\\f180\"; } .fa-trello:before { content: \"\\f181\"; } .fa-female:before { content: \"\\f182\"; } .fa-male:before { content: \"\\f183\"; } .fa-gittip:before, .fa-gratipay:before { content: \"\\f184\"; } .fa-sun-o:before { content: \"\\f185\"; } .fa-moon-o:before { content: \"\\f186\"; } .fa-archive:before { content: \"\\f187\"; } .fa-bug:before { content: \"\\f188\"; } .fa-vk:before { content: \"\\f189\"; } .fa-weibo:before { content: \"\\f18a\"; } .fa-renren:before { content: \"\\f18b\"; } .fa-pagelines:before { content: \"\\f18c\"; } .fa-stack-exchange:before { content: \"\\f18d\"; } .fa-arrow-circle-o-right:before { content: \"\\f18e\"; } .fa-arrow-circle-o-left:before { content: \"\\f190\"; } .fa-toggle-left:before, .fa-caret-square-o-left:before { content: \"\\f191\"; } .fa-dot-circle-o:before { content: \"\\f192\"; } .fa-wheelchair:before { content: \"\\f193\"; } .fa-vimeo-square:before { content: \"\\f194\"; } .fa-turkish-lira:before, .fa-try:before { content: \"\\f195\"; } .fa-plus-square-o:before { content: \"\\f196\"; } .fa-space-shuttle:before { content: \"\\f197\"; } .fa-slack:before { content: \"\\f198\"; } .fa-envelope-square:before { content: \"\\f199\"; } .fa-wordpress:before { content: \"\\f19a\"; } .fa-openid:before { content: \"\\f19b\"; } .fa-institution:before, .fa-bank:before, .fa-university:before { content: \"\\f19c\"; } .fa-mortar-board:before, .fa-graduation-cap:before { content: \"\\f19d\"; } .fa-yahoo:before { content: \"\\f19e\"; } .fa-google:before { content: \"\\f1a0\"; } .fa-reddit:before { content: \"\\f1a1\"; } .fa-reddit-square:before { content: \"\\f1a2\"; } .fa-stumbleupon-circle:before { content: \"\\f1a3\"; } .fa-stumbleupon:before { content: \"\\f1a4\"; } .fa-delicious:before { content: \"\\f1a5\"; } .fa-digg:before { content: \"\\f1a6\"; } .fa-pied-piper-pp:before { content: \"\\f1a7\"; } .fa-pied-piper-alt:before { content: \"\\f1a8\"; } .fa-drupal:before { content: \"\\f1a9\"; } .fa-joomla:before { content: \"\\f1aa\"; } .fa-language:before { content: \"\\f1ab\"; } .fa-fax:before { content: \"\\f1ac\"; } .fa-building:before { content: \"\\f1ad\"; } .fa-child:before { content: \"\\f1ae\"; } .fa-paw:before { content: \"\\f1b0\"; } .fa-spoon:before { content: \"\\f1b1\"; } .fa-cube:before { content: \"\\f1b2\"; } .fa-cubes:before { content: \"\\f1b3\"; } .fa-behance:before { content: \"\\f1b4\"; } .fa-behance-square:before { content: \"\\f1b5\"; } .fa-steam:before { content: \"\\f1b6\"; } .fa-steam-square:before { content: \"\\f1b7\"; } .fa-recycle:before { content: \"\\f1b8\"; } .fa-automobile:before, .fa-car:before { content: \"\\f1b9\"; } .fa-cab:before, .fa-taxi:before { content: \"\\f1ba\"; } .fa-tree:before { content: \"\\f1bb\"; } .fa-spotify:before { content: \"\\f1bc\"; } .fa-deviantart:before { content: \"\\f1bd\"; } .fa-soundcloud:before { content: \"\\f1be\"; } .fa-database:before { content: \"\\f1c0\"; } .fa-file-pdf-o:before { content: \"\\f1c1\"; } .fa-file-word-o:before { content: \"\\f1c2\"; } .fa-file-excel-o:before { content: \"\\f1c3\"; } .fa-file-powerpoint-o:before { content: \"\\f1c4\"; } .fa-file-photo-o:before, .fa-file-picture-o:before, .fa-file-image-o:before { content: \"\\f1c5\"; } .fa-file-zip-o:before, .fa-file-archive-o:before { content: \"\\f1c6\"; } .fa-file-sound-o:before, .fa-file-audio-o:before { content: \"\\f1c7\"; } .fa-file-movie-o:before, .fa-file-video-o:before { content: \"\\f1c8\"; } .fa-file-code-o:before { content: \"\\f1c9\"; } .fa-vine:before { content: \"\\f1ca\"; } .fa-codepen:before { content: \"\\f1cb\"; } .fa-jsfiddle:before { content: \"\\f1cc\"; } .fa-life-bouy:before, .fa-life-buoy:before, .fa-life-saver:before, .fa-support:before, .fa-life-ring:before { content: \"\\f1cd\"; } .fa-circle-o-notch:before { content: \"\\f1ce\"; } .fa-ra:before, .fa-resistance:before, .fa-rebel:before { content: \"\\f1d0\"; } .fa-ge:before, .fa-empire:before { content: \"\\f1d1\"; } .fa-git-square:before { content: \"\\f1d2\"; } .fa-git:before { content: \"\\f1d3\"; } .fa-y-combinator-square:before, .fa-yc-square:before, .fa-hacker-news:before { content: \"\\f1d4\"; } .fa-tencent-weibo:before { content: \"\\f1d5\"; } .fa-qq:before { content: \"\\f1d6\"; } .fa-wechat:before, .fa-weixin:before { content: \"\\f1d7\"; } .fa-send:before, .fa-paper-plane:before { content: \"\\f1d8\"; } .fa-send-o:before, .fa-paper-plane-o:before { content: \"\\f1d9\"; } .fa-history:before { content: \"\\f1da\"; } .fa-circle-thin:before { content: \"\\f1db\"; } .fa-header:before { content: \"\\f1dc\"; } .fa-paragraph:before { content: \"\\f1dd\"; } .fa-sliders:before { content: \"\\f1de\"; } .fa-share-alt:before { content: \"\\f1e0\"; } .fa-share-alt-square:before { content: \"\\f1e1\"; } .fa-bomb:before { content: \"\\f1e2\"; } .fa-soccer-ball-o:before, .fa-futbol-o:before { content: \"\\f1e3\"; } .fa-tty:before { content: \"\\f1e4\"; } .fa-binoculars:before { content: \"\\f1e5\"; } .fa-plug:before { content: \"\\f1e6\"; } .fa-slideshare:before { content: \"\\f1e7\"; } .fa-twitch:before { content: \"\\f1e8\"; } .fa-yelp:before { content: \"\\f1e9\"; } .fa-newspaper-o:before { content: \"\\f1ea\"; } .fa-wifi:before { content: \"\\f1eb\"; } .fa-calculator:before { content: \"\\f1ec\"; } .fa-paypal:before { content: \"\\f1ed\"; } .fa-google-wallet:before { content: \"\\f1ee\"; } .fa-cc-visa:before { content: \"\\f1f0\"; } .fa-cc-mastercard:before { content: \"\\f1f1\"; } .fa-cc-discover:before { content: \"\\f1f2\"; } .fa-cc-amex:before { content: \"\\f1f3\"; } .fa-cc-paypal:before { content: \"\\f1f4\"; } .fa-cc-stripe:before { content: \"\\f1f5\"; } .fa-bell-slash:before { content: \"\\f1f6\"; } .fa-bell-slash-o:before { content: \"\\f1f7\"; } .fa-trash:before { content: \"\\f1f8\"; } .fa-copyright:before { content: \"\\f1f9\"; } .fa-at:before { content: \"\\f1fa\"; } .fa-eyedropper:before { content: \"\\f1fb\"; } .fa-paint-brush:before { content: \"\\f1fc\"; } .fa-birthday-cake:before { content: \"\\f1fd\"; } .fa-area-chart:before { content: \"\\f1fe\"; } .fa-pie-chart:before { content: \"\\f200\"; } .fa-line-chart:before { content: \"\\f201\"; } .fa-lastfm:before { content: \"\\f202\"; } .fa-lastfm-square:before { content: \"\\f203\"; } .fa-toggle-off:before { content: \"\\f204\"; } .fa-toggle-on:before { content: \"\\f205\"; } .fa-bicycle:before { content: \"\\f206\"; } .fa-bus:before { content: \"\\f207\"; } .fa-ioxhost:before { content: \"\\f208\"; } .fa-angellist:before { content: \"\\f209\"; } .fa-cc:before { content: \"\\f20a\"; } .fa-shekel:before, .fa-sheqel:before, .fa-ils:before { content: \"\\f20b\"; } .fa-meanpath:before { content: \"\\f20c\"; } .fa-buysellads:before { content: \"\\f20d\"; } .fa-connectdevelop:before { content: \"\\f20e\"; } .fa-dashcube:before { content: \"\\f210\"; } .fa-forumbee:before { content: \"\\f211\"; } .fa-leanpub:before { content: \"\\f212\"; } .fa-sellsy:before { content: \"\\f213\"; } .fa-shirtsinbulk:before { content: \"\\f214\"; } .fa-simplybuilt:before { content: \"\\f215\"; } .fa-skyatlas:before { content: \"\\f216\"; } .fa-cart-plus:before { content: \"\\f217\"; } .fa-cart-arrow-down:before { content: \"\\f218\"; } .fa-diamond:before { content: \"\\f219\"; } .fa-ship:before { content: \"\\f21a\"; } .fa-user-secret:before { content: \"\\f21b\"; } .fa-motorcycle:before { content: \"\\f21c\"; } .fa-street-view:before { content: \"\\f21d\"; } .fa-heartbeat:before { content: \"\\f21e\"; } .fa-venus:before { content: \"\\f221\"; } .fa-mars:before { content: \"\\f222\"; } .fa-mercury:before { content: \"\\f223\"; } .fa-intersex:before, .fa-transgender:before { content: \"\\f224\"; } .fa-transgender-alt:before { content: \"\\f225\"; } .fa-venus-double:before { content: \"\\f226\"; } .fa-mars-double:before { content: \"\\f227\"; } .fa-venus-mars:before { content: \"\\f228\"; } .fa-mars-stroke:before { content: \"\\f229\"; } .fa-mars-stroke-v:before { content: \"\\f22a\"; } .fa-mars-stroke-h:before { content: \"\\f22b\"; } .fa-neuter:before { content: \"\\f22c\"; } .fa-genderless:before { content: \"\\f22d\"; } .fa-facebook-official:before { content: \"\\f230\"; } .fa-pinterest-p:before { content: \"\\f231\"; } .fa-whatsapp:before { content: \"\\f232\"; } .fa-server:before { content: \"\\f233\"; } .fa-user-plus:before { content: \"\\f234\"; } .fa-user-times:before { content: \"\\f235\"; } .fa-hotel:before, .fa-bed:before { content: \"\\f236\"; } .fa-viacoin:before { content: \"\\f237\"; } .fa-train:before { content: \"\\f238\"; } .fa-subway:before { content: \"\\f239\"; } .fa-medium:before { content: \"\\f23a\"; } .fa-yc:before, .fa-y-combinator:before { content: \"\\f23b\"; } .fa-optin-monster:before { content: \"\\f23c\"; } .fa-opencart:before { content: \"\\f23d\"; } .fa-expeditedssl:before { content: \"\\f23e\"; } .fa-battery-4:before, .fa-battery-full:before { content: \"\\f240\"; } .fa-battery-3:before, .fa-battery-three-quarters:before { content: \"\\f241\"; } .fa-battery-2:before, .fa-battery-half:before { content: \"\\f242\"; } .fa-battery-1:before, .fa-battery-quarter:before { content: \"\\f243\"; } .fa-battery-0:before, .fa-battery-empty:before { content: \"\\f244\"; } .fa-mouse-pointer:before { content: \"\\f245\"; } .fa-i-cursor:before { content: \"\\f246\"; } .fa-object-group:before { content: \"\\f247\"; } .fa-object-ungroup:before { content: \"\\f248\"; } .fa-sticky-note:before { content: \"\\f249\"; } .fa-sticky-note-o:before { content: \"\\f24a\"; } .fa-cc-jcb:before { content: \"\\f24b\"; } .fa-cc-diners-club:before { content: \"\\f24c\"; } .fa-clone:before { content: \"\\f24d\"; } .fa-balance-scale:before { content: \"\\f24e\"; } .fa-hourglass-o:before { content: \"\\f250\"; } .fa-hourglass-1:before, .fa-hourglass-start:before { content: \"\\f251\"; } .fa-hourglass-2:before, .fa-hourglass-half:before { content: \"\\f252\"; } .fa-hourglass-3:before, .fa-hourglass-end:before { content: \"\\f253\"; } .fa-hourglass:before { content: \"\\f254\"; } .fa-hand-grab-o:before, .fa-hand-rock-o:before { content: \"\\f255\"; } .fa-hand-stop-o:before, .fa-hand-paper-o:before { content: \"\\f256\"; } .fa-hand-scissors-o:before { content: \"\\f257\"; } .fa-hand-lizard-o:before { content: \"\\f258\"; } .fa-hand-spock-o:before { content: \"\\f259\"; } .fa-hand-pointer-o:before { content: \"\\f25a\"; } .fa-hand-peace-o:before { content: \"\\f25b\"; } .fa-trademark:before { content: \"\\f25c\"; } .fa-registered:before { content: \"\\f25d\"; } .fa-creative-commons:before { content: \"\\f25e\"; } .fa-gg:before { content: \"\\f260\"; } .fa-gg-circle:before { content: \"\\f261\"; } .fa-tripadvisor:before { content: \"\\f262\"; } .fa-odnoklassniki:before { content: \"\\f263\"; } .fa-odnoklassniki-square:before { content: \"\\f264\"; } .fa-get-pocket:before { content: \"\\f265\"; } .fa-wikipedia-w:before { content: \"\\f266\"; } .fa-safari:before { content: \"\\f267\"; } .fa-chrome:before { content: \"\\f268\"; } .fa-firefox:before { content: \"\\f269\"; } .fa-opera:before { content: \"\\f26a\"; } .fa-internet-explorer:before { content: \"\\f26b\"; } .fa-tv:before, .fa-television:before { content: \"\\f26c\"; } .fa-contao:before { content: \"\\f26d\"; } .fa-500px:before { content: \"\\f26e\"; } .fa-amazon:before { content: \"\\f270\"; } .fa-calendar-plus-o:before { content: \"\\f271\"; } .fa-calendar-minus-o:before { content: \"\\f272\"; } .fa-calendar-times-o:before { content: \"\\f273\"; } .fa-calendar-check-o:before { content: \"\\f274\"; } .fa-industry:before { content: \"\\f275\"; } .fa-map-pin:before { content: \"\\f276\"; } .fa-map-signs:before { content: \"\\f277\"; } .fa-map-o:before { content: \"\\f278\"; } .fa-map:before { content: \"\\f279\"; } .fa-commenting:before { content: \"\\f27a\"; } .fa-commenting-o:before { content: \"\\f27b\"; } .fa-houzz:before { content: \"\\f27c\"; } .fa-vimeo:before { content: \"\\f27d\"; } .fa-black-tie:before { content: \"\\f27e\"; } .fa-fonticons:before { content: \"\\f280\"; } .fa-reddit-alien:before { content: \"\\f281\"; } .fa-edge:before { content: \"\\f282\"; } .fa-credit-card-alt:before { content: \"\\f283\"; } .fa-codiepie:before { content: \"\\f284\"; } .fa-modx:before { content: \"\\f285\"; } .fa-fort-awesome:before { content: \"\\f286\"; } .fa-usb:before { content: \"\\f287\"; } .fa-product-hunt:before { content: \"\\f288\"; } .fa-mixcloud:before { content: \"\\f289\"; } .fa-scribd:before { content: \"\\f28a\"; } .fa-pause-circle:before { content: \"\\f28b\"; } .fa-pause-circle-o:before { content: \"\\f28c\"; } .fa-stop-circle:before { content: \"\\f28d\"; } .fa-stop-circle-o:before { content: \"\\f28e\"; } .fa-shopping-bag:before { content: \"\\f290\"; } .fa-shopping-basket:before { content: \"\\f291\"; } .fa-hashtag:before { content: \"\\f292\"; } .fa-bluetooth:before { content: \"\\f293\"; } .fa-bluetooth-b:before { content: \"\\f294\"; } .fa-percent:before { content: \"\\f295\"; } .fa-gitlab:before { content: \"\\f296\"; } .fa-wpbeginner:before { content: \"\\f297\"; } .fa-wpforms:before { content: \"\\f298\"; } .fa-envira:before { content: \"\\f299\"; } .fa-universal-access:before { content: \"\\f29a\"; } .fa-wheelchair-alt:before { content: \"\\f29b\"; } .fa-question-circle-o:before { content: \"\\f29c\"; } .fa-blind:before { content: \"\\f29d\"; } .fa-audio-description:before { content: \"\\f29e\"; } .fa-volume-control-phone:before { content: \"\\f2a0\"; } .fa-braille:before { content: \"\\f2a1\"; } .fa-assistive-listening-systems:before { content: \"\\f2a2\"; } .fa-asl-interpreting:before, .fa-american-sign-language-interpreting:before { content: \"\\f2a3\"; } .fa-deafness:before, .fa-hard-of-hearing:before, .fa-deaf:before { content: \"\\f2a4\"; } .fa-glide:before { content: \"\\f2a5\"; } .fa-glide-g:before { content: \"\\f2a6\"; } .fa-signing:before, .fa-sign-language:before { content: \"\\f2a7\"; } .fa-low-vision:before { content: \"\\f2a8\"; } .fa-viadeo:before { content: \"\\f2a9\"; } .fa-viadeo-square:before { content: \"\\f2aa\"; } .fa-snapchat:before { content: \"\\f2ab\"; } .fa-snapchat-ghost:before { content: \"\\f2ac\"; } .fa-snapchat-square:before { content: \"\\f2ad\"; } .fa-pied-piper:before { content: \"\\f2ae\"; } .fa-first-order:before { content: \"\\f2b0\"; } .fa-yoast:before { content: \"\\f2b1\"; } .fa-themeisle:before { content: \"\\f2b2\"; } .fa-google-plus-circle:before, .fa-google-plus-official:before { content: \"\\f2b3\"; } .fa-fa:before, .fa-font-awesome:before { content: \"\\f2b4\"; } .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; } .sr-only-focusable:active, .sr-only-focusable:focus { position: static; width: auto; height: auto; margin: 0; overflow: visible; clip: auto; }"},{"title":"","date":"2018-10-30T12:50:19.332Z","updated":"2016-05-13T03:44:28.000Z","comments":true,"path":"cv/assets/plugins/font-awesome/css/font-awesome.min.css","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/font-awesome/css/font-awesome.min.css","excerpt":"","text":"/*! * Font Awesome 4.6.3 by @davegandy - http://fontawesome.io - @fontawesome * License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License) */@font-face{font-family:'FontAwesome';src:url('../fonts/fontawesome-webfont.eot?v=4.6.3');src:url('../fonts/fontawesome-webfont.eot?#iefix&v=4.6.3') format('embedded-opentype'),url('../fonts/fontawesome-webfont.woff2?v=4.6.3') format('woff2'),url('../fonts/fontawesome-webfont.woff?v=4.6.3') format('woff'),url('../fonts/fontawesome-webfont.ttf?v=4.6.3') format('truetype'),url('../fonts/fontawesome-webfont.svg?v=4.6.3#fontawesomeregular') format('svg');font-weight:normal;font-style:normal}.fa{display:inline-block;font:normal normal normal 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.33333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.28571429em;text-align:center}.fa-ul{padding-left:0;margin-left:2.14285714em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.14285714em;width:2.14285714em;top:.14285714em;text-align:center}.fa-li.fa-lg{left:-1.85714286em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left{margin-right:.3em}.fa.fa-pull-right{margin-left:.3em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}.fa-rotate-90{-ms-filter:\"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\";-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-ms-filter:\"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\";-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-ms-filter:\"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\";-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-ms-filter:\"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\";-webkit-transform:scale(-1, 1);-ms-transform:scale(-1, 1);transform:scale(-1, 1)}.fa-flip-vertical{-ms-filter:\"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\";-webkit-transform:scale(1, -1);-ms-transform:scale(1, -1);transform:scale(1, -1)}:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-flip-horizontal,:root .fa-flip-vertical{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:\"\\f000\"}.fa-music:before{content:\"\\f001\"}.fa-search:before{content:\"\\f002\"}.fa-envelope-o:before{content:\"\\f003\"}.fa-heart:before{content:\"\\f004\"}.fa-star:before{content:\"\\f005\"}.fa-star-o:before{content:\"\\f006\"}.fa-user:before{content:\"\\f007\"}.fa-film:before{content:\"\\f008\"}.fa-th-large:before{content:\"\\f009\"}.fa-th:before{content:\"\\f00a\"}.fa-th-list:before{content:\"\\f00b\"}.fa-check:before{content:\"\\f00c\"}.fa-remove:before,.fa-close:before,.fa-times:before{content:\"\\f00d\"}.fa-search-plus:before{content:\"\\f00e\"}.fa-search-minus:before{content:\"\\f010\"}.fa-power-off:before{content:\"\\f011\"}.fa-signal:before{content:\"\\f012\"}.fa-gear:before,.fa-cog:before{content:\"\\f013\"}.fa-trash-o:before{content:\"\\f014\"}.fa-home:before{content:\"\\f015\"}.fa-file-o:before{content:\"\\f016\"}.fa-clock-o:before{content:\"\\f017\"}.fa-road:before{content:\"\\f018\"}.fa-download:before{content:\"\\f019\"}.fa-arrow-circle-o-down:before{content:\"\\f01a\"}.fa-arrow-circle-o-up:before{content:\"\\f01b\"}.fa-inbox:before{content:\"\\f01c\"}.fa-play-circle-o:before{content:\"\\f01d\"}.fa-rotate-right:before,.fa-repeat:before{content:\"\\f01e\"}.fa-refresh:before{content:\"\\f021\"}.fa-list-alt:before{content:\"\\f022\"}.fa-lock:before{content:\"\\f023\"}.fa-flag:before{content:\"\\f024\"}.fa-headphones:before{content:\"\\f025\"}.fa-volume-off:before{content:\"\\f026\"}.fa-volume-down:before{content:\"\\f027\"}.fa-volume-up:before{content:\"\\f028\"}.fa-qrcode:before{content:\"\\f029\"}.fa-barcode:before{content:\"\\f02a\"}.fa-tag:before{content:\"\\f02b\"}.fa-tags:before{content:\"\\f02c\"}.fa-book:before{content:\"\\f02d\"}.fa-bookmark:before{content:\"\\f02e\"}.fa-print:before{content:\"\\f02f\"}.fa-camera:before{content:\"\\f030\"}.fa-font:before{content:\"\\f031\"}.fa-bold:before{content:\"\\f032\"}.fa-italic:before{content:\"\\f033\"}.fa-text-height:before{content:\"\\f034\"}.fa-text-width:before{content:\"\\f035\"}.fa-align-left:before{content:\"\\f036\"}.fa-align-center:before{content:\"\\f037\"}.fa-align-right:before{content:\"\\f038\"}.fa-align-justify:before{content:\"\\f039\"}.fa-list:before{content:\"\\f03a\"}.fa-dedent:before,.fa-outdent:before{content:\"\\f03b\"}.fa-indent:before{content:\"\\f03c\"}.fa-video-camera:before{content:\"\\f03d\"}.fa-photo:before,.fa-image:before,.fa-picture-o:before{content:\"\\f03e\"}.fa-pencil:before{content:\"\\f040\"}.fa-map-marker:before{content:\"\\f041\"}.fa-adjust:before{content:\"\\f042\"}.fa-tint:before{content:\"\\f043\"}.fa-edit:before,.fa-pencil-square-o:before{content:\"\\f044\"}.fa-share-square-o:before{content:\"\\f045\"}.fa-check-square-o:before{content:\"\\f046\"}.fa-arrows:before{content:\"\\f047\"}.fa-step-backward:before{content:\"\\f048\"}.fa-fast-backward:before{content:\"\\f049\"}.fa-backward:before{content:\"\\f04a\"}.fa-play:before{content:\"\\f04b\"}.fa-pause:before{content:\"\\f04c\"}.fa-stop:before{content:\"\\f04d\"}.fa-forward:before{content:\"\\f04e\"}.fa-fast-forward:before{content:\"\\f050\"}.fa-step-forward:before{content:\"\\f051\"}.fa-eject:before{content:\"\\f052\"}.fa-chevron-left:before{content:\"\\f053\"}.fa-chevron-right:before{content:\"\\f054\"}.fa-plus-circle:before{content:\"\\f055\"}.fa-minus-circle:before{content:\"\\f056\"}.fa-times-circle:before{content:\"\\f057\"}.fa-check-circle:before{content:\"\\f058\"}.fa-question-circle:before{content:\"\\f059\"}.fa-info-circle:before{content:\"\\f05a\"}.fa-crosshairs:before{content:\"\\f05b\"}.fa-times-circle-o:before{content:\"\\f05c\"}.fa-check-circle-o:before{content:\"\\f05d\"}.fa-ban:before{content:\"\\f05e\"}.fa-arrow-left:before{content:\"\\f060\"}.fa-arrow-right:before{content:\"\\f061\"}.fa-arrow-up:before{content:\"\\f062\"}.fa-arrow-down:before{content:\"\\f063\"}.fa-mail-forward:before,.fa-share:before{content:\"\\f064\"}.fa-expand:before{content:\"\\f065\"}.fa-compress:before{content:\"\\f066\"}.fa-plus:before{content:\"\\f067\"}.fa-minus:before{content:\"\\f068\"}.fa-asterisk:before{content:\"\\f069\"}.fa-exclamation-circle:before{content:\"\\f06a\"}.fa-gift:before{content:\"\\f06b\"}.fa-leaf:before{content:\"\\f06c\"}.fa-fire:before{content:\"\\f06d\"}.fa-eye:before{content:\"\\f06e\"}.fa-eye-slash:before{content:\"\\f070\"}.fa-warning:before,.fa-exclamation-triangle:before{content:\"\\f071\"}.fa-plane:before{content:\"\\f072\"}.fa-calendar:before{content:\"\\f073\"}.fa-random:before{content:\"\\f074\"}.fa-comment:before{content:\"\\f075\"}.fa-magnet:before{content:\"\\f076\"}.fa-chevron-up:before{content:\"\\f077\"}.fa-chevron-down:before{content:\"\\f078\"}.fa-retweet:before{content:\"\\f079\"}.fa-shopping-cart:before{content:\"\\f07a\"}.fa-folder:before{content:\"\\f07b\"}.fa-folder-open:before{content:\"\\f07c\"}.fa-arrows-v:before{content:\"\\f07d\"}.fa-arrows-h:before{content:\"\\f07e\"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:\"\\f080\"}.fa-twitter-square:before{content:\"\\f081\"}.fa-facebook-square:before{content:\"\\f082\"}.fa-camera-retro:before{content:\"\\f083\"}.fa-key:before{content:\"\\f084\"}.fa-gears:before,.fa-cogs:before{content:\"\\f085\"}.fa-comments:before{content:\"\\f086\"}.fa-thumbs-o-up:before{content:\"\\f087\"}.fa-thumbs-o-down:before{content:\"\\f088\"}.fa-star-half:before{content:\"\\f089\"}.fa-heart-o:before{content:\"\\f08a\"}.fa-sign-out:before{content:\"\\f08b\"}.fa-linkedin-square:before{content:\"\\f08c\"}.fa-thumb-tack:before{content:\"\\f08d\"}.fa-external-link:before{content:\"\\f08e\"}.fa-sign-in:before{content:\"\\f090\"}.fa-trophy:before{content:\"\\f091\"}.fa-github-square:before{content:\"\\f092\"}.fa-upload:before{content:\"\\f093\"}.fa-lemon-o:before{content:\"\\f094\"}.fa-phone:before{content:\"\\f095\"}.fa-square-o:before{content:\"\\f096\"}.fa-bookmark-o:before{content:\"\\f097\"}.fa-phone-square:before{content:\"\\f098\"}.fa-twitter:before{content:\"\\f099\"}.fa-facebook-f:before,.fa-facebook:before{content:\"\\f09a\"}.fa-github:before{content:\"\\f09b\"}.fa-unlock:before{content:\"\\f09c\"}.fa-credit-card:before{content:\"\\f09d\"}.fa-feed:before,.fa-rss:before{content:\"\\f09e\"}.fa-hdd-o:before{content:\"\\f0a0\"}.fa-bullhorn:before{content:\"\\f0a1\"}.fa-bell:before{content:\"\\f0f3\"}.fa-certificate:before{content:\"\\f0a3\"}.fa-hand-o-right:before{content:\"\\f0a4\"}.fa-hand-o-left:before{content:\"\\f0a5\"}.fa-hand-o-up:before{content:\"\\f0a6\"}.fa-hand-o-down:before{content:\"\\f0a7\"}.fa-arrow-circle-left:before{content:\"\\f0a8\"}.fa-arrow-circle-right:before{content:\"\\f0a9\"}.fa-arrow-circle-up:before{content:\"\\f0aa\"}.fa-arrow-circle-down:before{content:\"\\f0ab\"}.fa-globe:before{content:\"\\f0ac\"}.fa-wrench:before{content:\"\\f0ad\"}.fa-tasks:before{content:\"\\f0ae\"}.fa-filter:before{content:\"\\f0b0\"}.fa-briefcase:before{content:\"\\f0b1\"}.fa-arrows-alt:before{content:\"\\f0b2\"}.fa-group:before,.fa-users:before{content:\"\\f0c0\"}.fa-chain:before,.fa-link:before{content:\"\\f0c1\"}.fa-cloud:before{content:\"\\f0c2\"}.fa-flask:before{content:\"\\f0c3\"}.fa-cut:before,.fa-scissors:before{content:\"\\f0c4\"}.fa-copy:before,.fa-files-o:before{content:\"\\f0c5\"}.fa-paperclip:before{content:\"\\f0c6\"}.fa-save:before,.fa-floppy-o:before{content:\"\\f0c7\"}.fa-square:before{content:\"\\f0c8\"}.fa-navicon:before,.fa-reorder:before,.fa-bars:before{content:\"\\f0c9\"}.fa-list-ul:before{content:\"\\f0ca\"}.fa-list-ol:before{content:\"\\f0cb\"}.fa-strikethrough:before{content:\"\\f0cc\"}.fa-underline:before{content:\"\\f0cd\"}.fa-table:before{content:\"\\f0ce\"}.fa-magic:before{content:\"\\f0d0\"}.fa-truck:before{content:\"\\f0d1\"}.fa-pinterest:before{content:\"\\f0d2\"}.fa-pinterest-square:before{content:\"\\f0d3\"}.fa-google-plus-square:before{content:\"\\f0d4\"}.fa-google-plus:before{content:\"\\f0d5\"}.fa-money:before{content:\"\\f0d6\"}.fa-caret-down:before{content:\"\\f0d7\"}.fa-caret-up:before{content:\"\\f0d8\"}.fa-caret-left:before{content:\"\\f0d9\"}.fa-caret-right:before{content:\"\\f0da\"}.fa-columns:before{content:\"\\f0db\"}.fa-unsorted:before,.fa-sort:before{content:\"\\f0dc\"}.fa-sort-down:before,.fa-sort-desc:before{content:\"\\f0dd\"}.fa-sort-up:before,.fa-sort-asc:before{content:\"\\f0de\"}.fa-envelope:before{content:\"\\f0e0\"}.fa-linkedin:before{content:\"\\f0e1\"}.fa-rotate-left:before,.fa-undo:before{content:\"\\f0e2\"}.fa-legal:before,.fa-gavel:before{content:\"\\f0e3\"}.fa-dashboard:before,.fa-tachometer:before{content:\"\\f0e4\"}.fa-comment-o:before{content:\"\\f0e5\"}.fa-comments-o:before{content:\"\\f0e6\"}.fa-flash:before,.fa-bolt:before{content:\"\\f0e7\"}.fa-sitemap:before{content:\"\\f0e8\"}.fa-umbrella:before{content:\"\\f0e9\"}.fa-paste:before,.fa-clipboard:before{content:\"\\f0ea\"}.fa-lightbulb-o:before{content:\"\\f0eb\"}.fa-exchange:before{content:\"\\f0ec\"}.fa-cloud-download:before{content:\"\\f0ed\"}.fa-cloud-upload:before{content:\"\\f0ee\"}.fa-user-md:before{content:\"\\f0f0\"}.fa-stethoscope:before{content:\"\\f0f1\"}.fa-suitcase:before{content:\"\\f0f2\"}.fa-bell-o:before{content:\"\\f0a2\"}.fa-coffee:before{content:\"\\f0f4\"}.fa-cutlery:before{content:\"\\f0f5\"}.fa-file-text-o:before{content:\"\\f0f6\"}.fa-building-o:before{content:\"\\f0f7\"}.fa-hospital-o:before{content:\"\\f0f8\"}.fa-ambulance:before{content:\"\\f0f9\"}.fa-medkit:before{content:\"\\f0fa\"}.fa-fighter-jet:before{content:\"\\f0fb\"}.fa-beer:before{content:\"\\f0fc\"}.fa-h-square:before{content:\"\\f0fd\"}.fa-plus-square:before{content:\"\\f0fe\"}.fa-angle-double-left:before{content:\"\\f100\"}.fa-angle-double-right:before{content:\"\\f101\"}.fa-angle-double-up:before{content:\"\\f102\"}.fa-angle-double-down:before{content:\"\\f103\"}.fa-angle-left:before{content:\"\\f104\"}.fa-angle-right:before{content:\"\\f105\"}.fa-angle-up:before{content:\"\\f106\"}.fa-angle-down:before{content:\"\\f107\"}.fa-desktop:before{content:\"\\f108\"}.fa-laptop:before{content:\"\\f109\"}.fa-tablet:before{content:\"\\f10a\"}.fa-mobile-phone:before,.fa-mobile:before{content:\"\\f10b\"}.fa-circle-o:before{content:\"\\f10c\"}.fa-quote-left:before{content:\"\\f10d\"}.fa-quote-right:before{content:\"\\f10e\"}.fa-spinner:before{content:\"\\f110\"}.fa-circle:before{content:\"\\f111\"}.fa-mail-reply:before,.fa-reply:before{content:\"\\f112\"}.fa-github-alt:before{content:\"\\f113\"}.fa-folder-o:before{content:\"\\f114\"}.fa-folder-open-o:before{content:\"\\f115\"}.fa-smile-o:before{content:\"\\f118\"}.fa-frown-o:before{content:\"\\f119\"}.fa-meh-o:before{content:\"\\f11a\"}.fa-gamepad:before{content:\"\\f11b\"}.fa-keyboard-o:before{content:\"\\f11c\"}.fa-flag-o:before{content:\"\\f11d\"}.fa-flag-checkered:before{content:\"\\f11e\"}.fa-terminal:before{content:\"\\f120\"}.fa-code:before{content:\"\\f121\"}.fa-mail-reply-all:before,.fa-reply-all:before{content:\"\\f122\"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:\"\\f123\"}.fa-location-arrow:before{content:\"\\f124\"}.fa-crop:before{content:\"\\f125\"}.fa-code-fork:before{content:\"\\f126\"}.fa-unlink:before,.fa-chain-broken:before{content:\"\\f127\"}.fa-question:before{content:\"\\f128\"}.fa-info:before{content:\"\\f129\"}.fa-exclamation:before{content:\"\\f12a\"}.fa-superscript:before{content:\"\\f12b\"}.fa-subscript:before{content:\"\\f12c\"}.fa-eraser:before{content:\"\\f12d\"}.fa-puzzle-piece:before{content:\"\\f12e\"}.fa-microphone:before{content:\"\\f130\"}.fa-microphone-slash:before{content:\"\\f131\"}.fa-shield:before{content:\"\\f132\"}.fa-calendar-o:before{content:\"\\f133\"}.fa-fire-extinguisher:before{content:\"\\f134\"}.fa-rocket:before{content:\"\\f135\"}.fa-maxcdn:before{content:\"\\f136\"}.fa-chevron-circle-left:before{content:\"\\f137\"}.fa-chevron-circle-right:before{content:\"\\f138\"}.fa-chevron-circle-up:before{content:\"\\f139\"}.fa-chevron-circle-down:before{content:\"\\f13a\"}.fa-html5:before{content:\"\\f13b\"}.fa-css3:before{content:\"\\f13c\"}.fa-anchor:before{content:\"\\f13d\"}.fa-unlock-alt:before{content:\"\\f13e\"}.fa-bullseye:before{content:\"\\f140\"}.fa-ellipsis-h:before{content:\"\\f141\"}.fa-ellipsis-v:before{content:\"\\f142\"}.fa-rss-square:before{content:\"\\f143\"}.fa-play-circle:before{content:\"\\f144\"}.fa-ticket:before{content:\"\\f145\"}.fa-minus-square:before{content:\"\\f146\"}.fa-minus-square-o:before{content:\"\\f147\"}.fa-level-up:before{content:\"\\f148\"}.fa-level-down:before{content:\"\\f149\"}.fa-check-square:before{content:\"\\f14a\"}.fa-pencil-square:before{content:\"\\f14b\"}.fa-external-link-square:before{content:\"\\f14c\"}.fa-share-square:before{content:\"\\f14d\"}.fa-compass:before{content:\"\\f14e\"}.fa-toggle-down:before,.fa-caret-square-o-down:before{content:\"\\f150\"}.fa-toggle-up:before,.fa-caret-square-o-up:before{content:\"\\f151\"}.fa-toggle-right:before,.fa-caret-square-o-right:before{content:\"\\f152\"}.fa-euro:before,.fa-eur:before{content:\"\\f153\"}.fa-gbp:before{content:\"\\f154\"}.fa-dollar:before,.fa-usd:before{content:\"\\f155\"}.fa-rupee:before,.fa-inr:before{content:\"\\f156\"}.fa-cny:before,.fa-rmb:before,.fa-yen:before,.fa-jpy:before{content:\"\\f157\"}.fa-ruble:before,.fa-rouble:before,.fa-rub:before{content:\"\\f158\"}.fa-won:before,.fa-krw:before{content:\"\\f159\"}.fa-bitcoin:before,.fa-btc:before{content:\"\\f15a\"}.fa-file:before{content:\"\\f15b\"}.fa-file-text:before{content:\"\\f15c\"}.fa-sort-alpha-asc:before{content:\"\\f15d\"}.fa-sort-alpha-desc:before{content:\"\\f15e\"}.fa-sort-amount-asc:before{content:\"\\f160\"}.fa-sort-amount-desc:before{content:\"\\f161\"}.fa-sort-numeric-asc:before{content:\"\\f162\"}.fa-sort-numeric-desc:before{content:\"\\f163\"}.fa-thumbs-up:before{content:\"\\f164\"}.fa-thumbs-down:before{content:\"\\f165\"}.fa-youtube-square:before{content:\"\\f166\"}.fa-youtube:before{content:\"\\f167\"}.fa-xing:before{content:\"\\f168\"}.fa-xing-square:before{content:\"\\f169\"}.fa-youtube-play:before{content:\"\\f16a\"}.fa-dropbox:before{content:\"\\f16b\"}.fa-stack-overflow:before{content:\"\\f16c\"}.fa-instagram:before{content:\"\\f16d\"}.fa-flickr:before{content:\"\\f16e\"}.fa-adn:before{content:\"\\f170\"}.fa-bitbucket:before{content:\"\\f171\"}.fa-bitbucket-square:before{content:\"\\f172\"}.fa-tumblr:before{content:\"\\f173\"}.fa-tumblr-square:before{content:\"\\f174\"}.fa-long-arrow-down:before{content:\"\\f175\"}.fa-long-arrow-up:before{content:\"\\f176\"}.fa-long-arrow-left:before{content:\"\\f177\"}.fa-long-arrow-right:before{content:\"\\f178\"}.fa-apple:before{content:\"\\f179\"}.fa-windows:before{content:\"\\f17a\"}.fa-android:before{content:\"\\f17b\"}.fa-linux:before{content:\"\\f17c\"}.fa-dribbble:before{content:\"\\f17d\"}.fa-skype:before{content:\"\\f17e\"}.fa-foursquare:before{content:\"\\f180\"}.fa-trello:before{content:\"\\f181\"}.fa-female:before{content:\"\\f182\"}.fa-male:before{content:\"\\f183\"}.fa-gittip:before,.fa-gratipay:before{content:\"\\f184\"}.fa-sun-o:before{content:\"\\f185\"}.fa-moon-o:before{content:\"\\f186\"}.fa-archive:before{content:\"\\f187\"}.fa-bug:before{content:\"\\f188\"}.fa-vk:before{content:\"\\f189\"}.fa-weibo:before{content:\"\\f18a\"}.fa-renren:before{content:\"\\f18b\"}.fa-pagelines:before{content:\"\\f18c\"}.fa-stack-exchange:before{content:\"\\f18d\"}.fa-arrow-circle-o-right:before{content:\"\\f18e\"}.fa-arrow-circle-o-left:before{content:\"\\f190\"}.fa-toggle-left:before,.fa-caret-square-o-left:before{content:\"\\f191\"}.fa-dot-circle-o:before{content:\"\\f192\"}.fa-wheelchair:before{content:\"\\f193\"}.fa-vimeo-square:before{content:\"\\f194\"}.fa-turkish-lira:before,.fa-try:before{content:\"\\f195\"}.fa-plus-square-o:before{content:\"\\f196\"}.fa-space-shuttle:before{content:\"\\f197\"}.fa-slack:before{content:\"\\f198\"}.fa-envelope-square:before{content:\"\\f199\"}.fa-wordpress:before{content:\"\\f19a\"}.fa-openid:before{content:\"\\f19b\"}.fa-institution:before,.fa-bank:before,.fa-university:before{content:\"\\f19c\"}.fa-mortar-board:before,.fa-graduation-cap:before{content:\"\\f19d\"}.fa-yahoo:before{content:\"\\f19e\"}.fa-google:before{content:\"\\f1a0\"}.fa-reddit:before{content:\"\\f1a1\"}.fa-reddit-square:before{content:\"\\f1a2\"}.fa-stumbleupon-circle:before{content:\"\\f1a3\"}.fa-stumbleupon:before{content:\"\\f1a4\"}.fa-delicious:before{content:\"\\f1a5\"}.fa-digg:before{content:\"\\f1a6\"}.fa-pied-piper-pp:before{content:\"\\f1a7\"}.fa-pied-piper-alt:before{content:\"\\f1a8\"}.fa-drupal:before{content:\"\\f1a9\"}.fa-joomla:before{content:\"\\f1aa\"}.fa-language:before{content:\"\\f1ab\"}.fa-fax:before{content:\"\\f1ac\"}.fa-building:before{content:\"\\f1ad\"}.fa-child:before{content:\"\\f1ae\"}.fa-paw:before{content:\"\\f1b0\"}.fa-spoon:before{content:\"\\f1b1\"}.fa-cube:before{content:\"\\f1b2\"}.fa-cubes:before{content:\"\\f1b3\"}.fa-behance:before{content:\"\\f1b4\"}.fa-behance-square:before{content:\"\\f1b5\"}.fa-steam:before{content:\"\\f1b6\"}.fa-steam-square:before{content:\"\\f1b7\"}.fa-recycle:before{content:\"\\f1b8\"}.fa-automobile:before,.fa-car:before{content:\"\\f1b9\"}.fa-cab:before,.fa-taxi:before{content:\"\\f1ba\"}.fa-tree:before{content:\"\\f1bb\"}.fa-spotify:before{content:\"\\f1bc\"}.fa-deviantart:before{content:\"\\f1bd\"}.fa-soundcloud:before{content:\"\\f1be\"}.fa-database:before{content:\"\\f1c0\"}.fa-file-pdf-o:before{content:\"\\f1c1\"}.fa-file-word-o:before{content:\"\\f1c2\"}.fa-file-excel-o:before{content:\"\\f1c3\"}.fa-file-powerpoint-o:before{content:\"\\f1c4\"}.fa-file-photo-o:before,.fa-file-picture-o:before,.fa-file-image-o:before{content:\"\\f1c5\"}.fa-file-zip-o:before,.fa-file-archive-o:before{content:\"\\f1c6\"}.fa-file-sound-o:before,.fa-file-audio-o:before{content:\"\\f1c7\"}.fa-file-movie-o:before,.fa-file-video-o:before{content:\"\\f1c8\"}.fa-file-code-o:before{content:\"\\f1c9\"}.fa-vine:before{content:\"\\f1ca\"}.fa-codepen:before{content:\"\\f1cb\"}.fa-jsfiddle:before{content:\"\\f1cc\"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-saver:before,.fa-support:before,.fa-life-ring:before{content:\"\\f1cd\"}.fa-circle-o-notch:before{content:\"\\f1ce\"}.fa-ra:before,.fa-resistance:before,.fa-rebel:before{content:\"\\f1d0\"}.fa-ge:before,.fa-empire:before{content:\"\\f1d1\"}.fa-git-square:before{content:\"\\f1d2\"}.fa-git:before{content:\"\\f1d3\"}.fa-y-combinator-square:before,.fa-yc-square:before,.fa-hacker-news:before{content:\"\\f1d4\"}.fa-tencent-weibo:before{content:\"\\f1d5\"}.fa-qq:before{content:\"\\f1d6\"}.fa-wechat:before,.fa-weixin:before{content:\"\\f1d7\"}.fa-send:before,.fa-paper-plane:before{content:\"\\f1d8\"}.fa-send-o:before,.fa-paper-plane-o:before{content:\"\\f1d9\"}.fa-history:before{content:\"\\f1da\"}.fa-circle-thin:before{content:\"\\f1db\"}.fa-header:before{content:\"\\f1dc\"}.fa-paragraph:before{content:\"\\f1dd\"}.fa-sliders:before{content:\"\\f1de\"}.fa-share-alt:before{content:\"\\f1e0\"}.fa-share-alt-square:before{content:\"\\f1e1\"}.fa-bomb:before{content:\"\\f1e2\"}.fa-soccer-ball-o:before,.fa-futbol-o:before{content:\"\\f1e3\"}.fa-tty:before{content:\"\\f1e4\"}.fa-binoculars:before{content:\"\\f1e5\"}.fa-plug:before{content:\"\\f1e6\"}.fa-slideshare:before{content:\"\\f1e7\"}.fa-twitch:before{content:\"\\f1e8\"}.fa-yelp:before{content:\"\\f1e9\"}.fa-newspaper-o:before{content:\"\\f1ea\"}.fa-wifi:before{content:\"\\f1eb\"}.fa-calculator:before{content:\"\\f1ec\"}.fa-paypal:before{content:\"\\f1ed\"}.fa-google-wallet:before{content:\"\\f1ee\"}.fa-cc-visa:before{content:\"\\f1f0\"}.fa-cc-mastercard:before{content:\"\\f1f1\"}.fa-cc-discover:before{content:\"\\f1f2\"}.fa-cc-amex:before{content:\"\\f1f3\"}.fa-cc-paypal:before{content:\"\\f1f4\"}.fa-cc-stripe:before{content:\"\\f1f5\"}.fa-bell-slash:before{content:\"\\f1f6\"}.fa-bell-slash-o:before{content:\"\\f1f7\"}.fa-trash:before{content:\"\\f1f8\"}.fa-copyright:before{content:\"\\f1f9\"}.fa-at:before{content:\"\\f1fa\"}.fa-eyedropper:before{content:\"\\f1fb\"}.fa-paint-brush:before{content:\"\\f1fc\"}.fa-birthday-cake:before{content:\"\\f1fd\"}.fa-area-chart:before{content:\"\\f1fe\"}.fa-pie-chart:before{content:\"\\f200\"}.fa-line-chart:before{content:\"\\f201\"}.fa-lastfm:before{content:\"\\f202\"}.fa-lastfm-square:before{content:\"\\f203\"}.fa-toggle-off:before{content:\"\\f204\"}.fa-toggle-on:before{content:\"\\f205\"}.fa-bicycle:before{content:\"\\f206\"}.fa-bus:before{content:\"\\f207\"}.fa-ioxhost:before{content:\"\\f208\"}.fa-angellist:before{content:\"\\f209\"}.fa-cc:before{content:\"\\f20a\"}.fa-shekel:before,.fa-sheqel:before,.fa-ils:before{content:\"\\f20b\"}.fa-meanpath:before{content:\"\\f20c\"}.fa-buysellads:before{content:\"\\f20d\"}.fa-connectdevelop:before{content:\"\\f20e\"}.fa-dashcube:before{content:\"\\f210\"}.fa-forumbee:before{content:\"\\f211\"}.fa-leanpub:before{content:\"\\f212\"}.fa-sellsy:before{content:\"\\f213\"}.fa-shirtsinbulk:before{content:\"\\f214\"}.fa-simplybuilt:before{content:\"\\f215\"}.fa-skyatlas:before{content:\"\\f216\"}.fa-cart-plus:before{content:\"\\f217\"}.fa-cart-arrow-down:before{content:\"\\f218\"}.fa-diamond:before{content:\"\\f219\"}.fa-ship:before{content:\"\\f21a\"}.fa-user-secret:before{content:\"\\f21b\"}.fa-motorcycle:before{content:\"\\f21c\"}.fa-street-view:before{content:\"\\f21d\"}.fa-heartbeat:before{content:\"\\f21e\"}.fa-venus:before{content:\"\\f221\"}.fa-mars:before{content:\"\\f222\"}.fa-mercury:before{content:\"\\f223\"}.fa-intersex:before,.fa-transgender:before{content:\"\\f224\"}.fa-transgender-alt:before{content:\"\\f225\"}.fa-venus-double:before{content:\"\\f226\"}.fa-mars-double:before{content:\"\\f227\"}.fa-venus-mars:before{content:\"\\f228\"}.fa-mars-stroke:before{content:\"\\f229\"}.fa-mars-stroke-v:before{content:\"\\f22a\"}.fa-mars-stroke-h:before{content:\"\\f22b\"}.fa-neuter:before{content:\"\\f22c\"}.fa-genderless:before{content:\"\\f22d\"}.fa-facebook-official:before{content:\"\\f230\"}.fa-pinterest-p:before{content:\"\\f231\"}.fa-whatsapp:before{content:\"\\f232\"}.fa-server:before{content:\"\\f233\"}.fa-user-plus:before{content:\"\\f234\"}.fa-user-times:before{content:\"\\f235\"}.fa-hotel:before,.fa-bed:before{content:\"\\f236\"}.fa-viacoin:before{content:\"\\f237\"}.fa-train:before{content:\"\\f238\"}.fa-subway:before{content:\"\\f239\"}.fa-medium:before{content:\"\\f23a\"}.fa-yc:before,.fa-y-combinator:before{content:\"\\f23b\"}.fa-optin-monster:before{content:\"\\f23c\"}.fa-opencart:before{content:\"\\f23d\"}.fa-expeditedssl:before{content:\"\\f23e\"}.fa-battery-4:before,.fa-battery-full:before{content:\"\\f240\"}.fa-battery-3:before,.fa-battery-three-quarters:before{content:\"\\f241\"}.fa-battery-2:before,.fa-battery-half:before{content:\"\\f242\"}.fa-battery-1:before,.fa-battery-quarter:before{content:\"\\f243\"}.fa-battery-0:before,.fa-battery-empty:before{content:\"\\f244\"}.fa-mouse-pointer:before{content:\"\\f245\"}.fa-i-cursor:before{content:\"\\f246\"}.fa-object-group:before{content:\"\\f247\"}.fa-object-ungroup:before{content:\"\\f248\"}.fa-sticky-note:before{content:\"\\f249\"}.fa-sticky-note-o:before{content:\"\\f24a\"}.fa-cc-jcb:before{content:\"\\f24b\"}.fa-cc-diners-club:before{content:\"\\f24c\"}.fa-clone:before{content:\"\\f24d\"}.fa-balance-scale:before{content:\"\\f24e\"}.fa-hourglass-o:before{content:\"\\f250\"}.fa-hourglass-1:before,.fa-hourglass-start:before{content:\"\\f251\"}.fa-hourglass-2:before,.fa-hourglass-half:before{content:\"\\f252\"}.fa-hourglass-3:before,.fa-hourglass-end:before{content:\"\\f253\"}.fa-hourglass:before{content:\"\\f254\"}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:\"\\f255\"}.fa-hand-stop-o:before,.fa-hand-paper-o:before{content:\"\\f256\"}.fa-hand-scissors-o:before{content:\"\\f257\"}.fa-hand-lizard-o:before{content:\"\\f258\"}.fa-hand-spock-o:before{content:\"\\f259\"}.fa-hand-pointer-o:before{content:\"\\f25a\"}.fa-hand-peace-o:before{content:\"\\f25b\"}.fa-trademark:before{content:\"\\f25c\"}.fa-registered:before{content:\"\\f25d\"}.fa-creative-commons:before{content:\"\\f25e\"}.fa-gg:before{content:\"\\f260\"}.fa-gg-circle:before{content:\"\\f261\"}.fa-tripadvisor:before{content:\"\\f262\"}.fa-odnoklassniki:before{content:\"\\f263\"}.fa-odnoklassniki-square:before{content:\"\\f264\"}.fa-get-pocket:before{content:\"\\f265\"}.fa-wikipedia-w:before{content:\"\\f266\"}.fa-safari:before{content:\"\\f267\"}.fa-chrome:before{content:\"\\f268\"}.fa-firefox:before{content:\"\\f269\"}.fa-opera:before{content:\"\\f26a\"}.fa-internet-explorer:before{content:\"\\f26b\"}.fa-tv:before,.fa-television:before{content:\"\\f26c\"}.fa-contao:before{content:\"\\f26d\"}.fa-500px:before{content:\"\\f26e\"}.fa-amazon:before{content:\"\\f270\"}.fa-calendar-plus-o:before{content:\"\\f271\"}.fa-calendar-minus-o:before{content:\"\\f272\"}.fa-calendar-times-o:before{content:\"\\f273\"}.fa-calendar-check-o:before{content:\"\\f274\"}.fa-industry:before{content:\"\\f275\"}.fa-map-pin:before{content:\"\\f276\"}.fa-map-signs:before{content:\"\\f277\"}.fa-map-o:before{content:\"\\f278\"}.fa-map:before{content:\"\\f279\"}.fa-commenting:before{content:\"\\f27a\"}.fa-commenting-o:before{content:\"\\f27b\"}.fa-houzz:before{content:\"\\f27c\"}.fa-vimeo:before{content:\"\\f27d\"}.fa-black-tie:before{content:\"\\f27e\"}.fa-fonticons:before{content:\"\\f280\"}.fa-reddit-alien:before{content:\"\\f281\"}.fa-edge:before{content:\"\\f282\"}.fa-credit-card-alt:before{content:\"\\f283\"}.fa-codiepie:before{content:\"\\f284\"}.fa-modx:before{content:\"\\f285\"}.fa-fort-awesome:before{content:\"\\f286\"}.fa-usb:before{content:\"\\f287\"}.fa-product-hunt:before{content:\"\\f288\"}.fa-mixcloud:before{content:\"\\f289\"}.fa-scribd:before{content:\"\\f28a\"}.fa-pause-circle:before{content:\"\\f28b\"}.fa-pause-circle-o:before{content:\"\\f28c\"}.fa-stop-circle:before{content:\"\\f28d\"}.fa-stop-circle-o:before{content:\"\\f28e\"}.fa-shopping-bag:before{content:\"\\f290\"}.fa-shopping-basket:before{content:\"\\f291\"}.fa-hashtag:before{content:\"\\f292\"}.fa-bluetooth:before{content:\"\\f293\"}.fa-bluetooth-b:before{content:\"\\f294\"}.fa-percent:before{content:\"\\f295\"}.fa-gitlab:before{content:\"\\f296\"}.fa-wpbeginner:before{content:\"\\f297\"}.fa-wpforms:before{content:\"\\f298\"}.fa-envira:before{content:\"\\f299\"}.fa-universal-access:before{content:\"\\f29a\"}.fa-wheelchair-alt:before{content:\"\\f29b\"}.fa-question-circle-o:before{content:\"\\f29c\"}.fa-blind:before{content:\"\\f29d\"}.fa-audio-description:before{content:\"\\f29e\"}.fa-volume-control-phone:before{content:\"\\f2a0\"}.fa-braille:before{content:\"\\f2a1\"}.fa-assistive-listening-systems:before{content:\"\\f2a2\"}.fa-asl-interpreting:before,.fa-american-sign-language-interpreting:before{content:\"\\f2a3\"}.fa-deafness:before,.fa-hard-of-hearing:before,.fa-deaf:before{content:\"\\f2a4\"}.fa-glide:before{content:\"\\f2a5\"}.fa-glide-g:before{content:\"\\f2a6\"}.fa-signing:before,.fa-sign-language:before{content:\"\\f2a7\"}.fa-low-vision:before{content:\"\\f2a8\"}.fa-viadeo:before{content:\"\\f2a9\"}.fa-viadeo-square:before{content:\"\\f2aa\"}.fa-snapchat:before{content:\"\\f2ab\"}.fa-snapchat-ghost:before{content:\"\\f2ac\"}.fa-snapchat-square:before{content:\"\\f2ad\"}.fa-pied-piper:before{content:\"\\f2ae\"}.fa-first-order:before{content:\"\\f2b0\"}.fa-yoast:before{content:\"\\f2b1\"}.fa-themeisle:before{content:\"\\f2b2\"}.fa-google-plus-circle:before,.fa-google-plus-official:before{content:\"\\f2b3\"}.fa-fa:before,.fa-font-awesome:before{content:\"\\f2b4\"}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}"},{"title":"","date":"2018-10-30T12:50:19.297Z","updated":"2016-09-30T02:46:05.952Z","comments":true,"path":"cv/assets/plugins/bootstrap/css/bootstrap.min.css","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/bootstrap/css/bootstrap.min.css","excerpt":"","text":"/*! * Bootstrap v3.3.7 (http://getbootstrap.com) * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) *//*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0;font-size:2em}mark{color:#000;background:#ff0}small{font-size:80%}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{height:0;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{margin:0;font:inherit;color:inherit}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input{line-height:normal}input[type=checkbox],input[type=radio]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{padding:.35em .625em .75em;margin:0 2px;border:1px solid silver}legend{padding:0;border:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-spacing:0;border-collapse:collapse}td,th{padding:0}/*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */@media print{*,:after,:before{color:#000!important;text-shadow:none!important;background:0 0!important;-webkit-box-shadow:none!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href) \")\"}abbr[title]:after{content:\" (\" attr(title) \")\"}a[href^=\"javascript:\"]:after,a[href^=\"#\"]:after{content:\"\"}blockquote,pre{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}.navbar{display:none}.btn>.caret,.dropup>.btn>.caret{border-top-color:#000!important}.label{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #ddd!important}}@font-face{font-family:'Glyphicons Halflings';src:url(../fonts/glyphicons-halflings-regular.eot);src:url(../fonts/glyphicons-halflings-regular.eot?#iefix) format('embedded-opentype'),url(../fonts/glyphicons-halflings-regular.woff2) format('woff2'),url(../fonts/glyphicons-halflings-regular.woff) format('woff'),url(../fonts/glyphicons-halflings-regular.ttf) format('truetype'),url(../fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular) format('svg')}.glyphicon{position:relative;top:1px;display:inline-block;font-family:'Glyphicons Halflings';font-style:normal;font-weight:400;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.glyphicon-asterisk:before{content:\"\\002a\"}.glyphicon-plus:before{content:\"\\002b\"}.glyphicon-eur:before,.glyphicon-euro:before{content:\"\\20ac\"}.glyphicon-minus:before{content:\"\\2212\"}.glyphicon-cloud:before{content:\"\\2601\"}.glyphicon-envelope:before{content:\"\\2709\"}.glyphicon-pencil:before{content:\"\\270f\"}.glyphicon-glass:before{content:\"\\e001\"}.glyphicon-music:before{content:\"\\e002\"}.glyphicon-search:before{content:\"\\e003\"}.glyphicon-heart:before{content:\"\\e005\"}.glyphicon-star:before{content:\"\\e006\"}.glyphicon-star-empty:before{content:\"\\e007\"}.glyphicon-user:before{content:\"\\e008\"}.glyphicon-film:before{content:\"\\e009\"}.glyphicon-th-large:before{content:\"\\e010\"}.glyphicon-th:before{content:\"\\e011\"}.glyphicon-th-list:before{content:\"\\e012\"}.glyphicon-ok:before{content:\"\\e013\"}.glyphicon-remove:before{content:\"\\e014\"}.glyphicon-zoom-in:before{content:\"\\e015\"}.glyphicon-zoom-out:before{content:\"\\e016\"}.glyphicon-off:before{content:\"\\e017\"}.glyphicon-signal:before{content:\"\\e018\"}.glyphicon-cog:before{content:\"\\e019\"}.glyphicon-trash:before{content:\"\\e020\"}.glyphicon-home:before{content:\"\\e021\"}.glyphicon-file:before{content:\"\\e022\"}.glyphicon-time:before{content:\"\\e023\"}.glyphicon-road:before{content:\"\\e024\"}.glyphicon-download-alt:before{content:\"\\e025\"}.glyphicon-download:before{content:\"\\e026\"}.glyphicon-upload:before{content:\"\\e027\"}.glyphicon-inbox:before{content:\"\\e028\"}.glyphicon-play-circle:before{content:\"\\e029\"}.glyphicon-repeat:before{content:\"\\e030\"}.glyphicon-refresh:before{content:\"\\e031\"}.glyphicon-list-alt:before{content:\"\\e032\"}.glyphicon-lock:before{content:\"\\e033\"}.glyphicon-flag:before{content:\"\\e034\"}.glyphicon-headphones:before{content:\"\\e035\"}.glyphicon-volume-off:before{content:\"\\e036\"}.glyphicon-volume-down:before{content:\"\\e037\"}.glyphicon-volume-up:before{content:\"\\e038\"}.glyphicon-qrcode:before{content:\"\\e039\"}.glyphicon-barcode:before{content:\"\\e040\"}.glyphicon-tag:before{content:\"\\e041\"}.glyphicon-tags:before{content:\"\\e042\"}.glyphicon-book:before{content:\"\\e043\"}.glyphicon-bookmark:before{content:\"\\e044\"}.glyphicon-print:before{content:\"\\e045\"}.glyphicon-camera:before{content:\"\\e046\"}.glyphicon-font:before{content:\"\\e047\"}.glyphicon-bold:before{content:\"\\e048\"}.glyphicon-italic:before{content:\"\\e049\"}.glyphicon-text-height:before{content:\"\\e050\"}.glyphicon-text-width:before{content:\"\\e051\"}.glyphicon-align-left:before{content:\"\\e052\"}.glyphicon-align-center:before{content:\"\\e053\"}.glyphicon-align-right:before{content:\"\\e054\"}.glyphicon-align-justify:before{content:\"\\e055\"}.glyphicon-list:before{content:\"\\e056\"}.glyphicon-indent-left:before{content:\"\\e057\"}.glyphicon-indent-right:before{content:\"\\e058\"}.glyphicon-facetime-video:before{content:\"\\e059\"}.glyphicon-picture:before{content:\"\\e060\"}.glyphicon-map-marker:before{content:\"\\e062\"}.glyphicon-adjust:before{content:\"\\e063\"}.glyphicon-tint:before{content:\"\\e064\"}.glyphicon-edit:before{content:\"\\e065\"}.glyphicon-share:before{content:\"\\e066\"}.glyphicon-check:before{content:\"\\e067\"}.glyphicon-move:before{content:\"\\e068\"}.glyphicon-step-backward:before{content:\"\\e069\"}.glyphicon-fast-backward:before{content:\"\\e070\"}.glyphicon-backward:before{content:\"\\e071\"}.glyphicon-play:before{content:\"\\e072\"}.glyphicon-pause:before{content:\"\\e073\"}.glyphicon-stop:before{content:\"\\e074\"}.glyphicon-forward:before{content:\"\\e075\"}.glyphicon-fast-forward:before{content:\"\\e076\"}.glyphicon-step-forward:before{content:\"\\e077\"}.glyphicon-eject:before{content:\"\\e078\"}.glyphicon-chevron-left:before{content:\"\\e079\"}.glyphicon-chevron-right:before{content:\"\\e080\"}.glyphicon-plus-sign:before{content:\"\\e081\"}.glyphicon-minus-sign:before{content:\"\\e082\"}.glyphicon-remove-sign:before{content:\"\\e083\"}.glyphicon-ok-sign:before{content:\"\\e084\"}.glyphicon-question-sign:before{content:\"\\e085\"}.glyphicon-info-sign:before{content:\"\\e086\"}.glyphicon-screenshot:before{content:\"\\e087\"}.glyphicon-remove-circle:before{content:\"\\e088\"}.glyphicon-ok-circle:before{content:\"\\e089\"}.glyphicon-ban-circle:before{content:\"\\e090\"}.glyphicon-arrow-left:before{content:\"\\e091\"}.glyphicon-arrow-right:before{content:\"\\e092\"}.glyphicon-arrow-up:before{content:\"\\e093\"}.glyphicon-arrow-down:before{content:\"\\e094\"}.glyphicon-share-alt:before{content:\"\\e095\"}.glyphicon-resize-full:before{content:\"\\e096\"}.glyphicon-resize-small:before{content:\"\\e097\"}.glyphicon-exclamation-sign:before{content:\"\\e101\"}.glyphicon-gift:before{content:\"\\e102\"}.glyphicon-leaf:before{content:\"\\e103\"}.glyphicon-fire:before{content:\"\\e104\"}.glyphicon-eye-open:before{content:\"\\e105\"}.glyphicon-eye-close:before{content:\"\\e106\"}.glyphicon-warning-sign:before{content:\"\\e107\"}.glyphicon-plane:before{content:\"\\e108\"}.glyphicon-calendar:before{content:\"\\e109\"}.glyphicon-random:before{content:\"\\e110\"}.glyphicon-comment:before{content:\"\\e111\"}.glyphicon-magnet:before{content:\"\\e112\"}.glyphicon-chevron-up:before{content:\"\\e113\"}.glyphicon-chevron-down:before{content:\"\\e114\"}.glyphicon-retweet:before{content:\"\\e115\"}.glyphicon-shopping-cart:before{content:\"\\e116\"}.glyphicon-folder-close:before{content:\"\\e117\"}.glyphicon-folder-open:before{content:\"\\e118\"}.glyphicon-resize-vertical:before{content:\"\\e119\"}.glyphicon-resize-horizontal:before{content:\"\\e120\"}.glyphicon-hdd:before{content:\"\\e121\"}.glyphicon-bullhorn:before{content:\"\\e122\"}.glyphicon-bell:before{content:\"\\e123\"}.glyphicon-certificate:before{content:\"\\e124\"}.glyphicon-thumbs-up:before{content:\"\\e125\"}.glyphicon-thumbs-down:before{content:\"\\e126\"}.glyphicon-hand-right:before{content:\"\\e127\"}.glyphicon-hand-left:before{content:\"\\e128\"}.glyphicon-hand-up:before{content:\"\\e129\"}.glyphicon-hand-down:before{content:\"\\e130\"}.glyphicon-circle-arrow-right:before{content:\"\\e131\"}.glyphicon-circle-arrow-left:before{content:\"\\e132\"}.glyphicon-circle-arrow-up:before{content:\"\\e133\"}.glyphicon-circle-arrow-down:before{content:\"\\e134\"}.glyphicon-globe:before{content:\"\\e135\"}.glyphicon-wrench:before{content:\"\\e136\"}.glyphicon-tasks:before{content:\"\\e137\"}.glyphicon-filter:before{content:\"\\e138\"}.glyphicon-briefcase:before{content:\"\\e139\"}.glyphicon-fullscreen:before{content:\"\\e140\"}.glyphicon-dashboard:before{content:\"\\e141\"}.glyphicon-paperclip:before{content:\"\\e142\"}.glyphicon-heart-empty:before{content:\"\\e143\"}.glyphicon-link:before{content:\"\\e144\"}.glyphicon-phone:before{content:\"\\e145\"}.glyphicon-pushpin:before{content:\"\\e146\"}.glyphicon-usd:before{content:\"\\e148\"}.glyphicon-gbp:before{content:\"\\e149\"}.glyphicon-sort:before{content:\"\\e150\"}.glyphicon-sort-by-alphabet:before{content:\"\\e151\"}.glyphicon-sort-by-alphabet-alt:before{content:\"\\e152\"}.glyphicon-sort-by-order:before{content:\"\\e153\"}.glyphicon-sort-by-order-alt:before{content:\"\\e154\"}.glyphicon-sort-by-attributes:before{content:\"\\e155\"}.glyphicon-sort-by-attributes-alt:before{content:\"\\e156\"}.glyphicon-unchecked:before{content:\"\\e157\"}.glyphicon-expand:before{content:\"\\e158\"}.glyphicon-collapse-down:before{content:\"\\e159\"}.glyphicon-collapse-up:before{content:\"\\e160\"}.glyphicon-log-in:before{content:\"\\e161\"}.glyphicon-flash:before{content:\"\\e162\"}.glyphicon-log-out:before{content:\"\\e163\"}.glyphicon-new-window:before{content:\"\\e164\"}.glyphicon-record:before{content:\"\\e165\"}.glyphicon-save:before{content:\"\\e166\"}.glyphicon-open:before{content:\"\\e167\"}.glyphicon-saved:before{content:\"\\e168\"}.glyphicon-import:before{content:\"\\e169\"}.glyphicon-export:before{content:\"\\e170\"}.glyphicon-send:before{content:\"\\e171\"}.glyphicon-floppy-disk:before{content:\"\\e172\"}.glyphicon-floppy-saved:before{content:\"\\e173\"}.glyphicon-floppy-remove:before{content:\"\\e174\"}.glyphicon-floppy-save:before{content:\"\\e175\"}.glyphicon-floppy-open:before{content:\"\\e176\"}.glyphicon-credit-card:before{content:\"\\e177\"}.glyphicon-transfer:before{content:\"\\e178\"}.glyphicon-cutlery:before{content:\"\\e179\"}.glyphicon-header:before{content:\"\\e180\"}.glyphicon-compressed:before{content:\"\\e181\"}.glyphicon-earphone:before{content:\"\\e182\"}.glyphicon-phone-alt:before{content:\"\\e183\"}.glyphicon-tower:before{content:\"\\e184\"}.glyphicon-stats:before{content:\"\\e185\"}.glyphicon-sd-video:before{content:\"\\e186\"}.glyphicon-hd-video:before{content:\"\\e187\"}.glyphicon-subtitles:before{content:\"\\e188\"}.glyphicon-sound-stereo:before{content:\"\\e189\"}.glyphicon-sound-dolby:before{content:\"\\e190\"}.glyphicon-sound-5-1:before{content:\"\\e191\"}.glyphicon-sound-6-1:before{content:\"\\e192\"}.glyphicon-sound-7-1:before{content:\"\\e193\"}.glyphicon-copyright-mark:before{content:\"\\e194\"}.glyphicon-registration-mark:before{content:\"\\e195\"}.glyphicon-cloud-download:before{content:\"\\e197\"}.glyphicon-cloud-upload:before{content:\"\\e198\"}.glyphicon-tree-conifer:before{content:\"\\e199\"}.glyphicon-tree-deciduous:before{content:\"\\e200\"}.glyphicon-cd:before{content:\"\\e201\"}.glyphicon-save-file:before{content:\"\\e202\"}.glyphicon-open-file:before{content:\"\\e203\"}.glyphicon-level-up:before{content:\"\\e204\"}.glyphicon-copy:before{content:\"\\e205\"}.glyphicon-paste:before{content:\"\\e206\"}.glyphicon-alert:before{content:\"\\e209\"}.glyphicon-equalizer:before{content:\"\\e210\"}.glyphicon-king:before{content:\"\\e211\"}.glyphicon-queen:before{content:\"\\e212\"}.glyphicon-pawn:before{content:\"\\e213\"}.glyphicon-bishop:before{content:\"\\e214\"}.glyphicon-knight:before{content:\"\\e215\"}.glyphicon-baby-formula:before{content:\"\\e216\"}.glyphicon-tent:before{content:\"\\26fa\"}.glyphicon-blackboard:before{content:\"\\e218\"}.glyphicon-bed:before{content:\"\\e219\"}.glyphicon-apple:before{content:\"\\f8ff\"}.glyphicon-erase:before{content:\"\\e221\"}.glyphicon-hourglass:before{content:\"\\231b\"}.glyphicon-lamp:before{content:\"\\e223\"}.glyphicon-duplicate:before{content:\"\\e224\"}.glyphicon-piggy-bank:before{content:\"\\e225\"}.glyphicon-scissors:before{content:\"\\e226\"}.glyphicon-bitcoin:before{content:\"\\e227\"}.glyphicon-btc:before{content:\"\\e227\"}.glyphicon-xbt:before{content:\"\\e227\"}.glyphicon-yen:before{content:\"\\00a5\"}.glyphicon-jpy:before{content:\"\\00a5\"}.glyphicon-ruble:before{content:\"\\20bd\"}.glyphicon-rub:before{content:\"\\20bd\"}.glyphicon-scale:before{content:\"\\e230\"}.glyphicon-ice-lolly:before{content:\"\\e231\"}.glyphicon-ice-lolly-tasted:before{content:\"\\e232\"}.glyphicon-education:before{content:\"\\e233\"}.glyphicon-option-horizontal:before{content:\"\\e234\"}.glyphicon-option-vertical:before{content:\"\\e235\"}.glyphicon-menu-hamburger:before{content:\"\\e236\"}.glyphicon-modal-window:before{content:\"\\e237\"}.glyphicon-oil:before{content:\"\\e238\"}.glyphicon-grain:before{content:\"\\e239\"}.glyphicon-sunglasses:before{content:\"\\e240\"}.glyphicon-text-size:before{content:\"\\e241\"}.glyphicon-text-color:before{content:\"\\e242\"}.glyphicon-text-background:before{content:\"\\e243\"}.glyphicon-object-align-top:before{content:\"\\e244\"}.glyphicon-object-align-bottom:before{content:\"\\e245\"}.glyphicon-object-align-horizontal:before{content:\"\\e246\"}.glyphicon-object-align-left:before{content:\"\\e247\"}.glyphicon-object-align-vertical:before{content:\"\\e248\"}.glyphicon-object-align-right:before{content:\"\\e249\"}.glyphicon-triangle-right:before{content:\"\\e250\"}.glyphicon-triangle-left:before{content:\"\\e251\"}.glyphicon-triangle-bottom:before{content:\"\\e252\"}.glyphicon-triangle-top:before{content:\"\\e253\"}.glyphicon-console:before{content:\"\\e254\"}.glyphicon-superscript:before{content:\"\\e255\"}.glyphicon-subscript:before{content:\"\\e256\"}.glyphicon-menu-left:before{content:\"\\e257\"}.glyphicon-menu-right:before{content:\"\\e258\"}.glyphicon-menu-down:before{content:\"\\e259\"}.glyphicon-menu-up:before{content:\"\\e260\"}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}:after,:before{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}button,input,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#337ab7;text-decoration:none}a:focus,a:hover{color:#23527c;text-decoration:underline}a:focus{outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}figure{margin:0}img{vertical-align:middle}.carousel-inner>.item>a>img,.carousel-inner>.item>img,.img-responsive,.thumbnail a>img,.thumbnail>img{display:block;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{display:inline-block;max-width:100%;height:auto;padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.img-circle{border-radius:50%}hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}[role=button]{cursor:pointer}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{font-family:inherit;font-weight:500;line-height:1.1;color:inherit}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-weight:400;line-height:1;color:#777}.h1,.h2,.h3,h1,h2,h3{margin-top:20px;margin-bottom:10px}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small{font-size:65%}.h4,.h5,.h6,h4,h5,h6{margin-top:10px;margin-bottom:10px}.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-size:75%}.h1,h1{font-size:36px}.h2,h2{font-size:30px}.h3,h3{font-size:24px}.h4,h4{font-size:18px}.h5,h5{font-size:14px}.h6,h6{font-size:12px}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:16px;font-weight:300;line-height:1.4}@media (min-width:768px){.lead{font-size:21px}}.small,small{font-size:85%}.mark,mark{padding:.2em;background-color:#fcf8e3}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}.text-nowrap{white-space:nowrap}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.text-muted{color:#777}.text-primary{color:#337ab7}a.text-primary:focus,a.text-primary:hover{color:#286090}.text-success{color:#3c763d}a.text-success:focus,a.text-success:hover{color:#2b542c}.text-info{color:#31708f}a.text-info:focus,a.text-info:hover{color:#245269}.text-warning{color:#8a6d3b}a.text-warning:focus,a.text-warning:hover{color:#66512c}.text-danger{color:#a94442}a.text-danger:focus,a.text-danger:hover{color:#843534}.bg-primary{color:#fff;background-color:#337ab7}a.bg-primary:focus,a.bg-primary:hover{background-color:#286090}.bg-success{background-color:#dff0d8}a.bg-success:focus,a.bg-success:hover{background-color:#c1e2b3}.bg-info{background-color:#d9edf7}a.bg-info:focus,a.bg-info:hover{background-color:#afd9ee}.bg-warning{background-color:#fcf8e3}a.bg-warning:focus,a.bg-warning:hover{background-color:#f7ecb5}.bg-danger{background-color:#f2dede}a.bg-danger:focus,a.bg-danger:hover{background-color:#e4b9b9}.page-header{padding-bottom:9px;margin:40px 0 20px;border-bottom:1px solid #eee}ol,ul{margin-top:0;margin-bottom:10px}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;margin-left:-5px;list-style:none}.list-inline>li{display:inline-block;padding-right:5px;padding-left:5px}dl{margin-top:0;margin-bottom:20px}dd,dt{line-height:1.42857143}dt{font-weight:700}dd{margin-left:0}@media (min-width:768px){.dl-horizontal dt{float:left;width:160px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}}abbr[data-original-title],abbr[title]{cursor:help;border-bottom:1px dotted #777}.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:10px 20px;margin:0 0 20px;font-size:17.5px;border-left:5px solid #eee}blockquote ol:last-child,blockquote p:last-child,blockquote ul:last-child{margin-bottom:0}blockquote .small,blockquote footer,blockquote small{display:block;font-size:80%;line-height:1.42857143;color:#777}blockquote .small:before,blockquote footer:before,blockquote small:before{content:'\\2014 \\00A0'}.blockquote-reverse,blockquote.pull-right{padding-right:15px;padding-left:0;text-align:right;border-right:5px solid #eee;border-left:0}.blockquote-reverse .small:before,.blockquote-reverse footer:before,.blockquote-reverse small:before,blockquote.pull-right .small:before,blockquote.pull-right footer:before,blockquote.pull-right small:before{content:''}.blockquote-reverse .small:after,.blockquote-reverse footer:after,.blockquote-reverse small:after,blockquote.pull-right .small:after,blockquote.pull-right footer:after,blockquote.pull-right small:after{content:'\\00A0 \\2014'}address{margin-bottom:20px;font-style:normal;line-height:1.42857143}code,kbd,pre,samp{font-family:Menlo,Monaco,Consolas,\"Courier New\",monospace}code{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px}kbd{padding:2px 4px;font-size:90%;color:#fff;background-color:#333;border-radius:3px;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.25);box-shadow:inset 0 -1px 0 rgba(0,0,0,.25)}kbd kbd{padding:0;font-size:100%;font-weight:700;-webkit-box-shadow:none;box-shadow:none}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:1.42857143;color:#333;word-break:break-all;word-wrap:break-word;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}.container{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1170px}}.container-fluid{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.row{margin-right:-15px;margin-left:-15px}.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{position:relative;min-height:1px;padding-right:15px;padding-left:15px}.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{float:left}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.col-xs-pull-12{right:100%}.col-xs-pull-11{right:91.66666667%}.col-xs-pull-10{right:83.33333333%}.col-xs-pull-9{right:75%}.col-xs-pull-8{right:66.66666667%}.col-xs-pull-7{right:58.33333333%}.col-xs-pull-6{right:50%}.col-xs-pull-5{right:41.66666667%}.col-xs-pull-4{right:33.33333333%}.col-xs-pull-3{right:25%}.col-xs-pull-2{right:16.66666667%}.col-xs-pull-1{right:8.33333333%}.col-xs-pull-0{right:auto}.col-xs-push-12{left:100%}.col-xs-push-11{left:91.66666667%}.col-xs-push-10{left:83.33333333%}.col-xs-push-9{left:75%}.col-xs-push-8{left:66.66666667%}.col-xs-push-7{left:58.33333333%}.col-xs-push-6{left:50%}.col-xs-push-5{left:41.66666667%}.col-xs-push-4{left:33.33333333%}.col-xs-push-3{left:25%}.col-xs-push-2{left:16.66666667%}.col-xs-push-1{left:8.33333333%}.col-xs-push-0{left:auto}.col-xs-offset-12{margin-left:100%}.col-xs-offset-11{margin-left:91.66666667%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-0{margin-left:0}@media (min-width:768px){.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9{float:left}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.col-sm-pull-12{right:100%}.col-sm-pull-11{right:91.66666667%}.col-sm-pull-10{right:83.33333333%}.col-sm-pull-9{right:75%}.col-sm-pull-8{right:66.66666667%}.col-sm-pull-7{right:58.33333333%}.col-sm-pull-6{right:50%}.col-sm-pull-5{right:41.66666667%}.col-sm-pull-4{right:33.33333333%}.col-sm-pull-3{right:25%}.col-sm-pull-2{right:16.66666667%}.col-sm-pull-1{right:8.33333333%}.col-sm-pull-0{right:auto}.col-sm-push-12{left:100%}.col-sm-push-11{left:91.66666667%}.col-sm-push-10{left:83.33333333%}.col-sm-push-9{left:75%}.col-sm-push-8{left:66.66666667%}.col-sm-push-7{left:58.33333333%}.col-sm-push-6{left:50%}.col-sm-push-5{left:41.66666667%}.col-sm-push-4{left:33.33333333%}.col-sm-push-3{left:25%}.col-sm-push-2{left:16.66666667%}.col-sm-push-1{left:8.33333333%}.col-sm-push-0{left:auto}.col-sm-offset-12{margin-left:100%}.col-sm-offset-11{margin-left:91.66666667%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-0{margin-left:0}}@media (min-width:992px){.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9{float:left}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.col-md-pull-12{right:100%}.col-md-pull-11{right:91.66666667%}.col-md-pull-10{right:83.33333333%}.col-md-pull-9{right:75%}.col-md-pull-8{right:66.66666667%}.col-md-pull-7{right:58.33333333%}.col-md-pull-6{right:50%}.col-md-pull-5{right:41.66666667%}.col-md-pull-4{right:33.33333333%}.col-md-pull-3{right:25%}.col-md-pull-2{right:16.66666667%}.col-md-pull-1{right:8.33333333%}.col-md-pull-0{right:auto}.col-md-push-12{left:100%}.col-md-push-11{left:91.66666667%}.col-md-push-10{left:83.33333333%}.col-md-push-9{left:75%}.col-md-push-8{left:66.66666667%}.col-md-push-7{left:58.33333333%}.col-md-push-6{left:50%}.col-md-push-5{left:41.66666667%}.col-md-push-4{left:33.33333333%}.col-md-push-3{left:25%}.col-md-push-2{left:16.66666667%}.col-md-push-1{left:8.33333333%}.col-md-push-0{left:auto}.col-md-offset-12{margin-left:100%}.col-md-offset-11{margin-left:91.66666667%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-9{margin-left:75%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-6{margin-left:50%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-3{margin-left:25%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-0{margin-left:0}}@media (min-width:1200px){.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9{float:left}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.col-lg-pull-12{right:100%}.col-lg-pull-11{right:91.66666667%}.col-lg-pull-10{right:83.33333333%}.col-lg-pull-9{right:75%}.col-lg-pull-8{right:66.66666667%}.col-lg-pull-7{right:58.33333333%}.col-lg-pull-6{right:50%}.col-lg-pull-5{right:41.66666667%}.col-lg-pull-4{right:33.33333333%}.col-lg-pull-3{right:25%}.col-lg-pull-2{right:16.66666667%}.col-lg-pull-1{right:8.33333333%}.col-lg-pull-0{right:auto}.col-lg-push-12{left:100%}.col-lg-push-11{left:91.66666667%}.col-lg-push-10{left:83.33333333%}.col-lg-push-9{left:75%}.col-lg-push-8{left:66.66666667%}.col-lg-push-7{left:58.33333333%}.col-lg-push-6{left:50%}.col-lg-push-5{left:41.66666667%}.col-lg-push-4{left:33.33333333%}.col-lg-push-3{left:25%}.col-lg-push-2{left:16.66666667%}.col-lg-push-1{left:8.33333333%}.col-lg-push-0{left:auto}.col-lg-offset-12{margin-left:100%}.col-lg-offset-11{margin-left:91.66666667%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-0{margin-left:0}}table{background-color:transparent}caption{padding-top:8px;padding-bottom:8px;color:#777;text-align:left}th{text-align:left}.table{width:100%;max-width:100%;margin-bottom:20px}.table>tbody>tr>td,.table>tbody>tr>th,.table>tfoot>tr>td,.table>tfoot>tr>th,.table>thead>tr>td,.table>thead>tr>th{padding:8px;line-height:1.42857143;vertical-align:top;border-top:1px solid #ddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #ddd}.table>caption+thead>tr:first-child>td,.table>caption+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>th,.table>thead:first-child>tr:first-child>td,.table>thead:first-child>tr:first-child>th{border-top:0}.table>tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed>tbody>tr>td,.table-condensed>tbody>tr>th,.table-condensed>tfoot>tr>td,.table-condensed>tfoot>tr>th,.table-condensed>thead>tr>td,.table-condensed>thead>tr>th{padding:5px}.table-bordered{border:1px solid #ddd}.table-bordered>tbody>tr>td,.table-bordered>tbody>tr>th,.table-bordered>tfoot>tr>td,.table-bordered>tfoot>tr>th,.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border:1px solid #ddd}.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border-bottom-width:2px}.table-striped>tbody>tr:nth-of-type(odd){background-color:#f9f9f9}.table-hover>tbody>tr:hover{background-color:#f5f5f5}table col[class*=col-]{position:static;display:table-column;float:none}table td[class*=col-],table th[class*=col-]{position:static;display:table-cell;float:none}.table>tbody>tr.active>td,.table>tbody>tr.active>th,.table>tbody>tr>td.active,.table>tbody>tr>th.active,.table>tfoot>tr.active>td,.table>tfoot>tr.active>th,.table>tfoot>tr>td.active,.table>tfoot>tr>th.active,.table>thead>tr.active>td,.table>thead>tr.active>th,.table>thead>tr>td.active,.table>thead>tr>th.active{background-color:#f5f5f5}.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr.active:hover>th,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover{background-color:#e8e8e8}.table>tbody>tr.success>td,.table>tbody>tr.success>th,.table>tbody>tr>td.success,.table>tbody>tr>th.success,.table>tfoot>tr.success>td,.table>tfoot>tr.success>th,.table>tfoot>tr>td.success,.table>tfoot>tr>th.success,.table>thead>tr.success>td,.table>thead>tr.success>th,.table>thead>tr>td.success,.table>thead>tr>th.success{background-color:#dff0d8}.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr.success:hover>th,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover{background-color:#d0e9c6}.table>tbody>tr.info>td,.table>tbody>tr.info>th,.table>tbody>tr>td.info,.table>tbody>tr>th.info,.table>tfoot>tr.info>td,.table>tfoot>tr.info>th,.table>tfoot>tr>td.info,.table>tfoot>tr>th.info,.table>thead>tr.info>td,.table>thead>tr.info>th,.table>thead>tr>td.info,.table>thead>tr>th.info{background-color:#d9edf7}.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr.info:hover>th,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover{background-color:#c4e3f3}.table>tbody>tr.warning>td,.table>tbody>tr.warning>th,.table>tbody>tr>td.warning,.table>tbody>tr>th.warning,.table>tfoot>tr.warning>td,.table>tfoot>tr.warning>th,.table>tfoot>tr>td.warning,.table>tfoot>tr>th.warning,.table>thead>tr.warning>td,.table>thead>tr.warning>th,.table>thead>tr>td.warning,.table>thead>tr>th.warning{background-color:#fcf8e3}.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr.warning:hover>th,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover{background-color:#faf2cc}.table>tbody>tr.danger>td,.table>tbody>tr.danger>th,.table>tbody>tr>td.danger,.table>tbody>tr>th.danger,.table>tfoot>tr.danger>td,.table>tfoot>tr.danger>th,.table>tfoot>tr>td.danger,.table>tfoot>tr>th.danger,.table>thead>tr.danger>td,.table>thead>tr.danger>th,.table>thead>tr>td.danger,.table>thead>tr>th.danger{background-color:#f2dede}.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr.danger:hover>th,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover{background-color:#ebcccc}.table-responsive{min-height:.01%;overflow-x:auto}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #ddd}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tfoot>tr>td,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>thead>tr>th{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}}fieldset{min-width:0;padding:0;margin:0;border:0}legend{display:block;width:100%;padding:0;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333;border:0;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}input[type=search]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}input[type=checkbox],input[type=radio]{margin:4px 0 0;margin-top:1px\\9;line-height:normal}input[type=file]{display:block}input[type=range]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type=file]:focus,input[type=checkbox]:focus,input[type=radio]:focus{outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{display:block;padding-top:7px;font-size:14px;line-height:1.42857143;color:#555}.form-control{display:block;width:100%;height:34px;padding:6px 12px;font-size:14px;line-height:1.42857143;color:#555;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075);-webkit-transition:border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;-o-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#999;opacity:1}.form-control:-ms-input-placeholder{color:#999}.form-control::-webkit-input-placeholder{color:#999}.form-control::-ms-expand{background-color:transparent;border:0}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{background-color:#eee;opacity:1}.form-control[disabled],fieldset[disabled] .form-control{cursor:not-allowed}textarea.form-control{height:auto}input[type=search]{-webkit-appearance:none}@media screen and (-webkit-min-device-pixel-ratio:0){input[type=date].form-control,input[type=time].form-control,input[type=datetime-local].form-control,input[type=month].form-control{line-height:34px}.input-group-sm input[type=date],.input-group-sm input[type=time],.input-group-sm input[type=datetime-local],.input-group-sm input[type=month],input[type=date].input-sm,input[type=time].input-sm,input[type=datetime-local].input-sm,input[type=month].input-sm{line-height:30px}.input-group-lg input[type=date],.input-group-lg input[type=time],.input-group-lg input[type=datetime-local],.input-group-lg input[type=month],input[type=date].input-lg,input[type=time].input-lg,input[type=datetime-local].input-lg,input[type=month].input-lg{line-height:46px}}.form-group{margin-bottom:15px}.checkbox,.radio{position:relative;display:block;margin-top:10px;margin-bottom:10px}.checkbox label,.radio label{min-height:20px;padding-left:20px;margin-bottom:0;font-weight:400;cursor:pointer}.checkbox input[type=checkbox],.checkbox-inline input[type=checkbox],.radio input[type=radio],.radio-inline input[type=radio]{position:absolute;margin-top:4px\\9;margin-left:-20px}.checkbox+.checkbox,.radio+.radio{margin-top:-5px}.checkbox-inline,.radio-inline{position:relative;display:inline-block;padding-left:20px;margin-bottom:0;font-weight:400;vertical-align:middle;cursor:pointer}.checkbox-inline+.checkbox-inline,.radio-inline+.radio-inline{margin-top:0;margin-left:10px}fieldset[disabled] input[type=checkbox],fieldset[disabled] input[type=radio],input[type=checkbox].disabled,input[type=checkbox][disabled],input[type=radio].disabled,input[type=radio][disabled]{cursor:not-allowed}.checkbox-inline.disabled,.radio-inline.disabled,fieldset[disabled] .checkbox-inline,fieldset[disabled] .radio-inline{cursor:not-allowed}.checkbox.disabled label,.radio.disabled label,fieldset[disabled] .checkbox label,fieldset[disabled] .radio label{cursor:not-allowed}.form-control-static{min-height:34px;padding-top:7px;padding-bottom:7px;margin-bottom:0}.form-control-static.input-lg,.form-control-static.input-sm{padding-right:0;padding-left:0}.input-sm{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-sm{height:30px;line-height:30px}select[multiple].input-sm,textarea.input-sm{height:auto}.form-group-sm .form-control{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.form-group-sm select.form-control{height:30px;line-height:30px}.form-group-sm select[multiple].form-control,.form-group-sm textarea.form-control{height:auto}.form-group-sm .form-control-static{height:30px;min-height:32px;padding:6px 10px;font-size:12px;line-height:1.5}.input-lg{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-lg{height:46px;line-height:46px}select[multiple].input-lg,textarea.input-lg{height:auto}.form-group-lg .form-control{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.form-group-lg select.form-control{height:46px;line-height:46px}.form-group-lg select[multiple].form-control,.form-group-lg textarea.form-control{height:auto}.form-group-lg .form-control-static{height:46px;min-height:38px;padding:11px 16px;font-size:18px;line-height:1.3333333}.has-feedback{position:relative}.has-feedback .form-control{padding-right:42.5px}.form-control-feedback{position:absolute;top:0;right:0;z-index:2;display:block;width:34px;height:34px;line-height:34px;text-align:center;pointer-events:none}.form-group-lg .form-control+.form-control-feedback,.input-group-lg+.form-control-feedback,.input-lg+.form-control-feedback{width:46px;height:46px;line-height:46px}.form-group-sm .form-control+.form-control-feedback,.input-group-sm+.form-control-feedback,.input-sm+.form-control-feedback{width:30px;height:30px;line-height:30px}.has-success .checkbox,.has-success .checkbox-inline,.has-success .control-label,.has-success .help-block,.has-success .radio,.has-success .radio-inline,.has-success.checkbox label,.has-success.checkbox-inline label,.has-success.radio label,.has-success.radio-inline label{color:#3c763d}.has-success .form-control{border-color:#3c763d;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-success .form-control:focus{border-color:#2b542c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168}.has-success .input-group-addon{color:#3c763d;background-color:#dff0d8;border-color:#3c763d}.has-success .form-control-feedback{color:#3c763d}.has-warning .checkbox,.has-warning .checkbox-inline,.has-warning .control-label,.has-warning .help-block,.has-warning .radio,.has-warning .radio-inline,.has-warning.checkbox label,.has-warning.checkbox-inline label,.has-warning.radio label,.has-warning.radio-inline label{color:#8a6d3b}.has-warning .form-control{border-color:#8a6d3b;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-warning .form-control:focus{border-color:#66512c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b}.has-warning .input-group-addon{color:#8a6d3b;background-color:#fcf8e3;border-color:#8a6d3b}.has-warning .form-control-feedback{color:#8a6d3b}.has-error .checkbox,.has-error .checkbox-inline,.has-error .control-label,.has-error .help-block,.has-error .radio,.has-error .radio-inline,.has-error.checkbox label,.has-error.checkbox-inline label,.has-error.radio label,.has-error.radio-inline label{color:#a94442}.has-error .form-control{border-color:#a94442;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-error .form-control:focus{border-color:#843534;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483}.has-error .input-group-addon{color:#a94442;background-color:#f2dede;border-color:#a94442}.has-error .form-control-feedback{color:#a94442}.has-feedback label~.form-control-feedback{top:25px}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .form-control-static{display:inline-block}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .form-control,.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .checkbox,.form-inline .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .checkbox label,.form-inline .radio label{padding-left:0}.form-inline .checkbox input[type=checkbox],.form-inline .radio input[type=radio]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}}.form-horizontal .checkbox,.form-horizontal .checkbox-inline,.form-horizontal .radio,.form-horizontal .radio-inline{padding-top:7px;margin-top:0;margin-bottom:0}.form-horizontal .checkbox,.form-horizontal .radio{min-height:27px}.form-horizontal .form-group{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.form-horizontal .control-label{padding-top:7px;margin-bottom:0;text-align:right}}.form-horizontal .has-feedback .form-control-feedback{right:15px}@media (min-width:768px){.form-horizontal .form-group-lg .control-label{padding-top:11px;font-size:18px}}@media (min-width:768px){.form-horizontal .form-group-sm .control-label{padding-top:6px;font-size:12px}}.btn{display:inline-block;padding:6px 12px;margin-bottom:0;font-size:14px;font-weight:400;line-height:1.42857143;text-align:center;white-space:nowrap;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:1px solid transparent;border-radius:4px}.btn.active.focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn:active:focus,.btn:focus{outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.focus,.btn:focus,.btn:hover{color:#333;text-decoration:none}.btn.active,.btn:active{background-image:none;outline:0;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none;opacity:.65}a.btn.disabled,fieldset[disabled] a.btn{pointer-events:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default.focus,.btn-default:focus{color:#333;background-color:#e6e6e6;border-color:#8c8c8c}.btn-default:hover{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active.focus,.btn-default.active:focus,.btn-default.active:hover,.btn-default:active.focus,.btn-default:active:focus,.btn-default:active:hover,.open>.dropdown-toggle.btn-default.focus,.open>.dropdown-toggle.btn-default:focus,.open>.dropdown-toggle.btn-default:hover{color:#333;background-color:#d4d4d4;border-color:#8c8c8c}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{background-image:none}.btn-default.disabled.focus,.btn-default.disabled:focus,.btn-default.disabled:hover,.btn-default[disabled].focus,.btn-default[disabled]:focus,.btn-default[disabled]:hover,fieldset[disabled] .btn-default.focus,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:hover{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#337ab7;border-color:#2e6da4}.btn-primary.focus,.btn-primary:focus{color:#fff;background-color:#286090;border-color:#122b40}.btn-primary:hover{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active.focus,.btn-primary.active:focus,.btn-primary.active:hover,.btn-primary:active.focus,.btn-primary:active:focus,.btn-primary:active:hover,.open>.dropdown-toggle.btn-primary.focus,.open>.dropdown-toggle.btn-primary:focus,.open>.dropdown-toggle.btn-primary:hover{color:#fff;background-color:#204d74;border-color:#122b40}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{background-image:none}.btn-primary.disabled.focus,.btn-primary.disabled:focus,.btn-primary.disabled:hover,.btn-primary[disabled].focus,.btn-primary[disabled]:focus,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary.focus,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:hover{background-color:#337ab7;border-color:#2e6da4}.btn-primary .badge{color:#337ab7;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success.focus,.btn-success:focus{color:#fff;background-color:#449d44;border-color:#255625}.btn-success:hover{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active.focus,.btn-success.active:focus,.btn-success.active:hover,.btn-success:active.focus,.btn-success:active:focus,.btn-success:active:hover,.open>.dropdown-toggle.btn-success.focus,.open>.dropdown-toggle.btn-success:focus,.open>.dropdown-toggle.btn-success:hover{color:#fff;background-color:#398439;border-color:#255625}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{background-image:none}.btn-success.disabled.focus,.btn-success.disabled:focus,.btn-success.disabled:hover,.btn-success[disabled].focus,.btn-success[disabled]:focus,.btn-success[disabled]:hover,fieldset[disabled] .btn-success.focus,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:hover{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info.focus,.btn-info:focus{color:#fff;background-color:#31b0d5;border-color:#1b6d85}.btn-info:hover{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active.focus,.btn-info.active:focus,.btn-info.active:hover,.btn-info:active.focus,.btn-info:active:focus,.btn-info:active:hover,.open>.dropdown-toggle.btn-info.focus,.open>.dropdown-toggle.btn-info:focus,.open>.dropdown-toggle.btn-info:hover{color:#fff;background-color:#269abc;border-color:#1b6d85}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{background-image:none}.btn-info.disabled.focus,.btn-info.disabled:focus,.btn-info.disabled:hover,.btn-info[disabled].focus,.btn-info[disabled]:focus,.btn-info[disabled]:hover,fieldset[disabled] .btn-info.focus,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:hover{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning.focus,.btn-warning:focus{color:#fff;background-color:#ec971f;border-color:#985f0d}.btn-warning:hover{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active.focus,.btn-warning.active:focus,.btn-warning.active:hover,.btn-warning:active.focus,.btn-warning:active:focus,.btn-warning:active:hover,.open>.dropdown-toggle.btn-warning.focus,.open>.dropdown-toggle.btn-warning:focus,.open>.dropdown-toggle.btn-warning:hover{color:#fff;background-color:#d58512;border-color:#985f0d}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{background-image:none}.btn-warning.disabled.focus,.btn-warning.disabled:focus,.btn-warning.disabled:hover,.btn-warning[disabled].focus,.btn-warning[disabled]:focus,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning.focus,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:hover{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger.focus,.btn-danger:focus{color:#fff;background-color:#c9302c;border-color:#761c19}.btn-danger:hover{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active.focus,.btn-danger.active:focus,.btn-danger.active:hover,.btn-danger:active.focus,.btn-danger:active:focus,.btn-danger:active:hover,.open>.dropdown-toggle.btn-danger.focus,.open>.dropdown-toggle.btn-danger:focus,.open>.dropdown-toggle.btn-danger:hover{color:#fff;background-color:#ac2925;border-color:#761c19}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{background-image:none}.btn-danger.disabled.focus,.btn-danger.disabled:focus,.btn-danger.disabled:hover,.btn-danger[disabled].focus,.btn-danger[disabled]:focus,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger.focus,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:hover{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{font-weight:400;color:#337ab7;border-radius:0}.btn-link,.btn-link.active,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:active,.btn-link:focus,.btn-link:hover{border-color:transparent}.btn-link:focus,.btn-link:hover{color:#23527c;text-decoration:underline;background-color:transparent}.btn-link[disabled]:focus,.btn-link[disabled]:hover,fieldset[disabled] .btn-link:focus,fieldset[disabled] .btn-link:hover{color:#777;text-decoration:none}.btn-group-lg>.btn,.btn-lg{padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.btn-group-sm>.btn,.btn-sm{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.btn-group-xs>.btn,.btn-xs{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.fade{opacity:0;-webkit-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;-webkit-transition-timing-function:ease;-o-transition-timing-function:ease;transition-timing-function:ease;-webkit-transition-duration:.35s;-o-transition-duration:.35s;transition-duration:.35s;-webkit-transition-property:height,visibility;-o-transition-property:height,visibility;transition-property:height,visibility}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-top:4px solid\\9;border-right:4px solid transparent;border-left:4px solid transparent}.dropdown,.dropup{position:relative}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;font-size:14px;text-align:left;list-style:none;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.15);border-radius:4px;-webkit-box-shadow:0 6px 12px rgba(0,0,0,.175);box-shadow:0 6px 12px rgba(0,0,0,.175)}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857143;color:#333;white-space:nowrap}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{color:#262626;text-decoration:none;background-color:#f5f5f5}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{color:#fff;text-decoration:none;background-color:#337ab7;outline:0}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{color:#777}.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{text-decoration:none;cursor:not-allowed;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-right{right:0;left:auto}.dropdown-menu-left{right:auto;left:0}.dropdown-header{display:block;padding:3px 20px;font-size:12px;line-height:1.42857143;color:#777;white-space:nowrap}.dropdown-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:990}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{content:\"\";border-top:0;border-bottom:4px dashed;border-bottom:4px solid\\9}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}@media (min-width:768px){.navbar-right .dropdown-menu{right:0;left:auto}.navbar-right .dropdown-menu-left{right:auto;left:0}}.btn-group,.btn-group-vertical{position:relative;display:inline-block;vertical-align:middle}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;float:left}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group-vertical>.btn:hover,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus,.btn-group>.btn:hover{z-index:2}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{margin-left:-5px}.btn-toolbar .btn,.btn-toolbar .btn-group,.btn-toolbar .input-group{float:left}.btn-toolbar>.btn,.btn-toolbar>.btn-group,.btn-toolbar>.input-group{margin-left:5px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.btn-group>.btn-group{float:left}.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding-right:8px;padding-left:8px}.btn-group>.btn-lg+.dropdown-toggle{padding-right:12px;padding-left:12px}.btn-group.open .dropdown-toggle{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-group.open .dropdown-toggle.btn-link{-webkit-box-shadow:none;box-shadow:none}.btn .caret{margin-left:0}.btn-lg .caret{border-width:5px 5px 0;border-bottom-width:0}.dropup .btn-lg .caret{border-width:0 5px 5px}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group,.btn-group-vertical>.btn-group>.btn{display:block;float:none;width:100%;max-width:100%}.btn-group-vertical>.btn-group>.btn{float:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:not(:first-child):not(:last-child){border-radius:0}.btn-group-vertical>.btn:first-child:not(:last-child){border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn:last-child:not(:first-child){border-top-left-radius:0;border-top-right-radius:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}.btn-group-vertical>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group-vertical>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group-vertical>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-top-right-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn,.btn-group-justified>.btn-group{display:table-cell;float:none;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.btn-group-justified>.btn-group .dropdown-menu{left:auto}[data-toggle=buttons]>.btn input[type=checkbox],[data-toggle=buttons]>.btn input[type=radio],[data-toggle=buttons]>.btn-group>.btn input[type=checkbox],[data-toggle=buttons]>.btn-group>.btn input[type=radio]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*=col-]{float:none;padding-right:0;padding-left:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group .form-control:focus{z-index:3}.input-group-lg>.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.btn{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-group-lg>.form-control,select.input-group-lg>.input-group-addon,select.input-group-lg>.input-group-btn>.btn{height:46px;line-height:46px}select[multiple].input-group-lg>.form-control,select[multiple].input-group-lg>.input-group-addon,select[multiple].input-group-lg>.input-group-btn>.btn,textarea.input-group-lg>.form-control,textarea.input-group-lg>.input-group-addon,textarea.input-group-lg>.input-group-btn>.btn{height:auto}.input-group-sm>.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.btn{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-group-sm>.form-control,select.input-group-sm>.input-group-addon,select.input-group-sm>.input-group-btn>.btn{height:30px;line-height:30px}select[multiple].input-group-sm>.form-control,select[multiple].input-group-sm>.input-group-addon,select[multiple].input-group-sm>.input-group-btn>.btn,textarea.input-group-sm>.form-control,textarea.input-group-sm>.input-group-addon,textarea.input-group-sm>.input-group-btn>.btn{height:auto}.input-group .form-control,.input-group-addon,.input-group-btn{display:table-cell}.input-group .form-control:not(:first-child):not(:last-child),.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child){border-radius:0}.input-group-addon,.input-group-btn{width:1%;white-space:nowrap;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;text-align:center;background-color:#eee;border:1px solid #ccc;border-radius:4px}.input-group-addon.input-sm{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type=checkbox],.input-group-addon input[type=radio]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn-group:not(:last-child)>.btn,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:first-child>.btn-group:not(:first-child)>.btn,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle{border-top-left-radius:0;border-bottom-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{position:relative;font-size:0;white-space:nowrap}.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:active,.input-group-btn>.btn:focus,.input-group-btn>.btn:hover{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{z-index:2;margin-left:-1px}.nav{padding-left:0;margin-bottom:0;list-style:none}.nav>li{position:relative;display:block}.nav>li>a{position:relative;display:block;padding:10px 15px}.nav>li>a:focus,.nav>li>a:hover{text-decoration:none;background-color:#eee}.nav>li.disabled>a{color:#777}.nav>li.disabled>a:focus,.nav>li.disabled>a:hover{color:#777;text-decoration:none;cursor:not-allowed;background-color:transparent}.nav .open>a,.nav .open>a:focus,.nav .open>a:hover{background-color:#eee;border-color:#337ab7}.nav .nav-divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.nav>li>a>img{max-width:none}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{float:left;margin-bottom:-1px}.nav-tabs>li>a{margin-right:2px;line-height:1.42857143;border:1px solid transparent;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover{border-color:#eee #eee #ddd}.nav-tabs>li.active>a,.nav-tabs>li.active>a:focus,.nav-tabs>li.active>a:hover{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-tabs.nav-justified{width:100%;border-bottom:0}.nav-tabs.nav-justified>li{float:none}.nav-tabs.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-tabs.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-tabs.nav-justified>li{display:table-cell;width:1%}.nav-tabs.nav-justified>li>a{margin-bottom:0}}.nav-tabs.nav-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs.nav-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border-bottom-color:#fff}}.nav-pills>li{float:left}.nav-pills>li>a{border-radius:4px}.nav-pills>li+li{margin-left:2px}.nav-pills>li.active>a,.nav-pills>li.active>a:focus,.nav-pills>li.active>a:hover{color:#fff;background-color:#337ab7}.nav-stacked>li{float:none}.nav-stacked>li+li{margin-top:2px;margin-left:0}.nav-justified{width:100%}.nav-justified>li{float:none}.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-justified>li{display:table-cell;width:1%}.nav-justified>li>a{margin-bottom:0}}.nav-tabs-justified{border-bottom:0}.nav-tabs-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border-bottom-color:#fff}}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-left-radius:0;border-top-right-radius:0}.navbar{position:relative;min-height:50px;margin-bottom:20px;border:1px solid transparent}@media (min-width:768px){.navbar{border-radius:4px}}@media (min-width:768px){.navbar-header{float:left}}.navbar-collapse{padding-right:15px;padding-left:15px;overflow-x:visible;-webkit-overflow-scrolling:touch;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1)}.navbar-collapse.in{overflow-y:auto}@media (min-width:768px){.navbar-collapse{width:auto;border-top:0;-webkit-box-shadow:none;box-shadow:none}.navbar-collapse.collapse{display:block!important;height:auto!important;padding-bottom:0;overflow:visible!important}.navbar-collapse.in{overflow-y:visible}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse,.navbar-static-top .navbar-collapse{padding-right:0;padding-left:0}}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:340px}@media (max-device-width:480px) and (orientation:landscape){.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:200px}}.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:0;margin-left:0}}.navbar-static-top{z-index:1000;border-width:0 0 1px}@media (min-width:768px){.navbar-static-top{border-radius:0}}.navbar-fixed-bottom,.navbar-fixed-top{position:fixed;right:0;left:0;z-index:1030}@media (min-width:768px){.navbar-fixed-bottom,.navbar-fixed-top{border-radius:0}}.navbar-fixed-top{top:0;border-width:0 0 1px}.navbar-fixed-bottom{bottom:0;margin-bottom:0;border-width:1px 0 0}.navbar-brand{float:left;height:50px;padding:15px 15px;font-size:18px;line-height:20px}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}.navbar-brand>img{display:block}@media (min-width:768px){.navbar>.container .navbar-brand,.navbar>.container-fluid .navbar-brand{margin-left:-15px}}.navbar-toggle{position:relative;float:right;padding:9px 10px;margin-top:8px;margin-right:15px;margin-bottom:8px;background-color:transparent;background-image:none;border:1px solid transparent;border-radius:4px}.navbar-toggle:focus{outline:0}.navbar-toggle .icon-bar{display:block;width:22px;height:2px;border-radius:1px}.navbar-toggle .icon-bar+.icon-bar{margin-top:4px}@media (min-width:768px){.navbar-toggle{display:none}}.navbar-nav{margin:7.5px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:20px}@media (max-width:767px){.navbar-nav .open .dropdown-menu{position:static;float:none;width:auto;margin-top:0;background-color:transparent;border:0;-webkit-box-shadow:none;box-shadow:none}.navbar-nav .open .dropdown-menu .dropdown-header,.navbar-nav .open .dropdown-menu>li>a{padding:5px 15px 5px 25px}.navbar-nav .open .dropdown-menu>li>a{line-height:20px}.navbar-nav .open .dropdown-menu>li>a:focus,.navbar-nav .open .dropdown-menu>li>a:hover{background-image:none}}@media (min-width:768px){.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:15px;padding-bottom:15px}}.navbar-form{padding:10px 15px;margin-top:8px;margin-right:-15px;margin-bottom:8px;margin-left:-15px;border-top:1px solid transparent;border-bottom:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1)}@media (min-width:768px){.navbar-form .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.navbar-form .form-control{display:inline-block;width:auto;vertical-align:middle}.navbar-form .form-control-static{display:inline-block}.navbar-form .input-group{display:inline-table;vertical-align:middle}.navbar-form .input-group .form-control,.navbar-form .input-group .input-group-addon,.navbar-form .input-group .input-group-btn{width:auto}.navbar-form .input-group>.form-control{width:100%}.navbar-form .control-label{margin-bottom:0;vertical-align:middle}.navbar-form .checkbox,.navbar-form .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.navbar-form .checkbox label,.navbar-form .radio label{padding-left:0}.navbar-form .checkbox input[type=checkbox],.navbar-form .radio input[type=radio]{position:relative;margin-left:0}.navbar-form .has-feedback .form-control-feedback{top:0}}@media (max-width:767px){.navbar-form .form-group{margin-bottom:5px}.navbar-form .form-group:last-child{margin-bottom:0}}@media (min-width:768px){.navbar-form{width:auto;padding-top:0;padding-bottom:0;margin-right:0;margin-left:0;border:0;-webkit-box-shadow:none;box-shadow:none}}.navbar-nav>li>.dropdown-menu{margin-top:0;border-top-left-radius:0;border-top-right-radius:0}.navbar-fixed-bottom .navbar-nav>li>.dropdown-menu{margin-bottom:0;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.navbar-btn{margin-top:8px;margin-bottom:8px}.navbar-btn.btn-sm{margin-top:10px;margin-bottom:10px}.navbar-btn.btn-xs{margin-top:14px;margin-bottom:14px}.navbar-text{margin-top:15px;margin-bottom:15px}@media (min-width:768px){.navbar-text{float:left;margin-right:15px;margin-left:15px}}@media (min-width:768px){.navbar-left{float:left!important}.navbar-right{float:right!important;margin-right:-15px}.navbar-right~.navbar-right{margin-right:0}}.navbar-default{background-color:#f8f8f8;border-color:#e7e7e7}.navbar-default .navbar-brand{color:#777}.navbar-default .navbar-brand:focus,.navbar-default .navbar-brand:hover{color:#5e5e5e;background-color:transparent}.navbar-default .navbar-text{color:#777}.navbar-default .navbar-nav>li>a{color:#777}.navbar-default .navbar-nav>li>a:focus,.navbar-default .navbar-nav>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.active>a:focus,.navbar-default .navbar-nav>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav>.disabled>a,.navbar-default .navbar-nav>.disabled>a:focus,.navbar-default .navbar-nav>.disabled>a:hover{color:#ccc;background-color:transparent}.navbar-default .navbar-toggle{border-color:#ddd}.navbar-default .navbar-toggle:focus,.navbar-default .navbar-toggle:hover{background-color:#ddd}.navbar-default .navbar-toggle .icon-bar{background-color:#888}.navbar-default .navbar-collapse,.navbar-default .navbar-form{border-color:#e7e7e7}.navbar-default .navbar-nav>.open>a,.navbar-default .navbar-nav>.open>a:focus,.navbar-default .navbar-nav>.open>a:hover{color:#555;background-color:#e7e7e7}@media (max-width:767px){.navbar-default .navbar-nav .open .dropdown-menu>li>a{color:#777}.navbar-default .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav .open .dropdown-menu>.active>a,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#ccc;background-color:transparent}}.navbar-default .navbar-link{color:#777}.navbar-default .navbar-link:hover{color:#333}.navbar-default .btn-link{color:#777}.navbar-default .btn-link:focus,.navbar-default .btn-link:hover{color:#333}.navbar-default .btn-link[disabled]:focus,.navbar-default .btn-link[disabled]:hover,fieldset[disabled] .navbar-default .btn-link:focus,fieldset[disabled] .navbar-default .btn-link:hover{color:#ccc}.navbar-inverse{background-color:#222;border-color:#080808}.navbar-inverse .navbar-brand{color:#9d9d9d}.navbar-inverse .navbar-brand:focus,.navbar-inverse .navbar-brand:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-text{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a:focus,.navbar-inverse .navbar-nav>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>.active>a,.navbar-inverse .navbar-nav>.active>a:focus,.navbar-inverse .navbar-nav>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav>.disabled>a,.navbar-inverse .navbar-nav>.disabled>a:focus,.navbar-inverse .navbar-nav>.disabled>a:hover{color:#444;background-color:transparent}.navbar-inverse .navbar-toggle{border-color:#333}.navbar-inverse .navbar-toggle:focus,.navbar-inverse .navbar-toggle:hover{background-color:#333}.navbar-inverse .navbar-toggle .icon-bar{background-color:#fff}.navbar-inverse .navbar-collapse,.navbar-inverse .navbar-form{border-color:#101010}.navbar-inverse .navbar-nav>.open>a,.navbar-inverse .navbar-nav>.open>a:focus,.navbar-inverse .navbar-nav>.open>a:hover{color:#fff;background-color:#080808}@media (max-width:767px){.navbar-inverse .navbar-nav .open .dropdown-menu>.dropdown-header{border-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu .divider{background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#444;background-color:transparent}}.navbar-inverse .navbar-link{color:#9d9d9d}.navbar-inverse .navbar-link:hover{color:#fff}.navbar-inverse .btn-link{color:#9d9d9d}.navbar-inverse .btn-link:focus,.navbar-inverse .btn-link:hover{color:#fff}.navbar-inverse .btn-link[disabled]:focus,.navbar-inverse .btn-link[disabled]:hover,fieldset[disabled] .navbar-inverse .btn-link:focus,fieldset[disabled] .navbar-inverse .btn-link:hover{color:#444}.breadcrumb{padding:8px 15px;margin-bottom:20px;list-style:none;background-color:#f5f5f5;border-radius:4px}.breadcrumb>li{display:inline-block}.breadcrumb>li+li:before{padding:0 5px;color:#ccc;content:\"/\\00a0\"}.breadcrumb>.active{color:#777}.pagination{display:inline-block;padding-left:0;margin:20px 0;border-radius:4px}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:6px 12px;margin-left:-1px;line-height:1.42857143;color:#337ab7;text-decoration:none;background-color:#fff;border:1px solid #ddd}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-top-left-radius:4px;border-bottom-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-top-right-radius:4px;border-bottom-right-radius:4px}.pagination>li>a:focus,.pagination>li>a:hover,.pagination>li>span:focus,.pagination>li>span:hover{z-index:2;color:#23527c;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:focus,.pagination>.active>a:hover,.pagination>.active>span,.pagination>.active>span:focus,.pagination>.active>span:hover{z-index:3;color:#fff;cursor:default;background-color:#337ab7;border-color:#337ab7}.pagination>.disabled>a,.pagination>.disabled>a:focus,.pagination>.disabled>a:hover,.pagination>.disabled>span,.pagination>.disabled>span:focus,.pagination>.disabled>span:hover{color:#777;cursor:not-allowed;background-color:#fff;border-color:#ddd}.pagination-lg>li>a,.pagination-lg>li>span{padding:10px 16px;font-size:18px;line-height:1.3333333}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-top-left-radius:6px;border-bottom-left-radius:6px}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-top-right-radius:6px;border-bottom-right-radius:6px}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:12px;line-height:1.5}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-top-left-radius:3px;border-bottom-left-radius:3px}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-top-right-radius:3px;border-bottom-right-radius:3px}.pager{padding-left:0;margin:20px 0;text-align:center;list-style:none}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;border-radius:15px}.pager li>a:focus,.pager li>a:hover{text-decoration:none;background-color:#eee}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:focus,.pager .disabled>a:hover,.pager .disabled>span{color:#777;cursor:not-allowed;background-color:#fff}.label{display:inline;padding:.2em .6em .3em;font-size:75%;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25em}a.label:focus,a.label:hover{color:#fff;text-decoration:none;cursor:pointer}.label:empty{display:none}.btn .label{position:relative;top:-1px}.label-default{background-color:#777}.label-default[href]:focus,.label-default[href]:hover{background-color:#5e5e5e}.label-primary{background-color:#337ab7}.label-primary[href]:focus,.label-primary[href]:hover{background-color:#286090}.label-success{background-color:#5cb85c}.label-success[href]:focus,.label-success[href]:hover{background-color:#449d44}.label-info{background-color:#5bc0de}.label-info[href]:focus,.label-info[href]:hover{background-color:#31b0d5}.label-warning{background-color:#f0ad4e}.label-warning[href]:focus,.label-warning[href]:hover{background-color:#ec971f}.label-danger{background-color:#d9534f}.label-danger[href]:focus,.label-danger[href]:hover{background-color:#c9302c}.badge{display:inline-block;min-width:10px;padding:3px 7px;font-size:12px;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:middle;background-color:#777;border-radius:10px}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.btn-group-xs>.btn .badge,.btn-xs .badge{top:0;padding:1px 5px}a.badge:focus,a.badge:hover{color:#fff;text-decoration:none;cursor:pointer}.list-group-item.active>.badge,.nav-pills>.active>a>.badge{color:#337ab7;background-color:#fff}.list-group-item>.badge{float:right}.list-group-item>.badge+.badge{margin-right:5px}.nav-pills>li>a>.badge{margin-left:3px}.jumbotron{padding-top:30px;padding-bottom:30px;margin-bottom:30px;color:inherit;background-color:#eee}.jumbotron .h1,.jumbotron h1{color:inherit}.jumbotron p{margin-bottom:15px;font-size:21px;font-weight:200}.jumbotron>hr{border-top-color:#d5d5d5}.container .jumbotron,.container-fluid .jumbotron{padding-right:15px;padding-left:15px;border-radius:6px}.jumbotron .container{max-width:100%}@media screen and (min-width:768px){.jumbotron{padding-top:48px;padding-bottom:48px}.container .jumbotron,.container-fluid .jumbotron{padding-right:60px;padding-left:60px}.jumbotron .h1,.jumbotron h1{font-size:63px}}.thumbnail{display:block;padding:4px;margin-bottom:20px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:border .2s ease-in-out;-o-transition:border .2s ease-in-out;transition:border .2s ease-in-out}.thumbnail a>img,.thumbnail>img{margin-right:auto;margin-left:auto}a.thumbnail.active,a.thumbnail:focus,a.thumbnail:hover{border-color:#337ab7}.thumbnail .caption{padding:9px;color:#333}.alert{padding:15px;margin-bottom:20px;border:1px solid transparent;border-radius:4px}.alert h4{margin-top:0;color:inherit}.alert .alert-link{font-weight:700}.alert>p,.alert>ul{margin-bottom:0}.alert>p+p{margin-top:5px}.alert-dismissable,.alert-dismissible{padding-right:35px}.alert-dismissable .close,.alert-dismissible .close{position:relative;top:-2px;right:-21px;color:inherit}.alert-success{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.alert-success hr{border-top-color:#c9e2b3}.alert-success .alert-link{color:#2b542c}.alert-info{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.alert-info hr{border-top-color:#a6e1ec}.alert-info .alert-link{color:#245269}.alert-warning{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.alert-warning hr{border-top-color:#f7e1b5}.alert-warning .alert-link{color:#66512c}.alert-danger{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.alert-danger hr{border-top-color:#e4b9c0}.alert-danger .alert-link{color:#843534}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:20px;margin-bottom:20px;overflow:hidden;background-color:#f5f5f5;border-radius:4px;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,.1);box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}.progress-bar{float:left;width:0;height:100%;font-size:12px;line-height:20px;color:#fff;text-align:center;background-color:#337ab7;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);-webkit-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress-bar-striped,.progress-striped .progress-bar{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;background-size:40px 40px}.progress-bar.active,.progress.active .progress-bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-bar-success{background-color:#5cb85c}.progress-striped .progress-bar-success{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-info{background-color:#5bc0de}.progress-striped .progress-bar-info{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-warning{background-color:#f0ad4e}.progress-striped .progress-bar-warning{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-danger{background-color:#d9534f}.progress-striped .progress-bar-danger{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.media{margin-top:15px}.media:first-child{margin-top:0}.media,.media-body{overflow:hidden;zoom:1}.media-body{width:10000px}.media-object{display:block}.media-object.img-thumbnail{max-width:none}.media-right,.media>.pull-right{padding-left:10px}.media-left,.media>.pull-left{padding-right:10px}.media-body,.media-left,.media-right{display:table-cell;vertical-align:top}.media-middle{vertical-align:middle}.media-bottom{vertical-align:bottom}.media-heading{margin-top:0;margin-bottom:5px}.media-list{padding-left:0;list-style:none}.list-group{padding-left:0;margin-bottom:20px}.list-group-item{position:relative;display:block;padding:10px 15px;margin-bottom:-1px;background-color:#fff;border:1px solid #ddd}.list-group-item:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.list-group-item:last-child{margin-bottom:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}a.list-group-item,button.list-group-item{color:#555}a.list-group-item .list-group-item-heading,button.list-group-item .list-group-item-heading{color:#333}a.list-group-item:focus,a.list-group-item:hover,button.list-group-item:focus,button.list-group-item:hover{color:#555;text-decoration:none;background-color:#f5f5f5}button.list-group-item{width:100%;text-align:left}.list-group-item.disabled,.list-group-item.disabled:focus,.list-group-item.disabled:hover{color:#777;cursor:not-allowed;background-color:#eee}.list-group-item.disabled .list-group-item-heading,.list-group-item.disabled:focus .list-group-item-heading,.list-group-item.disabled:hover .list-group-item-heading{color:inherit}.list-group-item.disabled .list-group-item-text,.list-group-item.disabled:focus .list-group-item-text,.list-group-item.disabled:hover .list-group-item-text{color:#777}.list-group-item.active,.list-group-item.active:focus,.list-group-item.active:hover{z-index:2;color:#fff;background-color:#337ab7;border-color:#337ab7}.list-group-item.active .list-group-item-heading,.list-group-item.active .list-group-item-heading>.small,.list-group-item.active .list-group-item-heading>small,.list-group-item.active:focus .list-group-item-heading,.list-group-item.active:focus .list-group-item-heading>.small,.list-group-item.active:focus .list-group-item-heading>small,.list-group-item.active:hover .list-group-item-heading,.list-group-item.active:hover .list-group-item-heading>.small,.list-group-item.active:hover .list-group-item-heading>small{color:inherit}.list-group-item.active .list-group-item-text,.list-group-item.active:focus .list-group-item-text,.list-group-item.active:hover .list-group-item-text{color:#c7ddef}.list-group-item-success{color:#3c763d;background-color:#dff0d8}a.list-group-item-success,button.list-group-item-success{color:#3c763d}a.list-group-item-success .list-group-item-heading,button.list-group-item-success .list-group-item-heading{color:inherit}a.list-group-item-success:focus,a.list-group-item-success:hover,button.list-group-item-success:focus,button.list-group-item-success:hover{color:#3c763d;background-color:#d0e9c6}a.list-group-item-success.active,a.list-group-item-success.active:focus,a.list-group-item-success.active:hover,button.list-group-item-success.active,button.list-group-item-success.active:focus,button.list-group-item-success.active:hover{color:#fff;background-color:#3c763d;border-color:#3c763d}.list-group-item-info{color:#31708f;background-color:#d9edf7}a.list-group-item-info,button.list-group-item-info{color:#31708f}a.list-group-item-info .list-group-item-heading,button.list-group-item-info .list-group-item-heading{color:inherit}a.list-group-item-info:focus,a.list-group-item-info:hover,button.list-group-item-info:focus,button.list-group-item-info:hover{color:#31708f;background-color:#c4e3f3}a.list-group-item-info.active,a.list-group-item-info.active:focus,a.list-group-item-info.active:hover,button.list-group-item-info.active,button.list-group-item-info.active:focus,button.list-group-item-info.active:hover{color:#fff;background-color:#31708f;border-color:#31708f}.list-group-item-warning{color:#8a6d3b;background-color:#fcf8e3}a.list-group-item-warning,button.list-group-item-warning{color:#8a6d3b}a.list-group-item-warning .list-group-item-heading,button.list-group-item-warning .list-group-item-heading{color:inherit}a.list-group-item-warning:focus,a.list-group-item-warning:hover,button.list-group-item-warning:focus,button.list-group-item-warning:hover{color:#8a6d3b;background-color:#faf2cc}a.list-group-item-warning.active,a.list-group-item-warning.active:focus,a.list-group-item-warning.active:hover,button.list-group-item-warning.active,button.list-group-item-warning.active:focus,button.list-group-item-warning.active:hover{color:#fff;background-color:#8a6d3b;border-color:#8a6d3b}.list-group-item-danger{color:#a94442;background-color:#f2dede}a.list-group-item-danger,button.list-group-item-danger{color:#a94442}a.list-group-item-danger .list-group-item-heading,button.list-group-item-danger .list-group-item-heading{color:inherit}a.list-group-item-danger:focus,a.list-group-item-danger:hover,button.list-group-item-danger:focus,button.list-group-item-danger:hover{color:#a94442;background-color:#ebcccc}a.list-group-item-danger.active,a.list-group-item-danger.active:focus,a.list-group-item-danger.active:hover,button.list-group-item-danger.active,button.list-group-item-danger.active:focus,button.list-group-item-danger.active:hover{color:#fff;background-color:#a94442;border-color:#a94442}.list-group-item-heading{margin-top:0;margin-bottom:5px}.list-group-item-text{margin-bottom:0;line-height:1.3}.panel{margin-bottom:20px;background-color:#fff;border:1px solid transparent;border-radius:4px;-webkit-box-shadow:0 1px 1px rgba(0,0,0,.05);box-shadow:0 1px 1px rgba(0,0,0,.05)}.panel-body{padding:15px}.panel-heading{padding:10px 15px;border-bottom:1px solid transparent;border-top-left-radius:3px;border-top-right-radius:3px}.panel-heading>.dropdown .dropdown-toggle{color:inherit}.panel-title{margin-top:0;margin-bottom:0;font-size:16px;color:inherit}.panel-title>.small,.panel-title>.small>a,.panel-title>a,.panel-title>small,.panel-title>small>a{color:inherit}.panel-footer{padding:10px 15px;background-color:#f5f5f5;border-top:1px solid #ddd;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.list-group,.panel>.panel-collapse>.list-group{margin-bottom:0}.panel>.list-group .list-group-item,.panel>.panel-collapse>.list-group .list-group-item{border-width:1px 0;border-radius:0}.panel>.list-group:first-child .list-group-item:first-child,.panel>.panel-collapse>.list-group:first-child .list-group-item:first-child{border-top:0;border-top-left-radius:3px;border-top-right-radius:3px}.panel>.list-group:last-child .list-group-item:last-child,.panel>.panel-collapse>.list-group:last-child .list-group-item:last-child{border-bottom:0;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.panel-heading+.panel-collapse>.list-group .list-group-item:first-child{border-top-left-radius:0;border-top-right-radius:0}.panel-heading+.list-group .list-group-item:first-child{border-top-width:0}.list-group+.panel-footer{border-top-width:0}.panel>.panel-collapse>.table,.panel>.table,.panel>.table-responsive>.table{margin-bottom:0}.panel>.panel-collapse>.table caption,.panel>.table caption,.panel>.table-responsive>.table caption{padding-right:15px;padding-left:15px}.panel>.table-responsive:first-child>.table:first-child,.panel>.table:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child,.panel>.table:first-child>thead:first-child>tr:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table:first-child>thead:first-child>tr:first-child th:first-child{border-top-left-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table:first-child>thead:first-child>tr:first-child th:last-child{border-top-right-radius:3px}.panel>.table-responsive:last-child>.table:last-child,.panel>.table:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:first-child{border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:last-child{border-bottom-right-radius:3px}.panel>.panel-body+.table,.panel>.panel-body+.table-responsive,.panel>.table+.panel-body,.panel>.table-responsive+.panel-body{border-top:1px solid #ddd}.panel>.table>tbody:first-child>tr:first-child td,.panel>.table>tbody:first-child>tr:first-child th{border-top:0}.panel>.table-bordered,.panel>.table-responsive>.table-bordered{border:0}.panel>.table-bordered>tbody>tr>td:first-child,.panel>.table-bordered>tbody>tr>th:first-child,.panel>.table-bordered>tfoot>tr>td:first-child,.panel>.table-bordered>tfoot>tr>th:first-child,.panel>.table-bordered>thead>tr>td:first-child,.panel>.table-bordered>thead>tr>th:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:first-child,.panel>.table-responsive>.table-bordered>thead>tr>td:first-child,.panel>.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.panel>.table-bordered>tbody>tr>td:last-child,.panel>.table-bordered>tbody>tr>th:last-child,.panel>.table-bordered>tfoot>tr>td:last-child,.panel>.table-bordered>tfoot>tr>th:last-child,.panel>.table-bordered>thead>tr>td:last-child,.panel>.table-bordered>thead>tr>th:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:last-child,.panel>.table-responsive>.table-bordered>thead>tr>td:last-child,.panel>.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.panel>.table-bordered>tbody>tr:first-child>td,.panel>.table-bordered>tbody>tr:first-child>th,.panel>.table-bordered>thead>tr:first-child>td,.panel>.table-bordered>thead>tr:first-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>th,.panel>.table-responsive>.table-bordered>thead>tr:first-child>td,.panel>.table-responsive>.table-bordered>thead>tr:first-child>th{border-bottom:0}.panel>.table-bordered>tbody>tr:last-child>td,.panel>.table-bordered>tbody>tr:last-child>th,.panel>.table-bordered>tfoot>tr:last-child>td,.panel>.table-bordered>tfoot>tr:last-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>th,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>td,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}.panel>.table-responsive{margin-bottom:0;border:0}.panel-group{margin-bottom:20px}.panel-group .panel{margin-bottom:0;border-radius:4px}.panel-group .panel+.panel{margin-top:5px}.panel-group .panel-heading{border-bottom:0}.panel-group .panel-heading+.panel-collapse>.list-group,.panel-group .panel-heading+.panel-collapse>.panel-body{border-top:1px solid #ddd}.panel-group .panel-footer{border-top:0}.panel-group .panel-footer+.panel-collapse .panel-body{border-bottom:1px solid #ddd}.panel-default{border-color:#ddd}.panel-default>.panel-heading{color:#333;background-color:#f5f5f5;border-color:#ddd}.panel-default>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ddd}.panel-default>.panel-heading .badge{color:#f5f5f5;background-color:#333}.panel-default>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ddd}.panel-primary{border-color:#337ab7}.panel-primary>.panel-heading{color:#fff;background-color:#337ab7;border-color:#337ab7}.panel-primary>.panel-heading+.panel-collapse>.panel-body{border-top-color:#337ab7}.panel-primary>.panel-heading .badge{color:#337ab7;background-color:#fff}.panel-primary>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#337ab7}.panel-success{border-color:#d6e9c6}.panel-success>.panel-heading{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.panel-success>.panel-heading+.panel-collapse>.panel-body{border-top-color:#d6e9c6}.panel-success>.panel-heading .badge{color:#dff0d8;background-color:#3c763d}.panel-success>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#d6e9c6}.panel-info{border-color:#bce8f1}.panel-info>.panel-heading{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.panel-info>.panel-heading+.panel-collapse>.panel-body{border-top-color:#bce8f1}.panel-info>.panel-heading .badge{color:#d9edf7;background-color:#31708f}.panel-info>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#bce8f1}.panel-warning{border-color:#faebcc}.panel-warning>.panel-heading{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.panel-warning>.panel-heading+.panel-collapse>.panel-body{border-top-color:#faebcc}.panel-warning>.panel-heading .badge{color:#fcf8e3;background-color:#8a6d3b}.panel-warning>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#faebcc}.panel-danger{border-color:#ebccd1}.panel-danger>.panel-heading{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.panel-danger>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ebccd1}.panel-danger>.panel-heading .badge{color:#f2dede;background-color:#a94442}.panel-danger>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ebccd1}.embed-responsive{position:relative;display:block;height:0;padding:0;overflow:hidden}.embed-responsive .embed-responsive-item,.embed-responsive embed,.embed-responsive iframe,.embed-responsive object,.embed-responsive video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.embed-responsive-16by9{padding-bottom:56.25%}.embed-responsive-4by3{padding-bottom:75%}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.05);box-shadow:inset 0 1px 1px rgba(0,0,0,.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,.15)}.well-lg{padding:24px;border-radius:6px}.well-sm{padding:9px;border-radius:3px}.close{float:right;font-size:21px;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;filter:alpha(opacity=20);opacity:.2}.close:focus,.close:hover{color:#000;text-decoration:none;cursor:pointer;filter:alpha(opacity=50);opacity:.5}button.close{-webkit-appearance:none;padding:0;cursor:pointer;background:0 0;border:0}.modal-open{overflow:hidden}.modal{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;display:none;overflow:hidden;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{-webkit-transition:-webkit-transform .3s ease-out;-o-transition:-o-transform .3s ease-out;transition:transform .3s ease-out;-webkit-transform:translate(0,-25%);-ms-transform:translate(0,-25%);-o-transform:translate(0,-25%);transform:translate(0,-25%)}.modal.in .modal-dialog{-webkit-transform:translate(0,0);-ms-transform:translate(0,0);-o-transform:translate(0,0);transform:translate(0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;outline:0;-webkit-box-shadow:0 3px 9px rgba(0,0,0,.5);box-shadow:0 3px 9px rgba(0,0,0,.5)}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{filter:alpha(opacity=0);opacity:0}.modal-backdrop.in{filter:alpha(opacity=50);opacity:.5}.modal-header{padding:15px;border-bottom:1px solid #e5e5e5}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.42857143}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}@media (min-width:768px){.modal-dialog{width:600px;margin:30px auto}.modal-content{-webkit-box-shadow:0 5px 15px rgba(0,0,0,.5);box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}.tooltip{position:absolute;z-index:1070;display:block;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:12px;font-style:normal;font-weight:400;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;word-wrap:normal;white-space:normal;filter:alpha(opacity=0);opacity:0;line-break:auto}.tooltip.in{filter:alpha(opacity=90);opacity:.9}.tooltip.top{padding:5px 0;margin-top:-3px}.tooltip.right{padding:0 5px;margin-left:3px}.tooltip.bottom{padding:5px 0;margin-top:3px}.tooltip.left{padding:0 5px;margin-left:-3px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-left .tooltip-arrow{right:5px;bottom:0;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-right .tooltip-arrow{bottom:0;left:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-left .tooltip-arrow{top:0;right:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-right .tooltip-arrow{top:0;left:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.popover{position:absolute;top:0;left:0;z-index:1060;display:none;max-width:276px;padding:1px;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;font-style:normal;font-weight:400;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;word-wrap:normal;white-space:normal;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.2);border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,.2);box-shadow:0 5px 10px rgba(0,0,0,.2);line-break:auto}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{padding:8px 14px;margin:0;font-size:14px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-radius:5px 5px 0 0}.popover-content{padding:9px 14px}.popover>.arrow,.popover>.arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.popover>.arrow{border-width:11px}.popover>.arrow:after{content:\"\";border-width:10px}.popover.top>.arrow{bottom:-11px;left:50%;margin-left:-11px;border-top-color:#999;border-top-color:rgba(0,0,0,.25);border-bottom-width:0}.popover.top>.arrow:after{bottom:1px;margin-left:-10px;content:\" \";border-top-color:#fff;border-bottom-width:0}.popover.right>.arrow{top:50%;left:-11px;margin-top:-11px;border-right-color:#999;border-right-color:rgba(0,0,0,.25);border-left-width:0}.popover.right>.arrow:after{bottom:-10px;left:1px;content:\" \";border-right-color:#fff;border-left-width:0}.popover.bottom>.arrow{top:-11px;left:50%;margin-left:-11px;border-top-width:0;border-bottom-color:#999;border-bottom-color:rgba(0,0,0,.25)}.popover.bottom>.arrow:after{top:1px;margin-left:-10px;content:\" \";border-top-width:0;border-bottom-color:#fff}.popover.left>.arrow{top:50%;right:-11px;margin-top:-11px;border-right-width:0;border-left-color:#999;border-left-color:rgba(0,0,0,.25)}.popover.left>.arrow:after{right:1px;bottom:-10px;content:\" \";border-right-width:0;border-left-color:#fff}.carousel{position:relative}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-inner>.item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel-inner>.item>a>img,.carousel-inner>.item>img{line-height:1}@media all and (transform-3d),(-webkit-transform-3d){.carousel-inner>.item{-webkit-transition:-webkit-transform .6s ease-in-out;-o-transition:-o-transform .6s ease-in-out;transition:transform .6s ease-in-out;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-perspective:1000px;perspective:1000px}.carousel-inner>.item.active.right,.carousel-inner>.item.next{left:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}.carousel-inner>.item.active.left,.carousel-inner>.item.prev{left:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}.carousel-inner>.item.active,.carousel-inner>.item.next.left,.carousel-inner>.item.prev.right{left:0;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:0;bottom:0;left:0;width:15%;font-size:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6);background-color:rgba(0,0,0,0);filter:alpha(opacity=50);opacity:.5}.carousel-control.left{background-image:-webkit-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,.0001)));background-image:linear-gradient(to right,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1);background-repeat:repeat-x}.carousel-control.right{right:0;left:auto;background-image:-webkit-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.0001)),to(rgba(0,0,0,.5)));background-image:linear-gradient(to right,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1);background-repeat:repeat-x}.carousel-control:focus,.carousel-control:hover{color:#fff;text-decoration:none;filter:alpha(opacity=90);outline:0;opacity:.9}.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{position:absolute;top:50%;z-index:5;display:inline-block;margin-top:-10px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{left:50%;margin-left:-10px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{right:50%;margin-right:-10px}.carousel-control .icon-next,.carousel-control .icon-prev{width:20px;height:20px;font-family:serif;line-height:1}.carousel-control .icon-prev:before{content:'\\2039'}.carousel-control .icon-next:before{content:'\\203a'}.carousel-indicators{position:absolute;bottom:10px;left:50%;z-index:15;width:60%;padding-left:0;margin-left:-30%;text-align:center;list-style:none}.carousel-indicators li{display:inline-block;width:10px;height:10px;margin:1px;text-indent:-999px;cursor:pointer;background-color:#000\\9;background-color:rgba(0,0,0,0);border:1px solid #fff;border-radius:10px}.carousel-indicators .active{width:12px;height:12px;margin:0;background-color:#fff}.carousel-caption{position:absolute;right:15%;bottom:20px;left:15%;z-index:10;padding-top:20px;padding-bottom:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6)}.carousel-caption .btn{text-shadow:none}@media screen and (min-width:768px){.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{width:30px;height:30px;margin-top:-10px;font-size:30px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{margin-left:-10px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{margin-right:-10px}.carousel-caption{right:20%;left:20%;padding-bottom:30px}.carousel-indicators{bottom:20px}}.btn-group-vertical>.btn-group:after,.btn-group-vertical>.btn-group:before,.btn-toolbar:after,.btn-toolbar:before,.clearfix:after,.clearfix:before,.container-fluid:after,.container-fluid:before,.container:after,.container:before,.dl-horizontal dd:after,.dl-horizontal dd:before,.form-horizontal .form-group:after,.form-horizontal .form-group:before,.modal-footer:after,.modal-footer:before,.modal-header:after,.modal-header:before,.nav:after,.nav:before,.navbar-collapse:after,.navbar-collapse:before,.navbar-header:after,.navbar-header:before,.navbar:after,.navbar:before,.pager:after,.pager:before,.panel-body:after,.panel-body:before,.row:after,.row:before{display:table;content:\" \"}.btn-group-vertical>.btn-group:after,.btn-toolbar:after,.clearfix:after,.container-fluid:after,.container:after,.dl-horizontal dd:after,.form-horizontal .form-group:after,.modal-footer:after,.modal-header:after,.nav:after,.navbar-collapse:after,.navbar-header:after,.navbar:after,.pager:after,.panel-body:after,.row:after{clear:both}.center-block{display:block;margin-right:auto;margin-left:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important}.affix{position:fixed}@-ms-viewport{width:device-width}.visible-lg,.visible-md,.visible-sm,.visible-xs{display:none!important}.visible-lg-block,.visible-lg-inline,.visible-lg-inline-block,.visible-md-block,.visible-md-inline,.visible-md-inline-block,.visible-sm-block,.visible-sm-inline,.visible-sm-inline-block,.visible-xs-block,.visible-xs-inline,.visible-xs-inline-block{display:none!important}@media (max-width:767px){.visible-xs{display:block!important}table.visible-xs{display:table!important}tr.visible-xs{display:table-row!important}td.visible-xs,th.visible-xs{display:table-cell!important}}@media (max-width:767px){.visible-xs-block{display:block!important}}@media (max-width:767px){.visible-xs-inline{display:inline!important}}@media (max-width:767px){.visible-xs-inline-block{display:inline-block!important}}@media (min-width:768px) and (max-width:991px){.visible-sm{display:block!important}table.visible-sm{display:table!important}tr.visible-sm{display:table-row!important}td.visible-sm,th.visible-sm{display:table-cell!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-block{display:block!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline{display:inline!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline-block{display:inline-block!important}}@media (min-width:992px) and (max-width:1199px){.visible-md{display:block!important}table.visible-md{display:table!important}tr.visible-md{display:table-row!important}td.visible-md,th.visible-md{display:table-cell!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-block{display:block!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline{display:inline!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline-block{display:inline-block!important}}@media (min-width:1200px){.visible-lg{display:block!important}table.visible-lg{display:table!important}tr.visible-lg{display:table-row!important}td.visible-lg,th.visible-lg{display:table-cell!important}}@media (min-width:1200px){.visible-lg-block{display:block!important}}@media (min-width:1200px){.visible-lg-inline{display:inline!important}}@media (min-width:1200px){.visible-lg-inline-block{display:inline-block!important}}@media (max-width:767px){.hidden-xs{display:none!important}}@media (min-width:768px) and (max-width:991px){.hidden-sm{display:none!important}}@media (min-width:992px) and (max-width:1199px){.hidden-md{display:none!important}}@media (min-width:1200px){.hidden-lg{display:none!important}}.visible-print{display:none!important}@media print{.visible-print{display:block!important}table.visible-print{display:table!important}tr.visible-print{display:table-row!important}td.visible-print,th.visible-print{display:table-cell!important}}.visible-print-block{display:none!important}@media print{.visible-print-block{display:block!important}}.visible-print-inline{display:none!important}@media print{.visible-print-inline{display:inline!important}}.visible-print-inline-block{display:none!important}@media print{.visible-print-inline-block{display:inline-block!important}}@media print{.hidden-print{display:none!important}} /*# sourceMappingURL=bootstrap.min.css.map */"},{"title":"","date":"2018-10-30T12:50:19.318Z","updated":"2015-11-24T03:37:04.000Z","comments":true,"path":"cv/assets/plugins/bootstrap/js/bootstrap.js","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/bootstrap/js/bootstrap.js","excerpt":"","text":"/*! * Bootstrap v3.3.6 (http://getbootstrap.com) * Copyright 2011-2015 Twitter, Inc. * Licensed under the MIT license */ if (typeof jQuery === 'undefined') { throw new Error('Bootstrap\\'s JavaScript requires jQuery') } +function ($) { 'use strict'; var version = $.fn.jquery.split(' ')[0].split('.') if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 2)) { throw new Error('Bootstrap\\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3') } }(jQuery); /* ======================================================================== * Bootstrap: transition.js v3.3.6 * http://getbootstrap.com/javascript/#transitions * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/) // ============================================================ function transitionEnd() { var el = document.createElement('bootstrap') var transEndEventNames = { WebkitTransition : 'webkitTransitionEnd', MozTransition : 'transitionend', OTransition : 'oTransitionEnd otransitionend', transition : 'transitionend' } for (var name in transEndEventNames) { if (el.style[name] !== undefined) { return { end: transEndEventNames[name] } } } return false // explicit for ie8 ( ._.) } // http://blog.alexmaccaw.com/css-transitions $.fn.emulateTransitionEnd = function (duration) { var called = false var $el = this $(this).one('bsTransitionEnd', function () { called = true }) var callback = function () { if (!called) $($el).trigger($.support.transition.end) } setTimeout(callback, duration) return this } $(function () { $.support.transition = transitionEnd() if (!$.support.transition) return $.event.special.bsTransitionEnd = { bindType: $.support.transition.end, delegateType: $.support.transition.end, handle: function (e) { if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments) } } }) }(jQuery); /* ======================================================================== * Bootstrap: alert.js v3.3.6 * http://getbootstrap.com/javascript/#alerts * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // ALERT CLASS DEFINITION // ====================== var dismiss = '[data-dismiss=\"alert\"]' var Alert = function (el) { $(el).on('click', dismiss, this.close) } Alert.VERSION = '3.3.6' Alert.TRANSITION_DURATION = 150 Alert.prototype.close = function (e) { var $this = $(this) var selector = $this.attr('data-target') if (!selector) { selector = $this.attr('href') selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7 } var $parent = $(selector) if (e) e.preventDefault() if (!$parent.length) { $parent = $this.closest('.alert') } $parent.trigger(e = $.Event('close.bs.alert')) if (e.isDefaultPrevented()) return $parent.removeClass('in') function removeElement() { // detach from parent, fire event then clean up data $parent.detach().trigger('closed.bs.alert').remove() } $.support.transition && $parent.hasClass('fade') ? $parent .one('bsTransitionEnd', removeElement) .emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement() } // ALERT PLUGIN DEFINITION // ======================= function Plugin(option) { return this.each(function () { var $this = $(this) var data = $this.data('bs.alert') if (!data) $this.data('bs.alert', (data = new Alert(this))) if (typeof option == 'string') data[option].call($this) }) } var old = $.fn.alert $.fn.alert = Plugin $.fn.alert.Constructor = Alert // ALERT NO CONFLICT // ================= $.fn.alert.noConflict = function () { $.fn.alert = old return this } // ALERT DATA-API // ============== $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close) }(jQuery); /* ======================================================================== * Bootstrap: button.js v3.3.6 * http://getbootstrap.com/javascript/#buttons * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // BUTTON PUBLIC CLASS DEFINITION // ============================== var Button = function (element, options) { this.$element = $(element) this.options = $.extend({}, Button.DEFAULTS, options) this.isLoading = false } Button.VERSION = '3.3.6' Button.DEFAULTS = { loadingText: 'loading...' } Button.prototype.setState = function (state) { var d = 'disabled' var $el = this.$element var val = $el.is('input') ? 'val' : 'html' var data = $el.data() state += 'Text' if (data.resetText == null) $el.data('resetText', $el[val]()) // push to event loop to allow forms to submit setTimeout($.proxy(function () { $el[val](data[state] == null ? this.options[state] : data[state]) if (state == 'loadingText') { this.isLoading = true $el.addClass(d).attr(d, d) } else if (this.isLoading) { this.isLoading = false $el.removeClass(d).removeAttr(d) } }, this), 0) } Button.prototype.toggle = function () { var changed = true var $parent = this.$element.closest('[data-toggle=\"buttons\"]') if ($parent.length) { var $input = this.$element.find('input') if ($input.prop('type') == 'radio') { if ($input.prop('checked')) changed = false $parent.find('.active').removeClass('active') this.$element.addClass('active') } else if ($input.prop('type') == 'checkbox') { if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false this.$element.toggleClass('active') } $input.prop('checked', this.$element.hasClass('active')) if (changed) $input.trigger('change') } else { this.$element.attr('aria-pressed', !this.$element.hasClass('active')) this.$element.toggleClass('active') } } // BUTTON PLUGIN DEFINITION // ======================== function Plugin(option) { return this.each(function () { var $this = $(this) var data = $this.data('bs.button') var options = typeof option == 'object' && option if (!data) $this.data('bs.button', (data = new Button(this, options))) if (option == 'toggle') data.toggle() else if (option) data.setState(option) }) } var old = $.fn.button $.fn.button = Plugin $.fn.button.Constructor = Button // BUTTON NO CONFLICT // ================== $.fn.button.noConflict = function () { $.fn.button = old return this } // BUTTON DATA-API // =============== $(document) .on('click.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) { var $btn = $(e.target) if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn') Plugin.call($btn, 'toggle') if (!($(e.target).is('input[type=\"radio\"]') || $(e.target).is('input[type=\"checkbox\"]'))) e.preventDefault() }) .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) { $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type)) }) }(jQuery); /* ======================================================================== * Bootstrap: carousel.js v3.3.6 * http://getbootstrap.com/javascript/#carousel * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // CAROUSEL CLASS DEFINITION // ========================= var Carousel = function (element, options) { this.$element = $(element) this.$indicators = this.$element.find('.carousel-indicators') this.options = options this.paused = null this.sliding = null this.interval = null this.$active = null this.$items = null this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this)) this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element .on('mouseenter.bs.carousel', $.proxy(this.pause, this)) .on('mouseleave.bs.carousel', $.proxy(this.cycle, this)) } Carousel.VERSION = '3.3.6' Carousel.TRANSITION_DURATION = 600 Carousel.DEFAULTS = { interval: 5000, pause: 'hover', wrap: true, keyboard: true } Carousel.prototype.keydown = function (e) { if (/input|textarea/i.test(e.target.tagName)) return switch (e.which) { case 37: this.prev(); break case 39: this.next(); break default: return } e.preventDefault() } Carousel.prototype.cycle = function (e) { e || (this.paused = false) this.interval && clearInterval(this.interval) this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval)) return this } Carousel.prototype.getItemIndex = function (item) { this.$items = item.parent().children('.item') return this.$items.index(item || this.$active) } Carousel.prototype.getItemForDirection = function (direction, active) { var activeIndex = this.getItemIndex(active) var willWrap = (direction == 'prev' && activeIndex === 0) || (direction == 'next' && activeIndex == (this.$items.length - 1)) if (willWrap && !this.options.wrap) return active var delta = direction == 'prev' ? -1 : 1 var itemIndex = (activeIndex + delta) % this.$items.length return this.$items.eq(itemIndex) } Carousel.prototype.to = function (pos) { var that = this var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active')) if (pos > (this.$items.length - 1) || pos < 0) return if (this.sliding) return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, \"slid\" if (activeIndex == pos) return this.pause().cycle() return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos)) } Carousel.prototype.pause = function (e) { e || (this.paused = true) if (this.$element.find('.next, .prev').length && $.support.transition) { this.$element.trigger($.support.transition.end) this.cycle(true) } this.interval = clearInterval(this.interval) return this } Carousel.prototype.next = function () { if (this.sliding) return return this.slide('next') } Carousel.prototype.prev = function () { if (this.sliding) return return this.slide('prev') } Carousel.prototype.slide = function (type, next) { var $active = this.$element.find('.item.active') var $next = next || this.getItemForDirection(type, $active) var isCycling = this.interval var direction = type == 'next' ? 'left' : 'right' var that = this if ($next.hasClass('active')) return (this.sliding = false) var relatedTarget = $next[0] var slideEvent = $.Event('slide.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) this.$element.trigger(slideEvent) if (slideEvent.isDefaultPrevented()) return this.sliding = true isCycling && this.pause() if (this.$indicators.length) { this.$indicators.find('.active').removeClass('active') var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]) $nextIndicator && $nextIndicator.addClass('active') } var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, \"slid\" if ($.support.transition && this.$element.hasClass('slide')) { $next.addClass(type) $next[0].offsetWidth // force reflow $active.addClass(direction) $next.addClass(direction) $active .one('bsTransitionEnd', function () { $next.removeClass([type, direction].join(' ')).addClass('active') $active.removeClass(['active', direction].join(' ')) that.sliding = false setTimeout(function () { that.$element.trigger(slidEvent) }, 0) }) .emulateTransitionEnd(Carousel.TRANSITION_DURATION) } else { $active.removeClass('active') $next.addClass('active') this.sliding = false this.$element.trigger(slidEvent) } isCycling && this.cycle() return this } // CAROUSEL PLUGIN DEFINITION // ========================== function Plugin(option) { return this.each(function () { var $this = $(this) var data = $this.data('bs.carousel') var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option) var action = typeof option == 'string' ? option : options.slide if (!data) $this.data('bs.carousel', (data = new Carousel(this, options))) if (typeof option == 'number') data.to(option) else if (action) data[action]() else if (options.interval) data.pause().cycle() }) } var old = $.fn.carousel $.fn.carousel = Plugin $.fn.carousel.Constructor = Carousel // CAROUSEL NO CONFLICT // ==================== $.fn.carousel.noConflict = function () { $.fn.carousel = old return this } // CAROUSEL DATA-API // ================= var clickHandler = function (e) { var href var $this = $(this) var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '')) // strip for ie7 if (!$target.hasClass('carousel')) return var options = $.extend({}, $target.data(), $this.data()) var slideIndex = $this.attr('data-slide-to') if (slideIndex) options.interval = false Plugin.call($target, options) if (slideIndex) { $target.data('bs.carousel').to(slideIndex) } e.preventDefault() } $(document) .on('click.bs.carousel.data-api', '[data-slide]', clickHandler) .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler) $(window).on('load', function () { $('[data-ride=\"carousel\"]').each(function () { var $carousel = $(this) Plugin.call($carousel, $carousel.data()) }) }) }(jQuery); /* ======================================================================== * Bootstrap: collapse.js v3.3.6 * http://getbootstrap.com/javascript/#collapse * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // COLLAPSE PUBLIC CLASS DEFINITION // ================================ var Collapse = function (element, options) { this.$element = $(element) this.options = $.extend({}, Collapse.DEFAULTS, options) this.$trigger = $('[data-toggle=\"collapse\"][href=\"#' + element.id + '\"],' + '[data-toggle=\"collapse\"][data-target=\"#' + element.id + '\"]') this.transitioning = null if (this.options.parent) { this.$parent = this.getParent() } else { this.addAriaAndCollapsedClass(this.$element, this.$trigger) } if (this.options.toggle) this.toggle() } Collapse.VERSION = '3.3.6' Collapse.TRANSITION_DURATION = 350 Collapse.DEFAULTS = { toggle: true } Collapse.prototype.dimension = function () { var hasWidth = this.$element.hasClass('width') return hasWidth ? 'width' : 'height' } Collapse.prototype.show = function () { if (this.transitioning || this.$element.hasClass('in')) return var activesData var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing') if (actives && actives.length) { activesData = actives.data('bs.collapse') if (activesData && activesData.transitioning) return } var startEvent = $.Event('show.bs.collapse') this.$element.trigger(startEvent) if (startEvent.isDefaultPrevented()) return if (actives && actives.length) { Plugin.call(actives, 'hide') activesData || actives.data('bs.collapse', null) } var dimension = this.dimension() this.$element .removeClass('collapse') .addClass('collapsing')[dimension](0) .attr('aria-expanded', true) this.$trigger .removeClass('collapsed') .attr('aria-expanded', true) this.transitioning = 1 var complete = function () { this.$element .removeClass('collapsing') .addClass('collapse in')[dimension]('') this.transitioning = 0 this.$element .trigger('shown.bs.collapse') } if (!$.support.transition) return complete.call(this) var scrollSize = $.camelCase(['scroll', dimension].join('-')) this.$element .one('bsTransitionEnd', $.proxy(complete, this)) .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]) } Collapse.prototype.hide = function () { if (this.transitioning || !this.$element.hasClass('in')) return var startEvent = $.Event('hide.bs.collapse') this.$element.trigger(startEvent) if (startEvent.isDefaultPrevented()) return var dimension = this.dimension() this.$element[dimension](this.$element[dimension]())[0].offsetHeight this.$element .addClass('collapsing') .removeClass('collapse in') .attr('aria-expanded', false) this.$trigger .addClass('collapsed') .attr('aria-expanded', false) this.transitioning = 1 var complete = function () { this.transitioning = 0 this.$element .removeClass('collapsing') .addClass('collapse') .trigger('hidden.bs.collapse') } if (!$.support.transition) return complete.call(this) this.$element [dimension](0) .one('bsTransitionEnd', $.proxy(complete, this)) .emulateTransitionEnd(Collapse.TRANSITION_DURATION) } Collapse.prototype.toggle = function () { this[this.$element.hasClass('in') ? 'hide' : 'show']() } Collapse.prototype.getParent = function () { return $(this.options.parent) .find('[data-toggle=\"collapse\"][data-parent=\"' + this.options.parent + '\"]') .each($.proxy(function (i, element) { var $element = $(element) this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element) }, this)) .end() } Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) { var isOpen = $element.hasClass('in') $element.attr('aria-expanded', isOpen) $trigger .toggleClass('collapsed', !isOpen) .attr('aria-expanded', isOpen) } function getTargetFromTrigger($trigger) { var href var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '') // strip for ie7 return $(target) } // COLLAPSE PLUGIN DEFINITION // ========================== function Plugin(option) { return this.each(function () { var $this = $(this) var data = $this.data('bs.collapse') var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option) if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false if (!data) $this.data('bs.collapse', (data = new Collapse(this, options))) if (typeof option == 'string') data[option]() }) } var old = $.fn.collapse $.fn.collapse = Plugin $.fn.collapse.Constructor = Collapse // COLLAPSE NO CONFLICT // ==================== $.fn.collapse.noConflict = function () { $.fn.collapse = old return this } // COLLAPSE DATA-API // ================= $(document).on('click.bs.collapse.data-api', '[data-toggle=\"collapse\"]', function (e) { var $this = $(this) if (!$this.attr('data-target')) e.preventDefault() var $target = getTargetFromTrigger($this) var data = $target.data('bs.collapse') var option = data ? 'toggle' : $this.data() Plugin.call($target, option) }) }(jQuery); /* ======================================================================== * Bootstrap: dropdown.js v3.3.6 * http://getbootstrap.com/javascript/#dropdowns * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // DROPDOWN CLASS DEFINITION // ========================= var backdrop = '.dropdown-backdrop' var toggle = '[data-toggle=\"dropdown\"]' var Dropdown = function (element) { $(element).on('click.bs.dropdown', this.toggle) } Dropdown.VERSION = '3.3.6' function getParent($this) { var selector = $this.attr('data-target') if (!selector) { selector = $this.attr('href') selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7 } var $parent = selector && $(selector) return $parent && $parent.length ? $parent : $this.parent() } function clearMenus(e) { if (e && e.which === 3) return $(backdrop).remove() $(toggle).each(function () { var $this = $(this) var $parent = getParent($this) var relatedTarget = { relatedTarget: this } if (!$parent.hasClass('open')) return if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget)) if (e.isDefaultPrevented()) return $this.attr('aria-expanded', 'false') $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget)) }) } Dropdown.prototype.toggle = function (e) { var $this = $(this) if ($this.is('.disabled, :disabled')) return var $parent = getParent($this) var isActive = $parent.hasClass('open') clearMenus() if (!isActive) { if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) { // if mobile we use a backdrop because click events don't delegate $(document.createElement('div')) .addClass('dropdown-backdrop') .insertAfter($(this)) .on('click', clearMenus) } var relatedTarget = { relatedTarget: this } $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget)) if (e.isDefaultPrevented()) return $this .trigger('focus') .attr('aria-expanded', 'true') $parent .toggleClass('open') .trigger($.Event('shown.bs.dropdown', relatedTarget)) } return false } Dropdown.prototype.keydown = function (e) { if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return var $this = $(this) e.preventDefault() e.stopPropagation() if ($this.is('.disabled, :disabled')) return var $parent = getParent($this) var isActive = $parent.hasClass('open') if (!isActive && e.which != 27 || isActive && e.which == 27) { if (e.which == 27) $parent.find(toggle).trigger('focus') return $this.trigger('click') } var desc = ' li:not(.disabled):visible a' var $items = $parent.find('.dropdown-menu' + desc) if (!$items.length) return var index = $items.index(e.target) if (e.which == 38 && index > 0) index-- // up if (e.which == 40 && index < $items.length - 1) index++ // down if (!~index) index = 0 $items.eq(index).trigger('focus') } // DROPDOWN PLUGIN DEFINITION // ========================== function Plugin(option) { return this.each(function () { var $this = $(this) var data = $this.data('bs.dropdown') if (!data) $this.data('bs.dropdown', (data = new Dropdown(this))) if (typeof option == 'string') data[option].call($this) }) } var old = $.fn.dropdown $.fn.dropdown = Plugin $.fn.dropdown.Constructor = Dropdown // DROPDOWN NO CONFLICT // ==================== $.fn.dropdown.noConflict = function () { $.fn.dropdown = old return this } // APPLY TO STANDARD DROPDOWN ELEMENTS // =================================== $(document) .on('click.bs.dropdown.data-api', clearMenus) .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() }) .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle) .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown) .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown) }(jQuery); /* ======================================================================== * Bootstrap: modal.js v3.3.6 * http://getbootstrap.com/javascript/#modals * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // MODAL CLASS DEFINITION // ====================== var Modal = function (element, options) { this.options = options this.$body = $(document.body) this.$element = $(element) this.$dialog = this.$element.find('.modal-dialog') this.$backdrop = null this.isShown = null this.originalBodyPad = null this.scrollbarWidth = 0 this.ignoreBackdropClick = false if (this.options.remote) { this.$element .find('.modal-content') .load(this.options.remote, $.proxy(function () { this.$element.trigger('loaded.bs.modal') }, this)) } } Modal.VERSION = '3.3.6' Modal.TRANSITION_DURATION = 300 Modal.BACKDROP_TRANSITION_DURATION = 150 Modal.DEFAULTS = { backdrop: true, keyboard: true, show: true } Modal.prototype.toggle = function (_relatedTarget) { return this.isShown ? this.hide() : this.show(_relatedTarget) } Modal.prototype.show = function (_relatedTarget) { var that = this var e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget }) this.$element.trigger(e) if (this.isShown || e.isDefaultPrevented()) return this.isShown = true this.checkScrollbar() this.setScrollbar() this.$body.addClass('modal-open') this.escape() this.resize() this.$element.on('click.dismiss.bs.modal', '[data-dismiss=\"modal\"]', $.proxy(this.hide, this)) this.$dialog.on('mousedown.dismiss.bs.modal', function () { that.$element.one('mouseup.dismiss.bs.modal', function (e) { if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true }) }) this.backdrop(function () { var transition = $.support.transition && that.$element.hasClass('fade') if (!that.$element.parent().length) { that.$element.appendTo(that.$body) // don't move modals dom position } that.$element .show() .scrollTop(0) that.adjustDialog() if (transition) { that.$element[0].offsetWidth // force reflow } that.$element.addClass('in') that.enforceFocus() var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget }) transition ? that.$dialog // wait for modal to slide in .one('bsTransitionEnd', function () { that.$element.trigger('focus').trigger(e) }) .emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e) }) } Modal.prototype.hide = function (e) { if (e) e.preventDefault() e = $.Event('hide.bs.modal') this.$element.trigger(e) if (!this.isShown || e.isDefaultPrevented()) return this.isShown = false this.escape() this.resize() $(document).off('focusin.bs.modal') this.$element .removeClass('in') .off('click.dismiss.bs.modal') .off('mouseup.dismiss.bs.modal') this.$dialog.off('mousedown.dismiss.bs.modal') $.support.transition && this.$element.hasClass('fade') ? this.$element .one('bsTransitionEnd', $.proxy(this.hideModal, this)) .emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal() } Modal.prototype.enforceFocus = function () { $(document) .off('focusin.bs.modal') // guard against infinite focus loop .on('focusin.bs.modal', $.proxy(function (e) { if (this.$element[0] !== e.target && !this.$element.has(e.target).length) { this.$element.trigger('focus') } }, this)) } Modal.prototype.escape = function () { if (this.isShown && this.options.keyboard) { this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) { e.which == 27 && this.hide() }, this)) } else if (!this.isShown) { this.$element.off('keydown.dismiss.bs.modal') } } Modal.prototype.resize = function () { if (this.isShown) { $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this)) } else { $(window).off('resize.bs.modal') } } Modal.prototype.hideModal = function () { var that = this this.$element.hide() this.backdrop(function () { that.$body.removeClass('modal-open') that.resetAdjustments() that.resetScrollbar() that.$element.trigger('hidden.bs.modal') }) } Modal.prototype.removeBackdrop = function () { this.$backdrop && this.$backdrop.remove() this.$backdrop = null } Modal.prototype.backdrop = function (callback) { var that = this var animate = this.$element.hasClass('fade') ? 'fade' : '' if (this.isShown && this.options.backdrop) { var doAnimate = $.support.transition && animate this.$backdrop = $(document.createElement('div')) .addClass('modal-backdrop ' + animate) .appendTo(this.$body) this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) { if (this.ignoreBackdropClick) { this.ignoreBackdropClick = false return } if (e.target !== e.currentTarget) return this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide() }, this)) if (doAnimate) this.$backdrop[0].offsetWidth // force reflow this.$backdrop.addClass('in') if (!callback) return doAnimate ? this.$backdrop .one('bsTransitionEnd', callback) .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback() } else if (!this.isShown && this.$backdrop) { this.$backdrop.removeClass('in') var callbackRemove = function () { that.removeBackdrop() callback && callback() } $.support.transition && this.$element.hasClass('fade') ? this.$backdrop .one('bsTransitionEnd', callbackRemove) .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove() } else if (callback) { callback() } } // these following methods are used to handle overflowing modals Modal.prototype.handleUpdate = function () { this.adjustDialog() } Modal.prototype.adjustDialog = function () { var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight this.$element.css({ paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '', paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : '' }) } Modal.prototype.resetAdjustments = function () { this.$element.css({ paddingLeft: '', paddingRight: '' }) } Modal.prototype.checkScrollbar = function () { var fullWindowWidth = window.innerWidth if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8 var documentElementRect = document.documentElement.getBoundingClientRect() fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left) } this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth this.scrollbarWidth = this.measureScrollbar() } Modal.prototype.setScrollbar = function () { var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10) this.originalBodyPad = document.body.style.paddingRight || '' if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth) } Modal.prototype.resetScrollbar = function () { this.$body.css('padding-right', this.originalBodyPad) } Modal.prototype.measureScrollbar = function () { // thx walsh var scrollDiv = document.createElement('div') scrollDiv.className = 'modal-scrollbar-measure' this.$body.append(scrollDiv) var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth this.$body[0].removeChild(scrollDiv) return scrollbarWidth } // MODAL PLUGIN DEFINITION // ======================= function Plugin(option, _relatedTarget) { return this.each(function () { var $this = $(this) var data = $this.data('bs.modal') var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option) if (!data) $this.data('bs.modal', (data = new Modal(this, options))) if (typeof option == 'string') data[option](_relatedTarget) else if (options.show) data.show(_relatedTarget) }) } var old = $.fn.modal $.fn.modal = Plugin $.fn.modal.Constructor = Modal // MODAL NO CONFLICT // ================= $.fn.modal.noConflict = function () { $.fn.modal = old return this } // MODAL DATA-API // ============== $(document).on('click.bs.modal.data-api', '[data-toggle=\"modal\"]', function (e) { var $this = $(this) var href = $this.attr('href') var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\\s]+$)/, ''))) // strip for ie7 var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data()) if ($this.is('a')) e.preventDefault() $target.one('show.bs.modal', function (showEvent) { if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown $target.one('hidden.bs.modal', function () { $this.is(':visible') && $this.trigger('focus') }) }) Plugin.call($target, option, this) }) }(jQuery); /* ======================================================================== * Bootstrap: tooltip.js v3.3.6 * http://getbootstrap.com/javascript/#tooltip * Inspired by the original jQuery.tipsy by Jason Frame * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // TOOLTIP PUBLIC CLASS DEFINITION // =============================== var Tooltip = function (element, options) { this.type = null this.options = null this.enabled = null this.timeout = null this.hoverState = null this.$element = null this.inState = null this.init('tooltip', element, options) } Tooltip.VERSION = '3.3.6' Tooltip.TRANSITION_DURATION = 150 Tooltip.DEFAULTS = { animation: true, placement: 'top', selector: false, template: '', trigger: 'hover focus', title: '', delay: 0, html: false, container: false, viewport: { selector: 'body', padding: 0 } } Tooltip.prototype.init = function (type, element, options) { this.enabled = true this.type = type this.$element = $(element) this.options = this.getOptions(options) this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport)) this.inState = { click: false, hover: false, focus: false } if (this.$element[0] instanceof document.constructor && !this.options.selector) { throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!') } var triggers = this.options.trigger.split(' ') for (var i = triggers.length; i--;) { var trigger = triggers[i] if (trigger == 'click') { this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this)) } else if (trigger != 'manual') { var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin' var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout' this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this)) this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this)) } } this.options.selector ? (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) : this.fixTitle() } Tooltip.prototype.getDefaults = function () { return Tooltip.DEFAULTS } Tooltip.prototype.getOptions = function (options) { options = $.extend({}, this.getDefaults(), this.$element.data(), options) if (options.delay && typeof options.delay == 'number') { options.delay = { show: options.delay, hide: options.delay } } return options } Tooltip.prototype.getDelegateOptions = function () { var options = {} var defaults = this.getDefaults() this._options && $.each(this._options, function (key, value) { if (defaults[key] != value) options[key] = value }) return options } Tooltip.prototype.enter = function (obj) { var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type) if (!self) { self = new this.constructor(obj.currentTarget, this.getDelegateOptions()) $(obj.currentTarget).data('bs.' + this.type, self) } if (obj instanceof $.Event) { self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true } if (self.tip().hasClass('in') || self.hoverState == 'in') { self.hoverState = 'in' return } clearTimeout(self.timeout) self.hoverState = 'in' if (!self.options.delay || !self.options.delay.show) return self.show() self.timeout = setTimeout(function () { if (self.hoverState == 'in') self.show() }, self.options.delay.show) } Tooltip.prototype.isInStateTrue = function () { for (var key in this.inState) { if (this.inState[key]) return true } return false } Tooltip.prototype.leave = function (obj) { var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type) if (!self) { self = new this.constructor(obj.currentTarget, this.getDelegateOptions()) $(obj.currentTarget).data('bs.' + this.type, self) } if (obj instanceof $.Event) { self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false } if (self.isInStateTrue()) return clearTimeout(self.timeout) self.hoverState = 'out' if (!self.options.delay || !self.options.delay.hide) return self.hide() self.timeout = setTimeout(function () { if (self.hoverState == 'out') self.hide() }, self.options.delay.hide) } Tooltip.prototype.show = function () { var e = $.Event('show.bs.' + this.type) if (this.hasContent() && this.enabled) { this.$element.trigger(e) var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]) if (e.isDefaultPrevented() || !inDom) return var that = this var $tip = this.tip() var tipId = this.getUID(this.type) this.setContent() $tip.attr('id', tipId) this.$element.attr('aria-describedby', tipId) if (this.options.animation) $tip.addClass('fade') var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement var autoToken = /\\s?auto?\\s?/i var autoPlace = autoToken.test(placement) if (autoPlace) placement = placement.replace(autoToken, '') || 'top' $tip .detach() .css({ top: 0, left: 0, display: 'block' }) .addClass(placement) .data('bs.' + this.type, this) this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element) this.$element.trigger('inserted.bs.' + this.type) var pos = this.getPosition() var actualWidth = $tip[0].offsetWidth var actualHeight = $tip[0].offsetHeight if (autoPlace) { var orgPlacement = placement var viewportDim = this.getPosition(this.$viewport) placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement $tip .removeClass(orgPlacement) .addClass(placement) } var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight) this.applyPlacement(calculatedOffset, placement) var complete = function () { var prevHoverState = that.hoverState that.$element.trigger('shown.bs.' + that.type) that.hoverState = null if (prevHoverState == 'out') that.leave(that) } $.support.transition && this.$tip.hasClass('fade') ? $tip .one('bsTransitionEnd', complete) .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete() } } Tooltip.prototype.applyPlacement = function (offset, placement) { var $tip = this.tip() var width = $tip[0].offsetWidth var height = $tip[0].offsetHeight // manually read margins because getBoundingClientRect includes difference var marginTop = parseInt($tip.css('margin-top'), 10) var marginLeft = parseInt($tip.css('margin-left'), 10) // we must check for NaN for ie 8/9 if (isNaN(marginTop)) marginTop = 0 if (isNaN(marginLeft)) marginLeft = 0 offset.top += marginTop offset.left += marginLeft // $.fn.offset doesn't round pixel values // so we use setOffset directly with our own function B-0 $.offset.setOffset($tip[0], $.extend({ using: function (props) { $tip.css({ top: Math.round(props.top), left: Math.round(props.left) }) } }, offset), 0) $tip.addClass('in') // check to see if placing tip in new offset caused the tip to resize itself var actualWidth = $tip[0].offsetWidth var actualHeight = $tip[0].offsetHeight if (placement == 'top' && actualHeight != height) { offset.top = offset.top + height - actualHeight } var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight) if (delta.left) offset.left += delta.left else offset.top += delta.top var isVertical = /top|bottom/.test(placement) var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight' $tip.offset(offset) this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical) } Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) { this.arrow() .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%') .css(isVertical ? 'top' : 'left', '') } Tooltip.prototype.setContent = function () { var $tip = this.tip() var title = this.getTitle() $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title) $tip.removeClass('fade in top bottom left right') } Tooltip.prototype.hide = function (callback) { var that = this var $tip = $(this.$tip) var e = $.Event('hide.bs.' + this.type) function complete() { if (that.hoverState != 'in') $tip.detach() that.$element .removeAttr('aria-describedby') .trigger('hidden.bs.' + that.type) callback && callback() } this.$element.trigger(e) if (e.isDefaultPrevented()) return $tip.removeClass('in') $.support.transition && $tip.hasClass('fade') ? $tip .one('bsTransitionEnd', complete) .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete() this.hoverState = null return this } Tooltip.prototype.fixTitle = function () { var $e = this.$element if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') { $e.attr('data-original-title', $e.attr('title') || '').attr('title', '') } } Tooltip.prototype.hasContent = function () { return this.getTitle() } Tooltip.prototype.getPosition = function ($element) { $element = $element || this.$element var el = $element[0] var isBody = el.tagName == 'BODY' var elRect = el.getBoundingClientRect() if (elRect.width == null) { // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093 elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top }) } var elOffset = isBody ? { top: 0, left: 0 } : $element.offset() var scroll = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() } var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null return $.extend({}, elRect, scroll, outerDims, elOffset) } Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) { return placement == 'bottom' ? { top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'top' ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'left' ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } : /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width } } Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) { var delta = { top: 0, left: 0 } if (!this.$viewport) return delta var viewportPadding = this.options.viewport && this.options.viewport.padding || 0 var viewportDimensions = this.getPosition(this.$viewport) if (/right|left/.test(placement)) { var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight if (topEdgeOffset < viewportDimensions.top) { // top overflow delta.top = viewportDimensions.top - topEdgeOffset } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset } } else { var leftEdgeOffset = pos.left - viewportPadding var rightEdgeOffset = pos.left + viewportPadding + actualWidth if (leftEdgeOffset < viewportDimensions.left) { // left overflow delta.left = viewportDimensions.left - leftEdgeOffset } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset } } return delta } Tooltip.prototype.getTitle = function () { var title var $e = this.$element var o = this.options title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title) return title } Tooltip.prototype.getUID = function (prefix) { do prefix += ~~(Math.random() * 1000000) while (document.getElementById(prefix)) return prefix } Tooltip.prototype.tip = function () { if (!this.$tip) { this.$tip = $(this.options.template) if (this.$tip.length != 1) { throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!') } } return this.$tip } Tooltip.prototype.arrow = function () { return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow')) } Tooltip.prototype.enable = function () { this.enabled = true } Tooltip.prototype.disable = function () { this.enabled = false } Tooltip.prototype.toggleEnabled = function () { this.enabled = !this.enabled } Tooltip.prototype.toggle = function (e) { var self = this if (e) { self = $(e.currentTarget).data('bs.' + this.type) if (!self) { self = new this.constructor(e.currentTarget, this.getDelegateOptions()) $(e.currentTarget).data('bs.' + this.type, self) } } if (e) { self.inState.click = !self.inState.click if (self.isInStateTrue()) self.enter(self) else self.leave(self) } else { self.tip().hasClass('in') ? self.leave(self) : self.enter(self) } } Tooltip.prototype.destroy = function () { var that = this clearTimeout(this.timeout) this.hide(function () { that.$element.off('.' + that.type).removeData('bs.' + that.type) if (that.$tip) { that.$tip.detach() } that.$tip = null that.$arrow = null that.$viewport = null }) } // TOOLTIP PLUGIN DEFINITION // ========================= function Plugin(option) { return this.each(function () { var $this = $(this) var data = $this.data('bs.tooltip') var options = typeof option == 'object' && option if (!data && /destroy|hide/.test(option)) return if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options))) if (typeof option == 'string') data[option]() }) } var old = $.fn.tooltip $.fn.tooltip = Plugin $.fn.tooltip.Constructor = Tooltip // TOOLTIP NO CONFLICT // =================== $.fn.tooltip.noConflict = function () { $.fn.tooltip = old return this } }(jQuery); /* ======================================================================== * Bootstrap: popover.js v3.3.6 * http://getbootstrap.com/javascript/#popovers * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // POPOVER PUBLIC CLASS DEFINITION // =============================== var Popover = function (element, options) { this.init('popover', element, options) } if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js') Popover.VERSION = '3.3.6' Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, { placement: 'right', trigger: 'click', content: '', template: '' }) // NOTE: POPOVER EXTENDS tooltip.js // ================================ Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype) Popover.prototype.constructor = Popover Popover.prototype.getDefaults = function () { return Popover.DEFAULTS } Popover.prototype.setContent = function () { var $tip = this.tip() var title = this.getTitle() var content = this.getContent() $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title) $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text' ](content) $tip.removeClass('fade top bottom left right in') // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do // this manually by checking the contents. if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide() } Popover.prototype.hasContent = function () { return this.getTitle() || this.getContent() } Popover.prototype.getContent = function () { var $e = this.$element var o = this.options return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content) } Popover.prototype.arrow = function () { return (this.$arrow = this.$arrow || this.tip().find('.arrow')) } // POPOVER PLUGIN DEFINITION // ========================= function Plugin(option) { return this.each(function () { var $this = $(this) var data = $this.data('bs.popover') var options = typeof option == 'object' && option if (!data && /destroy|hide/.test(option)) return if (!data) $this.data('bs.popover', (data = new Popover(this, options))) if (typeof option == 'string') data[option]() }) } var old = $.fn.popover $.fn.popover = Plugin $.fn.popover.Constructor = Popover // POPOVER NO CONFLICT // =================== $.fn.popover.noConflict = function () { $.fn.popover = old return this } }(jQuery); /* ======================================================================== * Bootstrap: scrollspy.js v3.3.6 * http://getbootstrap.com/javascript/#scrollspy * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // SCROLLSPY CLASS DEFINITION // ========================== function ScrollSpy(element, options) { this.$body = $(document.body) this.$scrollElement = $(element).is(document.body) ? $(window) : $(element) this.options = $.extend({}, ScrollSpy.DEFAULTS, options) this.selector = (this.options.target || '') + ' .nav li > a' this.offsets = [] this.targets = [] this.activeTarget = null this.scrollHeight = 0 this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this)) this.refresh() this.process() } ScrollSpy.VERSION = '3.3.6' ScrollSpy.DEFAULTS = { offset: 10 } ScrollSpy.prototype.getScrollHeight = function () { return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight) } ScrollSpy.prototype.refresh = function () { var that = this var offsetMethod = 'offset' var offsetBase = 0 this.offsets = [] this.targets = [] this.scrollHeight = this.getScrollHeight() if (!$.isWindow(this.$scrollElement[0])) { offsetMethod = 'position' offsetBase = this.$scrollElement.scrollTop() } this.$body .find(this.selector) .map(function () { var $el = $(this) var href = $el.data('target') || $el.attr('href') var $href = /^#./.test(href) && $(href) return ($href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]]) || null }) .sort(function (a, b) { return a[0] - b[0] }) .each(function () { that.offsets.push(this[0]) that.targets.push(this[1]) }) } ScrollSpy.prototype.process = function () { var scrollTop = this.$scrollElement.scrollTop() + this.options.offset var scrollHeight = this.getScrollHeight() var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height() var offsets = this.offsets var targets = this.targets var activeTarget = this.activeTarget var i if (this.scrollHeight != scrollHeight) { this.refresh() } if (scrollTop >= maxScroll) { return activeTarget != (i = targets[targets.length - 1]) && this.activate(i) } if (activeTarget && scrollTop < offsets[0]) { this.activeTarget = null return this.clear() } for (i = offsets.length; i--;) { activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]) } } ScrollSpy.prototype.activate = function (target) { this.activeTarget = target this.clear() var selector = this.selector + '[data-target=\"' + target + '\"],' + this.selector + '[href=\"' + target + '\"]' var active = $(selector) .parents('li') .addClass('active') if (active.parent('.dropdown-menu').length) { active = active .closest('li.dropdown') .addClass('active') } active.trigger('activate.bs.scrollspy') } ScrollSpy.prototype.clear = function () { $(this.selector) .parentsUntil(this.options.target, '.active') .removeClass('active') } // SCROLLSPY PLUGIN DEFINITION // =========================== function Plugin(option) { return this.each(function () { var $this = $(this) var data = $this.data('bs.scrollspy') var options = typeof option == 'object' && option if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options))) if (typeof option == 'string') data[option]() }) } var old = $.fn.scrollspy $.fn.scrollspy = Plugin $.fn.scrollspy.Constructor = ScrollSpy // SCROLLSPY NO CONFLICT // ===================== $.fn.scrollspy.noConflict = function () { $.fn.scrollspy = old return this } // SCROLLSPY DATA-API // ================== $(window).on('load.bs.scrollspy.data-api', function () { $('[data-spy=\"scroll\"]').each(function () { var $spy = $(this) Plugin.call($spy, $spy.data()) }) }) }(jQuery); /* ======================================================================== * Bootstrap: tab.js v3.3.6 * http://getbootstrap.com/javascript/#tabs * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // TAB CLASS DEFINITION // ==================== var Tab = function (element) { // jscs:disable requireDollarBeforejQueryAssignment this.element = $(element) // jscs:enable requireDollarBeforejQueryAssignment } Tab.VERSION = '3.3.6' Tab.TRANSITION_DURATION = 150 Tab.prototype.show = function () { var $this = this.element var $ul = $this.closest('ul:not(.dropdown-menu)') var selector = $this.data('target') if (!selector) { selector = $this.attr('href') selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7 } if ($this.parent('li').hasClass('active')) return var $previous = $ul.find('.active:last a') var hideEvent = $.Event('hide.bs.tab', { relatedTarget: $this[0] }) var showEvent = $.Event('show.bs.tab', { relatedTarget: $previous[0] }) $previous.trigger(hideEvent) $this.trigger(showEvent) if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return var $target = $(selector) this.activate($this.closest('li'), $ul) this.activate($target, $target.parent(), function () { $previous.trigger({ type: 'hidden.bs.tab', relatedTarget: $this[0] }) $this.trigger({ type: 'shown.bs.tab', relatedTarget: $previous[0] }) }) } Tab.prototype.activate = function (element, container, callback) { var $active = container.find('> .active') var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length) function next() { $active .removeClass('active') .find('> .dropdown-menu > .active') .removeClass('active') .end() .find('[data-toggle=\"tab\"]') .attr('aria-expanded', false) element .addClass('active') .find('[data-toggle=\"tab\"]') .attr('aria-expanded', true) if (transition) { element[0].offsetWidth // reflow for transition element.addClass('in') } else { element.removeClass('fade') } if (element.parent('.dropdown-menu').length) { element .closest('li.dropdown') .addClass('active') .end() .find('[data-toggle=\"tab\"]') .attr('aria-expanded', true) } callback && callback() } $active.length && transition ? $active .one('bsTransitionEnd', next) .emulateTransitionEnd(Tab.TRANSITION_DURATION) : next() $active.removeClass('in') } // TAB PLUGIN DEFINITION // ===================== function Plugin(option) { return this.each(function () { var $this = $(this) var data = $this.data('bs.tab') if (!data) $this.data('bs.tab', (data = new Tab(this))) if (typeof option == 'string') data[option]() }) } var old = $.fn.tab $.fn.tab = Plugin $.fn.tab.Constructor = Tab // TAB NO CONFLICT // =============== $.fn.tab.noConflict = function () { $.fn.tab = old return this } // TAB DATA-API // ============ var clickHandler = function (e) { e.preventDefault() Plugin.call($(this), 'show') } $(document) .on('click.bs.tab.data-api', '[data-toggle=\"tab\"]', clickHandler) .on('click.bs.tab.data-api', '[data-toggle=\"pill\"]', clickHandler) }(jQuery); /* ======================================================================== * Bootstrap: affix.js v3.3.6 * http://getbootstrap.com/javascript/#affix * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ +function ($) { 'use strict'; // AFFIX CLASS DEFINITION // ====================== var Affix = function (element, options) { this.options = $.extend({}, Affix.DEFAULTS, options) this.$target = $(this.options.target) .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)) .on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this)) this.$element = $(element) this.affixed = null this.unpin = null this.pinnedOffset = null this.checkPosition() } Affix.VERSION = '3.3.6' Affix.RESET = 'affix affix-top affix-bottom' Affix.DEFAULTS = { offset: 0, target: window } Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) { var scrollTop = this.$target.scrollTop() var position = this.$element.offset() var targetHeight = this.$target.height() if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false if (this.affixed == 'bottom') { if (offsetTop != null) return (scrollTop + this.unpin"},{"title":"","date":"2018-11-04T13:54:09.454Z","updated":"2018-11-04T13:54:09.454Z","comments":true,"path":"cv/assets/plugins/bootstrap/css/bootstrap.css","permalink":"http://tech.yushuai.xyz/cv/assets/plugins/bootstrap/css/bootstrap.css","excerpt":"","text":"/*! * Bootstrap v3.3.6 (http://getbootstrap.com) * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) */ /*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */ html { font-family: sans-serif; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; } body { margin: 0; } article, aside, details, figcaption, figure, footer, header, hgroup, main, menu, nav, section, summary { display: block; } audio, canvas, progress, video { display: inline-block; vertical-align: baseline; } audio:not([controls]) { display: none; height: 0; } [hidden], template { display: none; } a { background-color: transparent; } a:active, a:hover { outline: 0; } abbr[title] { border-bottom: 1px dotted; } b, strong { font-weight: bold; } dfn { font-style: italic; } h1 { margin: .67em 0; font-size: 2em; } mark { color: #000; background: #ff0; } small { font-size: 80%; } sub, sup { position: relative; font-size: 75%; line-height: 0; vertical-align: baseline; } sup { top: -.5em; } sub { bottom: -.25em; } img { border: 0; } svg:not(:root) { overflow: hidden; } figure { margin: 1em 40px; } hr { height: 0; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; } pre { overflow: auto; } code, kbd, pre, samp { font-family: monospace, monospace; font-size: 1em; } button, input, optgroup, select, textarea { margin: 0; font: inherit; color: inherit; } button { overflow: visible; } button, select { text-transform: none; } button, html input[type=\"button\"], input[type=\"reset\"], input[type=\"submit\"] { -webkit-appearance: button; cursor: pointer; } button[disabled], html input[disabled] { cursor: default; } button::-moz-focus-inner, input::-moz-focus-inner { padding: 0; border: 0; } input { line-height: normal; } input[type=\"checkbox\"], input[type=\"radio\"] { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; padding: 0; } input[type=\"number\"]::-webkit-inner-spin-button, input[type=\"number\"]::-webkit-outer-spin-button { height: auto; } input[type=\"search\"] { -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; -webkit-appearance: textfield; } input[type=\"search\"]::-webkit-search-cancel-button, input[type=\"search\"]::-webkit-search-decoration { -webkit-appearance: none; } fieldset { padding: .35em .625em .75em; margin: 0 2px; border: 1px solid #c0c0c0; } legend { padding: 0; border: 0; } textarea { overflow: auto; } optgroup { font-weight: bold; } table { border-spacing: 0; border-collapse: collapse; } td, th { padding: 0; } /*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */ @media print { *, *:before, *:after { color: #000 !important; text-shadow: none !important; background: transparent !important; -webkit-box-shadow: none !important; box-shadow: none !important; } a, a:visited { text-decoration: underline; } a[href]:after { content: \" (\" attr(href) \")\"; } abbr[title]:after { content: \" (\" attr(title) \")\"; } a[href^=\"#\"]:after, a[href^=\"javascript:\"]:after { content: \"\"; } pre, blockquote { border: 1px solid #999; page-break-inside: avoid; } thead { display: table-header-group; } tr, img { page-break-inside: avoid; } img { max-width: 100% !important; } p, h2, h3 { orphans: 3; widows: 3; } h2, h3 { page-break-after: avoid; } .navbar { display: none; } .btn > .caret, .dropup > .btn > .caret { border-top-color: #000 !important; } .label { border: 1px solid #000; } .table { border-collapse: collapse !important; } .table td, .table th { background-color: #fff !important; } .table-bordered th, .table-bordered td { border: 1px solid #ddd !important; } } @font-face { font-family: 'Glyphicons Halflings'; src: url('../fonts/glyphicons-halflings-regular.eot'); src: url('../fonts/glyphicons-halflings-regular.eot?#iefix') format('embedded-opentype'), url('../fonts/glyphicons-halflings-regular.woff2') format('woff2'), url('../fonts/glyphicons-halflings-regular.woff') format('woff'), url('../fonts/glyphicons-halflings-regular.ttf') format('truetype'), url('../fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular') format('svg'); } .glyphicon { position: relative; top: 1px; display: inline-block; font-family: 'Glyphicons Halflings'; font-style: normal; font-weight: normal; line-height: 1; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .glyphicon-asterisk:before { content: \"\\002a\"; } .glyphicon-plus:before { content: \"\\002b\"; } .glyphicon-euro:before, .glyphicon-eur:before { content: \"\\20ac\"; } .glyphicon-minus:before { content: \"\\2212\"; } .glyphicon-cloud:before { content: \"\\2601\"; } .glyphicon-envelope:before { content: \"\\2709\"; } .glyphicon-pencil:before { content: \"\\270f\"; } .glyphicon-glass:before { content: \"\\e001\"; } .glyphicon-music:before { content: \"\\e002\"; } .glyphicon-search:before { content: \"\\e003\"; } .glyphicon-heart:before { content: \"\\e005\"; } .glyphicon-star:before { content: \"\\e006\"; } .glyphicon-star-empty:before { content: \"\\e007\"; } .glyphicon-user:before { content: \"\\e008\"; } .glyphicon-film:before { content: \"\\e009\"; } .glyphicon-th-large:before { content: \"\\e010\"; } .glyphicon-th:before { content: \"\\e011\"; } .glyphicon-th-list:before { content: \"\\e012\"; } .glyphicon-ok:before { content: \"\\e013\"; } .glyphicon-remove:before { content: \"\\e014\"; } .glyphicon-zoom-in:before { content: \"\\e015\"; } .glyphicon-zoom-out:before { content: \"\\e016\"; } .glyphicon-off:before { content: \"\\e017\"; } .glyphicon-signal:before { content: \"\\e018\"; } .glyphicon-cog:before { content: \"\\e019\"; } .glyphicon-trash:before { content: \"\\e020\"; } .glyphicon-home:before { content: \"\\e021\"; } .glyphicon-file:before { content: \"\\e022\"; } .glyphicon-time:before { content: \"\\e023\"; } .glyphicon-road:before { content: \"\\e024\"; } .glyphicon-download-alt:before { content: \"\\e025\"; } .glyphicon-download:before { content: \"\\e026\"; } .glyphicon-upload:before { content: \"\\e027\"; } .glyphicon-inbox:before { content: \"\\e028\"; } .glyphicon-play-circle:before { content: \"\\e029\"; } .glyphicon-repeat:before { content: \"\\e030\"; } .glyphicon-refresh:before { content: \"\\e031\"; } .glyphicon-list-alt:before { content: \"\\e032\"; } .glyphicon-lock:before { content: \"\\e033\"; } .glyphicon-flag:before { content: \"\\e034\"; } .glyphicon-headphones:before { content: \"\\e035\"; } .glyphicon-volume-off:before { content: \"\\e036\"; } .glyphicon-volume-down:before { content: \"\\e037\"; } .glyphicon-volume-up:before { content: \"\\e038\"; } .glyphicon-qrcode:before { content: \"\\e039\"; } .glyphicon-barcode:before { content: \"\\e040\"; } .glyphicon-tag:before { content: \"\\e041\"; } .glyphicon-tags:before { content: \"\\e042\"; } .glyphicon-book:before { content: \"\\e043\"; } .glyphicon-bookmark:before { content: \"\\e044\"; } .glyphicon-print:before { content: \"\\e045\"; } .glyphicon-camera:before { content: \"\\e046\"; } .glyphicon-font:before { content: \"\\e047\"; } .glyphicon-bold:before { content: \"\\e048\"; } .glyphicon-italic:before { content: \"\\e049\"; } .glyphicon-text-height:before { content: \"\\e050\"; } .glyphicon-text-width:before { content: \"\\e051\"; } .glyphicon-align-left:before { content: \"\\e052\"; } .glyphicon-align-center:before { content: \"\\e053\"; } .glyphicon-align-right:before { content: \"\\e054\"; } .glyphicon-align-justify:before { content: \"\\e055\"; } .glyphicon-list:before { content: \"\\e056\"; } .glyphicon-indent-left:before { content: \"\\e057\"; } .glyphicon-indent-right:before { content: \"\\e058\"; } .glyphicon-facetime-video:before { content: \"\\e059\"; } .glyphicon-picture:before { content: \"\\e060\"; } .glyphicon-map-marker:before { content: \"\\e062\"; } .glyphicon-adjust:before { content: \"\\e063\"; } .glyphicon-tint:before { content: \"\\e064\"; } .glyphicon-edit:before { content: \"\\e065\"; } .glyphicon-share:before { content: \"\\e066\"; } .glyphicon-check:before { content: \"\\e067\"; } .glyphicon-move:before { content: \"\\e068\"; } .glyphicon-step-backward:before { content: \"\\e069\"; } .glyphicon-fast-backward:before { content: \"\\e070\"; } .glyphicon-backward:before { content: \"\\e071\"; } .glyphicon-play:before { content: \"\\e072\"; } .glyphicon-pause:before { content: \"\\e073\"; } .glyphicon-stop:before { content: \"\\e074\"; } .glyphicon-forward:before { content: \"\\e075\"; } .glyphicon-fast-forward:before { content: \"\\e076\"; } .glyphicon-step-forward:before { content: \"\\e077\"; } .glyphicon-eject:before { content: \"\\e078\"; } .glyphicon-chevron-left:before { content: \"\\e079\"; } .glyphicon-chevron-right:before { content: \"\\e080\"; } .glyphicon-plus-sign:before { content: \"\\e081\"; } .glyphicon-minus-sign:before { content: \"\\e082\"; } .glyphicon-remove-sign:before { content: \"\\e083\"; } .glyphicon-ok-sign:before { content: \"\\e084\"; } .glyphicon-question-sign:before { content: \"\\e085\"; } .glyphicon-info-sign:before { content: \"\\e086\"; } .glyphicon-screenshot:before { content: \"\\e087\"; } .glyphicon-remove-circle:before { content: \"\\e088\"; } .glyphicon-ok-circle:before { content: \"\\e089\"; } .glyphicon-ban-circle:before { content: \"\\e090\"; } .glyphicon-arrow-left:before { content: \"\\e091\"; } .glyphicon-arrow-right:before { content: \"\\e092\"; } .glyphicon-arrow-up:before { content: \"\\e093\"; } .glyphicon-arrow-down:before { content: \"\\e094\"; } .glyphicon-share-alt:before { content: \"\\e095\"; } .glyphicon-resize-full:before { content: \"\\e096\"; } .glyphicon-resize-small:before { content: \"\\e097\"; } .glyphicon-exclamation-sign:before { content: \"\\e101\"; } .glyphicon-gift:before { content: \"\\e102\"; } .glyphicon-leaf:before { content: \"\\e103\"; } .glyphicon-fire:before { content: \"\\e104\"; } .glyphicon-eye-open:before { content: \"\\e105\"; } .glyphicon-eye-close:before { content: \"\\e106\"; } .glyphicon-warning-sign:before { content: \"\\e107\"; } .glyphicon-plane:before { content: \"\\e108\"; } .glyphicon-calendar:before { content: \"\\e109\"; } .glyphicon-random:before { content: \"\\e110\"; } .glyphicon-comment:before { content: \"\\e111\"; } .glyphicon-magnet:before { content: \"\\e112\"; } .glyphicon-chevron-up:before { content: \"\\e113\"; } .glyphicon-chevron-down:before { content: \"\\e114\"; } .glyphicon-retweet:before { content: \"\\e115\"; } .glyphicon-shopping-cart:before { content: \"\\e116\"; } .glyphicon-folder-close:before { content: \"\\e117\"; } .glyphicon-folder-open:before { content: \"\\e118\"; } .glyphicon-resize-vertical:before { content: \"\\e119\"; } .glyphicon-resize-horizontal:before { content: \"\\e120\"; } .glyphicon-hdd:before { content: \"\\e121\"; } .glyphicon-bullhorn:before { content: \"\\e122\"; } .glyphicon-bell:before { content: \"\\e123\"; } .glyphicon-certificate:before { content: \"\\e124\"; } .glyphicon-thumbs-up:before { content: \"\\e125\"; } .glyphicon-thumbs-down:before { content: \"\\e126\"; } .glyphicon-hand-right:before { content: \"\\e127\"; } .glyphicon-hand-left:before { content: \"\\e128\"; } .glyphicon-hand-up:before { content: \"\\e129\"; } .glyphicon-hand-down:before { content: \"\\e130\"; } .glyphicon-circle-arrow-right:before { content: \"\\e131\"; } .glyphicon-circle-arrow-left:before { content: \"\\e132\"; } .glyphicon-circle-arrow-up:before { content: \"\\e133\"; } .glyphicon-circle-arrow-down:before { content: \"\\e134\"; } .glyphicon-globe:before { content: \"\\e135\"; } .glyphicon-wrench:before { content: \"\\e136\"; } .glyphicon-tasks:before { content: \"\\e137\"; } .glyphicon-filter:before { content: \"\\e138\"; } .glyphicon-briefcase:before { content: \"\\e139\"; } .glyphicon-fullscreen:before { content: \"\\e140\"; } .glyphicon-dashboard:before { content: \"\\e141\"; } .glyphicon-paperclip:before { content: \"\\e142\"; } .glyphicon-heart-empty:before { content: \"\\e143\"; } .glyphicon-link:before { content: \"\\e144\"; } .glyphicon-phone:before { content: \"\\e145\"; } .glyphicon-pushpin:before { content: \"\\e146\"; } .glyphicon-usd:before { content: \"\\e148\"; } .glyphicon-gbp:before { content: \"\\e149\"; } .glyphicon-sort:before { content: \"\\e150\"; } .glyphicon-sort-by-alphabet:before { content: \"\\e151\"; } .glyphicon-sort-by-alphabet-alt:before { content: \"\\e152\"; } .glyphicon-sort-by-order:before { content: \"\\e153\"; } .glyphicon-sort-by-order-alt:before { content: \"\\e154\"; } .glyphicon-sort-by-attributes:before { content: \"\\e155\"; } .glyphicon-sort-by-attributes-alt:before { content: \"\\e156\"; } .glyphicon-unchecked:before { content: \"\\e157\"; } .glyphicon-expand:before { content: \"\\e158\"; } .glyphicon-collapse-down:before { content: \"\\e159\"; } .glyphicon-collapse-up:before { content: \"\\e160\"; } .glyphicon-log-in:before { content: \"\\e161\"; } .glyphicon-flash:before { content: \"\\e162\"; } .glyphicon-log-out:before { content: \"\\e163\"; } .glyphicon-new-window:before { content: \"\\e164\"; } .glyphicon-record:before { content: \"\\e165\"; } .glyphicon-save:before { content: \"\\e166\"; } .glyphicon-open:before { content: \"\\e167\"; } .glyphicon-saved:before { content: \"\\e168\"; } .glyphicon-import:before { content: \"\\e169\"; } .glyphicon-export:before { content: \"\\e170\"; } .glyphicon-send:before { content: \"\\e171\"; } .glyphicon-floppy-disk:before { content: \"\\e172\"; } .glyphicon-floppy-saved:before { content: \"\\e173\"; } .glyphicon-floppy-remove:before { content: \"\\e174\"; } .glyphicon-floppy-save:before { content: \"\\e175\"; } .glyphicon-floppy-open:before { content: \"\\e176\"; } .glyphicon-credit-card:before { content: \"\\e177\"; } .glyphicon-transfer:before { content: \"\\e178\"; } .glyphicon-cutlery:before { content: \"\\e179\"; } .glyphicon-header:before { content: \"\\e180\"; } .glyphicon-compressed:before { content: \"\\e181\"; } .glyphicon-earphone:before { content: \"\\e182\"; } .glyphicon-phone-alt:before { content: \"\\e183\"; } .glyphicon-tower:before { content: \"\\e184\"; } .glyphicon-stats:before { content: \"\\e185\"; } .glyphicon-sd-video:before { content: \"\\e186\"; } .glyphicon-hd-video:before { content: \"\\e187\"; } .glyphicon-subtitles:before { content: \"\\e188\"; } .glyphicon-sound-stereo:before { content: \"\\e189\"; } .glyphicon-sound-dolby:before { content: \"\\e190\"; } .glyphicon-sound-5-1:before { content: \"\\e191\"; } .glyphicon-sound-6-1:before { content: \"\\e192\"; } .glyphicon-sound-7-1:before { content: \"\\e193\"; } .glyphicon-copyright-mark:before { content: \"\\e194\"; } .glyphicon-registration-mark:before { content: \"\\e195\"; } .glyphicon-cloud-download:before { content: \"\\e197\"; } .glyphicon-cloud-upload:before { content: \"\\e198\"; } .glyphicon-tree-conifer:before { content: \"\\e199\"; } .glyphicon-tree-deciduous:before { content: \"\\e200\"; } .glyphicon-cd:before { content: \"\\e201\"; } .glyphicon-save-file:before { content: \"\\e202\"; } .glyphicon-open-file:before { content: \"\\e203\"; } .glyphicon-level-up:before { content: \"\\e204\"; } .glyphicon-copy:before { content: \"\\e205\"; } .glyphicon-paste:before { content: \"\\e206\"; } .glyphicon-alert:before { content: \"\\e209\"; } .glyphicon-equalizer:before { content: \"\\e210\"; } .glyphicon-king:before { content: \"\\e211\"; } .glyphicon-queen:before { content: \"\\e212\"; } .glyphicon-pawn:before { content: \"\\e213\"; } .glyphicon-bishop:before { content: \"\\e214\"; } .glyphicon-knight:before { content: \"\\e215\"; } .glyphicon-baby-formula:before { content: \"\\e216\"; } .glyphicon-tent:before { content: \"\\26fa\"; } .glyphicon-blackboard:before { content: \"\\e218\"; } .glyphicon-bed:before { content: \"\\e219\"; } .glyphicon-apple:before { content: \"\\f8ff\"; } .glyphicon-erase:before { content: \"\\e221\"; } .glyphicon-hourglass:before { content: \"\\231b\"; } .glyphicon-lamp:before { content: \"\\e223\"; } .glyphicon-duplicate:before { content: \"\\e224\"; } .glyphicon-piggy-bank:before { content: \"\\e225\"; } .glyphicon-scissors:before { content: \"\\e226\"; } .glyphicon-bitcoin:before { content: \"\\e227\"; } .glyphicon-btc:before { content: \"\\e227\"; } .glyphicon-xbt:before { content: \"\\e227\"; } .glyphicon-yen:before { content: \"\\00a5\"; } .glyphicon-jpy:before { content: \"\\00a5\"; } .glyphicon-ruble:before { content: \"\\20bd\"; } .glyphicon-rub:before { content: \"\\20bd\"; } .glyphicon-scale:before { content: \"\\e230\"; } .glyphicon-ice-lolly:before { content: \"\\e231\"; } .glyphicon-ice-lolly-tasted:before { content: \"\\e232\"; } .glyphicon-education:before { content: \"\\e233\"; } .glyphicon-option-horizontal:before { content: \"\\e234\"; } .glyphicon-option-vertical:before { content: \"\\e235\"; } .glyphicon-menu-hamburger:before { content: \"\\e236\"; } .glyphicon-modal-window:before { content: \"\\e237\"; } .glyphicon-oil:before { content: \"\\e238\"; } .glyphicon-grain:before { content: \"\\e239\"; } .glyphicon-sunglasses:before { content: \"\\e240\"; } .glyphicon-text-size:before { content: \"\\e241\"; } .glyphicon-text-color:before { content: \"\\e242\"; } .glyphicon-text-background:before { content: \"\\e243\"; } .glyphicon-object-align-top:before { content: \"\\e244\"; } .glyphicon-object-align-bottom:before { content: \"\\e245\"; } .glyphicon-object-align-horizontal:before { content: \"\\e246\"; } .glyphicon-object-align-left:before { content: \"\\e247\"; } .glyphicon-object-align-vertical:before { content: \"\\e248\"; } .glyphicon-object-align-right:before { content: \"\\e249\"; } .glyphicon-triangle-right:before { content: \"\\e250\"; } .glyphicon-triangle-left:before { content: \"\\e251\"; } .glyphicon-triangle-bottom:before { content: \"\\e252\"; } .glyphicon-triangle-top:before { content: \"\\e253\"; } .glyphicon-console:before { content: \"\\e254\"; } .glyphicon-superscript:before { content: \"\\e255\"; } .glyphicon-subscript:before { content: \"\\e256\"; } .glyphicon-menu-left:before { content: \"\\e257\"; } .glyphicon-menu-right:before { content: \"\\e258\"; } .glyphicon-menu-down:before { content: \"\\e259\"; } .glyphicon-menu-up:before { content: \"\\e260\"; } * { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } *:before, *:after { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } html { font-size: 10px; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); } body { font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; font-size: 14px; line-height: 1.42857143; color: #333; background-color: #fff; } input, button, select, textarea { font-family: inherit; font-size: inherit; line-height: inherit; } a { color: #337ab7; text-decoration: none; } a:hover, a:focus { color: #23527c; text-decoration: underline; } a:focus { outline: thin dotted; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } figure { margin: 0; } img { vertical-align: middle; } .img-responsive, .thumbnail > img, .thumbnail a > img, .carousel-inner > .item > img, .carousel-inner > .item > a > img { display: block; max-width: 100%; height: auto; } .img-rounded { border-radius: 6px; } .img-thumbnail { display: inline-block; max-width: 100%; height: auto; padding: 4px; line-height: 1.42857143; background-color: #fff; border: 1px solid #ddd; border-radius: 4px; -webkit-transition: all .2s ease-in-out; -o-transition: all .2s ease-in-out; transition: all .2s ease-in-out; } .img-circle { border-radius: 50%; } hr { margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid #eee; } .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; } .sr-only-focusable:active, .sr-only-focusable:focus { position: static; width: auto; height: auto; margin: 0; overflow: visible; clip: auto; } [role=\"button\"] { cursor: pointer; } h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 { font-family: inherit; font-weight: 500; line-height: 1.1; color: inherit; } h1 small, h2 small, h3 small, h4 small, h5 small, h6 small, .h1 small, .h2 small, .h3 small, .h4 small, .h5 small, .h6 small, h1 .small, h2 .small, h3 .small, h4 .small, h5 .small, h6 .small, .h1 .small, .h2 .small, .h3 .small, .h4 .small, .h5 .small, .h6 .small { font-weight: normal; line-height: 1; color: #777; } h1, .h1, h2, .h2, h3, .h3 { margin-top: 20px; margin-bottom: 10px; } h1 small, .h1 small, h2 small, .h2 small, h3 small, .h3 small, h1 .small, .h1 .small, h2 .small, .h2 .small, h3 .small, .h3 .small { font-size: 65%; } h4, .h4, h5, .h5, h6, .h6 { margin-top: 10px; margin-bottom: 10px; } h4 small, .h4 small, h5 small, .h5 small, h6 small, .h6 small, h4 .small, .h4 .small, h5 .small, .h5 .small, h6 .small, .h6 .small { font-size: 75%; } h1, .h1 { font-size: 36px; } h2, .h2 { font-size: 30px; } h3, .h3 { font-size: 24px; } h4, .h4 { font-size: 18px; } h5, .h5 { font-size: 14px; } h6, .h6 { font-size: 12px; } p { margin: 0 0 10px; } .lead { margin-bottom: 20px; font-size: 16px; font-weight: 300; line-height: 1.4; } @media (min-width: 768px) { .lead { font-size: 21px; } } small, .small { font-size: 85%; } mark, .mark { padding: .2em; background-color: #fcf8e3; } .text-left { text-align: left; } .text-right { text-align: right; } .text-center { text-align: center; } .text-justify { text-align: justify; } .text-nowrap { white-space: nowrap; } .text-lowercase { text-transform: lowercase; } .text-uppercase { text-transform: uppercase; } .text-capitalize { text-transform: capitalize; } .text-muted { color: #777; } .text-primary { color: #337ab7; } a.text-primary:hover, a.text-primary:focus { color: #286090; } .text-success { color: #3c763d; } a.text-success:hover, a.text-success:focus { color: #2b542c; } .text-info { color: #31708f; } a.text-info:hover, a.text-info:focus { color: #245269; } .text-warning { color: #8a6d3b; } a.text-warning:hover, a.text-warning:focus { color: #66512c; } .text-danger { color: #a94442; } a.text-danger:hover, a.text-danger:focus { color: #843534; } .bg-primary { color: #fff; background-color: #337ab7; } a.bg-primary:hover, a.bg-primary:focus { background-color: #286090; } .bg-success { background-color: #dff0d8; } a.bg-success:hover, a.bg-success:focus { background-color: #c1e2b3; } .bg-info { background-color: #d9edf7; } a.bg-info:hover, a.bg-info:focus { background-color: #afd9ee; } .bg-warning { background-color: #fcf8e3; } a.bg-warning:hover, a.bg-warning:focus { background-color: #f7ecb5; } .bg-danger { background-color: #f2dede; } a.bg-danger:hover, a.bg-danger:focus { background-color: #e4b9b9; } .page-header { padding-bottom: 9px; margin: 40px 0 20px; border-bottom: 1px solid #eee; } ul, ol { margin-top: 0; margin-bottom: 10px; } ul ul, ol ul, ul ol, ol ol { margin-bottom: 0; } .list-unstyled { padding-left: 0; list-style: none; } .list-inline { padding-left: 0; margin-left: -5px; list-style: none; } .list-inline > li { display: inline-block; padding-right: 5px; padding-left: 5px; } dl { margin-top: 0; margin-bottom: 20px; } dt, dd { line-height: 1.42857143; } dt { font-weight: bold; } dd { margin-left: 0; } @media (min-width: 768px) { .dl-horizontal dt { float: left; width: 160px; overflow: hidden; clear: left; text-align: right; text-overflow: ellipsis; white-space: nowrap; } .dl-horizontal dd { margin-left: 180px; } } abbr[title], abbr[data-original-title] { cursor: help; border-bottom: 1px dotted #777; } .initialism { font-size: 90%; text-transform: uppercase; } blockquote { padding: 10px 20px; margin: 0 0 20px; font-size: 17.5px; border-left: 5px solid #eee; } blockquote p:last-child, blockquote ul:last-child, blockquote ol:last-child { margin-bottom: 0; } blockquote footer, blockquote small, blockquote .small { display: block; font-size: 80%; line-height: 1.42857143; color: #777; } blockquote footer:before, blockquote small:before, blockquote .small:before { content: '\\2014 \\00A0'; } .blockquote-reverse, blockquote.pull-right { padding-right: 15px; padding-left: 0; text-align: right; border-right: 5px solid #eee; border-left: 0; } .blockquote-reverse footer:before, blockquote.pull-right footer:before, .blockquote-reverse small:before, blockquote.pull-right small:before, .blockquote-reverse .small:before, blockquote.pull-right .small:before { content: ''; } .blockquote-reverse footer:after, blockquote.pull-right footer:after, .blockquote-reverse small:after, blockquote.pull-right small:after, .blockquote-reverse .small:after, blockquote.pull-right .small:after { content: '\\00A0 \\2014'; } address { margin-bottom: 20px; font-style: normal; line-height: 1.42857143; } code, kbd, pre, samp { font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace; } code { padding: 2px 4px; font-size: 90%; color: #c7254e; background-color: #f9f2f4; border-radius: 4px; } kbd { padding: 2px 4px; font-size: 90%; color: #fff; background-color: #333; border-radius: 3px; -webkit-box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .25); box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .25); } kbd kbd { padding: 0; font-size: 100%; font-weight: bold; -webkit-box-shadow: none; box-shadow: none; } pre { display: block; padding: 9.5px; margin: 0 0 10px; font-size: 13px; line-height: 1.42857143; color: #333; word-break: break-all; word-wrap: break-word; background-color: #f5f5f5; border: 1px solid #ccc; border-radius: 4px; } pre code { padding: 0; font-size: inherit; color: inherit; white-space: pre-wrap; background-color: transparent; border-radius: 0; } .pre-scrollable { max-height: 340px; overflow-y: scroll; } .container { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } @media (min-width: 768px) { .container { width: 750px; } } @media (min-width: 992px) { .container { width: 970px; } } @media (min-width: 1200px) { .container { width: 1170px; } } .container-fluid { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } .row { margin-right: -15px; margin-left: -15px; } .col-xs-1, .col-sm-1, .col-md-1, .col-lg-1, .col-xs-2, .col-sm-2, .col-md-2, .col-lg-2, .col-xs-3, .col-sm-3, .col-md-3, .col-lg-3, .col-xs-4, .col-sm-4, .col-md-4, .col-lg-4, .col-xs-5, .col-sm-5, .col-md-5, .col-lg-5, .col-xs-6, .col-sm-6, .col-md-6, .col-lg-6, .col-xs-7, .col-sm-7, .col-md-7, .col-lg-7, .col-xs-8, .col-sm-8, .col-md-8, .col-lg-8, .col-xs-9, .col-sm-9, .col-md-9, .col-lg-9, .col-xs-10, .col-sm-10, .col-md-10, .col-lg-10, .col-xs-11, .col-sm-11, .col-md-11, .col-lg-11, .col-xs-12, .col-sm-12, .col-md-12, .col-lg-12 { position: relative; min-height: 1px; padding-right: 15px; padding-left: 15px; } .col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12 { float: left; } .col-xs-12 { width: 100%; } .col-xs-11 { width: 91.66666667%; } .col-xs-10 { width: 83.33333333%; } .col-xs-9 { width: 75%; } .col-xs-8 { width: 66.66666667%; } .col-xs-7 { width: 58.33333333%; } .col-xs-6 { width: 50%; } .col-xs-5 { width: 41.66666667%; } .col-xs-4 { width: 33.33333333%; } .col-xs-3 { width: 25%; } .col-xs-2 { width: 16.66666667%; } .col-xs-1 { width: 8.33333333%; } .col-xs-pull-12 { right: 100%; } .col-xs-pull-11 { right: 91.66666667%; } .col-xs-pull-10 { right: 83.33333333%; } .col-xs-pull-9 { right: 75%; } .col-xs-pull-8 { right: 66.66666667%; } .col-xs-pull-7 { right: 58.33333333%; } .col-xs-pull-6 { right: 50%; } .col-xs-pull-5 { right: 41.66666667%; } .col-xs-pull-4 { right: 33.33333333%; } .col-xs-pull-3 { right: 25%; } .col-xs-pull-2 { right: 16.66666667%; } .col-xs-pull-1 { right: 8.33333333%; } .col-xs-pull-0 { right: auto; } .col-xs-push-12 { left: 100%; } .col-xs-push-11 { left: 91.66666667%; } .col-xs-push-10 { left: 83.33333333%; } .col-xs-push-9 { left: 75%; } .col-xs-push-8 { left: 66.66666667%; } .col-xs-push-7 { left: 58.33333333%; } .col-xs-push-6 { left: 50%; } .col-xs-push-5 { left: 41.66666667%; } .col-xs-push-4 { left: 33.33333333%; } .col-xs-push-3 { left: 25%; } .col-xs-push-2 { left: 16.66666667%; } .col-xs-push-1 { left: 8.33333333%; } .col-xs-push-0 { left: auto; } .col-xs-offset-12 { margin-left: 100%; } .col-xs-offset-11 { margin-left: 91.66666667%; } .col-xs-offset-10 { margin-left: 83.33333333%; } .col-xs-offset-9 { margin-left: 75%; } .col-xs-offset-8 { margin-left: 66.66666667%; } .col-xs-offset-7 { margin-left: 58.33333333%; } .col-xs-offset-6 { margin-left: 50%; } .col-xs-offset-5 { margin-left: 41.66666667%; } .col-xs-offset-4 { margin-left: 33.33333333%; } .col-xs-offset-3 { margin-left: 25%; } .col-xs-offset-2 { margin-left: 16.66666667%; } .col-xs-offset-1 { margin-left: 8.33333333%; } .col-xs-offset-0 { margin-left: 0; } @media (min-width: 768px) { .col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11, .col-sm-12 { float: left; } .col-sm-12 { width: 100%; } .col-sm-11 { width: 91.66666667%; } .col-sm-10 { width: 83.33333333%; } .col-sm-9 { width: 75%; } .col-sm-8 { width: 66.66666667%; } .col-sm-7 { width: 58.33333333%; } .col-sm-6 { width: 50%; } .col-sm-5 { width: 41.66666667%; } .col-sm-4 { width: 50%; } .col-sm-3 { width: 25%; } .col-sm-2 { width: 16.66666667%; } .col-sm-1 { width: 8.33333333%; } .col-sm-pull-12 { right: 100%; } .col-sm-pull-11 { right: 91.66666667%; } .col-sm-pull-10 { right: 83.33333333%; } .col-sm-pull-9 { right: 75%; } .col-sm-pull-8 { right: 66.66666667%; } .col-sm-pull-7 { right: 58.33333333%; } .col-sm-pull-6 { right: 50%; } .col-sm-pull-5 { right: 41.66666667%; } .col-sm-pull-4 { right: 33.33333333%; } .col-sm-pull-3 { right: 25%; } .col-sm-pull-2 { right: 16.66666667%; } .col-sm-pull-1 { right: 8.33333333%; } .col-sm-pull-0 { right: auto; } .col-sm-push-12 { left: 100%; } .col-sm-push-11 { left: 91.66666667%; } .col-sm-push-10 { left: 83.33333333%; } .col-sm-push-9 { left: 75%; } .col-sm-push-8 { left: 66.66666667%; } .col-sm-push-7 { left: 58.33333333%; } .col-sm-push-6 { left: 50%; } .col-sm-push-5 { left: 41.66666667%; } .col-sm-push-4 { left: 33.33333333%; } .col-sm-push-3 { left: 25%; } .col-sm-push-2 { left: 16.66666667%; } .col-sm-push-1 { left: 8.33333333%; } .col-sm-push-0 { left: auto; } .col-sm-offset-12 { margin-left: 100%; } .col-sm-offset-11 { margin-left: 91.66666667%; } .col-sm-offset-10 { margin-left: 83.33333333%; } .col-sm-offset-9 { margin-left: 75%; } .col-sm-offset-8 { margin-left: 66.66666667%; } .col-sm-offset-7 { margin-left: 58.33333333%; } .col-sm-offset-6 { margin-left: 50%; } .col-sm-offset-5 { margin-left: 41.66666667%; } .col-sm-offset-4 { margin-left: 33.33333333%; } .col-sm-offset-3 { margin-left: 25%; } .col-sm-offset-2 { margin-left: 16.66666667%; } .col-sm-offset-1 { margin-left: 8.33333333%; } .col-sm-offset-0 { margin-left: 0; } } @media (min-width: 992px) { .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12 { float: left; } .col-md-12 { width: 100%; } .col-md-11 { width: 91.66666667%; } .col-md-10 { width: 83.33333333%; } .col-md-9 { width: 75%; } .col-md-8 { width: 66.66666667%; } .col-md-7 { width: 58.33333333%; } .col-md-6 { width: 50%; } .col-md-5 { width: 41.66666667%; } .col-md-4 { width: 33.33333333%; } .col-md-3 { width: 25%; } .col-md-2 { width: 16.66666667%; } .col-md-1 { width: 8.33333333%; } .col-md-pull-12 { right: 100%; } .col-md-pull-11 { right: 91.66666667%; } .col-md-pull-10 { right: 83.33333333%; } .col-md-pull-9 { right: 75%; } .col-md-pull-8 { right: 66.66666667%; } .col-md-pull-7 { right: 58.33333333%; } .col-md-pull-6 { right: 50%; } .col-md-pull-5 { right: 41.66666667%; } .col-md-pull-4 { right: 33.33333333%; } .col-md-pull-3 { right: 25%; } .col-md-pull-2 { right: 16.66666667%; } .col-md-pull-1 { right: 8.33333333%; } .col-md-pull-0 { right: auto; } .col-md-push-12 { left: 100%; } .col-md-push-11 { left: 91.66666667%; } .col-md-push-10 { left: 83.33333333%; } .col-md-push-9 { left: 75%; } .col-md-push-8 { left: 66.66666667%; } .col-md-push-7 { left: 58.33333333%; } .col-md-push-6 { left: 50%; } .col-md-push-5 { left: 41.66666667%; } .col-md-push-4 { left: 33.33333333%; } .col-md-push-3 { left: 25%; } .col-md-push-2 { left: 16.66666667%; } .col-md-push-1 { left: 8.33333333%; } .col-md-push-0 { left: auto; } .col-md-offset-12 { margin-left: 100%; } .col-md-offset-11 { margin-left: 91.66666667%; } .col-md-offset-10 { margin-left: 83.33333333%; } .col-md-offset-9 { margin-left: 75%; } .col-md-offset-8 { margin-left: 66.66666667%; } .col-md-offset-7 { margin-left: 58.33333333%; } .col-md-offset-6 { margin-left: 50%; } .col-md-offset-5 { margin-left: 41.66666667%; } .col-md-offset-4 { margin-left: 33.33333333%; } .col-md-offset-3 { margin-left: 25%; } .col-md-offset-2 { margin-left: 16.66666667%; } .col-md-offset-1 { margin-left: 8.33333333%; } .col-md-offset-0 { margin-left: 0; } } @media (min-width: 1200px) { .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12 { float: left; } .col-lg-12 { width: 100%; } .col-lg-11 { width: 91.66666667%; } .col-lg-10 { width: 83.33333333%; } .col-lg-9 { width: 75%; } .col-lg-8 { width: 66.66666667%; } .col-lg-7 { width: 58.33333333%; } .col-lg-6 { width: 50%; } .col-lg-5 { width: 41.66666667%; } .col-lg-4 { width: 33.33333333%; } .col-lg-3 { width: 25%; } .col-lg-2 { width: 16.66666667%; } .col-lg-1 { width: 8.33333333%; } .col-lg-pull-12 { right: 100%; } .col-lg-pull-11 { right: 91.66666667%; } .col-lg-pull-10 { right: 83.33333333%; } .col-lg-pull-9 { right: 75%; } .col-lg-pull-8 { right: 66.66666667%; } .col-lg-pull-7 { right: 58.33333333%; } .col-lg-pull-6 { right: 50%; } .col-lg-pull-5 { right: 41.66666667%; } .col-lg-pull-4 { right: 33.33333333%; } .col-lg-pull-3 { right: 25%; } .col-lg-pull-2 { right: 16.66666667%; } .col-lg-pull-1 { right: 8.33333333%; } .col-lg-pull-0 { right: auto; } .col-lg-push-12 { left: 100%; } .col-lg-push-11 { left: 91.66666667%; } .col-lg-push-10 { left: 83.33333333%; } .col-lg-push-9 { left: 75%; } .col-lg-push-8 { left: 66.66666667%; } .col-lg-push-7 { left: 58.33333333%; } .col-lg-push-6 { left: 50%; } .col-lg-push-5 { left: 41.66666667%; } .col-lg-push-4 { left: 33.33333333%; } .col-lg-push-3 { left: 25%; } .col-lg-push-2 { left: 16.66666667%; } .col-lg-push-1 { left: 8.33333333%; } .col-lg-push-0 { left: auto; } .col-lg-offset-12 { margin-left: 100%; } .col-lg-offset-11 { margin-left: 91.66666667%; } .col-lg-offset-10 { margin-left: 83.33333333%; } .col-lg-offset-9 { margin-left: 75%; } .col-lg-offset-8 { margin-left: 66.66666667%; } .col-lg-offset-7 { margin-left: 58.33333333%; } .col-lg-offset-6 { margin-left: 50%; } .col-lg-offset-5 { margin-left: 41.66666667%; } .col-lg-offset-4 { margin-left: 33.33333333%; } .col-lg-offset-3 { margin-left: 25%; } .col-lg-offset-2 { margin-left: 16.66666667%; } .col-lg-offset-1 { margin-left: 8.33333333%; } .col-lg-offset-0 { margin-left: 0; } } table { background-color: transparent; } caption { padding-top: 8px; padding-bottom: 8px; color: #777; text-align: left; } th { text-align: left; } .table { width: 100%; max-width: 100%; margin-bottom: 20px; } .table > thead > tr > th, .table > tbody > tr > th, .table > tfoot > tr > th, .table > thead > tr > td, .table > tbody > tr > td, .table > tfoot > tr > td { padding: 8px; line-height: 1.42857143; vertical-align: top; border-top: 1px solid #ddd; } .table > thead > tr > th { vertical-align: bottom; border-bottom: 2px solid #ddd; } .table > caption + thead > tr:first-child > th, .table > colgroup + thead > tr:first-child > th, .table > thead:first-child > tr:first-child > th, .table > caption + thead > tr:first-child > td, .table > colgroup + thead > tr:first-child > td, .table > thead:first-child > tr:first-child > td { border-top: 0; } .table > tbody + tbody { border-top: 2px solid #ddd; } .table .table { background-color: #fff; } .table-condensed > thead > tr > th, .table-condensed > tbody > tr > th, .table-condensed > tfoot > tr > th, .table-condensed > thead > tr > td, .table-condensed > tbody > tr > td, .table-condensed > tfoot > tr > td { padding: 5px; } .table-bordered { border: 1px solid #ddd; } .table-bordered > thead > tr > th, .table-bordered > tbody > tr > th, .table-bordered > tfoot > tr > th, .table-bordered > thead > tr > td, .table-bordered > tbody > tr > td, .table-bordered > tfoot > tr > td { border: 1px solid #ddd; } .table-bordered > thead > tr > th, .table-bordered > thead > tr > td { border-bottom-width: 2px; } .table-striped > tbody > tr:nth-of-type(odd) { background-color: #f9f9f9; } .table-hover > tbody > tr:hover { background-color: #f5f5f5; } table col[class*=\"col-\"] { position: static; display: table-column; float: none; } table td[class*=\"col-\"], table th[class*=\"col-\"] { position: static; display: table-cell; float: none; } .table > thead > tr > td.active, .table > tbody > tr > td.active, .table > tfoot > tr > td.active, .table > thead > tr > th.active, .table > tbody > tr > th.active, .table > tfoot > tr > th.active, .table > thead > tr.active > td, .table > tbody > tr.active > td, .table > tfoot > tr.active > td, .table > thead > tr.active > th, .table > tbody > tr.active > th, .table > tfoot > tr.active > th { background-color: #f5f5f5; } .table-hover > tbody > tr > td.active:hover, .table-hover > tbody > tr > th.active:hover, .table-hover > tbody > tr.active:hover > td, .table-hover > tbody > tr:hover > .active, .table-hover > tbody > tr.active:hover > th { background-color: #e8e8e8; } .table > thead > tr > td.success, .table > tbody > tr > td.success, .table > tfoot > tr > td.success, .table > thead > tr > th.success, .table > tbody > tr > th.success, .table > tfoot > tr > th.success, .table > thead > tr.success > td, .table > tbody > tr.success > td, .table > tfoot > tr.success > td, .table > thead > tr.success > th, .table > tbody > tr.success > th, .table > tfoot > tr.success > th { background-color: #dff0d8; } .table-hover > tbody > tr > td.success:hover, .table-hover > tbody > tr > th.success:hover, .table-hover > tbody > tr.success:hover > td, .table-hover > tbody > tr:hover > .success, .table-hover > tbody > tr.success:hover > th { background-color: #d0e9c6; } .table > thead > tr > td.info, .table > tbody > tr > td.info, .table > tfoot > tr > td.info, .table > thead > tr > th.info, .table > tbody > tr > th.info, .table > tfoot > tr > th.info, .table > thead > tr.info > td, .table > tbody > tr.info > td, .table > tfoot > tr.info > td, .table > thead > tr.info > th, .table > tbody > tr.info > th, .table > tfoot > tr.info > th { background-color: #d9edf7; } .table-hover > tbody > tr > td.info:hover, .table-hover > tbody > tr > th.info:hover, .table-hover > tbody > tr.info:hover > td, .table-hover > tbody > tr:hover > .info, .table-hover > tbody > tr.info:hover > th { background-color: #c4e3f3; } .table > thead > tr > td.warning, .table > tbody > tr > td.warning, .table > tfoot > tr > td.warning, .table > thead > tr > th.warning, .table > tbody > tr > th.warning, .table > tfoot > tr > th.warning, .table > thead > tr.warning > td, .table > tbody > tr.warning > td, .table > tfoot > tr.warning > td, .table > thead > tr.warning > th, .table > tbody > tr.warning > th, .table > tfoot > tr.warning > th { background-color: #fcf8e3; } .table-hover > tbody > tr > td.warning:hover, .table-hover > tbody > tr > th.warning:hover, .table-hover > tbody > tr.warning:hover > td, .table-hover > tbody > tr:hover > .warning, .table-hover > tbody > tr.warning:hover > th { background-color: #faf2cc; } .table > thead > tr > td.danger, .table > tbody > tr > td.danger, .table > tfoot > tr > td.danger, .table > thead > tr > th.danger, .table > tbody > tr > th.danger, .table > tfoot > tr > th.danger, .table > thead > tr.danger > td, .table > tbody > tr.danger > td, .table > tfoot > tr.danger > td, .table > thead > tr.danger > th, .table > tbody > tr.danger > th, .table > tfoot > tr.danger > th { background-color: #f2dede; } .table-hover > tbody > tr > td.danger:hover, .table-hover > tbody > tr > th.danger:hover, .table-hover > tbody > tr.danger:hover > td, .table-hover > tbody > tr:hover > .danger, .table-hover > tbody > tr.danger:hover > th { background-color: #ebcccc; } .table-responsive { min-height: .01%; overflow-x: auto; } @media screen and (max-width: 767px) { .table-responsive { width: 100%; margin-bottom: 15px; overflow-y: hidden; -ms-overflow-style: -ms-autohiding-scrollbar; border: 1px solid #ddd; } .table-responsive > .table { margin-bottom: 0; } .table-responsive > .table > thead > tr > th, .table-responsive > .table > tbody > tr > th, .table-responsive > .table > tfoot > tr > th, .table-responsive > .table > thead > tr > td, .table-responsive > .table > tbody > tr > td, .table-responsive > .table > tfoot > tr > td { white-space: nowrap; } .table-responsive > .table-bordered { border: 0; } .table-responsive > .table-bordered > thead > tr > th:first-child, .table-responsive > .table-bordered > tbody > tr > th:first-child, .table-responsive > .table-bordered > tfoot > tr > th:first-child, .table-responsive > .table-bordered > thead > tr > td:first-child, .table-responsive > .table-bordered > tbody > tr > td:first-child, .table-responsive > .table-bordered > tfoot > tr > td:first-child { border-left: 0; } .table-responsive > .table-bordered > thead > tr > th:last-child, .table-responsive > .table-bordered > tbody > tr > th:last-child, .table-responsive > .table-bordered > tfoot > tr > th:last-child, .table-responsive > .table-bordered > thead > tr > td:last-child, .table-responsive > .table-bordered > tbody > tr > td:last-child, .table-responsive > .table-bordered > tfoot > tr > td:last-child { border-right: 0; } .table-responsive > .table-bordered > tbody > tr:last-child > th, .table-responsive > .table-bordered > tfoot > tr:last-child > th, .table-responsive > .table-bordered > tbody > tr:last-child > td, .table-responsive > .table-bordered > tfoot > tr:last-child > td { border-bottom: 0; } } fieldset { min-width: 0; padding: 0; margin: 0; border: 0; } legend { display: block; width: 100%; padding: 0; margin-bottom: 20px; font-size: 21px; line-height: inherit; color: #333; border: 0; border-bottom: 1px solid #e5e5e5; } label { display: inline-block; max-width: 100%; margin-bottom: 5px; font-weight: bold; } input[type=\"search\"] { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } input[type=\"radio\"], input[type=\"checkbox\"] { margin: 4px 0 0; margin-top: 1px \\9; line-height: normal; } input[type=\"file\"] { display: block; } input[type=\"range\"] { display: block; width: 100%; } select[multiple], select[size] { height: auto; } input[type=\"file\"]:focus, input[type=\"radio\"]:focus, input[type=\"checkbox\"]:focus { outline: thin dotted; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } output { display: block; padding-top: 7px; font-size: 14px; line-height: 1.42857143; color: #555; } .form-control { display: block; width: 100%; height: 34px; padding: 6px 12px; font-size: 14px; line-height: 1.42857143; color: #555; background-color: #fff; background-image: none; border: 1px solid #ccc; border-radius: 4px; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); -webkit-transition: border-color ease-in-out .15s, -webkit-box-shadow ease-in-out .15s; -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s; transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s; } .form-control:focus { border-color: #66afe9; outline: 0; -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6); box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6); } .form-control::-moz-placeholder { color: #999; opacity: 1; } .form-control:-ms-input-placeholder { color: #999; } .form-control::-webkit-input-placeholder { color: #999; } .form-control::-ms-expand { background-color: transparent; border: 0; } .form-control[disabled], .form-control[readonly], fieldset[disabled] .form-control { background-color: #eee; opacity: 1; } .form-control[disabled], fieldset[disabled] .form-control { cursor: not-allowed; } textarea.form-control { height: auto; } input[type=\"search\"] { -webkit-appearance: none; } @media screen and (-webkit-min-device-pixel-ratio: 0) { input[type=\"date\"].form-control, input[type=\"time\"].form-control, input[type=\"datetime-local\"].form-control, input[type=\"month\"].form-control { line-height: 34px; } input[type=\"date\"].input-sm, input[type=\"time\"].input-sm, input[type=\"datetime-local\"].input-sm, input[type=\"month\"].input-sm, .input-group-sm input[type=\"date\"], .input-group-sm input[type=\"time\"], .input-group-sm input[type=\"datetime-local\"], .input-group-sm input[type=\"month\"] { line-height: 30px; } input[type=\"date\"].input-lg, input[type=\"time\"].input-lg, input[type=\"datetime-local\"].input-lg, input[type=\"month\"].input-lg, .input-group-lg input[type=\"date\"], .input-group-lg input[type=\"time\"], .input-group-lg input[type=\"datetime-local\"], .input-group-lg input[type=\"month\"] { line-height: 46px; } } .form-group { margin-bottom: 15px; } .radio, .checkbox { position: relative; display: block; margin-top: 10px; margin-bottom: 10px; } .radio label, .checkbox label { min-height: 20px; padding-left: 20px; margin-bottom: 0; font-weight: normal; cursor: pointer; } .radio input[type=\"radio\"], .radio-inline input[type=\"radio\"], .checkbox input[type=\"checkbox\"], .checkbox-inline input[type=\"checkbox\"] { position: absolute; margin-top: 4px \\9; margin-left: -20px; } .radio + .radio, .checkbox + .checkbox { margin-top: -5px; } .radio-inline, .checkbox-inline { position: relative; display: inline-block; padding-left: 20px; margin-bottom: 0; font-weight: normal; vertical-align: middle; cursor: pointer; } .radio-inline + .radio-inline, .checkbox-inline + .checkbox-inline { margin-top: 0; margin-left: 10px; } input[type=\"radio\"][disabled], input[type=\"checkbox\"][disabled], input[type=\"radio\"].disabled, input[type=\"checkbox\"].disabled, fieldset[disabled] input[type=\"radio\"], fieldset[disabled] input[type=\"checkbox\"] { cursor: not-allowed; } .radio-inline.disabled, .checkbox-inline.disabled, fieldset[disabled] .radio-inline, fieldset[disabled] .checkbox-inline { cursor: not-allowed; } .radio.disabled label, .checkbox.disabled label, fieldset[disabled] .radio label, fieldset[disabled] .checkbox label { cursor: not-allowed; } .form-control-static { min-height: 34px; padding-top: 7px; padding-bottom: 7px; margin-bottom: 0; } .form-control-static.input-lg, .form-control-static.input-sm { padding-right: 0; padding-left: 0; } .input-sm { height: 30px; padding: 5px 10px; font-size: 12px; line-height: 1.5; border-radius: 3px; } select.input-sm { height: 30px; line-height: 30px; } textarea.input-sm, select[multiple].input-sm { height: auto; } .form-group-sm .form-control { height: 30px; padding: 5px 10px; font-size: 12px; line-height: 1.5; border-radius: 3px; } .form-group-sm select.form-control { height: 30px; line-height: 30px; } .form-group-sm textarea.form-control, .form-group-sm select[multiple].form-control { height: auto; } .form-group-sm .form-control-static { height: 30px; min-height: 32px; padding: 6px 10px; font-size: 12px; line-height: 1.5; } .input-lg { height: 46px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; border-radius: 6px; } select.input-lg { height: 46px; line-height: 46px; } textarea.input-lg, select[multiple].input-lg { height: auto; } .form-group-lg .form-control { height: 46px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; border-radius: 6px; } .form-group-lg select.form-control { height: 46px; line-height: 46px; } .form-group-lg textarea.form-control, .form-group-lg select[multiple].form-control { height: auto; } .form-group-lg .form-control-static { height: 46px; min-height: 38px; padding: 11px 16px; font-size: 18px; line-height: 1.3333333; } .has-feedback { position: relative; } .has-feedback .form-control { padding-right: 42.5px; } .form-control-feedback { position: absolute; top: 0; right: 0; z-index: 2; display: block; width: 34px; height: 34px; line-height: 34px; text-align: center; pointer-events: none; } .input-lg + .form-control-feedback, .input-group-lg + .form-control-feedback, .form-group-lg .form-control + .form-control-feedback { width: 46px; height: 46px; line-height: 46px; } .input-sm + .form-control-feedback, .input-group-sm + .form-control-feedback, .form-group-sm .form-control + .form-control-feedback { width: 30px; height: 30px; line-height: 30px; } .has-success .help-block, .has-success .control-label, .has-success .radio, .has-success .checkbox, .has-success .radio-inline, .has-success .checkbox-inline, .has-success.radio label, .has-success.checkbox label, .has-success.radio-inline label, .has-success.checkbox-inline label { color: #3c763d; } .has-success .form-control { border-color: #3c763d; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); } .has-success .form-control:focus { border-color: #2b542c; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #67b168; box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #67b168; } .has-success .input-group-addon { color: #3c763d; background-color: #dff0d8; border-color: #3c763d; } .has-success .form-control-feedback { color: #3c763d; } .has-warning .help-block, .has-warning .control-label, .has-warning .radio, .has-warning .checkbox, .has-warning .radio-inline, .has-warning .checkbox-inline, .has-warning.radio label, .has-warning.checkbox label, .has-warning.radio-inline label, .has-warning.checkbox-inline label { color: #8a6d3b; } .has-warning .form-control { border-color: #8a6d3b; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); } .has-warning .form-control:focus { border-color: #66512c; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #c0a16b; box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #c0a16b; } .has-warning .input-group-addon { color: #8a6d3b; background-color: #fcf8e3; border-color: #8a6d3b; } .has-warning .form-control-feedback { color: #8a6d3b; } .has-error .help-block, .has-error .control-label, .has-error .radio, .has-error .checkbox, .has-error .radio-inline, .has-error .checkbox-inline, .has-error.radio label, .has-error.checkbox label, .has-error.radio-inline label, .has-error.checkbox-inline label { color: #a94442; } .has-error .form-control { border-color: #a94442; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); } .has-error .form-control:focus { border-color: #843534; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #ce8483; box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #ce8483; } .has-error .input-group-addon { color: #a94442; background-color: #f2dede; border-color: #a94442; } .has-error .form-control-feedback { color: #a94442; } .has-feedback label ~ .form-control-feedback { top: 25px; } .has-feedback label.sr-only ~ .form-control-feedback { top: 0; } .help-block { display: block; margin-top: 5px; margin-bottom: 10px; color: #737373; } @media (min-width: 768px) { .form-inline .form-group { display: inline-block; margin-bottom: 0; vertical-align: middle; } .form-inline .form-control { display: inline-block; width: auto; vertical-align: middle; } .form-inline .form-control-static { display: inline-block; } .form-inline .input-group { display: inline-table; vertical-align: middle; } .form-inline .input-group .input-group-addon, .form-inline .input-group .input-group-btn, .form-inline .input-group .form-control { width: auto; } .form-inline .input-group > .form-control { width: 100%; } .form-inline .control-label { margin-bottom: 0; vertical-align: middle; } .form-inline .radio, .form-inline .checkbox { display: inline-block; margin-top: 0; margin-bottom: 0; vertical-align: middle; } .form-inline .radio label, .form-inline .checkbox label { padding-left: 0; } .form-inline .radio input[type=\"radio\"], .form-inline .checkbox input[type=\"checkbox\"] { position: relative; margin-left: 0; } .form-inline .has-feedback .form-control-feedback { top: 0; } } .form-horizontal .radio, .form-horizontal .checkbox, .form-horizontal .radio-inline, .form-horizontal .checkbox-inline { padding-top: 7px; margin-top: 0; margin-bottom: 0; } .form-horizontal .radio, .form-horizontal .checkbox { min-height: 27px; } .form-horizontal .form-group { margin-right: -15px; margin-left: -15px; } @media (min-width: 768px) { .form-horizontal .control-label { padding-top: 7px; margin-bottom: 0; text-align: right; } } .form-horizontal .has-feedback .form-control-feedback { right: 15px; } @media (min-width: 768px) { .form-horizontal .form-group-lg .control-label { padding-top: 11px; font-size: 18px; } } @media (min-width: 768px) { .form-horizontal .form-group-sm .control-label { padding-top: 6px; font-size: 12px; } } .btn { display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: normal; line-height: 1.42857143; text-align: center; white-space: nowrap; vertical-align: middle; -ms-touch-action: manipulation; touch-action: manipulation; cursor: pointer; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; background-image: none; border: 1px solid transparent; border-radius: 4px; } .btn:focus, .btn:active:focus, .btn.active:focus, .btn.focus, .btn:active.focus, .btn.active.focus { outline: thin dotted; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } .btn:hover, .btn:focus, .btn.focus { color: #333; text-decoration: none; } .btn:active, .btn.active { background-image: none; outline: 0; -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); } .btn.disabled, .btn[disabled], fieldset[disabled] .btn { cursor: not-allowed; filter: alpha(opacity=65); -webkit-box-shadow: none; box-shadow: none; opacity: .65; } a.btn.disabled, fieldset[disabled] a.btn { pointer-events: none; } .btn-default { color: #333; background-color: #fff; border-color: #ccc; } .btn-default:focus, .btn-default.focus { color: #333; background-color: #e6e6e6; border-color: #8c8c8c; } .btn-default:hover { color: #333; background-color: #e6e6e6; border-color: #adadad; } .btn-default:active, .btn-default.active, .open > .dropdown-toggle.btn-default { color: #333; background-color: #e6e6e6; border-color: #adadad; } .btn-default:active:hover, .btn-default.active:hover, .open > .dropdown-toggle.btn-default:hover, .btn-default:active:focus, .btn-default.active:focus, .open > .dropdown-toggle.btn-default:focus, .btn-default:active.focus, .btn-default.active.focus, .open > .dropdown-toggle.btn-default.focus { color: #333; background-color: #d4d4d4; border-color: #8c8c8c; } .btn-default:active, .btn-default.active, .open > .dropdown-toggle.btn-default { background-image: none; } .btn-default.disabled:hover, .btn-default[disabled]:hover, fieldset[disabled] .btn-default:hover, .btn-default.disabled:focus, .btn-default[disabled]:focus, fieldset[disabled] .btn-default:focus, .btn-default.disabled.focus, .btn-default[disabled].focus, fieldset[disabled] .btn-default.focus { background-color: #fff; border-color: #ccc; } .btn-default .badge { color: #fff; background-color: #333; } .btn-primary { color: #fff; background-color: #337ab7; border-color: #2e6da4; } .btn-primary:focus, .btn-primary.focus { color: #fff; background-color: #286090; border-color: #122b40; } .btn-primary:hover { color: #fff; background-color: #286090; border-color: #204d74; } .btn-primary:active, .btn-primary.active, .open > .dropdown-toggle.btn-primary { color: #fff; background-color: #286090; border-color: #204d74; } .btn-primary:active:hover, .btn-primary.active:hover, .open > .dropdown-toggle.btn-primary:hover, .btn-primary:active:focus, .btn-primary.active:focus, .open > .dropdown-toggle.btn-primary:focus, .btn-primary:active.focus, .btn-primary.active.focus, .open > .dropdown-toggle.btn-primary.focus { color: #fff; background-color: #204d74; border-color: #122b40; } .btn-primary:active, .btn-primary.active, .open > .dropdown-toggle.btn-primary { background-image: none; } .btn-primary.disabled:hover, .btn-primary[disabled]:hover, fieldset[disabled] .btn-primary:hover, .btn-primary.disabled:focus, .btn-primary[disabled]:focus, fieldset[disabled] .btn-primary:focus, .btn-primary.disabled.focus, .btn-primary[disabled].focus, fieldset[disabled] .btn-primary.focus { background-color: #337ab7; border-color: #2e6da4; } .btn-primary .badge { color: #337ab7; background-color: #fff; } .btn-success { color: #fff; background-color: #5cb85c; border-color: #4cae4c; } .btn-success:focus, .btn-success.focus { color: #fff; background-color: #449d44; border-color: #255625; } .btn-success:hover { color: #fff; background-color: #449d44; border-color: #398439; } .btn-success:active, .btn-success.active, .open > .dropdown-toggle.btn-success { color: #fff; background-color: #449d44; border-color: #398439; } .btn-success:active:hover, .btn-success.active:hover, .open > .dropdown-toggle.btn-success:hover, .btn-success:active:focus, .btn-success.active:focus, .open > .dropdown-toggle.btn-success:focus, .btn-success:active.focus, .btn-success.active.focus, .open > .dropdown-toggle.btn-success.focus { color: #fff; background-color: #398439; border-color: #255625; } .btn-success:active, .btn-success.active, .open > .dropdown-toggle.btn-success { background-image: none; } .btn-success.disabled:hover, .btn-success[disabled]:hover, fieldset[disabled] .btn-success:hover, .btn-success.disabled:focus, .btn-success[disabled]:focus, fieldset[disabled] .btn-success:focus, .btn-success.disabled.focus, .btn-success[disabled].focus, fieldset[disabled] .btn-success.focus { background-color: #5cb85c; border-color: #4cae4c; } .btn-success .badge { color: #5cb85c; background-color: #fff; } .btn-info { color: #fff; background-color: #5bc0de; border-color: #46b8da; } .btn-info:focus, .btn-info.focus { color: #fff; background-color: #31b0d5; border-color: #1b6d85; } .btn-info:hover { color: #fff; background-color: #31b0d5; border-color: #269abc; } .btn-info:active, .btn-info.active, .open > .dropdown-toggle.btn-info { color: #fff; background-color: #31b0d5; border-color: #269abc; } .btn-info:active:hover, .btn-info.active:hover, .open > .dropdown-toggle.btn-info:hover, .btn-info:active:focus, .btn-info.active:focus, .open > .dropdown-toggle.btn-info:focus, .btn-info:active.focus, .btn-info.active.focus, .open > .dropdown-toggle.btn-info.focus { color: #fff; background-color: #269abc; border-color: #1b6d85; } .btn-info:active, .btn-info.active, .open > .dropdown-toggle.btn-info { background-image: none; } .btn-info.disabled:hover, .btn-info[disabled]:hover, fieldset[disabled] .btn-info:hover, .btn-info.disabled:focus, .btn-info[disabled]:focus, fieldset[disabled] .btn-info:focus, .btn-info.disabled.focus, .btn-info[disabled].focus, fieldset[disabled] .btn-info.focus { background-color: #5bc0de; border-color: #46b8da; } .btn-info .badge { color: #5bc0de; background-color: #fff; } .btn-warning { color: #fff; background-color: #f0ad4e; border-color: #eea236; } .btn-warning:focus, .btn-warning.focus { color: #fff; background-color: #ec971f; border-color: #985f0d; } .btn-warning:hover { color: #fff; background-color: #ec971f; border-color: #d58512; } .btn-warning:active, .btn-warning.active, .open > .dropdown-toggle.btn-warning { color: #fff; background-color: #ec971f; border-color: #d58512; } .btn-warning:active:hover, .btn-warning.active:hover, .open > .dropdown-toggle.btn-warning:hover, .btn-warning:active:focus, .btn-warning.active:focus, .open > .dropdown-toggle.btn-warning:focus, .btn-warning:active.focus, .btn-warning.active.focus, .open > .dropdown-toggle.btn-warning.focus { color: #fff; background-color: #d58512; border-color: #985f0d; } .btn-warning:active, .btn-warning.active, .open > .dropdown-toggle.btn-warning { background-image: none; } .btn-warning.disabled:hover, .btn-warning[disabled]:hover, fieldset[disabled] .btn-warning:hover, .btn-warning.disabled:focus, .btn-warning[disabled]:focus, fieldset[disabled] .btn-warning:focus, .btn-warning.disabled.focus, .btn-warning[disabled].focus, fieldset[disabled] .btn-warning.focus { background-color: #f0ad4e; border-color: #eea236; } .btn-warning .badge { color: #f0ad4e; background-color: #fff; } .btn-danger { color: #fff; background-color: #d9534f; border-color: #d43f3a; } .btn-danger:focus, .btn-danger.focus { color: #fff; background-color: #c9302c; border-color: #761c19; } .btn-danger:hover { color: #fff; background-color: #c9302c; border-color: #ac2925; } .btn-danger:active, .btn-danger.active, .open > .dropdown-toggle.btn-danger { color: #fff; background-color: #c9302c; border-color: #ac2925; } .btn-danger:active:hover, .btn-danger.active:hover, .open > .dropdown-toggle.btn-danger:hover, .btn-danger:active:focus, .btn-danger.active:focus, .open > .dropdown-toggle.btn-danger:focus, .btn-danger:active.focus, .btn-danger.active.focus, .open > .dropdown-toggle.btn-danger.focus { color: #fff; background-color: #ac2925; border-color: #761c19; } .btn-danger:active, .btn-danger.active, .open > .dropdown-toggle.btn-danger { background-image: none; } .btn-danger.disabled:hover, .btn-danger[disabled]:hover, fieldset[disabled] .btn-danger:hover, .btn-danger.disabled:focus, .btn-danger[disabled]:focus, fieldset[disabled] .btn-danger:focus, .btn-danger.disabled.focus, .btn-danger[disabled].focus, fieldset[disabled] .btn-danger.focus { background-color: #d9534f; border-color: #d43f3a; } .btn-danger .badge { color: #d9534f; background-color: #fff; } .btn-link { font-weight: normal; color: #337ab7; border-radius: 0; } .btn-link, .btn-link:active, .btn-link.active, .btn-link[disabled], fieldset[disabled] .btn-link { background-color: transparent; -webkit-box-shadow: none; box-shadow: none; } .btn-link, .btn-link:hover, .btn-link:focus, .btn-link:active { border-color: transparent; } .btn-link:hover, .btn-link:focus { color: #23527c; text-decoration: underline; background-color: transparent; } .btn-link[disabled]:hover, fieldset[disabled] .btn-link:hover, .btn-link[disabled]:focus, fieldset[disabled] .btn-link:focus { color: #777; text-decoration: none; } .btn-lg, .btn-group-lg > .btn { padding: 10px 16px; font-size: 18px; line-height: 1.3333333; border-radius: 6px; } .btn-sm, .btn-group-sm > .btn { padding: 5px 10px; font-size: 12px; line-height: 1.5; border-radius: 3px; } .btn-xs, .btn-group-xs > .btn { padding: 1px 5px; font-size: 12px; line-height: 1.5; border-radius: 3px; } .btn-block { display: block; width: 100%; } .btn-block + .btn-block { margin-top: 5px; } input[type=\"submit\"].btn-block, input[type=\"reset\"].btn-block, input[type=\"button\"].btn-block { width: 100%; } .fade { opacity: 0; -webkit-transition: opacity .15s linear; -o-transition: opacity .15s linear; transition: opacity .15s linear; } .fade.in { opacity: 1; } .collapse { display: none; } .collapse.in { display: block; } tr.collapse.in { display: table-row; } tbody.collapse.in { display: table-row-group; } .collapsing { position: relative; height: 0; overflow: hidden; -webkit-transition-timing-function: ease; -o-transition-timing-function: ease; transition-timing-function: ease; -webkit-transition-duration: .35s; -o-transition-duration: .35s; transition-duration: .35s; -webkit-transition-property: height, visibility; -o-transition-property: height, visibility; transition-property: height, visibility; } .caret { display: inline-block; width: 0; height: 0; margin-left: 2px; vertical-align: middle; border-top: 4px dashed; border-top: 4px solid \\9; border-right: 4px solid transparent; border-left: 4px solid transparent; } .dropup, .dropdown { position: relative; } .dropdown-toggle:focus { outline: 0; } .dropdown-menu { position: absolute; top: 100%; left: 0; z-index: 1000; display: none; float: left; min-width: 160px; padding: 5px 0; margin: 2px 0 0; font-size: 14px; text-align: left; list-style: none; background-color: #fff; -webkit-background-clip: padding-box; background-clip: padding-box; border: 1px solid #ccc; border: 1px solid rgba(0, 0, 0, .15); border-radius: 4px; -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, .175); box-shadow: 0 6px 12px rgba(0, 0, 0, .175); } .dropdown-menu.pull-right { right: 0; left: auto; } .dropdown-menu .divider { height: 1px; margin: 9px 0; overflow: hidden; background-color: #e5e5e5; } .dropdown-menu > li > a { display: block; padding: 3px 20px; clear: both; font-weight: normal; line-height: 1.42857143; color: #333; white-space: nowrap; } .dropdown-menu > li > a:hover, .dropdown-menu > li > a:focus { color: #262626; text-decoration: none; background-color: #f5f5f5; } .dropdown-menu > .active > a, .dropdown-menu > .active > a:hover, .dropdown-menu > .active > a:focus { color: #fff; text-decoration: none; background-color: #337ab7; outline: 0; } .dropdown-menu > .disabled > a, .dropdown-menu > .disabled > a:hover, .dropdown-menu > .disabled > a:focus { color: #777; } .dropdown-menu > .disabled > a:hover, .dropdown-menu > .disabled > a:focus { text-decoration: none; cursor: not-allowed; background-color: transparent; background-image: none; filter: progid:DXImageTransform.Microsoft.gradient(enabled = false); } .open > .dropdown-menu { display: block; } .open > a { outline: 0; } .dropdown-menu-right { right: 0; left: auto; } .dropdown-menu-left { right: auto; left: 0; } .dropdown-header { display: block; padding: 3px 20px; font-size: 12px; line-height: 1.42857143; color: #777; white-space: nowrap; } .dropdown-backdrop { position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 990; } .pull-right > .dropdown-menu { right: 0; left: auto; } .dropup .caret, .navbar-fixed-bottom .dropdown .caret { content: \"\"; border-top: 0; border-bottom: 4px dashed; border-bottom: 4px solid \\9; } .dropup .dropdown-menu, .navbar-fixed-bottom .dropdown .dropdown-menu { top: auto; bottom: 100%; margin-bottom: 2px; } @media (min-width: 768px) { .navbar-right .dropdown-menu { right: 0; left: auto; } .navbar-right .dropdown-menu-left { right: auto; left: 0; } } .btn-group, .btn-group-vertical { position: relative; display: inline-block; vertical-align: middle; } .btn-group > .btn, .btn-group-vertical > .btn { position: relative; float: left; } .btn-group > .btn:hover, .btn-group-vertical > .btn:hover, .btn-group > .btn:focus, .btn-group-vertical > .btn:focus, .btn-group > .btn:active, .btn-group-vertical > .btn:active, .btn-group > .btn.active, .btn-group-vertical > .btn.active { z-index: 2; } .btn-group .btn + .btn, .btn-group .btn + .btn-group, .btn-group .btn-group + .btn, .btn-group .btn-group + .btn-group { margin-left: -1px; } .btn-toolbar { margin-left: -5px; } .btn-toolbar .btn, .btn-toolbar .btn-group, .btn-toolbar .input-group { float: left; } .btn-toolbar > .btn, .btn-toolbar > .btn-group, .btn-toolbar > .input-group { margin-left: 5px; } .btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) { border-radius: 0; } .btn-group > .btn:first-child { margin-left: 0; } .btn-group > .btn:first-child:not(:last-child):not(.dropdown-toggle) { border-top-right-radius: 0; border-bottom-right-radius: 0; } .btn-group > .btn:last-child:not(:first-child), .btn-group > .dropdown-toggle:not(:first-child) { border-top-left-radius: 0; border-bottom-left-radius: 0; } .btn-group > .btn-group { float: left; } .btn-group > .btn-group:not(:first-child):not(:last-child) > .btn { border-radius: 0; } .btn-group > .btn-group:first-child:not(:last-child) > .btn:last-child, .btn-group > .btn-group:first-child:not(:last-child) > .dropdown-toggle { border-top-right-radius: 0; border-bottom-right-radius: 0; } .btn-group > .btn-group:last-child:not(:first-child) > .btn:first-child { border-top-left-radius: 0; border-bottom-left-radius: 0; } .btn-group .dropdown-toggle:active, .btn-group.open .dropdown-toggle { outline: 0; } .btn-group > .btn + .dropdown-toggle { padding-right: 8px; padding-left: 8px; } .btn-group > .btn-lg + .dropdown-toggle { padding-right: 12px; padding-left: 12px; } .btn-group.open .dropdown-toggle { -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); } .btn-group.open .dropdown-toggle.btn-link { -webkit-box-shadow: none; box-shadow: none; } .btn .caret { margin-left: 0; } .btn-lg .caret { border-width: 5px 5px 0; border-bottom-width: 0; } .dropup .btn-lg .caret { border-width: 0 5px 5px; } .btn-group-vertical > .btn, .btn-group-vertical > .btn-group, .btn-group-vertical > .btn-group > .btn { display: block; float: none; width: 100%; max-width: 100%; } .btn-group-vertical > .btn-group > .btn { float: none; } .btn-group-vertical > .btn + .btn, .btn-group-vertical > .btn + .btn-group, .btn-group-vertical > .btn-group + .btn, .btn-group-vertical > .btn-group + .btn-group { margin-top: -1px; margin-left: 0; } .btn-group-vertical > .btn:not(:first-child):not(:last-child) { border-radius: 0; } .btn-group-vertical > .btn:first-child:not(:last-child) { border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .btn-group-vertical > .btn:last-child:not(:first-child) { border-top-left-radius: 0; border-top-right-radius: 0; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; } .btn-group-vertical > .btn-group:not(:first-child):not(:last-child) > .btn { border-radius: 0; } .btn-group-vertical > .btn-group:first-child:not(:last-child) > .btn:last-child, .btn-group-vertical > .btn-group:first-child:not(:last-child) > .dropdown-toggle { border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .btn-group-vertical > .btn-group:last-child:not(:first-child) > .btn:first-child { border-top-left-radius: 0; border-top-right-radius: 0; } .btn-group-justified { display: table; width: 100%; table-layout: fixed; border-collapse: separate; } .btn-group-justified > .btn, .btn-group-justified > .btn-group { display: table-cell; float: none; width: 1%; } .btn-group-justified > .btn-group .btn { width: 100%; } .btn-group-justified > .btn-group .dropdown-menu { left: auto; } [data-toggle=\"buttons\"] > .btn input[type=\"radio\"], [data-toggle=\"buttons\"] > .btn-group > .btn input[type=\"radio\"], [data-toggle=\"buttons\"] > .btn input[type=\"checkbox\"], [data-toggle=\"buttons\"] > .btn-group > .btn input[type=\"checkbox\"] { position: absolute; clip: rect(0, 0, 0, 0); pointer-events: none; } .input-group { position: relative; display: table; border-collapse: separate; } .input-group[class*=\"col-\"] { float: none; padding-right: 0; padding-left: 0; } .input-group .form-control { position: relative; z-index: 2; float: left; width: 100%; margin-bottom: 0; } .input-group .form-control:focus { z-index: 3; } .input-group-lg > .form-control, .input-group-lg > .input-group-addon, .input-group-lg > .input-group-btn > .btn { height: 46px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; border-radius: 6px; } select.input-group-lg > .form-control, select.input-group-lg > .input-group-addon, select.input-group-lg > .input-group-btn > .btn { height: 46px; line-height: 46px; } textarea.input-group-lg > .form-control, textarea.input-group-lg > .input-group-addon, textarea.input-group-lg > .input-group-btn > .btn, select[multiple].input-group-lg > .form-control, select[multiple].input-group-lg > .input-group-addon, select[multiple].input-group-lg > .input-group-btn > .btn { height: auto; } .input-group-sm > .form-control, .input-group-sm > .input-group-addon, .input-group-sm > .input-group-btn > .btn { height: 30px; padding: 5px 10px; font-size: 12px; line-height: 1.5; border-radius: 3px; } select.input-group-sm > .form-control, select.input-group-sm > .input-group-addon, select.input-group-sm > .input-group-btn > .btn { height: 30px; line-height: 30px; } textarea.input-group-sm > .form-control, textarea.input-group-sm > .input-group-addon, textarea.input-group-sm > .input-group-btn > .btn, select[multiple].input-group-sm > .form-control, select[multiple].input-group-sm > .input-group-addon, select[multiple].input-group-sm > .input-group-btn > .btn { height: auto; } .input-group-addon, .input-group-btn, .input-group .form-control { display: table-cell; } .input-group-addon:not(:first-child):not(:last-child), .input-group-btn:not(:first-child):not(:last-child), .input-group .form-control:not(:first-child):not(:last-child) { border-radius: 0; } .input-group-addon, .input-group-btn { width: 1%; white-space: nowrap; vertical-align: middle; } .input-group-addon { padding: 6px 12px; font-size: 14px; font-weight: normal; line-height: 1; color: #555; text-align: center; background-color: #eee; border: 1px solid #ccc; border-radius: 4px; } .input-group-addon.input-sm { padding: 5px 10px; font-size: 12px; border-radius: 3px; } .input-group-addon.input-lg { padding: 10px 16px; font-size: 18px; border-radius: 6px; } .input-group-addon input[type=\"radio\"], .input-group-addon input[type=\"checkbox\"] { margin-top: 0; } .input-group .form-control:first-child, .input-group-addon:first-child, .input-group-btn:first-child > .btn, .input-group-btn:first-child > .btn-group > .btn, .input-group-btn:first-child > .dropdown-toggle, .input-group-btn:last-child > .btn:not(:last-child):not(.dropdown-toggle), .input-group-btn:last-child > .btn-group:not(:last-child) > .btn { border-top-right-radius: 0; border-bottom-right-radius: 0; } .input-group-addon:first-child { border-right: 0; } .input-group .form-control:last-child, .input-group-addon:last-child, .input-group-btn:last-child > .btn, .input-group-btn:last-child > .btn-group > .btn, .input-group-btn:last-child > .dropdown-toggle, .input-group-btn:first-child > .btn:not(:first-child), .input-group-btn:first-child > .btn-group:not(:first-child) > .btn { border-top-left-radius: 0; border-bottom-left-radius: 0; } .input-group-addon:last-child { border-left: 0; } .input-group-btn { position: relative; font-size: 0; white-space: nowrap; } .input-group-btn > .btn { position: relative; } .input-group-btn > .btn + .btn { margin-left: -1px; } .input-group-btn > .btn:hover, .input-group-btn > .btn:focus, .input-group-btn > .btn:active { z-index: 2; } .input-group-btn:first-child > .btn, .input-group-btn:first-child > .btn-group { margin-right: -1px; } .input-group-btn:last-child > .btn, .input-group-btn:last-child > .btn-group { z-index: 2; margin-left: -1px; } .nav { padding-left: 0; margin-bottom: 0; list-style: none; } .nav > li { position: relative; display: block; } .nav > li > a { position: relative; display: block; padding: 10px 15px; } .nav > li > a:hover, .nav > li > a:focus { text-decoration: none; background-color: #eee; } .nav > li.disabled > a { color: #777; } .nav > li.disabled > a:hover, .nav > li.disabled > a:focus { color: #777; text-decoration: none; cursor: not-allowed; background-color: transparent; } .nav .open > a, .nav .open > a:hover, .nav .open > a:focus { background-color: #eee; border-color: #337ab7; } .nav .nav-divider { height: 1px; margin: 9px 0; overflow: hidden; background-color: #e5e5e5; } .nav > li > a > img { max-width: none; } .nav-tabs { border-bottom: 1px solid #ddd; } .nav-tabs > li { float: left; margin-bottom: -1px; } .nav-tabs > li > a { margin-right: 2px; line-height: 1.42857143; border: 1px solid transparent; border-radius: 4px 4px 0 0; } .nav-tabs > li > a:hover { border-color: #eee #eee #ddd; } .nav-tabs > li.active > a, .nav-tabs > li.active > a:hover, .nav-tabs > li.active > a:focus { color: #555; cursor: default; background-color: #fff; border: 1px solid #ddd; border-bottom-color: transparent; } .nav-tabs.nav-justified { width: 100%; border-bottom: 0; } .nav-tabs.nav-justified > li { float: none; } .nav-tabs.nav-justified > li > a { margin-bottom: 5px; text-align: center; } .nav-tabs.nav-justified > .dropdown .dropdown-menu { top: auto; left: auto; } @media (min-width: 768px) { .nav-tabs.nav-justified > li { display: table-cell; width: 1%; } .nav-tabs.nav-justified > li > a { margin-bottom: 0; } } .nav-tabs.nav-justified > li > a { margin-right: 0; border-radius: 4px; } .nav-tabs.nav-justified > .active > a, .nav-tabs.nav-justified > .active > a:hover, .nav-tabs.nav-justified > .active > a:focus { border: 1px solid #ddd; } @media (min-width: 768px) { .nav-tabs.nav-justified > li > a { border-bottom: 1px solid #ddd; border-radius: 4px 4px 0 0; } .nav-tabs.nav-justified > .active > a, .nav-tabs.nav-justified > .active > a:hover, .nav-tabs.nav-justified > .active > a:focus { border-bottom-color: #fff; } } .nav-pills > li { float: left; } .nav-pills > li > a { border-radius: 4px; } .nav-pills > li + li { margin-left: 2px; } .nav-pills > li.active > a, .nav-pills > li.active > a:hover, .nav-pills > li.active > a:focus { color: #fff; background-color: #337ab7; } .nav-stacked > li { float: none; } .nav-stacked > li + li { margin-top: 2px; margin-left: 0; } .nav-justified { width: 100%; } .nav-justified > li { float: none; } .nav-justified > li > a { margin-bottom: 5px; text-align: center; } .nav-justified > .dropdown .dropdown-menu { top: auto; left: auto; } @media (min-width: 768px) { .nav-justified > li { display: table-cell; width: 1%; } .nav-justified > li > a { margin-bottom: 0; } } .nav-tabs-justified { border-bottom: 0; } .nav-tabs-justified > li > a { margin-right: 0; border-radius: 4px; } .nav-tabs-justified > .active > a, .nav-tabs-justified > .active > a:hover, .nav-tabs-justified > .active > a:focus { border: 1px solid #ddd; } @media (min-width: 768px) { .nav-tabs-justified > li > a { border-bottom: 1px solid #ddd; border-radius: 4px 4px 0 0; } .nav-tabs-justified > .active > a, .nav-tabs-justified > .active > a:hover, .nav-tabs-justified > .active > a:focus { border-bottom-color: #fff; } } .tab-content > .tab-pane { display: none; } .tab-content > .active { display: block; } .nav-tabs .dropdown-menu { margin-top: -1px; border-top-left-radius: 0; border-top-right-radius: 0; } .navbar { position: relative; min-height: 50px; margin-bottom: 20px; border: 1px solid transparent; } @media (min-width: 768px) { .navbar { border-radius: 4px; } } @media (min-width: 768px) { .navbar-header { float: left; } } .navbar-collapse { padding-right: 15px; padding-left: 15px; overflow-x: visible; -webkit-overflow-scrolling: touch; border-top: 1px solid transparent; -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, .1); box-shadow: inset 0 1px 0 rgba(255, 255, 255, .1); } .navbar-collapse.in { overflow-y: auto; } @media (min-width: 768px) { .navbar-collapse { width: auto; border-top: 0; -webkit-box-shadow: none; box-shadow: none; } .navbar-collapse.collapse { display: block !important; height: auto !important; padding-bottom: 0; overflow: visible !important; } .navbar-collapse.in { overflow-y: visible; } .navbar-fixed-top .navbar-collapse, .navbar-static-top .navbar-collapse, .navbar-fixed-bottom .navbar-collapse { padding-right: 0; padding-left: 0; } } .navbar-fixed-top .navbar-collapse, .navbar-fixed-bottom .navbar-collapse { max-height: 340px; } @media (max-device-width: 480px) and (orientation: landscape) { .navbar-fixed-top .navbar-collapse, .navbar-fixed-bottom .navbar-collapse { max-height: 200px; } } .container > .navbar-header, .container-fluid > .navbar-header, .container > .navbar-collapse, .container-fluid > .navbar-collapse { margin-right: -15px; margin-left: -15px; } @media (min-width: 768px) { .container > .navbar-header, .container-fluid > .navbar-header, .container > .navbar-collapse, .container-fluid > .navbar-collapse { margin-right: 0; margin-left: 0; } } .navbar-static-top { z-index: 1000; border-width: 0 0 1px; } @media (min-width: 768px) { .navbar-static-top { border-radius: 0; } } .navbar-fixed-top, .navbar-fixed-bottom { position: fixed; right: 0; left: 0; z-index: 1030; } @media (min-width: 768px) { .navbar-fixed-top, .navbar-fixed-bottom { border-radius: 0; } } .navbar-fixed-top { top: 0; border-width: 0 0 1px; } .navbar-fixed-bottom { bottom: 0; margin-bottom: 0; border-width: 1px 0 0; } .navbar-brand { float: left; height: 50px; padding: 15px 15px; font-size: 18px; line-height: 20px; } .navbar-brand:hover, .navbar-brand:focus { text-decoration: none; } .navbar-brand > img { display: block; } @media (min-width: 768px) { .navbar > .container .navbar-brand, .navbar > .container-fluid .navbar-brand { margin-left: -15px; } } .navbar-toggle { position: relative; float: right; padding: 9px 10px; margin-top: 8px; margin-right: 15px; margin-bottom: 8px; background-color: transparent; background-image: none; border: 1px solid transparent; border-radius: 4px; } .navbar-toggle:focus { outline: 0; } .navbar-toggle .icon-bar { display: block; width: 22px; height: 2px; border-radius: 1px; } .navbar-toggle .icon-bar + .icon-bar { margin-top: 4px; } @media (min-width: 768px) { .navbar-toggle { display: none; } } .navbar-nav { margin: 7.5px -15px; } .navbar-nav > li > a { padding-top: 10px; padding-bottom: 10px; line-height: 20px; } @media (max-width: 767px) { .navbar-nav .open .dropdown-menu { position: static; float: none; width: auto; margin-top: 0; background-color: transparent; border: 0; -webkit-box-shadow: none; box-shadow: none; } .navbar-nav .open .dropdown-menu > li > a, .navbar-nav .open .dropdown-menu .dropdown-header { padding: 5px 15px 5px 25px; } .navbar-nav .open .dropdown-menu > li > a { line-height: 20px; } .navbar-nav .open .dropdown-menu > li > a:hover, .navbar-nav .open .dropdown-menu > li > a:focus { background-image: none; } } @media (min-width: 768px) { .navbar-nav { float: left; margin: 0; } .navbar-nav > li { float: left; } .navbar-nav > li > a { padding-top: 15px; padding-bottom: 15px; } } .navbar-form { padding: 10px 15px; margin-top: 8px; margin-right: -15px; margin-bottom: 8px; margin-left: -15px; border-top: 1px solid transparent; border-bottom: 1px solid transparent; -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, .1), 0 1px 0 rgba(255, 255, 255, .1); box-shadow: inset 0 1px 0 rgba(255, 255, 255, .1), 0 1px 0 rgba(255, 255, 255, .1); } @media (min-width: 768px) { .navbar-form .form-group { display: inline-block; margin-bottom: 0; vertical-align: middle; } .navbar-form .form-control { display: inline-block; width: auto; vertical-align: middle; } .navbar-form .form-control-static { display: inline-block; } .navbar-form .input-group { display: inline-table; vertical-align: middle; } .navbar-form .input-group .input-group-addon, .navbar-form .input-group .input-group-btn, .navbar-form .input-group .form-control { width: auto; } .navbar-form .input-group > .form-control { width: 100%; } .navbar-form .control-label { margin-bottom: 0; vertical-align: middle; } .navbar-form .radio, .navbar-form .checkbox { display: inline-block; margin-top: 0; margin-bottom: 0; vertical-align: middle; } .navbar-form .radio label, .navbar-form .checkbox label { padding-left: 0; } .navbar-form .radio input[type=\"radio\"], .navbar-form .checkbox input[type=\"checkbox\"] { position: relative; margin-left: 0; } .navbar-form .has-feedback .form-control-feedback { top: 0; } } @media (max-width: 767px) { .navbar-form .form-group { margin-bottom: 5px; } .navbar-form .form-group:last-child { margin-bottom: 0; } } @media (min-width: 768px) { .navbar-form { width: auto; padding-top: 0; padding-bottom: 0; margin-right: 0; margin-left: 0; border: 0; -webkit-box-shadow: none; box-shadow: none; } } .navbar-nav > li > .dropdown-menu { margin-top: 0; border-top-left-radius: 0; border-top-right-radius: 0; } .navbar-fixed-bottom .navbar-nav > li > .dropdown-menu { margin-bottom: 0; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .navbar-btn { margin-top: 8px; margin-bottom: 8px; } .navbar-btn.btn-sm { margin-top: 10px; margin-bottom: 10px; } .navbar-btn.btn-xs { margin-top: 14px; margin-bottom: 14px; } .navbar-text { margin-top: 15px; margin-bottom: 15px; } @media (min-width: 768px) { .navbar-text { float: left; margin-right: 15px; margin-left: 15px; } } @media (min-width: 768px) { .navbar-left { float: left !important; } .navbar-right { float: right !important; margin-right: -15px; } .navbar-right ~ .navbar-right { margin-right: 0; } } .navbar-default { background-color: #f8f8f8; border-color: #e7e7e7; } .navbar-default .navbar-brand { color: #777; } .navbar-default .navbar-brand:hover, .navbar-default .navbar-brand:focus { color: #5e5e5e; background-color: transparent; } .navbar-default .navbar-text { color: #777; } .navbar-default .navbar-nav > li > a { color: #777; } .navbar-default .navbar-nav > li > a:hover, .navbar-default .navbar-nav > li > a:focus { color: #333; background-color: transparent; } .navbar-default .navbar-nav > .active > a, .navbar-default .navbar-nav > .active > a:hover, .navbar-default .navbar-nav > .active > a:focus { color: #555; background-color: #e7e7e7; } .navbar-default .navbar-nav > .disabled > a, .navbar-default .navbar-nav > .disabled > a:hover, .navbar-default .navbar-nav > .disabled > a:focus { color: #ccc; background-color: transparent; } .navbar-default .navbar-toggle { border-color: #ddd; } .navbar-default .navbar-toggle:hover, .navbar-default .navbar-toggle:focus { background-color: #ddd; } .navbar-default .navbar-toggle .icon-bar { background-color: #888; } .navbar-default .navbar-collapse, .navbar-default .navbar-form { border-color: #e7e7e7; } .navbar-default .navbar-nav > .open > a, .navbar-default .navbar-nav > .open > a:hover, .navbar-default .navbar-nav > .open > a:focus { color: #555; background-color: #e7e7e7; } @media (max-width: 767px) { .navbar-default .navbar-nav .open .dropdown-menu > li > a { color: #777; } .navbar-default .navbar-nav .open .dropdown-menu > li > a:hover, .navbar-default .navbar-nav .open .dropdown-menu > li > a:focus { color: #333; background-color: transparent; } .navbar-default .navbar-nav .open .dropdown-menu > .active > a, .navbar-default .navbar-nav .open .dropdown-menu > .active > a:hover, .navbar-default .navbar-nav .open .dropdown-menu > .active > a:focus { color: #555; background-color: #e7e7e7; } .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a, .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:hover, .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:focus { color: #ccc; background-color: transparent; } } .navbar-default .navbar-link { color: #777; } .navbar-default .navbar-link:hover { color: #333; } .navbar-default .btn-link { color: #777; } .navbar-default .btn-link:hover, .navbar-default .btn-link:focus { color: #333; } .navbar-default .btn-link[disabled]:hover, fieldset[disabled] .navbar-default .btn-link:hover, .navbar-default .btn-link[disabled]:focus, fieldset[disabled] .navbar-default .btn-link:focus { color: #ccc; } .navbar-inverse { background-color: #222; border-color: #080808; } .navbar-inverse .navbar-brand { color: #9d9d9d; } .navbar-inverse .navbar-brand:hover, .navbar-inverse .navbar-brand:focus { color: #fff; background-color: transparent; } .navbar-inverse .navbar-text { color: #9d9d9d; } .navbar-inverse .navbar-nav > li > a { color: #9d9d9d; } .navbar-inverse .navbar-nav > li > a:hover, .navbar-inverse .navbar-nav > li > a:focus { color: #fff; background-color: transparent; } .navbar-inverse .navbar-nav > .active > a, .navbar-inverse .navbar-nav > .active > a:hover, .navbar-inverse .navbar-nav > .active > a:focus { color: #fff; background-color: #080808; } .navbar-inverse .navbar-nav > .disabled > a, .navbar-inverse .navbar-nav > .disabled > a:hover, .navbar-inverse .navbar-nav > .disabled > a:focus { color: #444; background-color: transparent; } .navbar-inverse .navbar-toggle { border-color: #333; } .navbar-inverse .navbar-toggle:hover, .navbar-inverse .navbar-toggle:focus { background-color: #333; } .navbar-inverse .navbar-toggle .icon-bar { background-color: #fff; } .navbar-inverse .navbar-collapse, .navbar-inverse .navbar-form { border-color: #101010; } .navbar-inverse .navbar-nav > .open > a, .navbar-inverse .navbar-nav > .open > a:hover, .navbar-inverse .navbar-nav > .open > a:focus { color: #fff; background-color: #080808; } @media (max-width: 767px) { .navbar-inverse .navbar-nav .open .dropdown-menu > .dropdown-header { border-color: #080808; } .navbar-inverse .navbar-nav .open .dropdown-menu .divider { background-color: #080808; } .navbar-inverse .navbar-nav .open .dropdown-menu > li > a { color: #9d9d9d; } .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:hover, .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:focus { color: #fff; background-color: transparent; } .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a, .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:hover, .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:focus { color: #fff; background-color: #080808; } .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a, .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:hover, .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:focus { color: #444; background-color: transparent; } } .navbar-inverse .navbar-link { color: #9d9d9d; } .navbar-inverse .navbar-link:hover { color: #fff; } .navbar-inverse .btn-link { color: #9d9d9d; } .navbar-inverse .btn-link:hover, .navbar-inverse .btn-link:focus { color: #fff; } .navbar-inverse .btn-link[disabled]:hover, fieldset[disabled] .navbar-inverse .btn-link:hover, .navbar-inverse .btn-link[disabled]:focus, fieldset[disabled] .navbar-inverse .btn-link:focus { color: #444; } .breadcrumb { padding: 8px 15px; margin-bottom: 20px; list-style: none; background-color: #f5f5f5; border-radius: 4px; } .breadcrumb > li { display: inline-block; } .breadcrumb > li + li:before { padding: 0 5px; color: #ccc; content: \"/\\00a0\"; } .breadcrumb > .active { color: #777; } .pagination { display: inline-block; padding-left: 0; margin: 20px 0; border-radius: 4px; } .pagination > li { display: inline; } .pagination > li > a, .pagination > li > span { position: relative; float: left; padding: 6px 12px; margin-left: -1px; line-height: 1.42857143; color: #337ab7; text-decoration: none; background-color: #fff; border: 1px solid #ddd; } .pagination > li:first-child > a, .pagination > li:first-child > span { margin-left: 0; border-top-left-radius: 4px; border-bottom-left-radius: 4px; } .pagination > li:last-child > a, .pagination > li:last-child > span { border-top-right-radius: 4px; border-bottom-right-radius: 4px; } .pagination > li > a:hover, .pagination > li > span:hover, .pagination > li > a:focus, .pagination > li > span:focus { z-index: 2; color: #23527c; background-color: #eee; border-color: #ddd; } .pagination > .active > a, .pagination > .active > span, .pagination > .active > a:hover, .pagination > .active > span:hover, .pagination > .active > a:focus, .pagination > .active > span:focus { z-index: 3; color: #fff; cursor: default; background-color: #337ab7; border-color: #337ab7; } .pagination > .disabled > span, .pagination > .disabled > span:hover, .pagination > .disabled > span:focus, .pagination > .disabled > a, .pagination > .disabled > a:hover, .pagination > .disabled > a:focus { color: #777; cursor: not-allowed; background-color: #fff; border-color: #ddd; } .pagination-lg > li > a, .pagination-lg > li > span { padding: 10px 16px; font-size: 18px; line-height: 1.3333333; } .pagination-lg > li:first-child > a, .pagination-lg > li:first-child > span { border-top-left-radius: 6px; border-bottom-left-radius: 6px; } .pagination-lg > li:last-child > a, .pagination-lg > li:last-child > span { border-top-right-radius: 6px; border-bottom-right-radius: 6px; } .pagination-sm > li > a, .pagination-sm > li > span { padding: 5px 10px; font-size: 12px; line-height: 1.5; } .pagination-sm > li:first-child > a, .pagination-sm > li:first-child > span { border-top-left-radius: 3px; border-bottom-left-radius: 3px; } .pagination-sm > li:last-child > a, .pagination-sm > li:last-child > span { border-top-right-radius: 3px; border-bottom-right-radius: 3px; } .pager { padding-left: 0; margin: 20px 0; text-align: center; list-style: none; } .pager li { display: inline; } .pager li > a, .pager li > span { display: inline-block; padding: 5px 14px; background-color: #fff; border: 1px solid #ddd; border-radius: 15px; } .pager li > a:hover, .pager li > a:focus { text-decoration: none; background-color: #eee; } .pager .next > a, .pager .next > span { float: right; } .pager .previous > a, .pager .previous > span { float: left; } .pager .disabled > a, .pager .disabled > a:hover, .pager .disabled > a:focus, .pager .disabled > span { color: #777; cursor: not-allowed; background-color: #fff; } .label { display: inline; padding: .2em .6em .3em; font-size: 75%; font-weight: bold; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: .25em; } a.label:hover, a.label:focus { color: #fff; text-decoration: none; cursor: pointer; } .label:empty { display: none; } .btn .label { position: relative; top: -1px; } .label-default { background-color: #777; } .label-default[href]:hover, .label-default[href]:focus { background-color: #5e5e5e; } .label-primary { background-color: #337ab7; } .label-primary[href]:hover, .label-primary[href]:focus { background-color: #286090; } .label-success { background-color: #5cb85c; } .label-success[href]:hover, .label-success[href]:focus { background-color: #449d44; } .label-info { background-color: #5bc0de; } .label-info[href]:hover, .label-info[href]:focus { background-color: #31b0d5; } .label-warning { background-color: #f0ad4e; } .label-warning[href]:hover, .label-warning[href]:focus { background-color: #ec971f; } .label-danger { background-color: #d9534f; } .label-danger[href]:hover, .label-danger[href]:focus { background-color: #c9302c; } .badge { display: inline-block; min-width: 10px; padding: 3px 7px; font-size: 12px; font-weight: bold; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: middle; background-color: #777; border-radius: 10px; } .badge:empty { display: none; } .btn .badge { position: relative; top: -1px; } .btn-xs .badge, .btn-group-xs > .btn .badge { top: 0; padding: 1px 5px; } a.badge:hover, a.badge:focus { color: #fff; text-decoration: none; cursor: pointer; } .list-group-item.active > .badge, .nav-pills > .active > a > .badge { color: #337ab7; background-color: #fff; } .list-group-item > .badge { float: right; } .list-group-item > .badge + .badge { margin-right: 5px; } .nav-pills > li > a > .badge { margin-left: 3px; } .jumbotron { padding-top: 30px; padding-bottom: 30px; margin-bottom: 30px; color: inherit; background-color: #eee; } .jumbotron h1, .jumbotron .h1 { color: inherit; } .jumbotron p { margin-bottom: 15px; font-size: 21px; font-weight: 200; } .jumbotron > hr { border-top-color: #d5d5d5; } .container .jumbotron, .container-fluid .jumbotron { padding-right: 15px; padding-left: 15px; border-radius: 6px; } .jumbotron .container { max-width: 100%; } @media screen and (min-width: 768px) { .jumbotron { padding-top: 48px; padding-bottom: 48px; } .container .jumbotron, .container-fluid .jumbotron { padding-right: 60px; padding-left: 60px; } .jumbotron h1, .jumbotron .h1 { font-size: 63px; } } .thumbnail { display: block; padding: 4px; margin-bottom: 20px; line-height: 1.42857143; background-color: #fff; border: 1px solid #ddd; border-radius: 4px; -webkit-transition: border .2s ease-in-out; -o-transition: border .2s ease-in-out; transition: border .2s ease-in-out; } .thumbnail > img, .thumbnail a > img { margin-right: auto; margin-left: auto; } a.thumbnail:hover, a.thumbnail:focus, a.thumbnail.active { border-color: #337ab7; } .thumbnail .caption { padding: 9px; color: #333; } .alert { padding: 15px; margin-bottom: 20px; border: 1px solid transparent; border-radius: 4px; } .alert h4 { margin-top: 0; color: inherit; } .alert .alert-link { font-weight: bold; } .alert > p, .alert > ul { margin-bottom: 0; } .alert > p + p { margin-top: 5px; } .alert-dismissable, .alert-dismissible { padding-right: 35px; } .alert-dismissable .close, .alert-dismissible .close { position: relative; top: -2px; right: -21px; color: inherit; } .alert-success { color: #3c763d; background-color: #dff0d8; border-color: #d6e9c6; } .alert-success hr { border-top-color: #c9e2b3; } .alert-success .alert-link { color: #2b542c; } .alert-info { color: #31708f; background-color: #d9edf7; border-color: #bce8f1; } .alert-info hr { border-top-color: #a6e1ec; } .alert-info .alert-link { color: #245269; } .alert-warning { color: #8a6d3b; background-color: #fcf8e3; border-color: #faebcc; } .alert-warning hr { border-top-color: #f7e1b5; } .alert-warning .alert-link { color: #66512c; } .alert-danger { color: #a94442; background-color: #f2dede; border-color: #ebccd1; } .alert-danger hr { border-top-color: #e4b9c0; } .alert-danger .alert-link { color: #843534; } @-webkit-keyframes progress-bar-stripes { from { background-position: 40px 0; } to { background-position: 0 0; } } @-o-keyframes progress-bar-stripes { from { background-position: 40px 0; } to { background-position: 0 0; } } @keyframes progress-bar-stripes { from { background-position: 40px 0; } to { background-position: 0 0; } } .progress { height: 20px; margin-bottom: 20px; overflow: hidden; background-color: #f5f5f5; border-radius: 4px; -webkit-box-shadow: inset 0 1px 2px rgba(0, 0, 0, .1); box-shadow: inset 0 1px 2px rgba(0, 0, 0, .1); } .progress-bar { float: left; width: 0; height: 100%; font-size: 12px; line-height: 20px; color: #fff; text-align: center; background-color: #337ab7; -webkit-box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .15); box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .15); -webkit-transition: width .6s ease; -o-transition: width .6s ease; transition: width .6s ease; } .progress-striped .progress-bar, .progress-bar-striped { background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); -webkit-background-size: 40px 40px; background-size: 40px 40px; } .progress.active .progress-bar, .progress-bar.active { -webkit-animation: progress-bar-stripes 2s linear infinite; -o-animation: progress-bar-stripes 2s linear infinite; animation: progress-bar-stripes 2s linear infinite; } .progress-bar-success { background-color: #5cb85c; } .progress-striped .progress-bar-success { background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); } .progress-bar-info { background-color: #5bc0de; } .progress-striped .progress-bar-info { background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); } .progress-bar-warning { background-color: #f0ad4e; } .progress-striped .progress-bar-warning { background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); } .progress-bar-danger { background-color: #d9534f; } .progress-striped .progress-bar-danger { background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); } .media { margin-top: 15px; } .media:first-child { margin-top: 0; } .media, .media-body { overflow: hidden; zoom: 1; } .media-body { width: 10000px; } .media-object { display: block; } .media-object.img-thumbnail { max-width: none; } .media-right, .media > .pull-right { padding-left: 10px; } .media-left, .media > .pull-left { padding-right: 10px; } .media-left, .media-right, .media-body { display: table-cell; vertical-align: top; } .media-middle { vertical-align: middle; } .media-bottom { vertical-align: bottom; } .media-heading { margin-top: 0; margin-bottom: 5px; } .media-list { padding-left: 0; list-style: none; } .list-group { padding-left: 0; margin-bottom: 20px; } .list-group-item { position: relative; display: block; padding: 10px 15px; margin-bottom: -1px; background-color: #fff; border: 1px solid #ddd; } .list-group-item:first-child { border-top-left-radius: 4px; border-top-right-radius: 4px; } .list-group-item:last-child { margin-bottom: 0; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; } a.list-group-item, button.list-group-item { color: #555; } a.list-group-item .list-group-item-heading, button.list-group-item .list-group-item-heading { color: #333; } a.list-group-item:hover, button.list-group-item:hover, a.list-group-item:focus, button.list-group-item:focus { color: #555; text-decoration: none; background-color: #f5f5f5; } button.list-group-item { width: 100%; text-align: left; } .list-group-item.disabled, .list-group-item.disabled:hover, .list-group-item.disabled:focus { color: #777; cursor: not-allowed; background-color: #eee; } .list-group-item.disabled .list-group-item-heading, .list-group-item.disabled:hover .list-group-item-heading, .list-group-item.disabled:focus .list-group-item-heading { color: inherit; } .list-group-item.disabled .list-group-item-text, .list-group-item.disabled:hover .list-group-item-text, .list-group-item.disabled:focus .list-group-item-text { color: #777; } .list-group-item.active, .list-group-item.active:hover, .list-group-item.active:focus { z-index: 2; color: #fff; background-color: #337ab7; border-color: #337ab7; } .list-group-item.active .list-group-item-heading, .list-group-item.active:hover .list-group-item-heading, .list-group-item.active:focus .list-group-item-heading, .list-group-item.active .list-group-item-heading > small, .list-group-item.active:hover .list-group-item-heading > small, .list-group-item.active:focus .list-group-item-heading > small, .list-group-item.active .list-group-item-heading > .small, .list-group-item.active:hover .list-group-item-heading > .small, .list-group-item.active:focus .list-group-item-heading > .small { color: inherit; } .list-group-item.active .list-group-item-text, .list-group-item.active:hover .list-group-item-text, .list-group-item.active:focus .list-group-item-text { color: #c7ddef; } .list-group-item-success { color: #3c763d; background-color: #dff0d8; } a.list-group-item-success, button.list-group-item-success { color: #3c763d; } a.list-group-item-success .list-group-item-heading, button.list-group-item-success .list-group-item-heading { color: inherit; } a.list-group-item-success:hover, button.list-group-item-success:hover, a.list-group-item-success:focus, button.list-group-item-success:focus { color: #3c763d; background-color: #d0e9c6; } a.list-group-item-success.active, button.list-group-item-success.active, a.list-group-item-success.active:hover, button.list-group-item-success.active:hover, a.list-group-item-success.active:focus, button.list-group-item-success.active:focus { color: #fff; background-color: #3c763d; border-color: #3c763d; } .list-group-item-info { color: #31708f; background-color: #d9edf7; } a.list-group-item-info, button.list-group-item-info { color: #31708f; } a.list-group-item-info .list-group-item-heading, button.list-group-item-info .list-group-item-heading { color: inherit; } a.list-group-item-info:hover, button.list-group-item-info:hover, a.list-group-item-info:focus, button.list-group-item-info:focus { color: #31708f; background-color: #c4e3f3; } a.list-group-item-info.active, button.list-group-item-info.active, a.list-group-item-info.active:hover, button.list-group-item-info.active:hover, a.list-group-item-info.active:focus, button.list-group-item-info.active:focus { color: #fff; background-color: #31708f; border-color: #31708f; } .list-group-item-warning { color: #8a6d3b; background-color: #fcf8e3; } a.list-group-item-warning, button.list-group-item-warning { color: #8a6d3b; } a.list-group-item-warning .list-group-item-heading, button.list-group-item-warning .list-group-item-heading { color: inherit; } a.list-group-item-warning:hover, button.list-group-item-warning:hover, a.list-group-item-warning:focus, button.list-group-item-warning:focus { color: #8a6d3b; background-color: #faf2cc; } a.list-group-item-warning.active, button.list-group-item-warning.active, a.list-group-item-warning.active:hover, button.list-group-item-warning.active:hover, a.list-group-item-warning.active:focus, button.list-group-item-warning.active:focus { color: #fff; background-color: #8a6d3b; border-color: #8a6d3b; } .list-group-item-danger { color: #a94442; background-color: #f2dede; } a.list-group-item-danger, button.list-group-item-danger { color: #a94442; } a.list-group-item-danger .list-group-item-heading, button.list-group-item-danger .list-group-item-heading { color: inherit; } a.list-group-item-danger:hover, button.list-group-item-danger:hover, a.list-group-item-danger:focus, button.list-group-item-danger:focus { color: #a94442; background-color: #ebcccc; } a.list-group-item-danger.active, button.list-group-item-danger.active, a.list-group-item-danger.active:hover, button.list-group-item-danger.active:hover, a.list-group-item-danger.active:focus, button.list-group-item-danger.active:focus { color: #fff; background-color: #a94442; border-color: #a94442; } .list-group-item-heading { margin-top: 0; margin-bottom: 5px; } .list-group-item-text { margin-bottom: 0; line-height: 1.3; } .panel { margin-bottom: 20px; background-color: #fff; border: 1px solid transparent; border-radius: 4px; -webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, .05); box-shadow: 0 1px 1px rgba(0, 0, 0, .05); } .panel-body { padding: 15px; } .panel-heading { padding: 10px 15px; border-bottom: 1px solid transparent; border-top-left-radius: 3px; border-top-right-radius: 3px; } .panel-heading > .dropdown .dropdown-toggle { color: inherit; } .panel-title { margin-top: 0; margin-bottom: 0; font-size: 16px; color: inherit; } .panel-title > a, .panel-title > small, .panel-title > .small, .panel-title > small > a, .panel-title > .small > a { color: inherit; } .panel-footer { padding: 10px 15px; background-color: #f5f5f5; border-top: 1px solid #ddd; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; } .panel > .list-group, .panel > .panel-collapse > .list-group { margin-bottom: 0; } .panel > .list-group .list-group-item, .panel > .panel-collapse > .list-group .list-group-item { border-width: 1px 0; border-radius: 0; } .panel > .list-group:first-child .list-group-item:first-child, .panel > .panel-collapse > .list-group:first-child .list-group-item:first-child { border-top: 0; border-top-left-radius: 3px; border-top-right-radius: 3px; } .panel > .list-group:last-child .list-group-item:last-child, .panel > .panel-collapse > .list-group:last-child .list-group-item:last-child { border-bottom: 0; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; } .panel > .panel-heading + .panel-collapse > .list-group .list-group-item:first-child { border-top-left-radius: 0; border-top-right-radius: 0; } .panel-heading + .list-group .list-group-item:first-child { border-top-width: 0; } .list-group + .panel-footer { border-top-width: 0; } .panel > .table, .panel > .table-responsive > .table, .panel > .panel-collapse > .table { margin-bottom: 0; } .panel > .table caption, .panel > .table-responsive > .table caption, .panel > .panel-collapse > .table caption { padding-right: 15px; padding-left: 15px; } .panel > .table:first-child, .panel > .table-responsive:first-child > .table:first-child { border-top-left-radius: 3px; border-top-right-radius: 3px; } .panel > .table:first-child > thead:first-child > tr:first-child, .panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child, .panel > .table:first-child > tbody:first-child > tr:first-child, .panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child { border-top-left-radius: 3px; border-top-right-radius: 3px; } .panel > .table:first-child > thead:first-child > tr:first-child td:first-child, .panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child td:first-child, .panel > .table:first-child > tbody:first-child > tr:first-child td:first-child, .panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child td:first-child, .panel > .table:first-child > thead:first-child > tr:first-child th:first-child, .panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child th:first-child, .panel > .table:first-child > tbody:first-child > tr:first-child th:first-child, .panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child th:first-child { border-top-left-radius: 3px; } .panel > .table:first-child > thead:first-child > tr:first-child td:last-child, .panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child td:last-child, .panel > .table:first-child > tbody:first-child > tr:first-child td:last-child, .panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child td:last-child, .panel > .table:first-child > thead:first-child > tr:first-child th:last-child, .panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child th:last-child, .panel > .table:first-child > tbody:first-child > tr:first-child th:last-child, .panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child th:last-child { border-top-right-radius: 3px; } .panel > .table:last-child, .panel > .table-responsive:last-child > .table:last-child { border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; } .panel > .table:last-child > tbody:last-child > tr:last-child, .panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child, .panel > .table:last-child > tfoot:last-child > tr:last-child, .panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child { border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; } .panel > .table:last-child > tbody:last-child > tr:last-child td:first-child, .panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child td:first-child, .panel > .table:last-child > tfoot:last-child > tr:last-child td:first-child, .panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child td:first-child, .panel > .table:last-child > tbody:last-child > tr:last-child th:first-child, .panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child th:first-child, .panel > .table:last-child > tfoot:last-child > tr:last-child th:first-child, .panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child th:first-child { border-bottom-left-radius: 3px; } .panel > .table:last-child > tbody:last-child > tr:last-child td:last-child, .panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child td:last-child, .panel > .table:last-child > tfoot:last-child > tr:last-child td:last-child, .panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child td:last-child, .panel > .table:last-child > tbody:last-child > tr:last-child th:last-child, .panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child th:last-child, .panel > .table:last-child > tfoot:last-child > tr:last-child th:last-child, .panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child th:last-child { border-bottom-right-radius: 3px; } .panel > .panel-body + .table, .panel > .panel-body + .table-responsive, .panel > .table + .panel-body, .panel > .table-responsive + .panel-body { border-top: 1px solid #ddd; } .panel > .table > tbody:first-child > tr:first-child th, .panel > .table > tbody:first-child > tr:first-child td { border-top: 0; } .panel > .table-bordered, .panel > .table-responsive > .table-bordered { border: 0; } .panel > .table-bordered > thead > tr > th:first-child, .panel > .table-responsive > .table-bordered > thead > tr > th:first-child, .panel > .table-bordered > tbody > tr > th:first-child, .panel > .table-responsive > .table-bordered > tbody > tr > th:first-child, .panel > .table-bordered > tfoot > tr > th:first-child, .panel > .table-responsive > .table-bordered > tfoot > tr > th:first-child, .panel > .table-bordered > thead > tr > td:first-child, .panel > .table-responsive > .table-bordered > thead > tr > td:first-child, .panel > .table-bordered > tbody > tr > td:first-child, .panel > .table-responsive > .table-bordered > tbody > tr > td:first-child, .panel > .table-bordered > tfoot > tr > td:first-child, .panel > .table-responsive > .table-bordered > tfoot > tr > td:first-child { border-left: 0; } .panel > .table-bordered > thead > tr > th:last-child, .panel > .table-responsive > .table-bordered > thead > tr > th:last-child, .panel > .table-bordered > tbody > tr > th:last-child, .panel > .table-responsive > .table-bordered > tbody > tr > th:last-child, .panel > .table-bordered > tfoot > tr > th:last-child, .panel > .table-responsive > .table-bordered > tfoot > tr > th:last-child, .panel > .table-bordered > thead > tr > td:last-child, .panel > .table-responsive > .table-bordered > thead > tr > td:last-child, .panel > .table-bordered > tbody > tr > td:last-child, .panel > .table-responsive > .table-bordered > tbody > tr > td:last-child, .panel > .table-bordered > tfoot > tr > td:last-child, .panel > .table-responsive > .table-bordered > tfoot > tr > td:last-child { border-right: 0; } .panel > .table-bordered > thead > tr:first-child > td, .panel > .table-responsive > .table-bordered > thead > tr:first-child > td, .panel > .table-bordered > tbody > tr:first-child > td, .panel > .table-responsive > .table-bordered > tbody > tr:first-child > td, .panel > .table-bordered > thead > tr:first-child > th, .panel > .table-responsive > .table-bordered > thead > tr:first-child > th, .panel > .table-bordered > tbody > tr:first-child > th, .panel > .table-responsive > .table-bordered > tbody > tr:first-child > th { border-bottom: 0; } .panel > .table-bordered > tbody > tr:last-child > td, .panel > .table-responsive > .table-bordered > tbody > tr:last-child > td, .panel > .table-bordered > tfoot > tr:last-child > td, .panel > .table-responsive > .table-bordered > tfoot > tr:last-child > td, .panel > .table-bordered > tbody > tr:last-child > th, .panel > .table-responsive > .table-bordered > tbody > tr:last-child > th, .panel > .table-bordered > tfoot > tr:last-child > th, .panel > .table-responsive > .table-bordered > tfoot > tr:last-child > th { border-bottom: 0; } .panel > .table-responsive { margin-bottom: 0; border: 0; } .panel-group { margin-bottom: 20px; } .panel-group .panel { margin-bottom: 0; border-radius: 4px; } .panel-group .panel + .panel { margin-top: 5px; } .panel-group .panel-heading { border-bottom: 0; } .panel-group .panel-heading + .panel-collapse > .panel-body, .panel-group .panel-heading + .panel-collapse > .list-group { border-top: 1px solid #ddd; } .panel-group .panel-footer { border-top: 0; } .panel-group .panel-footer + .panel-collapse .panel-body { border-bottom: 1px solid #ddd; } .panel-default { border-color: #ddd; } .panel-default > .panel-heading { color: #333; background-color: #f5f5f5; border-color: #ddd; } .panel-default > .panel-heading + .panel-collapse > .panel-body { border-top-color: #ddd; } .panel-default > .panel-heading .badge { color: #f5f5f5; background-color: #333; } .panel-default > .panel-footer + .panel-collapse > .panel-body { border-bottom-color: #ddd; } .panel-primary { border-color: #337ab7; } .panel-primary > .panel-heading { color: #fff; background-color: #337ab7; border-color: #337ab7; } .panel-primary > .panel-heading + .panel-collapse > .panel-body { border-top-color: #337ab7; } .panel-primary > .panel-heading .badge { color: #337ab7; background-color: #fff; } .panel-primary > .panel-footer + .panel-collapse > .panel-body { border-bottom-color: #337ab7; } .panel-success { border-color: #d6e9c6; } .panel-success > .panel-heading { color: #3c763d; background-color: #dff0d8; border-color: #d6e9c6; } .panel-success > .panel-heading + .panel-collapse > .panel-body { border-top-color: #d6e9c6; } .panel-success > .panel-heading .badge { color: #dff0d8; background-color: #3c763d; } .panel-success > .panel-footer + .panel-collapse > .panel-body { border-bottom-color: #d6e9c6; } .panel-info { border-color: #bce8f1; } .panel-info > .panel-heading { color: #31708f; background-color: #d9edf7; border-color: #bce8f1; } .panel-info > .panel-heading + .panel-collapse > .panel-body { border-top-color: #bce8f1; } .panel-info > .panel-heading .badge { color: #d9edf7; background-color: #31708f; } .panel-info > .panel-footer + .panel-collapse > .panel-body { border-bottom-color: #bce8f1; } .panel-warning { border-color: #faebcc; } .panel-warning > .panel-heading { color: #8a6d3b; background-color: #fcf8e3; border-color: #faebcc; } .panel-warning > .panel-heading + .panel-collapse > .panel-body { border-top-color: #faebcc; } .panel-warning > .panel-heading .badge { color: #fcf8e3; background-color: #8a6d3b; } .panel-warning > .panel-footer + .panel-collapse > .panel-body { border-bottom-color: #faebcc; } .panel-danger { border-color: #ebccd1; } .panel-danger > .panel-heading { color: #a94442; background-color: #f2dede; border-color: #ebccd1; } .panel-danger > .panel-heading + .panel-collapse > .panel-body { border-top-color: #ebccd1; } .panel-danger > .panel-heading .badge { color: #f2dede; background-color: #a94442; } .panel-danger > .panel-footer + .panel-collapse > .panel-body { border-bottom-color: #ebccd1; } .embed-responsive { position: relative; display: block; height: 0; padding: 0; overflow: hidden; } .embed-responsive .embed-responsive-item, .embed-responsive iframe, .embed-responsive embed, .embed-responsive object, .embed-responsive video { position: absolute; top: 0; bottom: 0; left: 0; width: 100%; height: 100%; border: 0; } .embed-responsive-16by9 { padding-bottom: 56.25%; } .embed-responsive-4by3 { padding-bottom: 75%; } .well { min-height: 20px; padding: 19px; margin-bottom: 20px; background-color: #f5f5f5; border: 1px solid #e3e3e3; border-radius: 4px; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .05); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .05); } .well blockquote { border-color: #ddd; border-color: rgba(0, 0, 0, .15); } .well-lg { padding: 24px; border-radius: 6px; } .well-sm { padding: 9px; border-radius: 3px; } .close { float: right; font-size: 21px; font-weight: bold; line-height: 1; color: #000; text-shadow: 0 1px 0 #fff; filter: alpha(opacity=20); opacity: .2; } .close:hover, .close:focus { color: #000; text-decoration: none; cursor: pointer; filter: alpha(opacity=50); opacity: .5; } button.close { -webkit-appearance: none; padding: 0; cursor: pointer; background: transparent; border: 0; } .modal-open { overflow: hidden; } .modal { position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1050; display: none; overflow: hidden; -webkit-overflow-scrolling: touch; outline: 0; } .modal.fade .modal-dialog { -webkit-transition: -webkit-transform .3s ease-out; -o-transition: -o-transform .3s ease-out; transition: transform .3s ease-out; -webkit-transform: translate(0, -25%); -ms-transform: translate(0, -25%); -o-transform: translate(0, -25%); transform: translate(0, -25%); } .modal.in .modal-dialog { -webkit-transform: translate(0, 0); -ms-transform: translate(0, 0); -o-transform: translate(0, 0); transform: translate(0, 0); } .modal-open .modal { overflow-x: hidden; overflow-y: auto; } .modal-dialog { position: relative; width: auto; margin: 10px; } .modal-content { position: relative; background-color: #fff; -webkit-background-clip: padding-box; background-clip: padding-box; border: 1px solid #999; border: 1px solid rgba(0, 0, 0, .2); border-radius: 6px; outline: 0; -webkit-box-shadow: 0 3px 9px rgba(0, 0, 0, .5); box-shadow: 0 3px 9px rgba(0, 0, 0, .5); } .modal-backdrop { position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1040; background-color: #000; } .modal-backdrop.fade { filter: alpha(opacity=0); opacity: 0; } .modal-backdrop.in { filter: alpha(opacity=50); opacity: .5; } .modal-header { padding: 15px; border-bottom: 1px solid #e5e5e5; } .modal-header .close { margin-top: -2px; } .modal-title { margin: 0; line-height: 1.42857143; } .modal-body { position: relative; padding: 15px; } .modal-footer { padding: 15px; text-align: right; border-top: 1px solid #e5e5e5; } .modal-footer .btn + .btn { margin-bottom: 0; margin-left: 5px; } .modal-footer .btn-group .btn + .btn { margin-left: -1px; } .modal-footer .btn-block + .btn-block { margin-left: 0; } .modal-scrollbar-measure { position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll; } @media (min-width: 768px) { .modal-dialog { width: 600px; margin: 30px auto; } .modal-content { -webkit-box-shadow: 0 5px 15px rgba(0, 0, 0, .5); box-shadow: 0 5px 15px rgba(0, 0, 0, .5); } .modal-sm { width: 300px; } } @media (min-width: 992px) { .modal-lg { width: 900px; } } .tooltip { position: absolute; z-index: 1070; display: block; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; font-size: 12px; font-style: normal; font-weight: normal; line-height: 1.42857143; text-align: left; text-align: start; text-decoration: none; text-shadow: none; text-transform: none; letter-spacing: normal; word-break: normal; word-spacing: normal; word-wrap: normal; white-space: normal; filter: alpha(opacity=0); opacity: 0; line-break: auto; } .tooltip.in { filter: alpha(opacity=90); opacity: .9; } .tooltip.top { padding: 5px 0; margin-top: -3px; } .tooltip.right { padding: 0 5px; margin-left: 3px; } .tooltip.bottom { padding: 5px 0; margin-top: 3px; } .tooltip.left { padding: 0 5px; margin-left: -3px; } .tooltip-inner { max-width: 200px; padding: 3px 8px; color: #fff; text-align: center; background-color: #000; border-radius: 4px; } .tooltip-arrow { position: absolute; width: 0; height: 0; border-color: transparent; border-style: solid; } .tooltip.top .tooltip-arrow { bottom: 0; left: 50%; margin-left: -5px; border-width: 5px 5px 0; border-top-color: #000; } .tooltip.top-left .tooltip-arrow { right: 5px; bottom: 0; margin-bottom: -5px; border-width: 5px 5px 0; border-top-color: #000; } .tooltip.top-right .tooltip-arrow { bottom: 0; left: 5px; margin-bottom: -5px; border-width: 5px 5px 0; border-top-color: #000; } .tooltip.right .tooltip-arrow { top: 50%; left: 0; margin-top: -5px; border-width: 5px 5px 5px 0; border-right-color: #000; } .tooltip.left .tooltip-arrow { top: 50%; right: 0; margin-top: -5px; border-width: 5px 0 5px 5px; border-left-color: #000; } .tooltip.bottom .tooltip-arrow { top: 0; left: 50%; margin-left: -5px; border-width: 0 5px 5px; border-bottom-color: #000; } .tooltip.bottom-left .tooltip-arrow { top: 0; right: 5px; margin-top: -5px; border-width: 0 5px 5px; border-bottom-color: #000; } .tooltip.bottom-right .tooltip-arrow { top: 0; left: 5px; margin-top: -5px; border-width: 0 5px 5px; border-bottom-color: #000; } .popover { position: absolute; top: 0; left: 0; z-index: 1060; display: none; max-width: 276px; padding: 1px; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; font-size: 14px; font-style: normal; font-weight: normal; line-height: 1.42857143; text-align: left; text-align: start; text-decoration: none; text-shadow: none; text-transform: none; letter-spacing: normal; word-break: normal; word-spacing: normal; word-wrap: normal; white-space: normal; background-color: #fff; -webkit-background-clip: padding-box; background-clip: padding-box; border: 1px solid #ccc; border: 1px solid rgba(0, 0, 0, .2); border-radius: 6px; -webkit-box-shadow: 0 5px 10px rgba(0, 0, 0, .2); box-shadow: 0 5px 10px rgba(0, 0, 0, .2); line-break: auto; } .popover.top { margin-top: -10px; } .popover.right { margin-left: 10px; } .popover.bottom { margin-top: 10px; } .popover.left { margin-left: -10px; } .popover-title { padding: 8px 14px; margin: 0; font-size: 14px; background-color: #f7f7f7; border-bottom: 1px solid #ebebeb; border-radius: 5px 5px 0 0; } .popover-content { padding: 9px 14px; } .popover > .arrow, .popover > .arrow:after { position: absolute; display: block; width: 0; height: 0; border-color: transparent; border-style: solid; } .popover > .arrow { border-width: 11px; } .popover > .arrow:after { content: \"\"; border-width: 10px; } .popover.top > .arrow { bottom: -11px; left: 50%; margin-left: -11px; border-top-color: #999; border-top-color: rgba(0, 0, 0, .25); border-bottom-width: 0; } .popover.top > .arrow:after { bottom: 1px; margin-left: -10px; content: \" \"; border-top-color: #fff; border-bottom-width: 0; } .popover.right > .arrow { top: 50%; left: -11px; margin-top: -11px; border-right-color: #999; border-right-color: rgba(0, 0, 0, .25); border-left-width: 0; } .popover.right > .arrow:after { bottom: -10px; left: 1px; content: \" \"; border-right-color: #fff; border-left-width: 0; } .popover.bottom > .arrow { top: -11px; left: 50%; margin-left: -11px; border-top-width: 0; border-bottom-color: #999; border-bottom-color: rgba(0, 0, 0, .25); } .popover.bottom > .arrow:after { top: 1px; margin-left: -10px; content: \" \"; border-top-width: 0; border-bottom-color: #fff; } .popover.left > .arrow { top: 50%; right: -11px; margin-top: -11px; border-right-width: 0; border-left-color: #999; border-left-color: rgba(0, 0, 0, .25); } .popover.left > .arrow:after { right: 1px; bottom: -10px; content: \" \"; border-right-width: 0; border-left-color: #fff; } .carousel { position: relative; } .carousel-inner { position: relative; width: 100%; overflow: hidden; } .carousel-inner > .item { position: relative; display: none; -webkit-transition: .6s ease-in-out left; -o-transition: .6s ease-in-out left; transition: .6s ease-in-out left; } .carousel-inner > .item > img, .carousel-inner > .item > a > img { line-height: 1; } @media all and (transform-3d), (-webkit-transform-3d) { .carousel-inner > .item { -webkit-transition: -webkit-transform .6s ease-in-out; -o-transition: -o-transform .6s ease-in-out; transition: transform .6s ease-in-out; -webkit-backface-visibility: hidden; backface-visibility: hidden; -webkit-perspective: 1000px; perspective: 1000px; } .carousel-inner > .item.next, .carousel-inner > .item.active.right { left: 0; -webkit-transform: translate3d(100%, 0, 0); transform: translate3d(100%, 0, 0); } .carousel-inner > .item.prev, .carousel-inner > .item.active.left { left: 0; -webkit-transform: translate3d(-100%, 0, 0); transform: translate3d(-100%, 0, 0); } .carousel-inner > .item.next.left, .carousel-inner > .item.prev.right, .carousel-inner > .item.active { left: 0; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); } } .carousel-inner > .active, .carousel-inner > .next, .carousel-inner > .prev { display: block; } .carousel-inner > .active { left: 0; } .carousel-inner > .next, .carousel-inner > .prev { position: absolute; top: 0; width: 100%; } .carousel-inner > .next { left: 100%; } .carousel-inner > .prev { left: -100%; } .carousel-inner > .next.left, .carousel-inner > .prev.right { left: 0; } .carousel-inner > .active.left { left: -100%; } .carousel-inner > .active.right { left: 100%; } .carousel-control { position: absolute; top: 0; bottom: 0; left: 0; width: 15%; font-size: 20px; color: #fff; text-align: center; text-shadow: 0 1px 2px rgba(0, 0, 0, .6); background-color: rgba(0, 0, 0, 0); filter: alpha(opacity=50); opacity: .5; } .carousel-control.left { background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%); background-image: -o-linear-gradient(left, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%); background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, .5)), to(rgba(0, 0, 0, .0001))); background-image: linear-gradient(to right, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1); background-repeat: repeat-x; } .carousel-control.right { right: 0; left: auto; background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, .0001) 0%, rgba(0, 0, 0, .5) 100%); background-image: -o-linear-gradient(left, rgba(0, 0, 0, .0001) 0%, rgba(0, 0, 0, .5) 100%); background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, .0001)), to(rgba(0, 0, 0, .5))); background-image: linear-gradient(to right, rgba(0, 0, 0, .0001) 0%, rgba(0, 0, 0, .5) 100%); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1); background-repeat: repeat-x; } .carousel-control:hover, .carousel-control:focus { color: #fff; text-decoration: none; filter: alpha(opacity=90); outline: 0; opacity: .9; } .carousel-control .icon-prev, .carousel-control .icon-next, .carousel-control .glyphicon-chevron-left, .carousel-control .glyphicon-chevron-right { position: absolute; top: 50%; z-index: 5; display: inline-block; margin-top: -10px; } .carousel-control .icon-prev, .carousel-control .glyphicon-chevron-left { left: 50%; margin-left: -10px; } .carousel-control .icon-next, .carousel-control .glyphicon-chevron-right { right: 50%; margin-right: -10px; } .carousel-control .icon-prev, .carousel-control .icon-next { width: 20px; height: 20px; font-family: serif; line-height: 1; } .carousel-control .icon-prev:before { content: '\\2039'; } .carousel-control .icon-next:before { content: '\\203a'; } .carousel-indicators { position: absolute; bottom: 10px; left: 50%; z-index: 15; width: 60%; padding-left: 0; margin-left: -30%; text-align: center; list-style: none; } .carousel-indicators li { display: inline-block; width: 10px; height: 10px; margin: 1px; text-indent: -999px; cursor: pointer; background-color: #000 \\9; background-color: rgba(0, 0, 0, 0); border: 1px solid #fff; border-radius: 10px; } .carousel-indicators .active { width: 12px; height: 12px; margin: 0; background-color: #fff; } .carousel-caption { position: absolute; right: 15%; bottom: 20px; left: 15%; z-index: 10; padding-top: 20px; padding-bottom: 20px; color: #fff; text-align: center; text-shadow: 0 1px 2px rgba(0, 0, 0, .6); } .carousel-caption .btn { text-shadow: none; } @media screen and (min-width: 768px) { .carousel-control .glyphicon-chevron-left, .carousel-control .glyphicon-chevron-right, .carousel-control .icon-prev, .carousel-control .icon-next { width: 30px; height: 30px; margin-top: -10px; font-size: 30px; } .carousel-control .glyphicon-chevron-left, .carousel-control .icon-prev { margin-left: -10px; } .carousel-control .glyphicon-chevron-right, .carousel-control .icon-next { margin-right: -10px; } .carousel-caption { right: 20%; left: 20%; padding-bottom: 30px; } .carousel-indicators { bottom: 20px; } } .clearfix:before, .clearfix:after, .dl-horizontal dd:before, .dl-horizontal dd:after, .container:before, .container:after, .container-fluid:before, .container-fluid:after, .row:before, .row:after, .form-horizontal .form-group:before, .form-horizontal .form-group:after, .btn-toolbar:before, .btn-toolbar:after, .btn-group-vertical > .btn-group:before, .btn-group-vertical > .btn-group:after, .nav:before, .nav:after, .navbar:before, .navbar:after, .navbar-header:before, .navbar-header:after, .navbar-collapse:before, .navbar-collapse:after, .pager:before, .pager:after, .panel-body:before, .panel-body:after, .modal-header:before, .modal-header:after, .modal-footer:before, .modal-footer:after { display: table; content: \" \"; } .clearfix:after, .dl-horizontal dd:after, .container:after, .container-fluid:after, .row:after, .form-horizontal .form-group:after, .btn-toolbar:after, .btn-group-vertical > .btn-group:after, .nav:after, .navbar:after, .navbar-header:after, .navbar-collapse:after, .pager:after, .panel-body:after, .modal-header:after, .modal-footer:after { clear: both; } .center-block { display: block; margin-right: auto; margin-left: auto; } .pull-right { float: right !important; } .pull-left { float: left !important; } .hide { display: none !important; } .show { display: block !important; } .invisible { visibility: hidden; } .text-hide { font: 0/0 a; color: transparent; text-shadow: none; background-color: transparent; border: 0; } .hidden { display: none !important; } .affix { position: fixed; } @-ms-viewport { width: device-width; } .visible-xs, .visible-sm, .visible-md, .visible-lg { display: none !important; } .visible-xs-block, .visible-xs-inline, .visible-xs-inline-block, .visible-sm-block, .visible-sm-inline, .visible-sm-inline-block, .visible-md-block, .visible-md-inline, .visible-md-inline-block, .visible-lg-block, .visible-lg-inline, .visible-lg-inline-block { display: none !important; } @media (max-width: 767px) { .visible-xs { display: block !important; } table.visible-xs { display: table !important; } tr.visible-xs { display: table-row !important; } th.visible-xs, td.visible-xs { display: table-cell !important; } } @media (max-width: 767px) { .visible-xs-block { display: block !important; } } @media (max-width: 767px) { .visible-xs-inline { display: inline !important; } } @media (max-width: 767px) { .visible-xs-inline-block { display: inline-block !important; } } @media (min-width: 768px) and (max-width: 991px) { .visible-sm { display: block !important; } table.visible-sm { display: table !important; } tr.visible-sm { display: table-row !important; } th.visible-sm, td.visible-sm { display: table-cell !important; } } @media (min-width: 768px) and (max-width: 991px) { .visible-sm-block { display: block !important; } } @media (min-width: 768px) and (max-width: 991px) { .visible-sm-inline { display: inline !important; } } @media (min-width: 768px) and (max-width: 991px) { .visible-sm-inline-block { display: inline-block !important; } } @media (min-width: 992px) and (max-width: 1199px) { .visible-md { display: block !important; } table.visible-md { display: table !important; } tr.visible-md { display: table-row !important; } th.visible-md, td.visible-md { display: table-cell !important; } } @media (min-width: 992px) and (max-width: 1199px) { .visible-md-block { display: block !important; } } @media (min-width: 992px) and (max-width: 1199px) { .visible-md-inline { display: inline !important; } } @media (min-width: 992px) and (max-width: 1199px) { .visible-md-inline-block { display: inline-block !important; } } @media (min-width: 1200px) { .visible-lg { display: block !important; } table.visible-lg { display: table !important; } tr.visible-lg { display: table-row !important; } th.visible-lg, td.visible-lg { display: table-cell !important; } } @media (min-width: 1200px) { .visible-lg-block { display: block !important; } } @media (min-width: 1200px) { .visible-lg-inline { display: inline !important; } } @media (min-width: 1200px) { .visible-lg-inline-block { display: inline-block !important; } } @media (max-width: 767px) { .hidden-xs { display: none !important; } } @media (min-width: 768px) and (max-width: 991px) { .hidden-sm { display: none !important; } } @media (min-width: 992px) and (max-width: 1199px) { .hidden-md { display: none !important; } } @media (min-width: 1200px) { .hidden-lg { display: none !important; } } .visible-print { display: none !important; } @media print { .visible-print { display: block !important; } table.visible-print { display: table !important; } tr.visible-print { display: table-row !important; } th.visible-print, td.visible-print { display: table-cell !important; } } .visible-print-block { display: none !important; } @media print { .visible-print-block { display: block !important; } } .visible-print-inline { display: none !important; } @media print { .visible-print-inline { display: inline !important; } } .visible-print-inline-block { display: none !important; } @media print { .visible-print-inline-block { display: inline-block !important; } } @media print { .hidden-print { display: none !important; } } /*# sourceMappingURL=bootstrap.css.map */"}],"posts":[{"title":"Leetcode题目解析（191122）：101&102&104","slug":"leetcode191122","date":"2019-11-22T03:16:14.000Z","updated":"2019-11-22T03:19:03.673Z","comments":false,"path":"2019/11/22/leetcode191122/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/22/leetcode191122/","excerpt":"","text":"Leetcode 101：对称二叉树题目描述给定一个二叉树，检查它是否是镜像对称的。 解题思路既然它是镜像的话，那么就是左右对称，这个我们可以使用一个递归来解决。我们令A等于这个树，B也等于这个树，假设A树和B树都只有一个结点（空结点也看做是一个结点）其实也就是两个树中至少一个树为NULL的时候，结果只会存在三种情况：1.A的该结点为NULL，B的该结点也为NULL，即都是空结点，那么这两个树相等，自然是镜像，返回true；2.A的该结点为NULL，B的该结点不为NULL（或者A的该结点不是NULL，B的该结点为NULL），那么不是镜像，返回false；3.A和B均有值，但不相等，自然不是镜像，返回false。我们把这个结点看做是其父结点的一个子树，然后逐层向上去扩展。判断的时候是由上向下，只要两个结点值相等就继续递归。 代码实现12345678910111213 bool isSym(TreeNode* root1, TreeNode* root2)&#123; if (root1 == nullptr &amp;&amp; root2 == nullptr) return true; if (root1 == nullptr || root2 == nullptr) return false; if (root1-&gt;val != root2-&gt;val) return false; return isSym(root1-&gt;left, root2-&gt;right) &amp;&amp; isSym(root1-&gt;right, root2-&gt;left);&#125;bool isSymmetric(TreeNode* root) &#123; return isSym(root, root);&#125; 时间复杂度&amp;空间复杂度 Leetcode 102：二叉树的层序遍历题目描述给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 解题思路这其实就是二叉树的BFS，但是和之前又有一点不同，那就是保存的结果不是一个vector，而是一个vector类型的vector数组，数组里面有多个vector，每个vector里面的元素是这一层的值。所以关键在于如何存储呢？那这个就可以借鉴之前做过的二叉树的右视角这个题，我们储存一个size，代表这一层有多少个元素，然后执行一个for循环，在这个for循环里面把元素push到一个tmp数组中，for循环完成后，把tmppush到result即可。 但是不知道为什么，那个for循环如果我用while循环的话，就会超时，需要研究一下。 代码实现12345678910111213141516171819202122232425vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; if (root == nullptr) return result; queue&lt;TreeNode*&gt;q; TreeNode* tt; q.push(root); while (!q.empty()) &#123; int size = q.size(); vector&lt;int&gt;tmp; for(int i=0;i&lt;size;i++) &#123; tt = q.front(); tmp.push_back(tt-&gt;val); q.pop(); if (tt-&gt;left) q.push(tt-&gt;left); if (tt-&gt;right) q.push(tt-&gt;right); &#125; result.push_back(tmp); &#125; return result;&#125; 执行用时和内存消耗 Leetcode 104：二叉树的最大深度题目描述给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。 示例给定二叉树 [3,9,20,null,null,15,7]，返回它的最大深度为3。 题目解析：递归法如果一棵树只有一个结点，那么深度为1.如果根节点只有左子树而没有右子树，那么深度就是左子树深度+1；同理，对于右子树也是如此。如果既有左子树，也有右子树，那么该树的深度就是左右子树深度的最大值+1。所以可以利用递归的方式实现该题目。 代码实现：递归法123456789101112131415int maxDepth(TreeNode* root) &#123; int Heightl,Heightr,MaxH; if(root) &#123; Heightl=maxDepth(root-&gt;left); Heightr=maxDepth(root-&gt;right); MaxH=(Heightl&gt;Heightr)?Heightl:Heightr; return MaxH+1; &#125; else &#123; return 0; &#125; &#125; 题目解析：广度优先借鉴层序遍历的方法，只不过使用了deque，不具体说思路了，比较简单。 代码实现：广度优先123456789101112131415161718192021int maxDepth(TreeNode* root) &#123; if(root==nullptr) return 0; deque&lt;TreeNode* &gt; q; q.push_back(root); int deep=0; while(!q.empty()) &#123; ++deep; int len=q.size(); for(int i=1;i&lt;=len;i++) &#123; TreeNode *tt=q.front(); q.pop_front(); if(tt-&gt;left) q.push_back(tt-&gt;left); if(tt-&gt;right) q.push_back(tt-&gt;right); &#125; &#125; return deep; &#125; 时间复杂度&amp;空间复杂度递归法： 广度优先： 可以看出，广度优先算法提升了速度，减小了内存消耗。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"Leetcode题目解析（191121）：105&114","slug":"leetcode191121","date":"2019-11-21T02:34:22.000Z","updated":"2019-11-21T02:42:40.083Z","comments":false,"path":"2019/11/21/leetcode191121/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/21/leetcode191121/","excerpt":"","text":"Leetcode 105：重建二叉树题目描述根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。 示例给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 题目解析我们根据前序遍历的特点可以发现，前序遍历的第一个数字一定是这个二叉树的根节点；然后根据中序遍历的特点可发现，根节点左侧的数字一定是左子树，右侧一定是右子树。然后将中序遍历以根节点为中心划分成两个部分，这又是两个子树，然后这个子树又可以根据前序遍历找到各个子树的根节点……以此类推，这非常适合有递推来实现。 就拿这个例子来说。 前序遍历： 序号 0 1 2 3 4 5 6 7 内容 1 2 4 7 3 5 6 8 中序遍历： 序号 0 1 2 3 4 5 6 7 内容 4 7 2 1 5 3 8 6 这又就把中序遍历分为了4/7/2和5/3/8/6两个部分。然后考虑4/7/2这个部分，前序遍历的第2个数字是划分4/7/2的数字，这样，2是这个子树的根节点，4/7都位于左子树。 然后再看右子树，也就是3/5/6/8这四个数字。同理可以得出，3是右子树的根节点，然后5在左子树，8/6在右子树。再去8/6这个子树看，根据前序遍历可以看到6为子树的根节点，根据中序遍历可以看到，8为子树的左结点。 接下来考虑代码实现问题。首先肯定要判断所给的两个数组是不是空，若是空肯定是个空树，否则继续进行。我们可以使用类里面的一个私有函数来进行具体的重建功能，而这个函数的参数自然是前序遍历结果、起始位置、结束位置、中序遍历结果、起始位置、结束位置。 当然作为刚开始的时候，起始位置肯定是0，结束位置肯定是length-1。 使用这个私有函数进行递归，肯定有停止递归的条件，那就是开始位置大于结束位置的时候，自然就代表迭代结束了。 然后新建一个TreeNode，第一个节点自然是前序遍历的第一个节点，所以可以： TreeNode root=new TreeNode(pre[startPre]); 接下来自然要开始进行判断，寻找前序遍历和中序遍历相等值的位置，由于前序遍历里面的点都可以作为中序遍历里面的根节点，所以我们只需要在中序遍历里面找到与前序遍历中值相等的位置，就是该子树的根节点的位置，就可以根据这个点划分左子树和右子树了。而中序遍历中到的根节点的位置i左侧有几个数字就是左子树有几个元素，右边有几个数字就是右子树有几个元素 对于左子树来说，左子树的起始位置自然是startPre的下一个位置，而结束是startPre+i-startIn（startPre是位置，i-startIn是从中序遍历中看左子树有几个元素），而中序遍历的开始位置自然是startIn，结束位置是i-1。 对于右子树来说，中序遍历的起始位置自然是i+1，结束位置是endIn；而对于前序遍历来说，自然是startPre+左子树的元素数+1，而左子树我们知道是i-startIn了，所以起始位置是startPre+i-startIn+1，结束位置自然是endPre。 于是，完成了这个程序的编写。 代码实现123456789101112131415161718192021222324252627TreeNode* build(vector&lt;int&gt;&amp; pre, int ps, int pe, vector&lt;int&gt;&amp; in, int is, int ie)&#123; if (ps &gt; pe || is &gt; ie) return nullptr; int mid = pre[ps];//找到中序遍历的中间结点 TreeNode* root = new TreeNode(mid); int i = is; for (; i &lt;= ie; ++i) &#123; if (in[i] == mid) break; &#125; root-&gt;left = build(pre, ps + 1, ps + i - is, in, is, i - 1);//对左子树下手 root-&gt;right = build(pre, ps + i - is + 1, pe, in, i + 1, ie);//对右子树下手 return root;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int presize = preorder.size(); int insize = inorder.size(); if (presize == 0 || insize == 0) return nullptr; else if (presize != insize) return nullptr; return build(preorder, 0, presize - 1, inorder, 0, insize - 1);&#125; 复杂度 Leetcode 114：二叉树展开为链表题目描述给定一个二叉树，原地将它展开为链表。 题目解析 我们以上图来考虑该如何去做。其整个过程如下图所示。首先确定根节点，然后寻找左子树的最右节点，将右子树挂在这个最右节点上，然后把左子树挂在右子树的位置上，最后将左子树置为空。这样便完成了一个循环。 然后将根结点指针往后移一个节点，继续下一个过程。如果该结点的左子树是空，那么就直接进入下一个过程。如果这个时候当前节点已经是空了，那么代表整个任务已经完成了。 代码实现1234567891011121314void flatten(TreeNode* root) &#123; while (root != nullptr) &#123; if (root-&gt;left != nullptr) &#123; auto mright = root-&gt;left;//如果左子树非空，找左子树的最右节点 while (mright-&gt;right != nullptr) mright = mright-&gt;right; //找完 mright-&gt;right = root-&gt;right;//把根的右孩子挂载左子树最右节点的右子树上 root-&gt;right = root-&gt;left;//这个时候根的右孩子可以无视了，把左孩子放到右孩子上 root-&gt;left = nullptr;//左子树置空即可 &#125; root = root-&gt;right;//下一步继续进行 &#125;&#125; 复杂度","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"Leetcode题目解析（191120）：124&128","slug":"leetcode191120","date":"2019-11-20T02:44:02.000Z","updated":"2019-11-20T02:45:25.037Z","comments":false,"path":"2019/11/20/leetcode191120/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/20/leetcode191120/","excerpt":"","text":"Leetcode 124：二叉树中的最大路径和题目描述给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 解题思路参见：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/er-cha-shu-zhong-de-zui-da-lu-jing-he-by-ikaruga/ 代码实现1234567891011121314151617int maxSum(TreeNode* root,int &amp;maxs)&#123; if (root == nullptr) return INT_MIN; int left = max(maxSum(root-&gt;left,maxs),0); int right = max(maxSum(root-&gt;right,maxs),0); int lmr = root-&gt;val + left + right; maxs = max(maxs, lmr); return root-&gt;val+max(left,right);&#125;int maxPathSum(TreeNode* root) &#123; if (root == nullptr) return 0; int maxs = INT_MIN; maxSum(root,maxs); return maxs;&#125; 复杂度 Leetcode 128：最长连续序列题目描述给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。 示例输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 代码实现123456789101112131415int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt;slen; int maxl = 0; for (auto num : nums) &#123; if (slen[num] == 0) &#123; int l = slen[num - 1], r = slen[num + 1]; slen[num] = l + r + 1; slen[num + r] = l + r + 1; slen[num - l] = l + r + 1; maxl = maxl &gt; slen[num]? maxl : slen[num]; &#125; &#125; return maxl;&#125; 复杂度","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"Leetcode题目解析（191119）：136&137&139","slug":"leetcode191119","date":"2019-11-19T02:26:51.000Z","updated":"2019-11-19T02:39:17.154Z","comments":false,"path":"2019/11/19/leetcode191119/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/19/leetcode191119/","excerpt":"","text":"Leetcode 136：只出现一次的数字题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例输入: [2,2,1]输出: 1 解题思路这里我们可以利用异或的原理，我们发现在异或中： a⊕0=a；a⊕a=0。a⊕b⊕a=(a⊕a)⊕b=0⊕b=b 所以我们只需要将所有的数进行 XOR 操作，得到那个唯一的数字。 代码实现1234567int singleNumber(vector&lt;int&gt;&amp; nums) &#123; //if (nums.empty()) // return 0; for (int i = 1; i &lt; nums.size(); i++) nums[0] ^= nums[i];//异或 return nums[0];&#125; 复杂度 时间复杂度：O(n)，空间复杂度：没有使用额外的空间。 拓展：Leetcode137（只出现一次的数字2）题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。你的算法应该具有线性时间复杂度。 你不可使用额外空间来实现。 解题思路我们前面的基础上用到了“异或”，它本质上是一种二进制下不考虑进位的加法。所以对于本题，我们可以考虑构造一种三进制下不考虑进位的加法，这种方法存在以下运算规则：假设运算符号为@，则0@1=1,1#1=2,2#1=0。所以在这种运算规则之下，出现3次的数字全部抵消为0，而只留下只出现1次的数字。所以有以下步骤： ones^=num：记录至目前元素num，二进制某位出现1次（当某位出现3次时有ones=1，与twos=1共同表示“出现3次”）。 twos|=ones&amp;num：记录至目前元素num，二进制某位出现2次（当某位出现2次时，twos=1且ones=0） threes=ones&amp;twos：记录至目前元素num，二进制某位出现3次（即当ones和twos对应位同时为1时three=1）。one&amp;=~threes,two&amp;=~threes：将onestwos中出现了3次的对应位清零，实现“不考虑进位的三进制加法”。 进一步简化：以上过程本质上是通过构建3个变量的状态转换表来表示对应位的出现次数：使所有数字“相加”后出现3N+1次的位ones=1，出现3N，3N+2次的位为ones=0。由于three其实是ones&amp;twos的结果，因此我们可以舍弃threes，仅使用ones和twos来记录出现次数。 解析转载自：https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/ 代码实现12345678910int singleNumber(vector&lt;int&gt;&amp; nums) &#123; //if (nums.empty()) // return 0; int ones = 0, twos = 0; for (int num : nums) &#123; ones = ones ^ num &amp; ~twos; twos = twos ^ num &amp; ~ones; &#125; return ones;&#125; 复杂度分析时间复杂度 O(n)：遍历一遍 nums 需要线性时间复杂度；空间复杂度 O(1)：使用常数额外空间。 Leetcode 139：单词拆分题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。 示例示例 1：输入: s = “leetcode”, wordDict = [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。 示例 2：输入: s = “applepenapple”, wordDict = [“apple”, “pen”]输出: true解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。注意你可以重复使用字典中的单词。 示例 3：输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]输出: false 解题说明这个题可以想到可以用动态规划的思想。原因是这个问题可以将给定的字符串s分解为s1和s2，然后这两个是独立的问题，同时s1和s2又可以继续拆分下去。所以说这符合动态规划的条件。 我们可以考虑如何进行动态规划求解。既然是分成两个字符串，实际上就是用两个指针i和j，其中i是当前字符串从头开始的子字符串的长度，j是当前字符串的拆分位置，于是字符串就被拆分为了(0,j)和(j+1,i)的区间。然后设置一个一维dp数组，dp数组中的下标代表着字符串结束的下标。 我们在求dp的时候，首先初始化dp[0]=true，剩余元素都初始化为false。我们用下标i来考虑所有从当前字符串开始的可能的字符串。对于每一个字符串，我们用j将它们分解为s1和s2，也就是说只有s1和s2都为true才可以，所以等价于，如果想要求dp[i]，就要看dp[j]（dp[j]代表到字符串下标到j的这个子字符串是否是子串，也就是s1是否是子串）和s2的情况。我们首先看dp[j]是否为true，若是则检查s2，s2实际上是下标(j+1,i)，所以只需要执行find(wordDict.begin(), wordDict.end(), s.substr(j, i - j)) != wordDict.end()即可。这样就完成了整个判断操作。最后返回dp[len]就好了。 代码实现123456789101112131415161718bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int len = s.size(); if (len == 0 || wordDict.size() == 0) return false; vector&lt;bool&gt; dp(len + 1, false); dp[0] = true; for (int i = 1; i &lt;= len; i++) &#123; for (int j = i - 1; j &gt;= 0; j--) &#123; if (dp[j] &amp;&amp; find(wordDict.begin(), wordDict.end(), s.substr(j, i - j)) != wordDict.end()) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[len];&#125; 复杂度时间复杂度：O(n2)，因为两层for循环。空间复杂度：O(n)，因为使用了长度为n+1的dp数组。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"Leetcode题目解析（191118）：141&142&146","slug":"leetcode191118","date":"2019-11-18T03:56:02.000Z","updated":"2019-11-19T02:39:39.494Z","comments":false,"path":"2019/11/18/leetcode191118/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/18/leetcode191118/","excerpt":"","text":"Leetcode 142：环形链表2题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 题目解析《剑指offer》中也有此题，所以直接复制过来予以说明。 其实我的思路是把每个访问过的结点做标记，然后不断往下走后，遇到的第一个标记过的点，就是还的入口结点，如果没有遇到，则就不存在环，返回null。但是这种方法比较复杂，而且很难找到标志每个结点的特点在哪里。 所以可以这样考虑。如图4.1所示。 图4.1 示意图 我们假设x为AB之间的距离，a为从b到c的距离（顺时针移动），c为环的长度。我们可以设置两个指针，一个快一个慢，然后快的是慢的速度的两倍。设快指针为f，慢指针为s，则当快指针和慢指针相遇的时候，s=x+mc+a，f=x+nc+a，m和n为某不同的常数，s=f。所以x=(n-2m)c-a=(n-2m-1)c+c-a。n-2m-1可为0。这里为了处理方便，省略前面这个类似于周期的东西，只留下c-a。c-a是什么？c-a就是图4.1中灰色的这条线。也就是说，AB之间的距离=灰色的线。这样，我们可以再重新将f这个指针（也可以是s）指向A，那么当f和s相遇的时候，所在的结点就是入口结点。 代码实现123456789101112131415161718192021222324ListNode *detectCycle(ListNode *head) &#123; if(head==nullptr||head-&gt;next==nullptr||head-&gt;next-&gt;next==nullptr)&#123; return nullptr; &#125; ListNode *slow=head-&gt;next; ListNode *fast=head-&gt;next-&gt;next; while(fast!=slow) &#123; if((fast-&gt;next!=nullptr)&amp;&amp;(fast-&gt;next-&gt;next!=nullptr))&#123; fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; &#125; else&#123; return nullptr; &#125; &#125; fast=head; while(fast!=slow) &#123; fast=fast-&gt;next; slow=slow-&gt;next; &#125; return slow; &#125; 复杂度分析 时间复杂度O(n)，空间复杂度O(1)。 其它题目详见Leetcode 141（环形链表），是本题的阉割版本，具体代码如下： 1234567891011121314151617181920bool hasCycle(ListNode *head) &#123; if(head==nullptr||head-&gt;next==nullptr||head-&gt;next-&gt;next==nullptr) &#123; return false; &#125; ListNode *slow=head-&gt;next; ListNode *fast=head-&gt;next-&gt;next; while(fast!=slow)&#123; if((fast-&gt;next!=nullptr)&amp;&amp;(fast-&gt;next-&gt;next!=nullptr)) &#123; fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; &#125; else&#123; return false; &#125; &#125; return true; &#125; Leetcode 146：LRU缓存机制题目描述运用你所掌握的数据结构，设计和实现一个LRU (最近最少使用)缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value)- 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 进阶 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例：12345678910LRUCache* cache = new LRUCache(2);cache-&gt;put(1, 1);cache-&gt;put(2, 2);int result1 = cache-&gt;get(1);//return 1cache-&gt;put(3, 3);//make (2,2) invalidint result2 = cache-&gt;get(2);//return -1cache-&gt;put(4, 4);//make (1,1) invalidint result3 = cache-&gt;get(1);//return -1int result4 = cache-&gt;get(3);//return 3int result5 = cache-&gt;get(4);//return 4 解题思路LRU就是这样一个数据结构：其内部含有一个容量为cap的结构，也就是说里面有cap个元素，每一个元素是一个键值对。这个数据结构插入（put）和寻找（get）有以下特点：对于插入来说，如果这个键值对不存在，那么插入到这个元组里面，并放置在开头，如果存在则更新这个元组并放置在开头；对于寻找来说，如果没有找到，则返回-1，否则返回这个键值对的value，然后将这个键值对放在元组开头。 通过以上的功能，我们可以首先想到的基本数据结构有：哈希表（键值对）、栈（先入先出）。但是考虑到我们get之后也需要把这个键值对放在开头，所以使用栈的话操作并不方便，因为栈只能操作一头。所以我们可以使用哈希表。另外因为要求查找的时间复杂度为O(1)，所以更应该使用哈希表。但是另外一点，我们还要求插入时间复杂度为O(1)，那么能实现该复杂度的基本数据结构只有链表。但是链表查找速度慢，那应该怎么操作呢？这里可以考虑采用哈希表和链表相结合的方法进行操作。即对应于hash表每一个key值的value值其实指向了链表中的一个pair，这个pair的key值与hash表中的key值相等。于是无论是get还是put只需要对这个组合数据结构进行操作即可。 实际上这个类的数据成员一共三个：int类型的容量cap、pair类型的双向链表cache、int和list的unordered_map mymap。所以对于构造函数来说，实际就是记录容量即可。对于get来说，我们要判断是否存在，由于hashmap更适合做查找工作，所以就在hashmap里面查找，如果不存在，则返回-1，否则的返回key对应的value。但是不能直接这么返回，还需要将这个key-value置于mymap的开头，搜易需要做的就是获取到这个键值对，然后在链表list里面删除该键值对，然后将键值对插入到cache的开头，再领map[key]指向这个地址，最后再返回value的值。 对于put来说，也需要先判断该key是否存在，若存在，则直接更改value值并插入到cache头部，具体步骤与前面思路一致，不再重述；若不存在，则首先判断cache长度是否已经达到容量，若达到了，则删除链表cache中最后一个元素，并获取相应key值在mymap中予以删除，这样就空出来了空间。若还有空间，则直接在cache头部添加，然后在mymap中直接添加即可。 具体可以见代码。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class LRUCache &#123;private: int cap;//capacity list&lt;pair&lt;int, int&gt;&gt; cache;//single key-value pair unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; mymap; //hash table:key to the position of(key,value) in cachepublic: LRUCache(int capacity) &#123; this-&gt;cap = capacity; &#125; int get(int key) &#123; auto it = mymap.find(key); //can not find key if (it == mymap.end()) return -1; //find key and put it in the front of the list pair&lt;int, int&gt; visited = *mymap[key]; cache.erase(mymap[key]); cache.push_front(visited); // update the position of (key,value) in cache mymap[key] = cache.begin(); return visited.second; &#125; void put(int key, int value) &#123; //first if existed? auto it = mymap.find(key); //1--no if (it == mymap.end()) &#123; //1.1 no position? if (cache.size() == cap) &#123; auto lastPair = cache.back(); int lastKey = lastPair.first; mymap.erase(lastKey); cache.pop_back(); &#125; //cache没满（或者已经删了一个位置）则可以直接添加 cache.push_front(make_pair ( key, value)); mymap[key] = cache.begin(); &#125; else &#123;//key存在，则更改key并换到队头 cache.erase(mymap[key]); cache.push_front(make_pair(key, value)); mymap[key] = cache.begin(); &#125; &#125;&#125;; 复杂度","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"Leetcode题目解析（191115）：148&152","slug":"leetcode191115","date":"2019-11-15T02:35:52.000Z","updated":"2019-11-15T02:50:33.429Z","comments":false,"path":"2019/11/15/leetcode191115/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/15/leetcode191115/","excerpt":"","text":"Leetcode 148：排序链表题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例示例 1:输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2:输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路由于题目要求复杂度为O(nlogn)且空间复杂度为常数级，我们可以想到的是堆排序，但是实际上，由于是链表，其不需要借助额外的数组来存储内容，只需要通过链表直接的链接调整即可，所以对于链表来说，归并排序的空间复杂度也是O(1)。当然在使用递归的时候就不是了。 归并排序的顺序是“二分”和“合并”。那么对于链表来说，由于我们不能使用递归，所以我们可以使用迭代来进行处理。首先是二分的步骤，其过程如下图所示。 对于cut这个过程，我们要做的就是，首先记录下链表的长度n，其实每一次划分，其划分出来的长度都是n&gt;&gt;2，也就是二分之n，所以我们只需要将一个指针从头走n/2次即可，然后将该指针的next指向空，记录下一个节点的地址为right，并返回。这样我们就记录了两个子链表的开始地址left和right，如下图所示。 代码实现如下的cut函数所示。 在cut完成之后，就需要开始“合并”。合并这个工序可以参见之前做过的合并有序链表即可，其过程不再重述，如下图所示。 整个过程如下图所示。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: ListNode* cut(ListNode* head, int n)&#123; auto p = head; while (--n &amp;&amp; p) &#123; p = p-&gt;next; &#125; if (!p) return nullptr; auto next = p-&gt;next; p-&gt;next = nullptr; return next;&#125;//合并两个有序链表的子程序即可ListNode* merge(ListNode* l1, ListNode* l2)&#123; ListNode dummy(0); auto p = &amp;dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; p-&gt;next = l1; p = l1;//或者写p=p-&gt;next也可以 l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; p = l2;//或者写p=p-&gt;next也可以 l2 = l2-&gt;next; &#125; &#125; p-&gt;next = (l1 ? l1 : l2); return dummy.next;&#125;ListNode* sortList(ListNode* head) &#123; ListNode dummy(0); dummy.next = head;//dummyHead auto p = head; int length = 0; while (p)// the length of this linkedlist &#123; ++length; p=p-&gt;next; &#125; for (int size = 1; size &lt; length; size &lt;&lt;= 1) &#123; auto cur = dummy.next; auto tail = &amp;dummy; while (cur) &#123; auto left = cur; auto right = cut(left, size);//left-&gt;@-&gt;@ |断开|right-&gt;@-&gt;@-&gt;@... cur = cut(right, size);//left-&gt;@-&gt;@|断开|right-&gt;@-&gt;@ |断开|cur-&gt;@-&gt;... tail-&gt;next = merge(left, right); while (tail-&gt;next) &#123; tail = tail-&gt;next; &#125; &#125; &#125; return dummy.next;&#125;&#125;; 复杂度 Leetcode 152：乘积最大子序列题目描述给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例示例 1:输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2:输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 解题思路通过做这么多题了，看到这个题的时候，能够第一时间想到要用动态规划去完成，其思想就是遍历数组同时计算当前的最大值，然后不断更新。如果使用dp[]数组倒也能完成，但是空间复杂度太高，其实我们可以直接用一个变量直接就可以完成，这样空间复杂度将至了O(1)。 我们令imax为最大值，那么imax的递推公式可以表述如下 1imax = max(imax * nums[i], nums[i]); 但是，我们的数组可能存在负值，所以会带来最大值变最小值，最小值变最大值的情况，所以我们还需要维护一个imin，其递推公式如下：1 imin = min(imin * nums[i], nums[i]); 正因为上面的原因，所以当我们当前值为负数的时候，我们需要交换一下imax和imin的值再进行计算，否则会出现混乱。 代码实现1234567891011121314151617int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int maxvalue = INT_MIN, imax = 1, imin = 1; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] &lt; 0) &#123; int tmp = imax; imax = imin; imin = tmp; &#125; imax = max(imax * nums[i], nums[i]); imin = min(imin * nums[i], nums[i]); maxvalue = max(maxvalue, imax); &#125; return maxvalue;&#125; 复杂度时间复杂度为O(n)。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"Leetcode题目解析（191114）：155&160","slug":"leetcode191114","date":"2019-11-14T01:12:55.000Z","updated":"2019-11-14T01:16:24.400Z","comments":false,"path":"2019/11/14/leetcode191114/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/14/leetcode191114/","excerpt":"","text":"Leetcode 155：最小栈题目描述设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。pop() – 删除栈顶的元素。top() – 获取栈顶元素。getMin() – 检索栈中的最小元素。 示例12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 解题思路看到这个题，实际上可以想到使用辅助栈来进行操作。所谓辅助栈就是用来存储每一步的最小值，数据栈自然是存储所有的数据。我们使用辅助栈和数据栈同步来做，这样的好处是思路简单，但是可能要多存一些不必要的元素。 对于push来说，这个函数操作很关键，要保证这一步辅助栈push进去的都是当前为止最小的。所以有两种情况：①辅助栈为空，自然直接push进入；②辅助栈不为空，就判断当前要push的值是否小于stack2最上面的值，如果是的话则push进去，否则不push进去。但是数据栈是直接push进去。 对于pop来说，只有数据栈和辅助栈最上面的元素一样的时候，才会pop掉辅助栈的栈顶元素。 自然，在上面的操作下，一定保证了辅助栈最上面的元素是最小的元素。所以getMin()的时候直接返回辅助栈的栈顶元素即可。 代码实现123456789101112131415161718192021222324252627class MinStack &#123;private: stack&lt;int&gt; stack1;//数据栈 stack&lt;int&gt; stack2;//辅助栈public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; stack1.push(x); if (stack2.empty()) stack2.push(x); else if (x &lt;= stack2.top()) stack2.push(x); &#125; void pop() &#123; if (stack1.top() == stack2.top()) stack2.pop(); stack1.pop(); &#125; int top() &#123; return stack1.top(); &#125; int getMin() &#123; return stack2.top(); &#125;&#125;; 复杂度分析 时间复杂度：O(1)，“出栈”、“入栈”、“查看栈顶元素”的操作不论数据规模多大，都只是有限个步骤，因此时间复杂度是：O(1)。空间复杂度：O(N)，这里N是读出的数据的个数。 Leetcode 160：相交链表题目描述编写一个程序，找到两个单链表相交的起始节点。 示例 在节点8处相交。 解题思路我这是属于一个比较傻瓜的思路。观察上图可知，我们可以考虑把两个指针放到相对于交点前移相同数目的位置作为基准进行往后移动，然后当两个指针相等的时候，就找到了它们的相交点。 那怎样实现这样呢？我们可以统计A链表的长度，假设为alen，统计B链表的长度，假设为blen，然后计算它们的差值clen。这样的话，将较长的链表的指针先往后移动clen就可以达到我们的目标了。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if(!headA||!headB) return nullptr; ListNode *countA=headA; ListNode *countB=headB; int cA=0; int cB=0; while(countA) &#123; ++cA; countA=countA-&gt;next; &#125; while(countB) &#123; ++cB; countB=countB-&gt;next; &#125; /*将较长的链表实现最后边与较短的对齐*/ int lLen,sLen; ListNode *lList; ListNode *sList; if(cA&gt;cB) &#123; sLen=cB; sList=headB; lLen=cA; lList=headA; &#125; else &#123; sLen=cA; sList=headA; lLen=cB; lList=headB; &#125; for(int i=0;i&lt;lLen-sLen;i++,lList=lList-&gt;next); while(lList!=nullptr&amp;&amp;sList!=nullptr) &#123; if(lList==sList) return lList; lList=lList-&gt;next; sList=sList-&gt;next; &#125; return nullptr; &#125; 复杂度","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"Leetcode题目解析（191113）：169&198","slug":"leetcode191113","date":"2019-11-13T02:05:40.000Z","updated":"2019-11-13T02:14:13.599Z","comments":false,"path":"2019/11/13/leetcode191113/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/13/leetcode191113/","excerpt":"","text":"Leetcode 169：求众数题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。 示例示例1：输入: [3,2,3]输出: 3 示例2：输入: [2,2,1,1,1,2,2]输出: 2 解题思路1由于众数是出现次数大于n/2的数字，所以第n/2个数字已经是众数。故可以采用快速排序方法。 代码实现11234567891011121314151617181920212223242526272829303132333435363738int partition(vector&lt;int&gt;&amp; nums, int left, int right)&#123; int start = left, end = right; int povit = nums[start]; while (start &lt; end) &#123; while ((start &lt; end) &amp;&amp; (nums[end] &gt;= povit)) --end; nums[start] = nums[end]; while ((start &lt; end) &amp;&amp; (nums[start] &lt; povit)) ++start; nums[end] = nums[start]; nums[start] = povit; &#125; return start;&#125;int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int nlen = nums.size(); int k = nlen / 2; int start = 0, end = nlen - 1; int target = 0; while (start &lt;= end) &#123; int mid = partition(nums, start, end); if (mid == k ) &#123; target = nums[mid]; break; &#125; else if (mid &gt; k ) end = mid; else start = mid + 1; &#125; return target;&#125; 复杂度1 时间复杂度：O(nlogn)。空间复杂度：O(1)。 解题思路2参见：https://leetcode-cn.com/problems/majority-element/solution/du-le-le-bu-ru-zhong-le-le-ru-he-zhuang-bi-de-qiu-/ 代码实现2123456789101112131415161718int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int can = nums[0], count = 1; for (int i = 1; i &lt; nums.size(); i++) &#123; if (count == 0) &#123; can = nums[i]; count = 1; &#125; else if (nums[i] == can) &#123; ++count; &#125; else &#123; --count; &#125; &#125; return can;&#125; 复杂度2 时间复杂度：O(n)总共只有一个循环，因此时间复杂度为 O(n)。空间复杂度：O(1)只需要常数级别的额外空间，因此空间复杂度为 O(1)。 Leetcode 198：打家劫舍题目描述是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例示例 1:输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2:输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解题思路动态规划，状态转移方程为 1dp[i]=max(dp[i-1],dp[i-2]+nums[i-1]) 代码实现123456789101112int rob(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt;dp(nums.size() + 1, 0); for (int i = 1; i &lt;= nums.size(); i++) &#123; if (i == 1) &#123; dp[i] = nums[i-1]; &#125;else dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1]); &#125; return dp[nums.size()];&#125; 复杂度 时间复杂度：O(n)。其中 n为房子的数量。空间复杂度：O(1)。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"how to use mathjax in hexo","slug":"how-to-use-mathjax-in-hexo","date":"2019-11-12T02:59:34.000Z","updated":"2019-11-12T03:03:44.096Z","comments":false,"path":"2019/11/12/how-to-use-mathjax-in-hexo/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/12/how-to-use-mathjax-in-hexo/","excerpt":"","text":"参考自：https://www.cnblogs.com/wangxin37/p/8185688.html 在主题中手动添加js安装mathjax。类似所有第三方js插件，js加载方式有两种： 第一种，通过连接CDN加载js代码。好处是省了本地配置js代码，并且每次加载都是最新的，缺点是一旦连接的CDN出问题，可能卡住页面的js加载。 第二种，将js代码下载下来，放到主题的js文件夹中，通过本地相对目录加载。优缺点和第一种方法正相反。 在themes/snippet/layout/_partial 目录中新建mathjax.ejs，填入如下js代码：123456789101112131415161718192021222324252627282930313233343536&lt;!-- MathJax配置，可通过单美元符号书写行内公式等 --&gt;&lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config(&#123; \"HTML-CSS\": &#123; preferredFont: \"TeX\", availableFonts: [\"STIX\",\"TeX\"], linebreaks: &#123; automatic:true &#125;, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) &#125;, tex2jax: &#123; inlineMath: [ [\"$\", \"$\"], [\"\\\\(\",\"\\\\)\"] ], processEscapes: true, ignoreClass: \"tex2jax_ignore|dno\", skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] &#125;, TeX: &#123; equationNumbers: &#123; autoNumber: \"AMS\" &#125;, noUndefined: &#123; attributes: &#123; mathcolor: \"red\", mathbackground: \"#FFEEEE\", mathsize: \"90%\" &#125; &#125;, Macros: &#123; href: \"&#123;&#125;\" &#125; &#125;, messageStyle: \"none\" &#125;); &lt;/script&gt;&lt;!-- 给MathJax元素添加has-jax class --&gt;&lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Queue(function() &#123; var all = MathJax.Hub.getAllJax(), i; for(i=0; i &lt; all.length; i += 1) &#123; all[i].SourceElement().parentNode.className += ' has-jax'; &#125; &#125;);&lt;/script&gt;&lt;!-- 通过连接CDN加载MathJax的js代码 --&gt;&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 只在有公式的页面才加载MathJax有公式才加载MathJax，这点比较重要，没有公式仍然加载js渲染公式，会影响页面加载速度。在所有有公式的文章的front-matter中增加一项配置 mathjax: true，位置是scaffolds目录下的三个md文件。例如 1234567891011---title: Leetcode题目解析（191112）：200&amp;206categories: - C/C++tags: - Leetcode - 算法comments: falsemathjax: truedate: 2019-11-12 10:39:05--- 然后在themes/snippet/layout/_partial/footer.ejs 中通过此配置变量决定是否加载mathjax.ejs ： 1234&lt;!-- 根据页面mathjax变量决定是否加载MathJax数学公式js --&gt;&lt;% if (page.mathjax)&#123; %&gt;&lt;%- partial('mathjax') %&gt;&lt;% &#125; %&gt; 解决MarkDown与MathJax渲染冲突Hexo默认的MarkDown渲染引擎hexo-renderer-marked会调用marked模块的marked.js脚本进行最终的解释，这个脚本在Hexo安装后的node_modules\\marked\\lib\\目录中。有两点修改： 针对下划线的问题，取消_作为斜体转义，因为marked.js中也是斜体的意思，所以取消掉_的转义并不影响使用markdown，我平时一般不用斜体，就是用也更习惯用作为斜体标记。针对marked.js与Mathjax对于个别字符二次转义的问题，我们只要不让marked.js去转义\\\\,\\{,\\}在MathJax中有特殊用途的字符就行了。编辑node_modules\\marked\\lib\\marked.js 脚本： 【第一步】将451行的 1escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/, 替换为1escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/, 这一步取消了对\\\\,\\{,\\}的转义(escape) 【第二步】将459行的1em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 替换为1em:/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 这一步取消了对斜体标记_的转义。 这样带来一个问题就是，以后每次更换电脑，在新电脑上安装完Hexo环境后，都要手动修改marked.js文件。 MathJax公式书写MathJax公式书写参考http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference 行内公式含下划线_的公式$x_mu$ 1234希腊字符$\\sigma$```$\\sigma$ 行内公式$\\cos 2\\theta = \\cos^2 \\theta - \\sin^2 \\theta = 2 \\cos^2 \\theta$ 1$\\cos 2\\theta = \\cos^2 \\theta - \\sin^2 \\theta = 2 \\cos^2 \\theta$ MathJax大括号右多行赋值$$ f(n) = \\begin{cases} n/2, &amp; \\text{if $n$ is even} \\ 3n+1, &amp; \\text{if $n$ is odd} \\end{cases} $$ 1$$ f(n) = \\begin&#123;cases&#125; n/2, &amp; \\text&#123;if $n$ is even&#125; \\\\ 3n+1, &amp; \\text&#123;if $n$ is odd&#125; \\end&#123;cases&#125; $$ 双\\\\公式内换行，cases实现大括号右多行赋值，&amp;用来对齐。 MathJax公式自动编号上面mathjax.ejs脚本中已加入公式编号的配置。书写时只要使用begin{equation}环境就会自动编号： 1234$$\\begin&#123;equation&#125;\\end&#123;equation&#125;$$ 注意此时会自动将文档内的所有begin{equation}公式连续编号，例如： 12345678910$$\\begin&#123;equation&#125;\\sum_&#123;i=0&#125;^n F_i \\cdot \\phi (H, p_i) - \\sum_&#123;i=1&#125;^n a_i \\cdot ( \\tilde&#123;x_i&#125;, \\tilde&#123;y_i&#125;) + b_i \\cdot ( \\tilde&#123;x_i&#125;^2 , \\tilde&#123;y_i&#125;^2 )\\end&#123;equation&#125;$$$$\\begin&#123;equation&#125;\\beta^*(D) = \\mathop&#123;argmin&#125; \\limits_&#123;\\beta&#125; \\lambda &#123;||\\beta||&#125;^2 + \\sum_&#123;i=1&#125;^n max(0, 1 - y_i f_&#123;\\beta&#125;(x_i)) \\end&#123;equation&#125;$$ $$\\begin{equation}\\sum_{i=0}^n F_i \\cdot \\phi (H, p_i) - \\sum_{i=1}^n a_i \\cdot ( \\tilde{x_i}, \\tilde{y_i}) + b_i \\cdot ( \\tilde{x_i}^2 , \\tilde{y_i}^2 )\\end{equation}$$$$\\begin{equation}\\beta^*(D) = \\mathop{argmin} \\limits_{\\beta} \\lambda {||\\beta||}^2 + \\sum_{i=1}^n max(0, 1 - y_i f_{\\beta}(x_i))\\end{equation}$$ 禁止自动编号在end{equation}前加\\nonumber可禁止对此公式自动编号，例如： 1234567891011$$\\begin&#123;equation&#125;\\sum_&#123;i=0&#125;^n F_i \\cdot \\phi (H, p_i) - \\sum_&#123;i=1&#125;^n a_i \\cdot ( \\tilde&#123;x_i&#125;, \\tilde&#123;y_i&#125;) + b_i \\cdot ( \\tilde&#123;x_i&#125;^2 , \\tilde&#123;y_i&#125;^2 )\\nonumber\\end&#123;equation&#125;$$$$\\begin&#123;equation&#125;\\beta^*(D) = \\mathop&#123;argmin&#125; \\limits_&#123;\\beta&#125; \\lambda &#123;||\\beta||&#125;^2 + \\sum_&#123;i=1&#125;^n max(0, 1 - y_i f_&#123;\\beta&#125;(x_i)) \\end&#123;equation&#125;$$ MathJax公式手动编号可以在公式书写时使用\\tag{手动编号}添加手动编号，例如： 12345$$\\begin&#123;equation&#125;\\sum_&#123;i=0&#125;^n F_i \\cdot \\phi (H, p_i) - \\sum_&#123;i=1&#125;^n a_i \\cdot ( \\tilde&#123;x_i&#125;, \\tilde&#123;y_i&#125;) + b_i \\cdot ( \\tilde&#123;x_i&#125;^2 , \\tilde&#123;y_i&#125;^2 ) \\tag&#123;1.2.3&#125;\\end&#123;equation&#125;$$ $$\\begin{equation}\\sum_{i=0}^n F_i \\cdot \\phi (H, p_i) - \\sum_{i=1}^n a_i \\cdot ( \\tilde{x_i}, \\tilde{y_i}) + b_i \\cdot ( \\tilde{x_i}^2 , \\tilde{y_i}^2 ) \\tag{1.2.3}\\end{equation}$$ 其它详见参考原文","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://tech.yushuai.xyz/tags/hexo/"},{"name":"mathjax","slug":"mathjax","permalink":"http://tech.yushuai.xyz/tags/mathjax/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"Leetcode题目解析（191112）：200&206","slug":"leetcode191112","date":"2019-11-12T02:39:05.000Z","updated":"2019-11-13T02:07:01.922Z","comments":false,"path":"2019/11/12/leetcode191112/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/12/leetcode191112/","excerpt":"","text":"Leetcode 200：岛屿数量题目描述给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class UnionFind &#123;public: UnionFind(vector &lt; vector&lt;char&gt;&gt; &amp; grid) &#123; count = 0; int m = grid.size(); int n = grid[0].size(); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == '1') &#123; parent.push_back(i * n + j); ++count; &#125; else &#123; parent.push_back(-1); &#125; rank.push_back(0); &#125; &#125; &#125; int find(int i) &#123; if (parent[i] != i) parent[i] = find(parent[i]); return parent[i]; &#125; void Union(int x, int y) &#123; int rootx = find(x); int rooty = find(y); if (rootx != rooty) &#123; if (rank[rootx] &gt; rank[rooty]) parent[rooty] = rootx; else if (rank[rootx] &lt; rank[rooty]) parent[rootx] = rooty; else &#123; parent[rooty] = rootx; rank[rootx] += 1; &#125; --count; &#125; &#125; int getCount() const &#123; return count; &#125;private: vector&lt;int&gt; parent; vector&lt;int&gt; rank; int count;&#125;;class Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int nr = grid.size(); if (!nr) return 0; int nc = grid[0].size(); UnionFind uf(grid); int num_islands = 0; for (int r = 0; r &lt; nr; ++r) &#123; for (int c = 0; c &lt; nc; ++c) &#123; if (grid[r][c] == '1') &#123; grid[r][c] = '0'; if (r - 1 &gt;= 0 &amp;&amp; grid[r - 1][c] == '1') uf.Union(r * nc + c, (r - 1) * nc + c); if (r + 1 &lt; nr &amp;&amp; grid[r + 1][c] == '1') uf.Union(r * nc + c, (r + 1) * nc + c); if (c - 1 &gt;= 0 &amp;&amp; grid[r][c - 1] == '1') uf.Union(r * nc + c, r * nc + c - 1); if (c + 1 &lt; nc &amp;&amp; grid[r][c + 1] == '1') uf.Union(r * nc + c, r * nc + c + 1); &#125; &#125; &#125; return uf.getCount(); &#125;&#125;; Leetcode 206：反转链表题目描述反转一个单链表。 示例输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解题思路首先我们应该考虑两个问题（鲁棒性）： 链表为空呢？返回空。 链表就只有一个结点呢？返回这个结点。 其它一般情况就是多个结点了。为了正确翻转一个链表，需要调整链表中指针的方向。我们假设有下面三个结点：a-&gt;b-&gt;c，假设我们要翻转b的next指向a，那么指向a之后，b和c之间的联系就断了，因此我们需要把结点c的地址保存下来。也就是说，我们在调整结点b的next指针的时候，除了需要知道结点b本身，还需要知道结点b的前一个结点a，因为我们要把结点b的next指针指向a。同时，我们还需要实现保存b的一个结点c，以防止链表断开。 我们新建一个next指针，让它来保存b指针的next所指向的地址，然后把a的next指向NULL，然后令node=a，然后把lnode=b；这个时候，进入下一个循环，next指向了c，然后把b的next指向了a，然后令node=b，然后将lnode往下指向c；下一个循环，next=空了，然后把c的next指向了b，然后node=c，然后lnode=空。这个时候判断了lnode为空，结束循环，形成了a&lt;-b&lt;-c。 代码实现12345678910111213 ListNode* reverseList(ListNode* head) &#123; ListNode* node = head; ListNode* pre = nullptr; while (node != nullptr) &#123; ListNode* temp = node-&gt;next; node-&gt;next = pre; pre = node; node = temp; &#125; return pre;&#125; 复杂度分析时间复杂度：O(n)，空间复杂度：O(1)","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"论文阅读整理（基于声源信息提取的说话人定位）","slug":"speaker-localization-using-excitation-sourc-information","date":"2019-11-11T09:06:25.000Z","updated":"2019-11-11T09:15:57.653Z","comments":false,"path":"2019/11/11/speaker-localization-using-excitation-sourc-information/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/11/speaker-localization-using-excitation-sourc-information/","excerpt":"","text":"阅读论文题目：Speaker Localization using Excitation Source Information in Speech PREPRINT 算法基本内容 常用的时延估计方法就是广义互相关函数（GCC）方法，其使用的权重主要有两种：相位变换（PHAT）和最大似然（ML）法。前者只适用于噪声较低的情况，它通过展平幅度谱，GCC函数中最高峰的位置对应于延迟，因为它对低信噪比和高信噪比施加同样的权重，所以才只适用于总体信噪比较低的情况。后者在存在多径传播效应或混响较强的情况下性能急剧下降。这主要是因为上面的方法都是用的频谱特征，在传输过程中，由于介质、噪声、混响等原因，这些特征都会被破坏。 但是对应于激发源的特征在面对这些破坏的时候还是有鲁棒性的。所以提出了下面的方法。所提出的方法不使用有声语音的周期性，而是利用含音段的激励特性，尤其是声门闭合瞬间周围的特性。 声道系统的常见激励方式是声带振动，称之为声门振动，它可以被看做是一系列脉冲组成。动态声道系统的特征由短时频谱特征表示。由于在麦克风处接收的信号受噪声和房间响应的影响，因此接收到的信号包含有关声道系统的信息，该声道系统因在不同麦克风处的不同程度的劣化而受到损失。然而有意思的是，在语音产生过程中的显著激励的瞬间(epochs or instants of significant excitation)的相对位置并不受麦克风劣化的影响。在含音段（含有语音的部分）的时刻对应于声门闭合的时刻，并且它们相对于时间轴的位置不随着声学环境的脉冲响应的变化而变化。当然在非声段也可能由于突发的强烈激励出现epochs，即使它们可能不像含音段那样以周期性间隔出现，但是它们的相对位置依旧不受劣化的影响。以上的这种excitation被称为excitation source（激励源）。激励源的信息可以通过语音信号使用线性预测分析来提取到。 线性预测编码通过估计共振峰（共振峰信息包含在语音频谱包络中，共振峰参数提取的关键是估计语音的频谱包络，一般认为谱包络中的最大值就是共振峰）、剔除它们在语音信号中的作用、估计保留的蜂鸣音强度与频率来分析语音信号（保留下来的就是含有源激励的信号）。剔除共振峰的过程称为逆滤波，经过这个过程剩余的信号称为残余（残差）信号。 这个方法使用了线性预测（LP, Linear Prediction）分析。在这里面，每一个样点都被定义为由前p个样点加权组合而成，p就是预测阶数。如果语音信号在第n个瞬间的采样为s(n)，则 其中ak就是线性预测系数。真实值与预测值之间的误差可以表示为 线性预测系数（LPC）的最佳值可以通过在大约10-30 ms的分析帧上最小化平方误差来获得。 我们把误差e(n)称为LP残差（LP residual）。给定语音信号，LP残差可以通过将该信号通过一个逆滤波器来提取得到 关于激励源的最重要的信号就是含音段的时刻的序列。 我们知道由于噪声或者混响的影响，直接计算语音信号的互相关函数，相关峰可能就会不太明显。由上面我们可以想到，我们可以对LP残差做互相关函数来求相关峰的位置。当然这样做，因为逆滤波器的缘故，LP残差的频谱的高频部分的噪声会被增强，这会导致两个麦克风之间的噪声相关性变弱，从而在求峰位置的时候一点点影响，不过这点影响很小（little effect）。 在每个音调周期中，主要激励发生在对应于声门关闭瞬间的时期。 在每个时期周围，预测将很差，因此残差中的误差很大。但是，每个epoch周围的残留信号的幅度取决于信号的相位，这会引起幅度的随机波动，因此如果我们直接使用LP残差，则可能会导致较差的相关峰值。所以实际中通常不会直接使用LP参数，而是使用LP残差的希尔伯特包络，它被定义为 其中，eh(n)是e(n)的希尔伯特变换（Hilbert Transform），希尔伯特变换是通过交换离散傅立叶变换（DFT）的实部和虚部获得的，然后进行逆变换。 它是将e(n)通过一个相应为以下的滤波器得到的 论文中是用Peak-to-Sidelobe Ratio（PSR，峰旁瓣比）来比较不同的方法，PSR是指峰值除以峰周围40个样本的标准偏差（除去峰两侧的各5个样点）。PSR测量值给出了主峰相对于峰周围值的强度。选择40个样本是非常随机的。 结果分析 下面两张图是一段音频的互相关峰值情况。 图1 来自mic-1和mic-2的50毫秒语音段在不同情况下的互相关函数：（a）语音信号，（b）GCC-PHAT，（c）十阶LP残差，以及（d）LP残差的希尔伯特包络。 PSR是针对每个互相关函数中的最大峰计算的。 图2 来自mic-1和mic-2的50 ms非语音段在不同情况下的互相关函数：（a）语音信号，（b）GCC-PHAT，（c）十阶LP残差，以及（d）Hilbert包络LP残差 由图1(b)我们可以看出，GCC-PHAT的PSR要远远好于纯语音的GCC的PSR，但是PHAT权重的缺点在于它对噪声样点加权，所以它只在低信噪比的时候有较好效果；由图1(c)可以看出10阶LP残差的互相关函数PSR好于纯语音的，但是与GCC-PHAT方法接近；由图1(d)可以看出，带有希尔伯特变换的LP残差的PSR有明显的提高。这主要因为，在LP残差的希尔伯特包络中，高信噪比的部分对应于声道系统的主要激励epoch。epochs中的高振幅值部分主导了互相关函数的计算。注意时延估计仅仅使用互相关函数的主峰来估计。在图1(d)中其它的大峰值是因为基音周期造成的。由于从LP残差的希尔伯特包络计算出来的PSR值相对于给定的有声段而言较高，故我们使用每帧的PSR来导出归一化权重函数，以便比较每种方法偏差、方差和均方根误差（RMSE, Root Mean Square Error）。 图2展示了50ms非语音段的互相关函数情况。即使对于非语音段来说，LP残差的希尔伯特包络的PSR依旧很高。但是PSR值取决于非语音段中突发脉冲的强度。注意，突发脉冲不需要是周期性的。因此，对于非语音段，希尔伯特包络也可以用于获得比其它方法PSR值高的峰值。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"Leetcode题目解析（191111）：207&208","slug":"leetcode191111","date":"2019-11-11T07:13:55.000Z","updated":"2019-11-11T07:29:35.148Z","comments":false,"path":"2019/11/11/leetcode191111/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/11/leetcode191111/","excerpt":"","text":"Leetcode 207：课程表题目描述现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 解题思路这个题目是一个图的问题，所给的示例是用边缘列表来表示的图。也即假如边缘列表表示如下 序号 节点1 节点2 1 0 1 2 1 2 3 2 0 所表示的图为 可以发现上图就是一个无法实现课程的图，这类的特点是它是一个有向有环图。 所以这个问题可以转换为另一个问题：如何判断一个图是有向无环图？ 使用拓扑排序如下： 首先新建一个入度表indegrees，用于记录每个节点的入度。 新建一个队列que，用于存储入度为0的节点。 当queue非空，一次将首节点出队，在图中删除此节点pre，并将--numCourses。当然，我们不是真正从邻接表中删除pre，而是将indegrees[cur]-=1；当入度-1邻接节点cur的入度为0的时候，说明cur所有前驱结点已经删除，可以入队。 若是有向无环图，则所有节点一定入队并且出队过，即若存在环的话，一定有节点入度始终不为0，即numCourses大于0。所以判断numCourses==0即可判断出是否是有向无环图。 代码实现12345678910111213141516171819202122232425262728293031323334bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; if(prerequisites.empty()) return true; vector&lt;int&gt; indegrees(numCourses, 0);//新建入度表 for (int i = 0; i &lt; prerequisites.size();i++) &#123; ++indegrees[prerequisites[i][0]]; &#125;//统计每一个节点入度 queue&lt;int&gt; que;//新建一个队列，用于存储入度为0的节点 for (int i = 0; i &lt; numCourses; i++) &#123; if (indegrees[i] == 0) que.push(i); &#125;//借助一个队列，将入度为0的节点入队 while (!que.empty()) &#123; int pre = que.front(); que.pop(); --numCourses;//在每次pre出队的时候，执行--numCourses //当queue非空，一次将首节点出队，在图中删除此节点pre for (auto req : prerequisites) &#123; if (req[1] != pre) continue; if (--indegrees[req[0]] == 0) que.push(req[0]); &#125; //并不是真正从邻接表中删除pre，而是将indegrees[cur]-=1 //当入度-1邻接节点cur的入度为0的时候，说明cur所有前驱结点已经删除，可以入队。 &#125; //若是有向无环图，则所有节点一定入队并且出队过，即若存在环的话，一定有节点入度始终不为0，即numCourses大于0 //所以判断numCourses==0即可 return numCourses == 0;&#125; 复杂度复杂度挺高的 Leetcode 208：实现Trie（前缀树）题目描述实现一个 Trie (前缀树)，包含insert, search, 和 startsWith 这三个操作。 示例12345678Trie trie = new Trie();trie.insert(\"apple\");trie.search(\"apple\"); // 返回 truetrie.search(\"app\"); // 返回 falsetrie.startsWith(\"app\"); // 返回 truetrie.insert(\"app\"); trie.search(\"app\"); // 返回 true 解题思路Trie树的结点结构Trie树是一个有根的树，其结点具有以下字段：。 最多 R个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。本文中假定 R为26，小写拉丁字母的数量。布尔字段，以指定节点是对应键的结尾还是只是键前缀。 向Trial插入字符串我们通过搜索 Trie 树来插入一个键。我们从根开始搜索它对应于第一个键字符的链接。有两种情况： 如果链接已经存在。那么沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。 如果链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配。 重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。 时间复杂度：O(m)，其中m为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 m次操作。 空间复杂度：O(m)。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 m 个结点，使用 O(m)空间。 查找Trial中的字符串这个思路很简单。每个键在Trie树种都表示从根到内部结点或者叶的路径。我们用第一个键字符开始，检查当前结点与建字符对应的链接，其有两种情况： 存在链接。继续往下一个结点走，如此循环。 没有链接。再看isStr是否是True，是则返回true，否则就返回false。 时间复杂度：O(m)，空间复杂度O(1)。 查找Trie中的键前缀类似于前面的方法，但是到达键前缀的末尾时，总是返回true。理由也很简单，我们只是为了寻找与键前缀相匹配的字符串而已，并不是完全相等的字符串。 时间复杂度：O(m)，空间复杂度O(1)。 参考：https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/ 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int MAXN = 26;class Trie &#123;public: bool isStr;//当前结点是否为一个完整的字符串 Trie* next[MAXN]; /** Initialize your data structure here. */ Trie() &#123; isStr = NULL; memset(next, 0, sizeof(next)); &#125; /** Inserts a word into the trie. */ void insert(string word) &#123; Trie* cur = this;//cur初始化为根节点指针 for (char w : word) &#123;//遍历word中每一个字符 if (cur-&gt;next[w - 'a'] == NULL)//下一个结点不存在，新增一个结点 &#123; Trie* nnode = new Trie(); cur-&gt;next[w - 'a'] = nnode; &#125; cur = cur-&gt;next[w - 'a']; &#125; cur-&gt;isStr = true;//当前结点已经是一个完整的字符串 &#125; /** Returns if the word is in the trie. */ bool search(string word) &#123; Trie* cur = this; for (char w : word) &#123; if (cur != NULL) cur = cur-&gt;next[w - 'a'];//更新cr指针的指向，指向下一个结点 &#125; return (cur != NULL &amp;&amp; cur-&gt;isStr); &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) &#123; Trie* cur = this; for (char w : prefix) &#123; if (cur != NULL) cur = cur-&gt;next[w - 'a'];//同上 &#125; return (cur != NULL); &#125;&#125;; 复杂度分析","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"Leetcode题目解析（191108）：215及221","slug":"leetcode191108","date":"2019-11-08T03:24:20.000Z","updated":"2019-11-08T03:28:06.814Z","comments":false,"path":"2019/11/08/leetcode191108/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/08/leetcode191108/","excerpt":"","text":"Leetcode 215：数组中的第K个最大元素题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例示例 1:输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2：输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 解题思路偷了个懒，就是利用求第k个小的数字改的。因为求第k个大的数字和求第m个小的数字有以下关系（假设数组长度为len）：m=len-k+1，所以直接进行转换即可。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243int partition(vector&lt;int&gt;&amp; nums, int left, int right)&#123; int start = left; int end = right; int poivt = nums[start]; while (start &lt; end) &#123; while (start &lt; end &amp;&amp; nums[end] &gt;= poivt) --end; nums[start] = nums[end]; while (start &lt; end &amp;&amp; nums[start] &lt; poivt) ++start; nums[end] = nums[start]; nums[start] = poivt; &#125; return start;&#125;int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int nlen = nums.size(); int m = nlen-k+1; if (nlen &lt; 1 || nlen &lt; m) &#123; return -1; &#125; int start = 0; int end = nlen - 1; int target = 0; while (start &lt;= end) &#123; int mid = partition(nums, start, end); if (mid == m - 1) &#123; target = nums[mid]; break; &#125; else if (mid &gt; m - 1) end = mid; else start = mid + 1; &#125; return target;&#125; 复杂度分析时间复杂度：O(nlogn) Leetcode 221：最大正方形题目描述在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例输入:1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 解题思路参考官方题解，步骤如下： 我们用 0 初始化另一个矩阵 dp，维数和原始矩阵维数相同；dp(i,j) 表示的是由 1 组成的最大正方形的边长。 从 (0,0)(0,0) 开始，对原始矩阵中的每一个 1，我们将当前元素的值更新为 dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1 我们用一个变量记录当前出现的最大边长，这样遍历一次就可以找到正方形的最大边长maxr，返回的结果就是maxr*maxr。 由于动态规划可以分解为若干个独立的子问题，由于一个格子的值受其左侧、左上角和上侧三个点来决定，所以我们以四个格子举例来解释这个式子，如下图所示。我们假设左下角的格子为最小值，那么有三种情况： 该值为0。则和前面组不成正方形，dp[i]=0+1=1。 该值为1。则其它值只能大于等于1，若都是等于1，说明周围三个小正方形没办法和其它正方形组成更大的正方形，所以只能它们4个组成。 该值为大于1的数，假设为2。则代表该蓝色格子与其左侧、左上侧、上侧组成了一个边长为2的正方形，由于黑色和绿色都大于2，所以黑色格子的左上角和上侧、绿色格子的上侧都不是0，于是就可以组成一个3*3的正方形，也即边长=2+1=3。其它大小以此类推。 上面的时间复杂度为O(mn)，空间复杂度为O(mn)。接下来，我们可以对其进行优化。在上面的方法中，计算第i行的dp只用到了上一个元素和第i-1行，因此我们可以使用一维dp来满足要求。在扫描一行原始矩阵元素的时候，根据公式dp[j]=min(dp[j−1],dp[j],prev)来更新dp，其中prev是dp[j-1]。对于每一行，我们执行一遍过程，最后输出最大值即可。新的方法时间复杂度为O(mn)，空间复杂度为O(n)。 代码实现12345678910111213141516171819202122232425262728293031int min3(int a, int b, int c)&#123; return (a &lt; b ? (a &lt; c ? a : c) : (b &lt; c ? b : c));&#125;int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return 0; int rows = matrix.size(); int cols = matrix[0].size(); vector&lt;int&gt; dp(cols + 1, 0); int maxr = 0, prev = 0; for (int i = 1; i &lt;= rows; i++) &#123; for (int j = 1; j &lt;= cols; j++) &#123; int temp = dp[j]; if (matrix[i - 1][j - 1] == '1') &#123; dp[j] = min3(dp[j - 1], prev, dp[j]) + 1; maxr = max(maxr, dp[j]); &#125; else &#123; dp[j] = 0; &#125; prev = temp; &#125; &#125; return maxr * maxr;&#125; 复杂度分析时间复杂度为O(mn)，空间复杂度为O(n)。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191107）","slug":"leetcode191107","date":"2019-11-07T03:19:47.000Z","updated":"2019-11-07T03:23:49.729Z","comments":false,"path":"2019/11/07/leetcode191107/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/07/leetcode191107/","excerpt":"","text":"Leetcode 234：回文链表题目描述请判断一个链表是否为回文链表。 示例示例 1:输入: 1-&gt;2输出: false 示例 2:输入: 1-&gt;2-&gt;2-&gt;1输出: true 解题思路我的解题思路很简单：第一步：寻找到中间结点；第二步，其中一侧进行反转然后进行比较是否相等。 所以代码其实分块很明显。第一部分就是寻找中间结点，同时将前半部分进行链表翻转，这一部分是用快慢指针和翻转链表方法完成，无需解释。然后，对于奇数个结点的链表来说，在完成第一步的时候fast不为空，所以这个时候slow往后走一步，否则不需要走。然后开始比较即可。 具体如图所示，图中的各种状态对应着代码里面状态1/2/3。 代码实现123456789101112131415161718192021222324252627282930bool isPalindrome(ListNode* head) &#123; if (!head || !(head-&gt;next)) return true; ListNode* slow = head; ListNode* fast = head; ListNode* lnode = head; ListNode* node = nullptr; //完成上述操作为状态1 //找到中间节点的同时翻转前半部分 while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; lnode = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; lnode-&gt;next = node; node = lnode; &#125; //完成上述操作为状态2 if (fast != nullptr)//奇数个节点的情况 slow = slow-&gt;next; //完成上述操作为状态3 while (lnode != nullptr &amp;&amp; slow != nullptr) &#123; if (lnode-&gt;val != slow-&gt;val) return false; lnode = lnode-&gt;next; slow = slow-&gt;next; &#125; return true;&#125; 执行用时和内存消耗 Leetcode226：翻转二叉树题目描述翻转一棵二叉树 示例 解题思路代码实现123456789void invertTree(TreeNode* root) &#123; if (!root) return ; TreeNode* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; invertTree(root-&gt;left); invertTree(root-&gt;right);&#125; 123456789TreeNode* invertTree(TreeNode* root) &#123; if (!root) return nullptr; TreeNode *right = invertTree(root-&gt;right); TreeNode *left = invertTree(root-&gt;left); root-&gt;left = right; root-&gt;right = left; return root;&#125; 复杂度","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191106）","slug":"leetcode191106","date":"2019-11-06T12:21:35.000Z","updated":"2019-11-06T12:25:09.412Z","comments":false,"path":"2019/11/06/leetcode191106/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/06/leetcode191106/","excerpt":"","text":"Leetcode 236：二叉树的最近公共祖先题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 示例示例 1:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 解题思路参考：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-jian-j/ 两个节点p,q分为两种情况： p和q在相同子树中 p和q在不同子树中 从根节点遍历，递归向左右子树查询节点信息递归终止条件：如果当前节点为空或等于p或q，则返回当前节点 递归遍历左右子树，如果左右子树查到节点都不为空，则表明p和q分别在左右子树中，因此，当前节点即为最近公共祖先；如果左右子树其中一个不为空，则返回非空节点。 代码实现1234567891011 TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == nullptr || root == p || root == q) &#123; return root; &#125; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if (left &amp;&amp; right) &#123; return root; &#125; return left ? left : right;&#125; 算法性能 Leetcode 238：除自身以外数组的乘积题目描述给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i]之外其余各元素的乘积。 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 示例输入: [1,2,3,4]；输出: [24,12,8,6] 解题思路1这个题不需要想太多，可以这样想，每一个输出结果的第i个值等于输入数组的0~i-1乘积和i+1~m（m为输入数组长度），然后进行相乘。具体看代码。 代码实现11234567891011121314151617181920212223vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; //先左再右 vector&lt;int&gt;resleft(nums.size(), 1); for (int i = 1; i &lt; nums.size(); i++) &#123; resleft[i] = resleft[i - 1] * nums[i - 1]; //cout &lt;&lt; resleft[i] &lt;&lt; \" \"; &#125; //cout &lt;&lt; endl; vector&lt;int&gt;resright(nums.size(), 1); for (int i = nums.size() - 2; i &gt;= 0; i--) &#123; resright[i] = resright[i + 1] * nums[i + 1]; //cout &lt;&lt; resright[i] &lt;&lt; \" \"; &#125; //cout &lt;&lt; endl; vector&lt;int&gt;result(nums.size(), 1); for (int i = 0; i &lt; nums.size(); i++) &#123; result[i] = resleft[i] * resright[i]; &#125; return result;&#125; 复杂度1空间复杂度：O(n)，时间复杂度O(n) leetcode238resultzjz.jpg 解题思路2用一个常数k代替resleft数组。 代码实现212345678910111213141516vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; //先左再右 vector&lt;int&gt;result(nums.size(), 1); int k = 1; for (int i = 0; i &lt; result.size(); i++) &#123; result[i] = k; k *= nums[i]; &#125; k = 1; for (int i = result.size() - 1; i &gt;= 0; i--) &#123; result[i] *= k; k *= nums[i]; &#125; return result;&#125; 复杂度2空间复杂度：O(1)，时间复杂度O(n)","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191105）","slug":"leetcode191105","date":"2019-11-05T03:07:13.000Z","updated":"2019-11-05T03:18:15.775Z","comments":false,"path":"2019/11/05/leetcode191105/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/05/leetcode191105/","excerpt":"","text":"Leetcode 239：滑动窗口最大值题目描述给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。 示例输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7]解释: 滑动窗口的位置 最大值 [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 解题思路在剑指offer题目解析（2）中也曾经有这个题，我当时使用的是模拟建立一个滑动窗口，因为该方法使用了两个for循环，所以复杂度为O(n2)，这个版本在leetcode中是无法通过的。但是现在有一种新的方法可以保证算法整体时间复杂度为O(n)。 借鉴这里，实际我们并不需要每次都提取3个元素进行比较，因为实际每一次比较的3个元素，都有两个元素与前面的两个元素是重叠的（即是前一组元素减掉最前面的值），这个时候我们可以考虑采用类似于队列的方法。即需要写： 123void push(int n);//在队尾插入一个元素void pop(int n);//队头元素如果是n删除它int max();//返回当前队列中的最大值 根据这个思想，写出主体框架来： 12345678910111213141516171819vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; result; if (nums.empty()) return result; Solution win; for (int i = 0; i &lt; nums.size(); i++) &#123; if (i &lt; k - 1) win.push(nums[i]);//先填满窗口前k-1个元素 else &#123; //插入队尾元素，else后面这三句话相当于窗口滑动且找到最大值push给result win.push(nums[i]); result.push_back(win.max()); win.pop(nums[i - k + 1]); &#125; &#125; return result;&#125; 接下来我们要实现各个函数的功能。 对于push来说，我们依然要在队尾添加元素，但是要把前面比新元素小的元素都删除掉。这样的话，最终单调队列中的元素就会保持一个单调递减的顺序。所以push和max都可以直接这样写：123456789void push(int n) &#123; while (!data.empty() &amp;&amp; data.back() &lt; n) data.pop_back(); data.push_back(n); &#125;int max() &#123; return data.front();&#125; 代码实现1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: private: deque&lt;int&gt; deq;public: void push(int k) &#123; while (!deq.empty() &amp;&amp; deq.back() &lt; k) deq.pop_back(); deq.push_back(k); &#125; int max() &#123; return deq.front(); &#125; void pop(int k) &#123; if (!deq.empty() &amp;&amp; deq.front() == k) deq.pop_front(); &#125; vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; result; if (nums.empty()) return result; Solution win; for (int i = 0; i &lt; nums.size(); i++) &#123; if (i &lt; k - 1) win.push(nums[i]);//先填满窗口前k-1个元素 else &#123; win.push(nums[i]); result.push_back(win.max()); win.pop(nums[i - k + 1]); &#125; &#125; return result; &#125;&#125;; 复杂度","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191104）","slug":"leetcode191104","date":"2019-11-04T03:22:31.000Z","updated":"2019-11-04T03:29:49.241Z","comments":false,"path":"2019/11/04/leetcode191104/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/04/leetcode191104/","excerpt":"","text":"Leetcode 279：完全平方数题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例示例1： 输入: n = 12，输出: 3解释: 12 = 4 + 4 + 4. 示例2： 输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路这个题很容易想到用动态规划做，为什么呢？因为我们输入一个元素，可以把它分割为多个子问题（例如13=4+9,4有多少种方法、9有多少种方法，就是子问题），而且它们相互独立，符合动态规划的要求。 所以这个dp数组我们习惯上设计为(n+1)*1维，并且初始化第i个元素为i，这是为什么呢？因为第i个元素最少有i个方法组成，就是i个1。 接下来我们写出状态转移方程，这个方程非常好写： dp[i]=min(dp[i],dp[i-j*j]+1); 意义很明显，在此不再重复。 代码实现1234567891011121314int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1, 0); for (int i = 1; i &lt; n+1;i++) &#123; dp[i] = i;//最少有i中方法（1+1+1+...+1） for (int j = 1; i - j * j &gt;= 0; j++) &#123; dp[i] = min(dp[i], dp[i - j * j] + 1); &#125; &#125; return dp[n];&#125; 复杂度时间复杂度为O(n2) Leetcode 283：移动零题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例输入: [0,1,0,3,12]；输出: [1,3,12,0,0] 解题思路其实看到这个题我就想到了能不能使用两个指针，一个快指针一个慢指针呢？答案是可以的，思路就是只要fast所代表的元素不为0，就直接交换fast和slow的元素，这样的话，就是保证slow之前的元素全部为非零元素，所有的零元素在slow或slow后面。 代码实现12345678910void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return; for (int slow = 0, fast = 0; fast &lt; nums.size(); ++fast) &#123; if (nums[fast] != 0) swap(nums[slow++], nums[fast]); &#125;&#125; 复杂度分析时间复杂度为O(n)，空间复杂度为O(1)","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191101）","slug":"leetcode191101","date":"2019-10-31T21:58:22.000Z","updated":"2019-11-01T07:38:12.545Z","comments":false,"path":"2019/11/01/leetcode191101/","link":"","permalink":"http://tech.yushuai.xyz/2019/11/01/leetcode191101/","excerpt":"","text":"Leetcode 287：寻找重复数题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例输入: [1,3,4,2,2]，输出: 2 输入: [3,1,3,4,2]，输出: 3 解题思路代码实现12345678910111213141516171819int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len &lt; 1) return -1; int slow = nums[0]; int fast = nums[nums[0]]; while (slow != fast) &#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125; int res = 0;//从开头开始，与慢指针相遇 while (res != slow) &#123; slow = nums[slow]; res = nums[res]; &#125; return res;&#125; 代码性能Leetcode 287：寻找重复数题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例输入: [1,3,4,2,2]，输出: 2 输入: [3,1,3,4,2]，输出: 3 解题思路代码实现12345678910111213141516171819int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len &lt; 1) return -1; int slow = nums[0]; int fast = nums[nums[0]]; while (slow != fast) &#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125; int res = 0;//从开头开始，与慢指针相遇 while (res != slow) &#123; slow = nums[slow]; res = nums[res]; &#125; return res;&#125; 代码性能 Leetcode 300：最长上升序列题目描述给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例输入: [10,9,2,5,3,7,101,18]输出: 4解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 代码实现123456789101112int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; inseq;; for(int i = 0;i &lt; nums.size();i++)&#123; auto it = std::lower_bound(inseq.begin(),inseq.end(),nums[i]); if(it == inseq.end())&#123; inseq.push_back(nums[i]); &#125; else *it = nums[i]; &#125; return inseq.size(); &#125; 代码性能","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191031）","slug":"leetcode191031","date":"2019-10-30T22:37:12.000Z","updated":"2019-11-01T07:38:58.854Z","comments":false,"path":"2019/10/31/leetcode191031/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/31/leetcode191031/","excerpt":"","text":"Leetcode 301：删除无效的括号题目描述删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。说明: 输入可能包含了除 ( 和 ) 以外的字符。 示例示例1：输入: “()())()”输出: [“()()()”, “(())()”] 示例2：输入: “(a)())()”输出: [“(a)()()”, “(a())()”] 示例3： 输入: “)(“输出: [“”] 代码实现123456789101112131415161718192021222324252627282930class Solution &#123;public:void DFS(string s, char ch, int last) &#123; for (int i = 0,cnt = 0; i &lt; s.size();i++) &#123; if (s[i] == '(' || s[i] == ')') s[i] == ch ? cnt++ : cnt--; if (cnt &lt;= 0) continue; for (int j = last; j &lt;= i; j++) &#123; if (s[j] == ch &amp;&amp; (j == last || s[j - 1] != ch)) DFS(s.substr(0, j) + s.substr(j + 1), ch, j); &#125; return; &#125; reverse(s.begin(), s.end()); if (ch == ')') return DFS(s, '(', 0); ans.push_back(s); &#125; vector&lt;string&gt; removeInvalidParentheses(string s) &#123; DFS(s, ')', 0); return ans; &#125;private: vector&lt;string&gt; ans;&#125;; 代码参考自：https://blog.csdn.net/qq508618087/article/details/50408894 代码性能 Leetcode 297：二叉树的序列化与反序列化题目描述序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例你可以将以下二叉树： 1 / \\ 2 3 / \\ 4 5 序列化为 “[1,2,3,null,null,4,5]” 解题思路代码实现123456789101112131415161718192021222324252627282930313233343536373839404142class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; ostringstream result; serialized(root, result); return result.str(); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; istringstream ideserialized(data); return deserialized(ideserialized); &#125;private: void serialized(TreeNode* root, ostringstream&amp; out) &#123; if (root) &#123; out &lt;&lt; root-&gt;val &lt;&lt; ' '; serialized(root-&gt;left, out); serialized(root-&gt;right, out); &#125; else &#123; out &lt;&lt; \"# \"; &#125; &#125; TreeNode* deserialized(istringstream&amp; in) &#123; string val; in &gt;&gt; val; if (val == \"#\") return nullptr; TreeNode* root = new TreeNode(stoi(val)); root-&gt;left = deserialized(in); root-&gt;right = deserialized(in); return root; &#125;&#125;; 代码性能","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"Leetcode：股票系列题","slug":"leetcode-buy-and-sell-stock","date":"2019-10-30T02:25:10.000Z","updated":"2019-10-30T02:32:22.092Z","comments":false,"path":"2019/10/30/leetcode-buy-and-sell-stock/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/30/leetcode-buy-and-sell-stock/","excerpt":"","text":"题目描述题目1： 买卖股票的最佳时机 I。给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。 题目2： 买卖股票的最佳时机 II。给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 题目3： 买卖股票的最佳时机 III。给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成两笔交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 题目4： 买卖股票的最佳时机 IV。给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成k笔交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 题目5： 买卖股票的最佳时机含手续费。给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。 基础解析通过对 https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-w-5/的阅读，自己理解了，写下自己的理解。 其实这6道题（因为含有冷冻期的那道题昨天已经整理了，故今天没有整理，所以本文中只有5个题）看似不同，但其实都是反映了同一种思路。以第四题为基本，因为第四题其实是一种泛化形式的题目。 第一题只是第四题中当k=1的特例；第二题实际相当于当k=infinity时候的特例；第三题相当于当k=2的时候的特例；第五题和第六题相当于第二题的特例。 我们发现在这个题里面存在三个主动变量（也就是原解析中提到的状态一词），即：第i天价格、第k次交易、持有或卖出（1或0），所以实际上这个dp数组可以写为dp[i][k][0]或dp[i][k][1]。我们想要的答案肯定是dp[i][k][0]，因为当第三个状态为1的时候，说明我们还有股票，只有卖出才能有收益。 下面画出状态转移图 通过这个图，我们可以很容易的写出状态转移方程的形式： dp[i][k][0]=max(dp[i-1][k][0],dp[i-1][k][1]+prices[i]) 这个式子的含义是，如果今天我没有持有股票，那么只有两种可能： 昨天的时候我就没有股票，那么铁定至迟在昨天的时候就已经完成了k次交易，所以是dp[i-1][k][0]。 昨天我持有股票，今天我把它卖了，由于买一次和卖一次算一次交易，所以昨天也是第k次交易，所以是dp[i-1][k][1]+prices[i]。 dp[i][k][1]=max(dp[i-1][k][1]mdp[i-1][k-1][0]-prices[i]) 这个式子的含义是，今天我持有股票，那么又是有两种可能： 昨天我持有股票，今天我不卖； 昨天我没有持有，今天我买了，所以今天我进行了第k次交易，故昨天是第k-1的状态。 至此，解决这6个问题的核心已经解决了。接下来就是一些边界问题。 dp[-1][k][0] = 0解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。 dp[-1][k][1] = -infinity解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。 dp[i][0][0] = 0解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。 dp[i][0][1] = -infinity解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。 第一题解析及代码实现对于第一题来说，实际上就是k=1的情况，那我们可以将dp数组简化为二维数组，即省略k这一项。写为12dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], -prices[i]) 为什么第二个式子max的第二项是-prices[i]呢，因为：dp[i][1]=max(dp[-1][1],dp[-1][0]-prices[i])=max(-infinity, 0-prices[i])=-prices[i]。 考虑到一个新的状态只与相邻一个状态有关系，我们可以继续节省空间复杂度，将数组用变量来表示，即dp_i_0相当于原来的dp[i][0],dp_i_1相当于原来的dp[i][1]。 代码实现如下： 1234567891011121314 int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if (len &lt;= 1) return 0; int dp_i_0 = 0, dp_i_1 = INT_MIN; for (int i = 0; i &lt; len; i++) &#123; dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = max(dp_i_1, -prices[i]); &#125; return dp_i_0;&#125; 第二题解析及代码实现当k为无穷的时候，实际上k和k-1已经可以看做是一样的，然后继续省略k这一项。这个时候写出来的状态转移方程是 dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) 与第一题同理，修改为变量进行更新。但是注意，由于此时k并不是1了，而是可以任意数字了，所以dp[i-1][k-1][0]还是要专门写出来，由于在第一个式子中dp_i_0已经更新为当前这一步的结果，所以在dp_i_0更新之前需要将它的值缓存在t中以便dp_i_1更新时使用。 12345678910111213int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if (len &lt;= 1) return 0; int dp_i_0 = 0, dp_i_1 = INT_MIN; for (int i = 0; i &lt; len; i++) &#123; int t = dp_i_0; dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = max(dp_i_1, t - prices[i]); &#125; return dp_i_0;&#125; 第三题解析及代码实现k之前都被化简掉了，但是这里k不能做被忽略，所以必须要对k进行穷举。但是由于k在本题只有1和2两种状态，所以实际也可以将其写为变量的形式，即 dp_i_2_0 = max(dp_i_2_0, dp_i_2_1 + price);dp_i_2_1 = max(dp_i_2_1, dp_i_1_0 - price);dp_i_1_0 = max(dp_i_1_0, dp_i_1_1 + price);dp_i_1_1 = max(dp_i_1_1, -price); 1234567891011121314151617int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if (len &lt;= 1) return 0; int dp_i_1_0 = 0, dp_i_1_1 = INT_MIN; int dp_i_2_0 = 0, dp_i_2_1 = INT_MIN; for (int price : prices) &#123; dp_i_2_0 = max(dp_i_2_0, dp_i_2_1 + price); dp_i_2_1 = max(dp_i_2_1, dp_i_1_0 - price); dp_i_1_0 = max(dp_i_1_0, dp_i_1_1 + price); dp_i_1_1 = max(dp_i_1_1, -price); &#125; return dp_i_2_0;&#125; 第四题解析及代码实现当k等于任意可能数字的时候，k就有可能大于所给天数的长度，此时就要进行特殊处理。也就是说，此时直接将所有坡度加起来就好了。 而当k小于的时候，就可以正常更新了。因为i只依赖于i-1的情况，所以我们可以省略i这个状态，用二维数组进行更新即可。 123456789101112131415161718192021222324252627int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if (len &lt;= 1||k&lt;1) return 0; //处理k&gt;len/2的情况 if (k &gt;= len / 2) &#123; int res = 0; for (int i = 1; i &lt; len; i++) &#123; if (prices[i] &gt; prices[i - 1]) res += (prices[i] - prices[i - 1]); &#125; return res;//只要后一天比前一天高就卖 &#125; //省略i的表达式，节省空间 vector&lt;vector&lt;int&gt;&gt; dp(k + 1, vector&lt;int&gt;&#123; 0,INT_MIN &#125;); for (int price:prices) &#123; for (int j = k; j &gt; 0; j--) &#123; dp[j][0] = max(dp[j][0], dp[j][1] + price); dp[j][1] = max(dp[j][1], dp[j - 1][0] - price); &#125; &#125; return dp[k][0];&#125; 第五题解析及代码实现一次交易一个手续费，所以只需要把手续费从利润中减去即可。也就是 12dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee) 当然fee费用也可以写到第一个数字里，但是此时对于dp[i][1]的初始化应为INT_MIN+fee，不然可能会超出范围导致出错。 123456789101112131415 int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int len = prices.size(); if (len &lt;= 1) return 0; int dp_i_0 = 0, dp_i_1 = INT_MIN; for (int i = 0; i &lt; len; i++) &#123; int dp_temp = dp_i_0; dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = max(dp_i_1, dp_temp-prices[i] - fee); &#125; return dp_i_0;&#125; 有冷冻期的题目的解析由于有一天冷冻期，所以唯一不同点在于所依赖的不是前一天而是前两天，即将i-1改为i-2。即 12dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191029）","slug":"leetcode191029","date":"2019-10-29T05:48:55.000Z","updated":"2019-10-29T06:18:53.742Z","comments":false,"path":"2019/10/29/leetcode191029/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/29/leetcode191029/","excerpt":"","text":"Leetcode 309：最佳买卖股票时机含冷冻期题目描述给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例输入: [1,2,3,0,2]输出: 3解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 解题思路这又是一个动态规划问题，我们思考该题的状态图。一共可能有三个状态： Hold：购入股票； Sold：卖出股票； Rest：持有股票什么都不做。 那么如何能得到这三个状态呢？ 对于Hold来说： 前一天持有，当日Rest； 前一天Rest，当日买入股票。 对于Sold来说： 前一日Hold股票，当日卖出。 对于Rest来说： 前一日Sold了，当日必须Rest； 也可以前一天Rest，当日继续Rest。 所以说状态转换图如下： 由上面的状态转换图我们可以得到：（以下i表示第i天，i-1代表前一天） 123sold[i]=hold[i-1]+price[i];hold[i]=max(hold[i-1],rest[i-1]-price[i]);rest[i]=max(rest[i-1],sold[i-1]); 那么对于最后一天来说，最大值存在两种情况：什么都不做；卖出股票。所以为max(sold,rest)。 代码实现12345678910int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int sold=0,hold=INT_MIN,rest=0; for(int price:prices)&#123; int pre_sold=sold; sold=hold+price; hold=max(hold,rest-price); rest=max(rest,pre_sold); &#125; return max(sold,rest); &#125; 复杂度分析时间复杂度：O(n) LeetCode 312：戳气球题目描述 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] nums[i] nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明:你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例输入: [3,1,5,8]输出: 167解释: nums = [3,1,5,8] –&gt; [3,5,8] –&gt; [3,8] –&gt; [8] –&gt; [] coins = 315 + 358 + 138 + 181 = 167 解题思路这个题类似于游艇租赁问题，游艇租赁问题就是找分隔点，而本题也是类似的。这种动态规划问题和我们前面遇到的是不太一样的。 动态规划问题就是将一个大问题分隔成多个独立的小问题。在这个问题上，就是我们可以将大的区间分隔为独立的小区间，然后先戳爆小区间，也就是先算小区间，再组合出大区间。 对于本题的示例[3,1,5,8]来说，步骤如下： 第一步：计算长度为1的区间，分别戳3,1,5,8。 第二步：计算长度为2的区间，分别算[3,1],[1,5],[5,8]：对于3,1:3最后戳，1已经算出；同样1最后戳，3也算出；对于1,5:1最后戳，5已经算出；同样5最后戳，1也算出；对于5,8:5最后戳，8已经算出；同样8最后戳，5也算出。 第三步，计算长度为3的区间，分别计算[3,1,5]和[1,5,8]：对于3,1,5来说，3最后戳，1/5已经计算出来；1最后戳，3/5已经计算出来；5最后戳，3,1已经计算出来；对于1,5,8来说，1最后戳，5/8已经计算出来；5最后戳，1/8已经计算出来；8最后戳，1,5已经计算出来。 第四步，计算长度为4的区间，即[3,1,5,8]：3最后戳，1，5，8已经算出。1最后戳3和5，8已经算出。5最后戳，3，1和8已经算出。8最后戳，3，1，5已经算出。 简单来说，写一个伪代码：序列为num，[i,j]为区间，dp[i][j]为dp数组；c为区间长度，则 12345678910for(c in [1,N])&#123; for(i in [1,N-c+1])//区间起始点在[1,N-c+1]这个区间里面 &#123; j=i+c-1;//区间长度为c-1，即代表分别计算1,2,...,N的长度区间 for(k in [i,j])&#123; dp[i][j]=max(num[i-1]*num[k]*num[j+1])+dp[i][k-1]+dp[k+1][j]); //当前戳中的值+其左侧戳中的值+其右侧戳中的值 &#125; &#125;&#125; 解析参考自：https://leetcode-cn.com/problems/burst-balloons/solution/san-chong-jie-fa-by-jason-2-6/ 代码实现1234567891011121314151617181920int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int N; N = nums.size(); nums.insert(nums.begin(), 1); nums.push_back(1);//在开头和结尾插入1，因为题目说-1和最后一个位置当做1 const int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len, 0)); for (int i = 1; i &lt;= N; ++i) &#123; for (int j = 1; j + i - 1 &lt;= N; ++j) &#123; const int k = j + i - 1; int&amp; ans = dp[j][k]; for (int m = j; m &lt;= k; ++m) &#123; ans = max(ans, nums[j - 1] * nums[m] * nums[k + 1] + dp[j][m - 1] + dp[m + 1][k]); &#125; &#125; &#125; return dp[1][N];&#125; 复杂度分析 Leetcode 338：比特位计数题目描述给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。要求时间复杂度为O(n) 示例示例1：输入: 2输出: [0,1,1] 示例2：输入: 5输出: [0,1,1,2,1,2] 解题思路最简单的思路，就是对每一个数字进行右移然后与1相与然后计算结果，但是这样的复杂度是O(n*sizeof(integer))。 我们要求是O(n)，可以想到要实现线性时间的话，只能当前结果依赖前面的结果才可以实现。顺着这个思路我们可以发现十进制数字所对应的二进制数字的两条规律： 对于奇数来说，其一定是前一个偶数在最低位上的数字为1，因为1的0次方是1，所以实际上是前一个偶数多一个1。所以result[i] = result[i - 1] + 1; 对于偶数来说，因为我们知道一个数字左移1位相当于扩大为原来的2倍，但是左移1位之后补上的是0，所以说扩大前后1的个数不变，所以偶数m的1的个数一定是m/2的个数，所以result[i] = result[i &gt;&gt; 1]。 代码实现123456789101112131415vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt;result(num + 1, 0); for (int i = 1; i &lt;= num; i++) &#123; if ((i &amp; 1)) &#123; result[i] = result[i - 1] + 1; &#125; else &#123; result[i] = result[i &gt;&gt; 1]; &#125; &#125; return result; &#125; 复杂度分析 时间复杂度：O(n)","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191028）","slug":"leetcode191028","date":"2019-10-28T14:59:56.000Z","updated":"2019-10-28T15:00:53.293Z","comments":false,"path":"2019/10/28/leetcode191028/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/28/leetcode191028/","excerpt":"","text":"Leetcode 322：零钱兑换题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例示例1： 输入: coins = [1, 2, 5], amount = 11输出: 3解释: 11 = 5 + 5 + 1 示例2： 输入: coins = [2], amount = 3输出: -1 解题思路这个问题很明显是一种0-1背包问题，利用动态规划的思想，写出其状态转移方程为： dp(n)=0,if n=0;dp(n)=min(dp(n),dp(i-coin)+1),n&gt;0 那么接下来，代码实现就自然而然的事情了。 代码实现1234567891011121314int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount + 1, amount + 1); dp[0] = 0; for (int i = 1; i &lt;= amount; i++) &#123; for (int c : coins) &#123; if (c &lt;= i) dp[i] = min(dp[i], dp[i - c] + 1); &#125; &#125; return dp[amount] &gt; amount ? -1:dp[amount];&#125; 性能时间复杂度：O(amount*coins) Leetcode 337：打家劫舍（3）题目描述小偷发现了一个可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 解题思路这道升级版的树状动态规划问题也可以由一维的dp延伸来，只是情况稍微复杂一些，每一个节点的dp值与三层二叉树的结点dp值相关。对于下图所示的一棵三层满二叉树来说： 1 / \\ 2 3 / / 4 5 6 7 在每个结点的金额非负的情况下，且要保证取值结点不相邻，只可能有四种最大的取值方式： 结点2 + 结点3 结点1 + 结点4 + 结点5 + 结点6 + 结点7 那么我们可以自底向上递归进行这个dp运算，令dp[i]代表以i结点为根节点的子树的最大偷窃金额值，计算结束后将dp值直接保存在i结点的val值当中返回。可以推出状态转移方程为： 1dp[root] = Max(dp[l]+dp[r], root.val+dp[ll]+dp[lr]+dp[rr]+dp[rl], dp[l]+dp[rl]+dp[rr], dp[r]+dp[lr]+dp[rl]); 分别对应上述四种情况。而观察发现，在dp[l]和dp[r]的计算中实际已经包含了dp[ll]、dp[lr]、dp[rr]、dp[rl]的取舍情况，因此可以简化为前两种情况。状态转移方程简化为： 1dp[root] = Max(dp[l]+dp[r], root.val+dp[ll]+dp[lr]+dp[rr]+dp[rl]); 为了方便运算，我们一般会为dp数组赋予初值。在树状dp中同样，我们需要将每一个非叶结点作为根节点的子树构造成一棵三层满二叉树方便运算。 对于叶子结点，我们给其添加值为0的左右子结点。 对于左/右子树为空的非叶节点，我们在其左/右添加一棵两层值为0的满二叉树。 代码实现1234567891011121314151617181920212223242526 TreeNode* solution(TreeNode* root)&#123; if (root == nullptr) &#123; TreeNode* nnode = new TreeNode(0); return solution(nnode); &#125; if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123; root-&gt;left = new TreeNode(0); root-&gt;right = new TreeNode(0); return root; &#125; root-&gt;left = solution(root-&gt;left); root-&gt;right = solution(root-&gt;right); root-&gt;val = max(root-&gt;left-&gt;val + root-&gt;right-&gt;val, root-&gt;val + root-&gt;left-&gt;left-&gt;val + root-&gt;left-&gt;right-&gt;val + root-&gt;right-&gt;left-&gt;val + root-&gt;right-&gt;right-&gt;val); return root;&#125;int rob(TreeNode* root) &#123; return solution(root)-&gt;val;&#125; 复杂度 该代码修改自https://leetcode-cn.com/problems/house-robber-iii/solution/jian-dan-gao-xiao-de-shu-zhuang-dpzi-di-xiang-shan/，解题思路也转载自该贴。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"WebRTC整体架构分析","slug":"webrtc-structure-191028","date":"2019-10-28T12:19:39.000Z","updated":"2019-10-28T12:20:34.127Z","comments":false,"path":"2019/10/28/webrtc-structure-191028/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/28/webrtc-structure-191028/","excerpt":"","text":"1 设计WebRTC的目的WebRTC（Web Real-Time Communication）项目的最终目的主要是让Web开发者能够基于浏览器（Chrome\\FireFox...）轻易快捷开发出丰富的实时多媒体应用，而无需下载安装任何插件，Web开发者也无需关注多媒体的数字信号处理过程，只需编写简单的Javascript程序即可实现。W3C等组织正在制定Javascript标准API，目前是WebRTC 1.0版本（2019年10月24日），Draft状态，网址：http://w3c.github.io/webrtc-pc/。 另外WebRTC还希望能够建立一个多互联网浏览器间健壮的实时通信的平台，形成开发者与浏览器厂商良好的生态环境。同时，Google也希望和致力于让WebRTC的技术成为HTML5标准之一，可见Google布局之深远。 2 WebRTC架构图 图2.1 WebRTC架构图 架构图颜色标识说明： （1）紫色部分是Web开发者API层； （2）蓝色实线部分是面向浏览器厂商的API层（其中本人研究的部分主要在Voice Engine中的一部分）； （3）蓝色虚线部分浏览器厂商可以自定义实现。 3 WebRTC架构组件介绍1.Your Web App Web开发者开发的程序，Web开发者可以基于集成WebRTC的浏览器提供的web API开发基于视频、音频的实时通信应用。 2.Web API 面向第三方开发者的WebRTC标准API（Javascript），使开发者能够容易地开发出类似于网络视频聊天的web应用。 3.WebRTC Native C++ API 本地C++ API层，使浏览器厂商容易实现WebRTC标准的Web API，抽象地对数字信号过程进行处理。 4.Transport / Session 传输/会话层 会话层组件采用了libjingle库的部分组件实现，无须使用xmpp/jingle协议 （1）RTP Stack协议栈 Real Time Protocol （2）STUN/ICE 可以通过STUN和ICE组件来建立不同类型网络间的呼叫连接。 （3）Session Management 一个抽象的会话层，提供会话建立和管理功能。该层协议留给应用开发者自定义实现。 5.VoiceEngine（我的研究核心） 音频引擎是包含一系列音频多媒体处理的框架，包括从视频采集卡到网络传输端等整个解决方案。 （1）iSAC Internet Speech Audio Codec 针对VoIP和音频流的宽带和超宽带音频编解码器，是WebRTC音频引擎的默认的编解码器 采样频率：16khz，24khz，32khz；（默认为16khz） 自适应速率为10kbit/s ~ 52kbit/； 自适应包大小：30~60ms； 算法延时：frame + 3ms （2）iLBC Internet Low Bitrate Codec VoIP音频流的窄带语音编解码器 采样频率：8khz； 20ms帧比特率为15.2kbps 30ms帧比特率为13.33kbps 标准由IETF RFC3951和RFC3952定义 （3）NetEQ for Voice 针对音频软件实现的语音信号处理元件 NetEQ算法：自适应抖动控制算法以及语音包丢失隐藏算法。使其能够快速且高解析度地适应不断变化的网络环境，确保音质优美且缓冲延迟最小。 是GIPS公司独步天下的技术，能够有效的处理由于网络抖动和语音包丢失时候对语音质量产生的影响。 PS：NetEQ 也是WebRTC中一个极具价值的技术，对于提高VoIP质量有明显效果，加以AEC\\NR\\AGC等模块集成使用，效果更好。 （4）Acoustic Echo Canceler (AEC) 回声消除器是一个基于软件的信号处理元件，能实时的去除mic采集到的回声。 （5）Noise Reduction (NR) 噪声抑制也是一个基于软件的信号处理元件，用于消除与相关VoIP的某些类型的背景噪声（嘶嘶声，风扇噪音等等… …） 6.VideoEngine——WebRTC视频处理引擎 VideoEngine是包含一系列视频处理的整体框架，从摄像头采集视频到视频信息网络传输再到视频显示整个完整过程的解决方案。 （1）VP8 视频图像编解码器，是WebRTC视频引擎的默认的编解码器 VP8适合实时通信应用场景，因为它主要是针对低延时而设计的编解码器。 PS:VPx编解码器是Google收购ON2公司后开源的，VPx现在是WebM项目的一部分，而WebM项目是Google致力于推动的HTML5标准之一 （2）Video Jitter Buffer 视频抖动缓冲器，可以降低由于视频抖动和视频信息包丢失带来的不良影响。 （3）Image enhancements 图像质量增强模块 对网络摄像头采集到的图像进行处理，包括明暗度检测、颜色增强、降噪处理等功能，用来提升视频质量。 4 WebRTC核心模块API1.网络传输模块：libjingle WebRTC重用了libjingle的一些组件，主要是network和transport组件，关于libjingle的文档资料可以查看这里。 2.音频、视频图像处理的主要数据结构 常量\\VideoEngine\\VoiceEngine _注意：以下所有的方法、类、结构体、枚举常量等都在webrtc命名空间里。 表4.1 数据结构列表|类、结构体、枚举常量|头文件||–|–||Structures|common_types.h||Enumerators|common_types.h||Classes| common_types.h||class VoiceEngine|voe_base.h||class VideoEngine|vie_base.h| 3.音频引擎（VoiceEngine）模块APIs 表4.2 音频引擎（VoiceEngine）模块APIs 本文转载自https://blog.csdn.net/temotemo/article/details/7530504，部分内容做修改。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"},{"name":"WebRTC","slug":"WebRTC","permalink":"http://tech.yushuai.xyz/tags/WebRTC/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"leetcode题目解析（191017）","slug":"leetcode191017","date":"2019-10-25T08:18:21.000Z","updated":"2019-10-25T08:19:47.454Z","comments":false,"path":"2019/10/25/leetcode191017/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/25/leetcode191017/","excerpt":"","text":"Leetcode 543：二叉树的直径题目描述给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例给定二叉树 1 / \\ 2 3 / \\ 4 5 返回3，它的长度路径[4,2,1,3]或者[5,2,1,3] 解题思路最长长度一定是最长左子树的长度+最长右子树的长度+1，按照这个思路来走即可。 代码实现12345678910111213141516int ans;int getDepth(TreeNode* root) &#123; if (root == nullptr) return 0; int ll = getDepth(root-&gt;left); int rr = getDepth(root-&gt;right); ans = max(ans, ll+rr+1); return max(ll, rr) + 1;&#125;int diameterOfBinaryTree(TreeNode* root) &#123; ans = 1; getDepth(root); return ans - 1;&#125; 16ms内存消耗：19.7MB Leetcode 560：和为k的子数组题目描述给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 解题思路我感觉没啥需要写的，很简单就看懂。复杂度O(n2)有一点高。 代码实现1234567891011121314151617int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; if (nums.empty()) return -1; int count = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; int sum = 0; for (int j = i;j &lt; nums.size(); j++) &#123; sum += nums[j]; if (sum == k) count++; &#125; &#125; return count;&#125; 性能复杂度：O(n2)执行用时：752ms内存消耗：9.7MB","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191025）","slug":"leetcode191025","date":"2019-10-25T07:53:14.000Z","updated":"2019-10-25T07:55:02.059Z","comments":false,"path":"2019/10/25/leetcode191025/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/25/leetcode191025/","excerpt":"","text":"Leetcode 347：前k个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 示例示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2:输入: nums = [1], k = 1输出: [1] 解题思路一看到这种出现频率最高的k个数字这种题目，就会想到key-value pair，就自然想到map，然后就可以使用map来做。 所以我需要做的就是两步：第一步，将元素插入map中，元素值为key，出现次数为value。第二步，将map按照value进行降序排序。 由于我们没办法使用sort直接对map进行排序，这一点之前也说过，所以依旧是将其转换为一个vector，然后进行排序，只不过我这里使用lambda函数。 最后，将map前k项的key值push到result即可。 代码实现123456789101112131415161718192021vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, int&gt; mymap; for (int i = 0; i &lt; nums.size(); i++) &#123; if (mymap.find(nums[i]) != mymap.end())//复杂度O(1) ++mymap[nums[i]]; else &#123; mymap.insert(pair&lt;int, int&gt;(nums[i], 1)); &#125; &#125; vector&lt;int&gt;result; vector&lt;pair&lt;int, int&gt;&gt;mapsort(mymap.begin(), mymap.end()); sort(mapsort.begin(), mapsort.end(), [](pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) &#123;return a.second &gt; b.second; &#125;); int count = 0; for (auto it = mapsort.begin(); count &lt; k; count++, ++it) &#123; result.push_back(it-&gt;first); &#125; return result;&#125; 代码性能插入性能：O(logn)，n个元素为O(nlogn)排序为O(nlogn）总的来说，时间复杂度为O(nlogn)。符合要求执行用时有一些高，内存消耗尚可。 Leetcode 394 字符串解码题目描述给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例s = “3[a]2[bc]”, 返回 “aaabcbc”.s = “3[a2[c]]”, 返回 “accaccacc”.s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”. 解题思路这个题其实之前在做某次笔试的时候遇到过更复杂的，但是这里简单多了。利用两个栈，一个栈num用来存放存储的数字，一个栈str用来存放字符串，当识别到[的时候，将数字和前面以后的字母分别push进入两个栈，然后遇到]的时候，pop出数字，这个数字就对应着str中最上面的字符串重复的次数。 代码实现123456789101112131415161718192021222324252627282930313233343536373839string decodeString(string s) &#123; string result = \"\"; stack&lt;int&gt;nums; stack&lt;string&gt;str; int num = 0; int len = s.size(); for (int i = 0; i &lt; len; i++) &#123; if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') &#123; num = num * 10 + s[i] - '0'; &#125; else if ((s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z')||(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z')) &#123; result = result + s[i]; &#125; else if (s[i] == '[')//将‘[’前的数字压入nums栈内， 字母字符串压入strs栈内 &#123; nums.push(num); num = 0; str.push(result); result = \"\"; &#125; else if (s[i] == ']') //遇到‘]’时，操作与之相配的‘[’之间的字符，使用分配律 &#123; int times = nums.top(); nums.pop(); for (int j = 0; j &lt; times; j++) &#123; str.top() += result; //之后若还是字母，就会直接加到res之后，因为它们是同一级的运算 //若是左括号，res会被压入strs栈，作为上一层的运算 &#125; result = str.top(); str.pop(); &#125; &#125; return result;&#125; 复杂度","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《优化阵列信号处理》学习笔记（第十章）","slug":"array-signal-process-chapter-ten","date":"2019-10-25T02:02:06.000Z","updated":"2019-10-25T01:56:45.057Z","comments":false,"path":"2019/10/25/array-signal-process-chapter-ten/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/25/array-signal-process-chapter-ten/","excerpt":"","text":"本次分享是个人阅读《优化阵列信号处理》一书最后一个章节，也是针对该书比较整体的学习笔记的最后一次更新了。 第十章：圆环阵阵列处理10.1 引言由于直线阵是一维阵，其波束响应围绕该直线轴对称，因此它只能估计目标的一维角度，而另一维角度是模糊的，也就出现线阵的左右舷模糊缺点。而要解决这一问题就要采用二维阵或者三维阵。 圆环阵是一种二维阵，它也具有轴对称特性，不过它以垂直于该圆环的直线为轴，这样就可以在其所在平面360°方位具有相同的目标探测与方位估计性能。 圆环阵由于其对称性，其常规波束形成响应可以表示为一个贝塞尔函数。 10.2 连续圆环阵10.3 均匀圆环阵10.2.1 均匀加权连续圆环阵10.2.2 圆环阵常规波束形成10.2.3 相位模式激励10.4 本章小结连续圆环阵时延求和波束响应是0阶贝塞尔函数。采用均匀加权时，圆环阵与线阵的波束指向与阵列垂直，当圆环阵直径与线阵长度相等时，两者波束响应函数总量相等。对于同等最大尺度的两种连续阵，随着波束观察方向偏离垂直方向，两者波束响应函数总量也相同。当偏离90°时，前者称为圆环面波束形成，后者称为端射阵波束形成。 连续圆环阵波束旁瓣高于连续线阵，同等最大尺度时，连续圆环阵时延求和波束的主瓣比连续线阵更窄。 连续圆环阵波束响应可以表示成相位模式激励级数求和的形式，所以其波束形成也可以理解为圆环谐波域波束形成。 均匀圆环阵相当于对连续圆环阵进行空间采样，均匀圆环阵在其所在平面的常规时延求和波束形成可以表示为若干阶贝塞尔函数之和的形式，或者说0阶贝塞尔函数加若干阶高阶量。为了保证均匀圆环阵波束响应逼近于连续圆环阵波束响应，应保证圆环上任意两阵元间弧长不大于半波长。阵元间距越小，逼近精度越高。 当在均匀圆环阵所在的平面进行波束形成器设计时，在空间均匀噪声场中的最佳波束形成器的阵增益在低频时远高于时延求和常规波束形成器，即具有超增益特性，这与端射线阵最佳波束形成类似。但这种低频超增益波束形成的白噪声增益很小，稳健性很差，在阵列流形向量和噪声协方差矩阵存在误差时阵增益严重下降，甚至低于常规波束形成器。 …… 受篇幅和格式限制，更多内容，请在百度云盘下载。感谢对我的支持！ 因为我都是把笔记打到word文档中，目前来说在wordpress上写的话公式还需要一个一个调整，如果有可以直接复制过来的方法，欢迎与我分享。谢谢！ 下载链接: https://pan.baidu.com/s/1kR8lqyWiDmygWE27fwVwSQ 提取码请关注本人公众号，回复“优化阵列学习笔记”获取。 本人微信公众号为xiaoao_study，也可以扫描下图关注。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"},{"name":"Optimal Array Signal Process","slug":"Optimal-Array-Signal-Process","permalink":"http://tech.yushuai.xyz/tags/Optimal-Array-Signal-Process/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"《优化阵列信号处理》学习笔记（第五章）","slug":"array-signal-process-chapter-five","date":"2019-10-25T01:38:34.000Z","updated":"2019-10-25T01:56:24.722Z","comments":false,"path":"2019/10/25/array-signal-process-chapter-five/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/25/array-signal-process-chapter-five/","excerpt":"","text":"第五章：稳健波束设计除了原始的对角加载之外，另一类具有代表性的对角加载类方法是加权向量范数约束方法。由于该方法等同于白噪声增益约束，所以也称为白噪声增益月书法。不过，对角加载方法的最大问题是难以根据导向向量误差信息确定对角加载量大小。 后续有一些新的方法，能够真正有效利用导向向量误差信息，它们是根据导向向量误差椭圆精确计算对角加载量的大小。 5.1 对角加载法5.2 加权向量范数约束法5.3 最差性能最佳化法5.4 协方差矩阵拟合法5.5 总结…… 受篇幅和格式限制，更多内容，请在百度云盘下载。感谢对我的支持！ 因为我都是把笔记打到word文档中，目前来说在wordpress上写的话公式还需要一个一个调整，如果有可以直接复制过来的方法，欢迎与我分享。谢谢！ 下载链接: https://pan.baidu.com/s/1kR8lqyWiDmygWE27fwVwSQ 提取码请关注本人公众号，回复“优化阵列学习笔记”获取。 本人微信公众号为xiaoao_study，也可以扫描下图关注。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"},{"name":"Optimal Array Signal Process","slug":"Optimal-Array-Signal-Process","permalink":"http://tech.yushuai.xyz/tags/Optimal-Array-Signal-Process/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"leetcode题目解析（191024）","slug":"leetcode191024","date":"2019-10-24T08:29:27.000Z","updated":"2019-10-24T08:41:43.785Z","comments":false,"path":"2019/10/24/leetcode191024/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/24/leetcode191024/","excerpt":"","text":"昨天晚上有事情，导致都没有做题，所以计划的做题只能每次拖后一天，但是今天不能再拖了。 Leetcode 406：根据身高重建队列题目描述假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意：总人数少于1100人。 示例输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解题思路其实这道题我看到之后，第一想到的就是排序，当然怎么排序还是一个问题。后来经过思考之后我想到在排完序之后我可以这样做：根据第2个元素的大小，插入相应的位置，这样，只要我先插入的是第一个元素大的item，后续有item插入同一位置的时候，就可以保证第一个元素小的item前面比它小的item个数是第二个元素大小，第一个元素大的item前面比它小的item个数也是第二个元素所表示的大小。 所以这就要求我们，首先要对第一个元素从大到小排列，第二个元素从小到大排列。具体见代码。 代码示例1234567891011121314151617static bool cmp(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123; if(a[0]&gt;b[0]) return true; if (a[0] == b[0] &amp;&amp; a[1] &lt; b[1]) return true; return false;&#125;vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123; sort(people.begin(),people.end(),cmp); vector&lt;vector&lt;int&gt;&gt;result; for(auto p:people) &#123; result.insert(result.begin()+p[1],p); &#125; return result;&#125; 代码性能排序复杂度：O(nlogn)插入复杂度 O(n^2)总的来说复杂度O(n^2) Leetcode 416：分割等和子集题目描述给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100数组的大小不会超过 200 示例示例1：输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]。 示例2：输入：[1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。 解题思路其实这个题是Leetcode494的简化版本。首先我们可以把本题的题意重写为下面这段话，意思不变： 给定一个非负整数数组，a1, a2, …, an,。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回是否可以使最终数组和为目标数 0 。 由于目标数是0，实际上这个数组所有元素之和sum应该是我们所认为的和的两倍，所以如果sum为奇数，则直接返回false，其它参考494来做即可。 但是目前在leetcode上第74个用例总是出错，问题尚待研究。 代码实现123456789101112131415161718192021222324252627 bool canPartition(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return false; int sum = 0; for (auto n : nums) &#123; sum += n; &#125; cout &lt;&lt; sum &lt;&lt; endl; if (sum % 2 == 1) return false; sum /= 2; vector&lt;int&gt; dp(sum + 1, INT_MIN); dp[0] = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; int n = nums[i]; for (int j = sum; j &gt;= n; j--) &#123; dp[j] = max(dp[j], dp[j - n] + n); if (dp[j] &lt; 0) dp[j] = INT_MIN; &#125; &#125; return dp.back()==sum;&#125;&#125;;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191022）","slug":"leetcode191022","date":"2019-10-22T14:28:38.000Z","updated":"2019-10-24T08:41:58.160Z","comments":false,"path":"2019/10/22/leetcode191022/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/22/leetcode191022/","excerpt":"","text":"Leetcode 112：路径总和题目描述给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。 示例给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 代码实现123456789bool hasPathSum(TreeNode* root, int sum) &#123; if (root == nullptr) return false; if ((root-&gt;left == nullptr) &amp;&amp; (root-&gt;right == nullptr) &amp;&amp; (root-&gt;val == sum)) return true; int newsum = sum - root-&gt;val; return hasPathSum(root-&gt;left,newsum) || hasPathSum(root-&gt;right, newsum);&#125; 代码性能执行用时：12ms（击败93.51%的C++用户）内存消耗：19.8MB（击败50.80%的C++用户） Leetcode 113：路径总和II题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。 示例给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5]] 代码实现123456789101112131415161718192021222324252627void hasPathSum(TreeNode* root, int sum, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; temp) &#123; sum -= root-&gt;val; temp.push_back(root-&gt;val); if (sum == 0 &amp;&amp; (root-&gt;left == nullptr) &amp;&amp; (root-&gt;right == nullptr)) &#123; result.push_back(temp); return; &#125; if (root-&gt;left) &#123; hasPathSum(root-&gt;left, sum, result, temp); temp.pop_back(); &#125; if (root-&gt;right) &#123; hasPathSum(root-&gt;right, sum, result, temp); temp.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt;result; if (root == nullptr) return result; vector&lt;int&gt;temp; hasPathSum(root, sum, result, temp); return result;&#125; 代码性能执行用时：12ms（击败98.02%的C++用户）内存消耗：19.7MB（击败88.70%的C++用户） Leetcode 437：路径总和III题目描述给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ 3 2 11 / \\3 -2 1 返回 3。和等于 8 的路径有: 5 -&gt; 3 5 -&gt; 2 -&gt; 1 -3 -&gt; 11 代码实现12345678910111213141516int psum(TreeNode* root, int sum)&#123; if (root == nullptr) return 0; int res = 0; if (root-&gt;val == sum) res += 1; res += psum(root-&gt;left, sum - root-&gt;val); res += psum(root-&gt;right, sum - root-&gt;val); return res;&#125;int pathSum(TreeNode* root, int sum) &#123; if (root == nullptr) return 0; return psum(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);&#125; 代码性能时间复杂度O(n)，n为树的节点个数；空间复杂度O(h)，h为树的高度； 执行用时：40ms（击败56.55%的C++用户）内存消耗：14.5MB（击败89.02%的C++用户）","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191021）","slug":"leetcode191021","date":"2019-10-21T12:45:07.000Z","updated":"2019-10-21T12:45:48.506Z","comments":false,"path":"2019/10/21/leetcode191021/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/21/leetcode191021/","excerpt":"","text":"Leetcode 448：找到所有数组中消失的数字题目描述给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例输入:[4,3,2,7,8,2,3,1] 输出:[5,6] 解题思路平时我们会怎么做呢？我们会新建一个长度为nums中最大数字的数组flag，且全部初始化为0；然后遍历原来的nums中的每一个元素m，令flag[m-1]=1；这样的话，flag中所有不为1的元素再加上1就是缺失的元素，这样就能保证时间复杂度是O(n)。 但是这里我们不能额外空间，那我们该怎么办呢？其实也很简单，我们将置为1的思路转变为加上一个非常大的数，使原来为0的位置上的数字远远比不上它大就可以了。所以这里我们可以加上数组的尺寸。 这样，对于nums中的数字m，对nums[m-1]加上nums.size()。这样就区分开了，那么对于nums中不存在的数字n，nums[n-1]就一定小于等于nums.size()。 当然我们还有注意一件事情，即这个数字有可能已经被加了nums.size()，所以在实际获取m-1的时候通常取余。 代码实现1234567891011121314151617181920vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; if (nums.empty()) return res; for (int i = 0; i &lt; nums.size(); i++) &#123; int ind = (nums[i] - 1) % nums.size();//获取到当前位的数字-1是多少，假设为ind（因为数组下标从0开始） nums[ind] += nums.size();//然后将第Ind位加上数组长度 &#125; //如果缺失了m，那么在第m-1位的数字肯定没有加上数组的长度，那么这一位必然小于等于数组的长度。 //其实这个题还是类似于设置一个flag数组然后有这个数字则置为1（相当于本题中的加上数组长度）， //没有这个数字则置为0（相当于本题的不加） for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] &lt;= nums.size()) res.push_back(i + 1); &#125; return res;&#125; 算法性能执行用时：116ms内存消耗：14.8MB超过了96.12%的C++提交记录。 Leetcode 461：汉明距离题目描述两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意：0 ≤ x, y &lt; 2^31. 示例输入: x = 1, y = 4 输出: 2 解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。 解题思路看代码即可，非常简单。 代码实现12345678910111213int hammingDistance(int x, int y)&#123; int count = 0; while (x != 0 || y != 0) &#123; if ((x &amp; 1) != (y &amp; 1)) ++count; x &gt;&gt;= 1; y &gt;&gt;= 1; &#125; return count;&#125; 代码性能用时：4ms内存：8.3MB","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191018）","slug":"leetcode191018","date":"2019-10-21T08:18:37.000Z","updated":"2019-10-21T09:53:50.120Z","comments":false,"path":"2019/10/21/leetcode191018/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/21/leetcode191018/","excerpt":"","text":"Leetcode 494：目标和题目描述给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释:-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3 一共有5种方法让最终目标和为3。 解题思路这个题本质上是一个背包问题。但是如果不进行一些推导，我们很难看出这是一个背包问题。所以这真的是很考察人的逻辑思维能力。 由题目可知，数组里面的数字要么为加上的数字要么为减去的数字，所以我们可以将这两组数字分为两组，一组为要加上的数字，我们命名为P，它的和为sum(P)；一组为要减去的数字，我们命名为N，它的和为sum(N)。另外我们将数组中所有和命名为sum(nums)。那么可以得到sum(P)-sum(N)=target。 进一步推导，1234sum(nums)+sum(P)-sum(N)=target+sum(nums)==&gt;sum(P)+sum(N)+sum(P)-sum(N)=target+sum(nums)==&gt;2*sum(P)=target+sum(nums)==&gt;sum(P)=(target+sum(nums))/2 那么这个问题就转化为了：在nums数组中选择哪些数字，使它们的和为(target+sum(nums))/2。这个问题，我们就可以使用0-1背包来解决。 其实从这个新的问题我们就可以看出，若sum(P)为奇数，那么就不存在相应的组合。 0-1背包问题，我们可以使用动态规划的思想来解决。我们新建一个dp数组，大小为(target+sum(nums))/2+1。对于数组中每一个元素来说，其下标代表着和为当前数的方案数（例如dp[4]=9代表和为4有9种情况）。代码中for循环的意思，其实是针对前i个数的情况下，和的值为相应下标有多少种情况（例如在对于第3个1的情况下dp[4]就是代表着加入这个数组只有前3个数字，那么就在这三个数字情况下和为4有多少种情况）。其实这是一个动态更新的过程。 我们知道对于0-1背包问题来说，当前物品有两种情况，一为选择二为不选择。所以对于0-1背包问题来说，目标值=当前物品不选择且前一步骤达到目标值的情况+前一步骤没有达到目标值且加上当前物品恰好达到目标值的情况。那么对于dp[i]=dp[i]+dp[i-num]来说，等号后面的dp[i]的值是上一步计算出来的和为i的情况数，也就是说我们在上一步选择完成之后已经达到了我们的target，那么当前数字肯定不选择，所以dp[i]就是代表了这种情况。 对于后面的dp[i-num]来说，就是前一步骤没有达到目标值且加上当前物品恰好达到目标值的情况。其实dp[i-num]就是到目前为止和为i-num有多少种选择，所以这也就等价于前一步骤没有达到目标值且加上当前物品恰好达到目标值的情况。 故这就是整个题目的思路。 代码实现12345678910111213141516171819 int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int sum = 0; int times = 0; for (int n : nums) &#123; sum += n; &#125; if (sum &lt; S||(sum+S)%2==1) return 0; S = (S + sum) / 2; vector&lt;int&gt;dp(S + 1, 0); dp[0] = 1; for (int num : nums) &#123; for (int i = S;i &gt;= num;i--) dp[i] += dp[i - num]; &#125; return dp[S];&#125; Leetcode 538：把二叉搜索树转换成累加树题目描述给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 示例输入: 二叉搜索树: 5 / \\ 2 13 输出: 转换为累加树: 18 / \\ 20 13 解题思路这个题其实就是一个变相的中序遍历，所以按照中序遍历进行处理即可。具体看代码。 代码实现123456789101112int num=0;TreeNode* convertBST(TreeNode* root) &#123; if(root!=nullptr) &#123; convertBST(root-&gt;right); root-&gt;val=root-&gt;val+num; num=root-&gt;val; convertBST(root-&gt;left); return root; &#125; return nullptr;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《优化阵列信号处理》学习笔记（第四章）","slug":"array-signal-process-chapter-four","date":"2019-10-21T07:21:57.000Z","updated":"2019-10-21T08:31:59.322Z","comments":false,"path":"2019/10/21/array-signal-process-chapter-four/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/21/array-signal-process-chapter-four/","excerpt":"","text":"注：目前因系统问题，故将本文中的公式全部删除，具体请见pdf版本或访问：http://www.yushuai.xyz/2019/10/16/4442.html 第四章：波束稳健性分析在实际中，由于各种误差（如观察方向误差、阵型标定误差、通道幅度与相位误差等）的影响，造成导向向量存在误差；另外，由于接收数据协方差矩阵无法精确计算，只能通过接受数据进行估计，也不可避免的存在估计误差。导向向量与接受数据互谱矩阵误差都势必影响最佳波束形成器的输出信噪比性能。 4.1 最佳波束形成器稳健性影响因素无论是MVDR还是MMSE，亦或是MSNR波束形成器，其加权向量其实统一可以写为 造成导向向量失配的原因有方向失配与阵元接收响应误差等。其中阵元接收响应误差包括通道幅相误差、阵元位置误差、阵元各向异性与不一致性引起的响应灵敏度误差等。 造成数据协方差矩阵误差的原因主要是：我们一般采用有限长度数据快拍估计得到数据协方差矩阵，估计值与实际值存在误差。 4.2 导向向量失配对波束性能的影响我们知道MVDR的阵增益是 将上式进行处理可以得到 根据上式分析导向向量误差、输入信噪比对MVDR波束形成器的阵增益的影响： 4.3 协方差矩阵失配对波束性能的影响4.3.1 样本协方差矩阵求逆波束形成 接下来，我们对协方差矩阵统一用R来表示，于是MVDR波束形成器加权向量又可以表示为 式中 它不影响波束形成器的阵增益性能，只是为了满足无失真约束。 一个自适应波束形成器处于白噪声环境下的波束称为静态波束（quiescent pattern），对应的加权向量称为静态波束加权向量。对于式所示的MVDR对应的静态波束为常规时延求和波束。但是，其它自适应波束形成算法对应的静态波束不一定是常规波束。 在实际中，也包括自己编写的程序中，协方差矩阵都是通过一段数据快拍样本（长度为N）的空间相关矩阵来估计（当然实际中只是第一帧是如此估计），也就是 为了保证R ^ 可逆，快拍数需要满足N≥M。当N无穷大的时候，R ^逼近于真实协方差矩阵R。权向量也就变成了 这种方法就是自适应波束形成。上面所示的直接对数据样本协方差矩阵求逆来实现MVDR波束形成器的方法称为样本协方差矩阵求逆（Sample Matrix Inversion, SMI）方法。在计算式的时候，主要计算量来源于对样本协方差矩阵进行特征分解，其计算复杂度为 4.3.2 样本协方差矩阵求逆法波束性能 在假设观察数据中不包含期望信号（β=0）的条件下分析SMI方法，归一化输出信干噪比定义如下 式中，分母表示在精确制导数据协方差矩阵与导向向量情况下的最优输出信干噪比。在采用N个快拍估计数据协方差矩阵时，归一化输出信干噪比的均值为 上式表明，为了保证SMI波束形成的平均输出SINR比最有情况下损失在3dB以内，要求 在快拍数有限的时候，SMI波束旁瓣升高，它除了高于静态波束【一个自适应波束形成器处于白噪声环境下的波束】之外，平均旁瓣与样本数目的关系大约为 在式中，SLL表示旁瓣级。 当数据样本中包含期望信号的时候（β=1），SMI波束形成的性能会收到更严重的影响。这就是信号“自消”现象。由于快拍数目有限，用样本协方差矩阵代替理想数值会产生误差，它不能和真实的信号响应向量匹配。因此，SMI波束形成器会误将期望信号视作干扰信号进行零陷，而不是增强。 如果信噪比较高，为保证SMI波束形成器的平均输出SINR损失在3dB以内，快拍数需要满足 从上式可以看出，在训练数据包括期望信号的时候，SMI方法收敛速度更慢，稳健性更差。 pdf版本下载链接: https://pan.baidu.com/s/1kR8lqyWiDmygWE27fwVwSQ 提取码请关注本人公众号，回复“优化阵列学习笔记”获取。 本人微信公众号为xiaoao_study，也可以扫描下图关注。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"},{"name":"Optimal Array Signal Process","slug":"Optimal-Array-Signal-Process","permalink":"http://tech.yushuai.xyz/tags/Optimal-Array-Signal-Process/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"leetcode题目解析（191016）","slug":"leetcode191016","date":"2019-10-16T13:14:12.000Z","updated":"2019-10-16T13:19:20.131Z","comments":false,"path":"2019/10/16/leetcode191016/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/16/leetcode191016/","excerpt":"","text":"Leetcode 572：另一个树的子树题目描述给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 解题思路这个题我用两个函数来实现的，首先是官方给的isSubtree()函数，它主要是来做寻找到S和T第一个相同的结点。第二个函数就是isSub()函数，它主要是用来在找到这个结点之后，子树的判断。它们的思路如下： isSubtree()函数 s为空，则一定false； 然后判断当前S和T的结点值是否相等（isSub子函数)，若相等，返回true（if语句括号里面收到true的时候，一定是在isSub所有点都比较完成了）； 若当前值不相等，那么分别看s的左子树和s的右子树里面有没有相等的。 isSub()函数 如果当前点都为null，那么这一步是相等的，return true； 如果当前点一个有值，一个为空，那么一定是false（两个点都为空的情况在上面已经返回了，所以这里肯定没有）； 如果当前点两个值不相等，那么没必要比较下去了，直接return false； 如果当前点的两个值相等，那么分别比较左子树和右子树。 代码实现1234567891011121314151617bool isSub(TreeNode* s, TreeNode* t)&#123; if (!s &amp;&amp; !t) return true; if (!s || !t) return false; if (s-&gt;val != t-&gt;val) return false; return isSub(s-&gt;left, t-&gt;left) &amp;&amp; isSub(s-&gt;right, t-&gt;right);&#125;bool isSubtree(TreeNode* s, TreeNode* t) &#123; if (!s) return false; if (isSub(s, t)) return true; return isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);&#125; Leetcode 581：最短无序连续子数组题目描述给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。你找到的子数组应是最短的，请输出它的长度。 示例示例1输入: [2, 6, 4, 8, 10, 9, 15]输出: 5解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 解题思路我的思路很简单，对整个数组进行排序，然后图方便，将所有与原来相同位置上数字不同的位置记录下来，然后记录start为第一个位置，end为最后一个位置，结果就是end-start-1。当然也可以用其它方法只记录end和start，节省空间。 之所以这样做是因为，找到的子数组是最短的，说明应该找的是第一个动的位置和最后一个动的位置及包含它们在内的子数组，所以才这样做。 代码实现1234567891011121314151617181920 int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt;tmp(nums); sort(nums.begin(), nums.end()); vector&lt;int&gt;pos; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] != tmp[i]) &#123; pos.push_back(i); &#125; &#125; int posize = pos.size(); if(posize==0) return 0; int start = pos[0]; int end = pos[pos.size() - 1]; //cout &lt;&lt; &quot;start=&quot; &lt;&lt; start &lt;&lt; &quot;end=&quot; &lt;&lt; end &lt;&lt; endl; return (end - start + 1);&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《优化阵列信号处理》学习笔记（第三章）","slug":"array-signal-process-chapter-three","date":"2019-10-16T09:40:55.000Z","updated":"2019-10-16T09:41:45.342Z","comments":false,"path":"2019/10/16/array-signal-process-chapter-three/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/16/array-signal-process-chapter-three/","excerpt":"","text":"第三章：规则阵波束设计对于规则形状的基阵，它们的几何形状具有对称性，其阵列信号处理数学模型将表现出一些特有的性质。对于线阵来说，线阵空域信号处理与时间序列信号处理有很多相似之处，因此通过时空类比，很多时间序列分析的方法也可以应用于线阵空域信号处理。线阵具有轴对称性，其波束形成器同样具有轴对称性，所以线阵估计目标方向时具有左右舷模糊的缺点。 3.1 线阵3.1.1 连续线阵3.1.2 均匀线列阵3.1.3 二元阵3.1.4 均匀线列阵窗函数加权3.2 矩形阵3.2.1 波束图乘积定理3.2.2 均匀矩形阵…… 受篇幅和格式限制，更多内容，请在百度云盘下载。感谢对我的支持！ 因为我都是把笔记打到word文档中，目前来说在wordpress上写的话公式还需要一个一个调整，如果有可以直接复制过来的方法，欢迎与我分享。谢谢！ 下载链接: https://pan.baidu.com/s/1kR8lqyWiDmygWE27fwVwSQ 提取码请关注本人公众号，回复“优化阵列学习笔记”获取。 本人微信公众号为xiaoao_study，也可以扫描下图关注。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"},{"name":"Optimal Array Signal Process","slug":"Optimal-Array-Signal-Process","permalink":"http://tech.yushuai.xyz/tags/Optimal-Array-Signal-Process/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"《优化阵列信号处理》学习笔记（第二章）","slug":"array-signal-process-chapter-two","date":"2019-10-15T22:33:57.000Z","updated":"2019-10-16T09:40:44.652Z","comments":false,"path":"2019/10/16/array-signal-process-chapter-two/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/16/array-signal-process-chapter-two/","excerpt":"","text":"1.一般的阵列信号处理问题：将若干传感器布置在空间不同为止组成传感器阵列采集空间场数据，然后采用阵列信号处理算法对接收的阵列数据进行处理，获得有用信息。阵列信号处理的任务包括：从噪声和干扰中检测有用信号、估计信号波形、对接收的信号与噪声场进行是空谱估计、估计信号到达放心、对信号源定位等。 2.波束形成的主要功能：形成基阵接收系统的方向性；进行空域滤波，抑制空间干扰与环境噪声，提高信噪比；估计信号到达方向；进行多目标分辨；为信号源定位创造条件；为目标识别提供信息等。 3.阵列的数学模型——基阵 基阵的组成结构影响基阵的空间特性，其包括两个部分：阵元排列几何形状和各阵元的方向性。基阵的几何形状可以分为三类：线阵、平面阵、体积阵。线阵和平面阵可以认为是体积阵的特例。 选定某一个空间参考点，以该空间参考点作为原点，第m个阵元位置可以用三维表示为 为了不失一般性，长选取基阵的中心店为参考点。 4.阵列的数学模型——信号模型 首先考虑简单的xoy二维平面情况，假设有两个阵元，一个位于坐标原点（参考点），另一个位于y轴上，其坐标为(0,d)。以平民波点源信号从角度θ方向入射到基阵，如图2.4.1所示。在平面波假设情况下，各阵元接受信号都是入射信号的延迟信号。某阵元接收信号相对于参考点信号的延迟时间取决于该阵元与参考点距离在信号入射方向上的投影（径向距离，即式中的dsinθ）和信号传播速度，假设信号传播速度为c，可以计算得到位于(0,d)的阵元接收到的信号相比于参考点信号的时间延迟为 受篇幅和格式限制，更多内容，请在百度云盘下载。感谢对我的支持！ 下载链接: https://pan.baidu.com/s/1kR8lqyWiDmygWE27fwVwSQ 提取码请关注本人公众号，回复“优化阵列学习笔记”获取。 本人微信公众号为xiaoao_study，也可以扫描下图关注。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"},{"name":"Optimal Array Signal Process","slug":"Optimal-Array-Signal-Process","permalink":"http://tech.yushuai.xyz/tags/Optimal-Array-Signal-Process/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"leetcode题目解析（191015）","slug":"leetcode191015","date":"2019-10-15T13:56:55.000Z","updated":"2019-10-15T13:57:21.907Z","comments":false,"path":"2019/10/15/leetcode191015/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/15/leetcode191015/","excerpt":"","text":"Leetcode 621：任务调度器题目描述给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。 示例示例 1: 输入: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2输出: 8执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 题目思想利用贪心算法，首先统计出现的各个字母的次数，然后按照由大到小排序。然后选择其中出现次数最多的字母开始安放。例如例子中，我们假设先安排A（因为例子中A、B出现次数相同），那么就会出现： 0 1 2 3 4 5 6 A A A 然后开始安排B 0 1 2 3 4 5 6 7 A B A B A B 其实这样可以总结为一个公式：(n+1) * (count-1)+m其中n为题目给定的冷却时间，count为字母出现最多的次数，m为出现最多次数的字母的个数。 当然，若单个字母的数量远远大于重复字母的种类数时，实际上所求结果就是这个vector的长度。所以这个时候只需要在最后做过判断即可，即求两者的最大值。 代码实现1234567891011121314151617181920212223242526272829303132333435363738typedef pair&lt;char, int&gt; PAIR;bool cmp(const PAIR &amp;left, const PAIR &amp;right)&#123; return right.second &lt; left.second;&#125; int leastInterval(vector&lt;char&gt;&amp; tasks, int n) &#123; if (tasks.empty()) return 0; int lenoft = tasks.size(); map&lt;char, int&gt;mymap; for (int i = 0; i &lt; tasks.size(); i++) &#123; if (mymap.find(tasks[i]) != mymap.end())//如果在map中找到这个字符，则将字符对应的次数+1 &#123; mymap[tasks[i]]++; &#125; else//如果没有找到这个字符，则在map中添加这个字符，出现次数设置为1 &#123; char tt = tasks[i]; mymap.insert(pair&lt;char, int&gt;(tt, 1)); &#125; &#125; vector&lt;PAIR&gt; vec(mymap.begin(), mymap.end()); sort(vec.begin(), vec.end(), cmp); int lenofbig = 0; for (int i = 0; i &lt; vec.size(); i++) &#123; if (vec[i].second == vec[0].second) ++lenofbig; else break; &#125; int houxuan = (n + 1) * (vec[0].second - 1) + lenofbig; return ((houxuan &gt; lenoft) ? houxuan: lenoft); &#125; Leetcode 617：合并二叉树题目描述给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 题目思想其实这个题的思想和另一个合并两个排序的二叉树（http://www.yushuai.xyz/2019/03/04/4258.html）思想是一样的。我们可以想都把所有的数据加到第一个二叉树上。类似于那个题目，有这样几个情况： 若第一个链表为空，则直接返回第2个； 若第二个链表为空，则直接返回第1个； 其实若两个链表都为空的话，在第一个if语句判断的时候返回了第二个链表，而第2个链表为空，所以正好也是返回了NULL。 若两个二叉树都有值，则将第二个二叉树的值加到第一个上。 然后递归调用左树和右树的计算。 最后返回第一个二叉树。 代码实现12345678910TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; if(t1==nullptr) return t2; if(t2==nullptr) return t1; t1-&gt;val+=t2-&gt;val; t1-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left); t1-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right); return t1;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"leetcode题目解析（191014）","slug":"leetcode191014","date":"2019-10-14T14:02:48.000Z","updated":"2019-10-14T14:05:49.627Z","comments":false,"path":"2019/10/14/leetcode191014/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/14/leetcode191014/","excerpt":"","text":"Leetcode 647：回文子串题目描述给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。 示例示例 1: 输入: “abc”输出: 3解释: 三个回文子串: “a”, “b”, “c”.示例 2: 输入: “aaa”输出: 6说明: 6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”. 题目思想这里我的思路就是分为了两步：第一步提取出该字符串的所有子串；第二步，对每个子串判断是否是回文，若是则计数。最后返回结果。但是这种方法复杂度太高，因为重复计算了太多。可以使用一种名为中心扩展的方法。这种方法的思路是选定一个点i，然后分别以i及(i,i+1)向两边扩展开始计算。这种扩展的思路就在countNums()函数中得以实现。 代码实现1234567891011121314151617181920212223int countNums(string&amp; s, int i, int j)&#123; if (i &gt; j || i &lt; 0 || j &gt;= s.size()) return 0; int nums = 0; while (i &gt;= 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] == s[j]) &#123; --i; ++j; ++nums; &#125; return nums;&#125;int countSubstrings(string s)&#123; int res = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; res += countNums(s, i, i); res += countNums(s, i, i + 1); &#125; return res;&#125; Leetcode 771：宝石与石头题目描述给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例示例 1:输入: J = “aA”, S = “aAAbbbb”输出: 3示例 2:输入: J = “z”, S = “ZZ”输出: 0 题目思想这个题目思路很简单，我感觉没必要做太多解释。就是说，对于S中的每一个字母，看在J中是否存在，若存在则nums++。 代码实现123456789int numJewelsInStones(string J, string S) &#123; int nums = 0; for (auto s : S) &#123; if (J.find(s) != J.npos)//如果能找到这个字母 nums++; &#125; return nums;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《优化阵列信号处理》学习笔记（第一章）","slug":"array-signal-process-chapter-one","date":"2019-10-09T02:01:48.000Z","updated":"2019-10-09T02:06:29.386Z","comments":false,"path":"2019/10/09/array-signal-process-chapter-one/","link":"","permalink":"http://tech.yushuai.xyz/2019/10/09/array-signal-process-chapter-one/","excerpt":"","text":"随着项目的进行，越发发现自己缺乏了太多波束形成的基础知识，而这些知识就在阵列信号处理这一门课程中学习，但是当初自己选择了自适应信号处理，并没有选择《阵列信号处理》。所以从前几天起一直在找阵列信号处理领域比较优秀的书籍，然后看到了鄢社锋编写的《优化阵列信号处理》一书，总体感觉还很不错，问了声学所的同学也说他的书写的不错，故想自己开始对这方面研究一下，整理一些笔记。 今天发布的是第一章的笔记。第一章是绪论，只要是一些概括性的知识，包括分类、发展历史、方法总体优缺点等，没有深入的知识。 第一章：绪论1.波束形成是阵列信号处理的一个非常重要的任务，它采用空间分布的传感器阵列采集包含期望信号与噪声的物理场数据，然后对所采集的阵列数据进行线性加权组合处理得到一个标量波束输出。 2.波束形成的功能：①形成基阵接收系统的方向性；②进行空域滤波，抑制空间干扰与环境噪声，提高信噪比；③估计信号到达放心，进行多目标分辨；④为信号源定位创造条件；⑤为目标识别提供信息等。通过波束形成处理，可以实现对目标的检测与定位。 3.根据频带宽度划分可以划分为窄带波束形成器和宽带波束形成器。窄带波束形成器中，各阵元数据进行加权求和得到输出，通过设计合适的加权值，可以有选择性地增强来自某一指定方向的信号，抑制其它方向的到达信号，提高输出信噪比。这一点与FIR滤波器系数，有选择性地使某些频率成分通过、抑制其它频率成分的处理过程相似。 4.传感器阵列的空域滤波性能由其结构形状、阵元数目及处理算法等因素确决定。 5.加权值决定了波束形成器的空间滤波特性。根据加权值的选择可以分为数据独立波束形成器和统计最优的波束形成器。数据独立波束形成器加权值是固定的，不随接收数据的变化而变化，对接受数据提供固定的响应，包括常规（时延求和）波束形成器和部分旁瓣控制波束形成器（如Chebyshev）；统计最优波束形成器基于接受数据的统计特性对加权值进行优化。 6.波束形成器的性能参数： （1）主瓣宽度； （2）旁瓣级； （3）阵列增益； （4）主瓣响应； （5）频率响应。 低旁瓣可以有效抑制来自旁瓣区域的干扰，降低目标检测的虚警概率；窄的主瓣宽度可以提高目标方向的辨别能力；高的阵列增益可以提高系统对弱目标的检测能力；高稳健性使波束形成的性能受各种失配影响减小。波束优化设计的目的就是使波束形成器的这些性能最优。 Capon波束形成器（MVDR）使理想阵增益最高；Cox波束形成器是一种提高基阵波束形成器对基阵误差稳健性的波束形成器。 7.MVDR波束形成方法的阵列增益与稳健性 MVDR波束形成器：MVDR波束形成器在保证对感兴趣方位的信号无失真输出的条件下，使基阵的输出功率最小，最大限度地提高输出信噪比，或者说最大限度地提高阵列增益，具有很好的干扰抑制能力。它可以解释为协方差矩阵拟合问题，具有很好的方位分辨能力。但是MVDR波束形成方法是建立在阵列对期望信号的响应精确已知的基础之上，对基阵的误差非常敏感。要获得更好的性能，需要精确知道期望信号导向矢量和噪声（包括干扰）协方差矩阵。而这两者都存在误差，造成性能下降严重。 首先，阵列对期望信号的假想响应与真实响应适配。造成这种适配的原因主要有：观察方向误差、阵型标定误差、未知波前扭曲与信号衰减、近场模型失配、局部散射、环境非平稳造成信号和噪声幅度与相位起伏等。传统的自适应算法对这些类型的失配哪怕十分轻微也会特别敏感，因为这些失真条件并不是恰好针对实际期望信号的，会把实际期望信号当作干扰而形成零陷，导致信号自消，这样MVDR算法性能就会比标准波束形成器性能下降严重。 其次，噪声协方差矩阵一般是未知的，我们往往采用自适应方法估计的数据协方差矩阵来代替。一方面，采用有限样本估计的数据协方差矩阵与真实数据方差矩阵间存在误差，训练样本越少，误差越大；另一方面，传统的自适应波束形成方法假设在训练数据中不包括期望信号成分，但是在大多数情况下，观察数据中一般含有期望信号成分。【麦克风阵列中虽然使用了VAD，但无法保证VAD结果一定准确，所以可能会在噪声混杂在训练数据中，也就会产生信号“自消”现象】 使用样本数据协方差矩阵代替噪声协方差矩阵对自适应波束形成造成的影响是旁瓣升高、阵列增益减小。在训练数据中不包括期望信号成分时，自适应波束形成算法对导向向量误差与较少训练样本还具有一定的稳健性，但是当训练数据中包含期望信号，传统的自适应波束形成方法就会产生信号“自消”，此时波束性能和收敛速率就会严重下降。即使导向向量精确已知，但训练样本有限时也是如此。 由于训练样本较少产生的协方差矩阵误差对MVDR波束形成性能影响可以看作是号线由于导向矢量误差引起的，输入信噪比越高，性能下降程度越剧烈。在高信噪比情况下，即使很小随机误差都会使基阵增益严重下降，甚至比常规波束形成器还差。 高增益和稳健性是一对矛盾。 为了解决这一问题，有很多方法被提出。例如，线性约束最小方差（LCMV），包括点约束和微分约束，但是他们只适用于观察方向失配情况，对其它类型导向矢量失配等并不能提供足够的稳健性，而且它会减小波束形成器的自由度，降低其干扰抑制能力。【这一段话非常重要，解释了LCMV在我使用的时候为什么效果还比MVDR差。】 在能够部分解决任意导向矢量失配问题的方法中，最常用的是二次约束方法和基于特征空间的波束形成方法。 二次约束方法对权向量的Euclidean范数施加一个二次约束。早期由于加权向量范数约束方法难以直接实现，所以一般采用样本协方差矩阵对角加载波束形成方法【师兄使用的就是该方法】来实现，这些方法及其改进方法能够提供信号导向向量失配与样本协方差矩阵存在误差情况下的稳健波束形成。不过这种方法的缺点是：无法根据失配的程度获得优化的对角加载量。 基于子空间的方法要求知道噪声协方差矩阵的信息，不仅对导向向量误差敏感，而且对噪声协方差矩阵的不精确性也非常敏感，而且在低信噪比情况或当信号加干扰子空间维数较高的时候失效。 可以看一下Gershman等、Li等、Boyd等提出的能够根据导向向量不确定范围来选取参数的稳健波束形成方法。这些方法属于对角加载类型算法，但是他们明确利用了导向向量误差信息，能够根据导向向量误差椭圆不确定集来精确计算对角加载量。Kim后续将这一类方法进一步发展，能够处理更灵活的导向向量和协方差矩阵模型不确定性问题。 【参考文献】 [1] Vorobyov S A, Gershman A B, Luo Z Q. Robust adaptivebeamforming using worst-case performance optimization: a solution to the signalmismatch problem[J]. IEEE Transactions on Signal Processing, 2003,51(2):313-324. [2] Stoica P , Wang Z , Li J . Robust CaponBeamforming[C]// Conference on Signals, Systems &amp; Computers. IEEE, 2006. [3] Li J , Stoica P , Wang Z . On robust Caponbeamforming and diagonal loading[J]. IEEE Transactions on Signal Processing,2003, 51(7):1702-1715. [4] Li J , Stoica P , Wang Z . Doubly constrained robustcapon beamformer[J]. IEEE Transactions on Signal Processing, 2005, 52(9):2407-2423. [5] Lorenz R G , Boyd S P . Robust minimum variancebeamforming[J]. IEEE Transactions on Signal Processing, 2005, 53(5):1684-1696. [6] Kim S J , Magnani A , Mutapcic A , et al. RobustBeamforming via Worst-Case SINR Maximization[J]. IEEE Transactions on SignalProcessing, 2008, 56(4):1539-1547. 8.波束图优化设计 波束图形状设计包括两个方面：控制波束旁瓣；设计波束主瓣响应。波束图综合主要指期望响应波束设计问题。 首先考虑旁瓣控制波束设计问题。单个传感器可能不是各向同性，各个传感器的灵敏度也可能不太相同，这些都可能使旁瓣进一步升高。另外，在之前统计最优波束形成器中，为了追求高增益而造成波束旁瓣升高，有时会达到难以忍受的程度。Dolph-Chebyshev方法能产生恒定旁瓣级，对于半波长间隔均匀线阵列，该方法在给定主瓣宽度下能获得最低的旁瓣级，或在给定旁瓣级条件下能够得到最小主瓣宽度。Riblet-Chebyshev方法对于半波长间隔均匀线列阵与上面相同，但当阵元间距小于半波长，且阵元数为不小于7的奇数时，Riblet-Chebyshev能获得更窄的主瓣。但是上面两个只能是各向同性阵元组成的均匀线列阵。Taylor提出了适用于圆面阵的旁瓣约束方法，该方法约束最大旁瓣高度，并获得远离主瓣方向逐渐下降的旁瓣。这个方法适用于圆形阵，要求各阵元各向同性，对于其它任意几何形状阵列、阵元本身具有指向性，或组成基阵各阵元灵敏度存在差异的时候，就不能获得理想的期望旁瓣。 【参考文献】 [7] Taylor T . Design of circular apertures for narrowbeamwidth and low sidelobes[J]. IRE Transactions on Antennas and Propagation,2003, 8(1):17-22. 基于自适应阵原理的旁瓣控制方法适用于任意结构阵列。在存在干扰的情况下，自适应波束形成器能够在干扰方向自动形成一个“凹槽”。Olen等于1990年提出了一种静态波束图的数字综合方法，它对旁瓣区域内噪声源的自适应调整做了进一步讨论，通过反复迭代过程，可以获得给定主瓣宽度条件下的最低均匀旁瓣级。这一类方法缺点是：采用自适应或迭代方法实现，并不能保证完全收敛，不能保证旁瓣得到严格控制，误差比较大。而且迭代过程中对于主瓣宽度没有约束，容易造成主瓣较快增宽。或者说，在给定旁瓣级条件下并不能保证获得最窄的主瓣。 在给定波束主瓣宽度情况下，波束能获得的最低旁瓣是有限的。当干扰功率太大时，即使从波束旁瓣方位入射，仍旧会对主瓣入射的期望信号产生较大的干扰，我们可以在干扰方向形成凹槽或零点来抑制，但是当目标运动的时候，自适应方法可能很难快速跟踪，这个时候可以使用零点展宽技术。使得波束旁瓣区域形成一个交款的凹槽，保证干扰方向始终位于凹槽内。 【参考文献】 [8] Zhou P Y , Ingram M A , Anderson P D . Synthesis ofminimax sidelobes for arbitrary arrays[J]. IEEE Transactions on Antennas andPropagation, 1998, 46(11):1759-1760. 除了旁瓣控制以外，期望响应设计也是一个研究方向。二次规划方法适用于任意结构基阵的期望响应波束设计方法，原理就是使设计的波束与期望波束的均方误差（或l2的范数）最小。二次规划方法的一个主要缺点是：它只使用了误差的l2范数逼近准则，相当于使设计波束在全方位（包括主瓣和旁瓣）同时逼近于期望波束，而我们感兴趣的是波束主瓣，这些方法相当于在旁瓣区域增加了多余的约束，必然造成设计波束与参考波束主瓣区域拟合误差增大。事实上，对于旁瓣区域，我们往往更希望控制最高旁瓣峰，即控制旁瓣与零电平之间的最大误差（**l**无穷范数），这是二次规划方法无法实现的。 以上的方法都是只考虑主瓣或者旁瓣，没有考虑到稳健性和阵增益，而这些指标是相互关联的，单纯优化其中一两个指标，另外的性能往往就会变差。 二阶锥规划（Second-order Cone Programming, SOCP）方法是一种兼顾多个性能指标的波束形成器优化设计方法，包括稳健低旁瓣高增益波束设计和稳健低旁瓣期望主瓣响应波束设计。前者采用Minimax准则控制波束旁瓣，可以在任意阵型、且考虑阵元方向性，更重要的是该方法能够通过对加权向量范数施加约束来提高波束形成器的稳健性。对于后者，采用混合范数准则，让主瓣响应与旁瓣按不同的准则逼近期望值（让误差l2或l无穷范数最小），能满足多样化的设计需求，且能提高波束稳健性。 如果只考虑波束幅度响应而不考虑相位响应，则这种问题称为期望幅度响应波束设计问题。对于这种问题，期望响应（包括幅度和相位）波束只是一个次优解。如果不考虑相位响应，期望幅度响应波束形成器应该能获得更高的主瓣幅度逼近精度。 9.恒定主瓣响应波束设计 在很多情况下，宽带波束形成器在频域实现，通过傅里叶变换将数据从时域转换到频域的多个子带，每个子带满足窄带条件，用前面的窄带波束设计方法可以直接使用。 对于常规波束形成器来说，其主瓣宽度随频率降低而增宽。此时只有当信号源从波束所指方向（主轴）入射时，才能保证信号通过波束形成器后，输出频谱保持不变；否则，若信号从主瓣非主轴方向入射，信号频谱就会发生畸变，类似于进行了低通滤波。所以在子带波束设计问题中，恒定主瓣响应波束形成器是研究较多的一种波束设计问题，它的重要特性就是保证从主瓣区域入射信号的波束输出频谱不发生畸变，即只要信号从主瓣扇面区域入射，就能保证工作频带内的频谱不发生畸变。 10.波束形成器的实现 波束形成器的实现包括频域实现和时域实现两种。 对于窄带波束形成器，频域实现就是直接将窄带阵列快拍数据【快拍数据就是全部阵元在时域的一次采样。如果阵元数为M，那么通常用X(t)来表示一次采样，维数是M*1】进行复数加权求和、得到波束输出，但要求阵列快拍数据也是复数形式，如果阵列数据是实数模型，则需要将数据在基带进行正交解调，然后对两个正交分量分别于加权向量的实部和虚部进行加权求和。时域实现就是直接对个阵列数据进行时延加权求和。由于窄带数据时延等效为相移，所以也可以采用相移加权求和来实现。 宽带信号可以获得更比窄带信号丰富的目标信息，有利于目标检测。 对于宽带波束形成，频域处理方法为：首先使用FFT变换将阵列数据分解为若干子带，每个子带满足窄带条件，然后针对每个子带进行窄带波束形成，最后对各子带输出进行IFFT得到宽带波束输出时间序列，这种称为DFT波束形成器。时域处理方法为：首先将各个阵元数据进行适当的延时，然后分别通过一个对应的FIR滤波器，再将每个滤波器输出相加，得到宽带波束输出序列，这种时域处理器称为FIR波束形成器。 DFT波束形成器是分块处理，不具有实时性，而且DFT处理相当于在频域进行了加窗处理，使得变换到时域时数据块前后不符存在误差。将各块波束输出时域数据组合成连续信号后出现块间“缝合”不流畅，相当于引入了周期性的干扰。如果对数据采用重叠分段处理，这种误差可以减小。时域是实时连续处理，可以解决波束输出不连贯的问题。【频域不能实时处理，且帧与帧之间可能会引入误差；时域处理是实时处理，解决输出不连贯问题】 1972年Frost提出的LCMV方法是早期比较著名的FIR波束形成法，它采用约束最小均方方法使FIR波束形成器对已知方向的期望信号产生响应，但该方法要求期望信号到达各FIR滤波器第1节拍时是同相位的。如果相位不相同，需要各通道先进行延迟实现同相位。Griffiths和Jim提出的GSC算法同样假设期望信号到达各FIR滤波器第一节拍是同相位的，并指出当预延迟存在误差时造成波束形成器性能下降，高信噪比时尤其严重。 对于自适应阵来说，当FIR处理器中的节拍数与DFT处理器中样本长度相等时他们能获得相同的输出信噪比。 期望响应FIR滤波器设计与期望响应波束设计问题类似，可以通过构造不同的设计准则与选择合适的求解计算技术来实现。鄢社锋和马远良提出了一种通用的FIR滤波器优化设计方法，采用二阶锥规划方法求解，设计精度高，并将该FIR滤波器设计与波束优化设计相结合，提高了FIR波束形成器“分步设计法”的精度。 分步设计法设计简便，计算量小，虽然采用二阶锥规划法在两个步骤都能获得单独设计问题的最优解，但不能保证最终综合的结果是全局最优的。例如：FIR滤波器阻带衰减量难以确定；在阻带与过渡带的波束旁瓣难以控制；FIR滤波器不可避免的设计误差会导致FIR波束形成器的旁瓣升高，自适应方法中干扰方向的凹槽深度变浅等。鄢社锋提出了一种恒定主瓣响应FIR波束形成器，其设计思想是：将FIR波束形成器的宽带波束响应表达成滤波器系数的函数，构造优化问题，直接针对优化问题求解对应于所有通道的滤波器系数，可以获得满足约束条件的全局最优解。该方法能够严格控制FIR波束形成器的旁瓣，还能够控制过渡带与阻带区域的波束相应幅度（频域旁瓣）。相对于分部设计法来说，社京都更高，但是计算量更大。此外，通过增加滤波器系数范数约束，可以提高FIR波束形成器的稳健性。 该方法和前面所有恒定主瓣响应波束形成器设计都有一个共同点——首先选择一个期望波束响应，然后使各子带波束响应逼近于该期望响应，从而使宽带波束具有近似恒定的主瓣响应。如何选择一个最优期望响应是一个关键。鄢社锋针对这个问题提出了基于最小主瓣差异的波束设计方法，如参考文献10，该方法不需要预先选择参考波束，仅仅让各频率波束主瓣响应间的误差最小化。 【参考文献】 [9] Yan S , Ma Y . A unified framework for designing FIRfilters with arbitrary magnitude and phase response[J]. Digital SignalProcessing, 2004, 14(6):510-522. [10] Yan S , Ma Y , Hou C . Optimal array patternsynthesis for broadband arrays[J]. The Journal of the Acoustical Society ofAmerica, 2007, 122(5):2686. 11.模态阵列信号处理（与球面、圆面麦克风阵列相关） 前面的方法都是直接对各阵元接受数据进行波束形成，称为阵元域波束形成。模态阵列信号处理方法基于傅里叶声学原理，将球面阵、圆环阵等阵列接收的声场分解成若干阶正交的模态，于是可提取各阶模态进行声场重构，这类方法将声场传播、散射规律与信号处理紧密结合起来。 【傅里叶声学参考文献】 [11] Williams E G , Mann J A . Fourier Acoustics: SoundRadiation and Nearfield Acoustical Holography[J]. The Journal of the AcousticalSociety of America, 2000, 108(4):1373-1373. 圆环阵也可以采用模态阵列信号处理方法，即将圆环阵接收声场分解为若干阶圆谐波，然后进行圆谐波域处理。Mathews和Zoltowski利用均匀圆环阵进行相位模式波束形成估计目标方位，见文献12。 高阶圆谐波相位模式处理在低频时稳健性较差，降低使用的圆谐波结束可以提高稳健性，但这将降低其阵增益。 鄢社锋提出了圆谐波域优化波束形成方法。他采用圆谐波变换将圆环阵阵元域数据变换到圆谐波域，然后在圆谐波域进行波束形成。他利用圆谐波域与阵元域波束形成的等效性关系，推导了波束形成器的各性能参数在圆谐波域的表示，将阵元域波束优化设计方法推广应用到圆谐波域。基于该框架发现：圆环阵阵相位模式阵列处理等效于平面各向同性噪声场中的圆谐波域MVDR波束形成器，如参考文献13。 具体内容可以参加本书第11章和第12章。 【参考文献】 [12] Mathews C P , Zoltowski, M.D. Eigenstructuretechniques for 2-D angle estimation with uniform circular arrays[J]. IEEETransactions on Signal Processing, 1994, 42(9):2395-2407. [13] Yan, Shefeng. Optimal design of modal beamformersfor circular arrays[J]. The Journal of the Acoustical Society of America, 2015,138(4):2140-2151. 12.目标方向估计 瑞利准则：对于位于基阵远场的两个点源，仅当它们的夹角大于基阵孔径倒数的时候，它们才能被分辨。 MUSIC、ESPRIT算法和加权子空间拟合算法等，从理论上克服了方位分辨的瑞利准则，获得了超过常规方法的方位分辨能力。 早期的信号子空间处理方法是为窄带信号模型提出的。对于宽带数据，先将其分解为多个窄带分量，再针对各窄带数据进行子空间方位估计，最后对各窄带估计结果进行简单组合得到宽带方位估计，这便是非相干信号子空间（Incoherent Signal Subspace, ISS）方位估计方法。但是，ISS方法不能够处理相干信号源问题。Wang和Kaveh提出了相干信号子空间（coherent signal subspace,CSS）处理方法来处理相干源问题。该方法先将信号宽带数据分解为多个窄带分量，通过寻找聚焦矩阵，将各频率分量聚焦到参考频率，从而可以采用只爱带子空间处理方法进行方位估计。CSS方法相对于ISS方法具有脚底的检测与分辨信噪比门限和较小的方位估计均方根误差。但是CSS方法设计聚焦矩阵需要在真实目标附近预先估计目标方位，预估计方位偏差影响CSS方法的方位估计性能。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"},{"name":"Optimal Array Signal Process","slug":"Optimal-Array-Signal-Process","permalink":"http://tech.yushuai.xyz/tags/Optimal-Array-Signal-Process/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"基于WebRTC的噪声消除系统发布第二个版本","slug":"the-second-version-of-webrtc-noise-suppression","date":"2019-09-01T11:59:32.000Z","updated":"2019-09-01T12:04:28.279Z","comments":false,"path":"2019/09/01/the-second-version-of-webrtc-noise-suppression/","link":"","permalink":"http://tech.yushuai.xyz/2019/09/01/the-second-version-of-webrtc-noise-suppression/","excerpt":"","text":"WebRTC Noise Suppression工程主页&amp;下载地址：http://tech.yushuai.xyz/WebRTC_deNoise/ 这是一个基于WebRTC的单通道语音增强系统，其为浮点版本。 该工程包括: common_audio：处理音频所需要的文件在的文件夹。 ns：Noise Suppression处理的核心文件在的文件夹 dr_wav.h：读取和解析wav文件。 main.c：整个程序的主程序，系统的入口。 timing.h：计时使用的头文件。 本工程具体算法流程图及函数解释详见链接1和链接2。 Directory description 目录 说明 WebRTC_NS-GCC GCC版本的程序 WebRTC_NS-VS VS版本的程序 以上文件夹各自目录下的工程名称解释如下： v**_mm 其中： **表示版本号。如20表示2.0版本。 mm表示浮点或顶点，其中float表示浮点版本，fixed表示定点版本。 Development Environmentv2.0版本 项目 内容 操作系统（VS环境） Windows 10 x64 VS版本 Microsoft Visual Studio 2019 操作系统（GCC环境） Cent OS6.4 操作系统（GCC） GCC 4.8 v1.0版本 项目 内容 操作系统（VS） Windows 10 x64 VS版本 Microsoft Visual Studio 2015 操作系统（GCC环境） Cent OS6.4 操作系统（GCC） GCC 4.8 ChangeLogv2.0(2019.9.1) 将原来参考的程序文件全部替换为从WebRTC中提取的文件，更加忠实于原工程版本。 将程序中所有使用C++类的部分、使用函数模板的部分等全部替换为了C语言中的实现。 将音频文件读取的函数整合到了主程序之中。 2.0版本暂未提供GCC下工程，请暂时参考VS2019工程和1.0版本的GCC下工程，自行修改CMakeList.txt并进行编译。 v1.0(2019.7.18) 参考cpuimage的程序实现了WebRTC_NS的功能。 InstallLinux下请确认是否安装GCC，确认方式，输入 1$ gcc -v 若返回相应的GCC版本信息，则代表安装完成。具体按照GCC方法请Google即可。 Usage对于VS版本来说，你可以直接打开VS工程进行调试或者生成测试。 对于Linux下版本来说，请在工程目录下执行1234$ mkdir build$ cd ./build$ cmake ..$ make 即可编译链接完成，运行的时候，运行下面的命令 1$ ./ns &lt;input&gt; &lt;output&gt; 在使用的时候，若文件目录中已存在与输出文件名同名的文件，则系统提示该文件已经存在，需要判断是否覆盖，若键入N或n，则拒绝覆盖，程序报错退出；若键入Y或y，则覆盖。 Result Time domain image Frequency domain image SNR &amp; PESQ Related EffortsTo be continued Maintainers@dqhplhzz2008. Contact MeIf you have any questions, please submit a message. ContributorsYou can focus on my WeChat Official Account At same time, welcome to My blog[Simplified Chinese]! LicenseGPL-3.0 © Yushuai Zhang","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"},{"name":"WebRTC","slug":"WebRTC","permalink":"http://tech.yushuai.xyz/tags/WebRTC/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"WebRTC中AGC模块分析（下）","slug":"introduction-of-AGC-in-WebRTC-2","date":"2019-08-13T02:30:51.000Z","updated":"2019-08-13T02:49:12.793Z","comments":false,"path":"2019/08/13/introduction-of-AGC-in-WebRTC-2/","link":"","permalink":"http://tech.yushuai.xyz/2019/08/13/introduction-of-AGC-in-WebRTC-2/","excerpt":"","text":"3.AGC的函数介绍3.1 WebRtcAgc_Process()函数这一部分是WebRTC的自动增益控制模块的核心程序，如图3.1所示，主要分为以下5个步骤： 首先要判断采样点数是否符合规定的要求。即若采样率为8000Hz，则一帧长度必须为80个点；若采样率为16000Hz或32kHz或48kHz，则长度必须为160个点。否则就会返回错误退出。 其次要初始化saturationWarning为0，初始化输出的语音的麦克风级别为输入的语音的麦克风级别。 然后执行WebRtcAgc_ProcessDigital()函数，它是AGC的核心函数，无论什么模式都要调用到，具体功能在后续会进行介绍。该函数返回值取值为0或-1，若为-1则代表出错，返回，否则为正确。 再然后需要判断是否符合条件1。条件1的内容如下： stt-&gt;agcMode &lt; kAgcModeFixedDigital &amp;&amp; (stt-&gt;lowLevelSignal == 0 || stt-&gt;agcMode != kAgcModeAdaptiveDigital 也就是说必须要同时符合两个条件： ①agcMode为kAgcModeUnchanged、kAgcModeAdaptiveAnalog或kAgcModeAdaptiveDigital。 ②lowLevelSignal为0，或者agcMode不是kAgcModeAdaptiveDigital。 符合以上两个条件的话，就去执行WebRtcAgc_ProcessAnalog()，该函数的功能是根据能量的大小、饱和标志（WebRtcAgc_StaturationCtrl）、零状态(WebRtcAgc_ZeroCtrl)，和近端语音活度(WebRtcAgc_SpeakerInactiveCtrl)的结果，来初步控制输入语音的大小。具体介绍后续会有。 最后，完成上述操作以后，更新inQueue。 图3.1 Process函数的流程图 3.2 WebRtcAgc_ProcessDigital()函数WebRtcAgc_ProcessDigital()是WebRTC中AGC模块的核心函数，任何模式都要调用到它。该函数在采样率为8kHz时处理80个点的数据，16kHz、32kHz等都是处理160个点。 由于该函数流程过长，所以这里我会将流程图分为多块，然后逐块进行分析讲解。 如图3.2所示，第一部分首先要计算近端信号的VAD结果，并且当远端信号超过10帧（100ms）之后，使用远端的VAD结果来修正近端VAD，具体的修正公式如下： 接着就是使用V来计算出衰减decay，其计算公式为 然后接下来的具体操作在图中都有，就不再叙述。 图3.2 ProcessDigital()函数流程图1 第二部分如图3.3中的蓝色部分。该部分通过快、慢包络和增益计算每个子帧的增益数组gain。首先计算了快慢包络，如下所示 然后取两个包络的最大值作为level。最后使用对数的分段线性函数把cur_level转换成gain。对数函数的整数部分是cur_level前面0的个数，如果0越少，说明数值越大，最多是31个0，最少1个0（有符号数）。小数部分用线性差值的方法，找到gain[zeros]，gain[zeros-1]中间的量。 第三部分如图3.3中的橘色部分，是来计算门限gate。gate意味着衰减原来的增益。gate的计算可以看成两部分，第一部分是基于快慢包络计算出的似然比，相当于快包络与慢包络能量的倍数。第二部分是近端信号的短时方差。然后计算门限 在计算完gate之后，确定gate是否小于0，若小于，则gatePrevious=0，否则就平滑门限。 平滑后，把门限转换成gain_adj。当gate最小的时候为0（语音），gain_adj取到最大，此时不使用gainTable[0]的值作为参考；当gate最大的时候为2500（噪声），gain_adj取到最小，此时g[k+1]要取到相对于gainTable[0]的值的70%；当gate处于最大最小值之间，g[k+1]在gainTable[0]和g[k+1]确定的这条直线上移动。这一部分如图3.4所示。 图3.3 ProcessDigital()函数流程图2 图3.4 ProcessDigital()函数流程图3 最后一部分就是gain与语音进行处理，如图3.5所示，图中描述已经非常清楚。 图3.5 ProcessDigital()函数流程图4 3.3 WebRtcAgc_ProcessAnalog()函数该函数的作用就是根据输入信号的能量大小、饱和标志（WebRtcAgc_StaturationCtrl()函数）、零状态（WebRtcAgc_ZeroCtrl()）和近端语音活度（WebRtcAgc_SpeakerInactiveCtrl()）来初步调整和控制语音幅度的大小。主要有以下几个部分。 3.3.1对麦克风音量进行预处理 图3.6 ProcessAnalog()函数框图第一部分 这一部分是对micVol进行处理。micVol的大小决定了模拟初步调节的音量。要注意一点，在在kAgcModeAdaptiveAnalog模式下，不调用AddVirtualMic()函数；同时在kAgcModeAdaptiveDigital()下，micVol只是一个第一步粗调节的中间变量，起到了一个初步调节的作用。 3.3.2 判断信号是否饱和该部分是基于信号的包络计算信号是否饱和，使用的是WebRtcAgc_SaturationCtrl()函数。 实际上系统在Webrtc_AddMic()函数中计算了包络env的值。对于16kHz的数据来说，10ms的数据是160个采样点，要分成10块，这样每一块是就是16个采样点，然后对求每块16个点求平方，值最大的点作为包络。 如图3.7所示，当有一块值大于875的时候，就为将envSum累加一次tmpW16。循环完之后，如果没有累计超过25000，则算饱和，将saturated设置为1，然后将envSum清零。如果envSum没有大于25000，则按照0.99的值衰减envSum。 图3.7 ProcessAnalog()函数框图第二部分 若信号饱和，则执行如图3.8中橘色部分所示的操作，具体在图中已经详细叙述，不再累述。 若信号不饱和（或信号饱和后执行的操作完成），则进行零信号检查和近端语音活度检查，如图3.8中蓝色的框图。 3.3.3 零信号检查WebRtcAgc_ZeroCtrl()该函数用来计算信号的大小，并且用msZero来记录，用来控制语音活度（actgiveSpeech）和块低频能量最大值（Rxx16_LPw32Max），这两个变量后续影响计算低频能量Rxx160_LPw32。 3.3.4 近端语音活度检查该部分使用的函数名称为WebRtcAgc_SpeakerInactiveCtrl()。检查近端扬声器是否处于非活动状态。如果是这种情况，由于VAD语音模型在长时间静音后对任何声音更敏感，因此VAD阈值增加。该部分较为简单，不再累述。代码如下：123456789101112131415161718void WebRtcAgc_SpeakerInactiveCtrl(LegacyAgc *stt) &#123; int32_t tmp32; int16_t vadThresh; if (stt-&gt;vadMic.stdLongTerm &lt; 2500) &#123; stt-&gt;vadThreshold = 1500; &#125; else &#123; vadThresh = kNormalVadThreshold; if (stt-&gt;vadMic.stdLongTerm &lt; 4500) &#123; /* Scale between min and max threshold */ vadThresh += (4500 - stt-&gt;vadMic.stdLongTerm) / 2; &#125; /* stt-&gt;vadThreshold = (31 * stt-&gt;vadThreshold + vadThresh) / 32; */ tmp32 = vadThresh + 31 * stt-&gt;vadThreshold; stt-&gt;vadThreshold = (int16_t) (tmp32 &gt;&gt; 5); &#125;&#125; 图3.8 ProcessAnalog()函数框图第三部分 3.3.5 计算子带能量和总能量计算子带能量和总能量如图3.8中粉红色部分所示。流程图中叙述非常清晰，不再描述。 3.3.6 根据vadMic.logRatio判断是否进入条件流程然后根据vadMic.logRatio判断是否进入调节流程，若是，则进行进一步处理，否则继续返回计算能量部分。如图3.8紫色部分所示。 3.3.7 调节流程在前面计算完全帧能量Rxx160LPw32之后，该变量会根据4个阈值划分为5个范围。四个阈值分别是： ①upperSecondaryLimit ②upperLimit ③lowerLimit ④lowerSecondaryLimit 该四个阈值由上到下递减。该部分核心是对micVol进行调整，保证一个帧的能量在[upperLimit, lowerLimit]之间。 3.3.8 检查回声等最后处理步骤该部分保证回声状态和零状态下不会被放大，同时限制增益在一定范围之内，限制音量最大值，如图3.8中白色部分。 部分内容是我阅读https://blog.csdn.net/ssdzdk/中的学习笔记整理而得到的，在此感谢原作者。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"},{"name":"WebRTC","slug":"WebRTC","permalink":"http://tech.yushuai.xyz/tags/WebRTC/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"WebRTC中AGC模块分析（上）","slug":"introduction-of-AGC-in-WebRTC-1","date":"2019-08-12T04:44:56.000Z","updated":"2019-08-12T06:54:36.049Z","comments":false,"path":"2019/08/12/introduction-of-AGC-in-WebRTC-1/","link":"","permalink":"http://tech.yushuai.xyz/2019/08/12/introduction-of-AGC-in-WebRTC-1/","excerpt":"","text":"拖了快一个月了，终于有时间来将所研究的WebRTC中的自动增益控制（AGC）模块的内容进行下系统的整理。目前个人了解的还很初步，有很多东西还没有研究透彻，所以这部分分析整理可能会比较浅薄，后续随着研究的深入，内容会不断完善。 本次先更新第一部分，包括WebRTC的AGC模块的介绍、框图、函数关系图和函数功能介绍等。下一期更新具体的函数原理内容。 1.AGC模块的简介和性能结果WebRTC的音频处理模块分为语音活动检测（VAD）、降噪（NS和NSX）、回音消除（AEC）、回声控制（AECM）和音频增益（AGC）等5个部分。本次我要介绍的是其中的自动增益控制（AGC）部分，其代码主要位于WebRTC的modules\\audio_processing\\agc\\legacy中。 什么时候用得到增益控制呢？实际上，当对语音的响度进行调整的需要时，就要做语音自动增益（AGC）算法处理，平时的语音聊天都会用到这个算法。 最简单的方法就是对所有的音频采样乘上一个增益系数，由于人的听觉对所有频率的感知不是线性的，所以会导致这样处理以后，听起来有的频率增强了、有的频率削弱了，导致了语音失真的方法。所以，要让整个频段听起来响度增益都是相同的，就必须在遵循响度曲线基础上，在响度这个尺度做增益，即按照响度曲线对语音的频率进行加权。 本工程以10ms为单位对语音进行模拟和数字增益的自适应调整。增益的调整仅在语音活动期间进行，语音的长度必须依照程序中所给的长度（8000Hz时为80个点，16000Hz为160个点，320000Hz为320个点，48000Hz为480个点）。本程序必须在进行回声消除后，在近端麦克风信号进行调用。 在这里介绍的时候，我以Github上的工程（https://github.com/cpuimage/WebRTC_AGC）为例进行讲解WebRTC中AGC的过程。 该方法的效果，如图1.1所示。 图1.1 语音效果图像 2.AGC的整体框图和函数关系图2.1 AGC模块整体框图 图2.1 AGC模块整体框图 2.2 AGC模块函数关系图表2.1 AGC模块函数关系图 2.3 AGC模块函数功能解释表2.2 AGC模块函数功能解释 表2.3 其它相关函数功能及解释 2.4 使用到的常量1.全通滤波器因子：12static const uint16_t kResampleAllpass1[3] = &#123;3284, 24441, 49528&#125;;static const uint16_t kResampleAllpass2[3] = &#123;12199, 37471, 60255&#125;; 2.AGC的四种工作模式 表2.4 AGC的四种工作模式 &lt;![endif]–&gt; 2.5 使用到的结构体WebRtcAgc_config是配置targetLevelDbfs和compressionGaindB用于调节agc的动态范围。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120typedef struct &#123; int16_t targetLevelDbfs; // default 3 (-3 dBOv) int16_t compressionGaindB; // default 9 dB uint8_t limiterEnable; // default kAgcTrue (on)&#125; WebRtcAgcConfig;typedef struct &#123; int32_t downState[8]; int16_t HPstate; int16_t counter; int16_t logRatio; // log( P(active) / P(inactive) ) (Q10) int16_t meanLongTerm; // Q10 int32_t varianceLongTerm; // Q8 int16_t stdLongTerm; // Q10 int16_t meanShortTerm; // Q10 int32_t varianceShortTerm; // Q8 int16_t stdShortTerm; // Q10&#125; AgcVad; typedef struct &#123; int32_t capacitorSlow; int32_t capacitorFast; int32_t gain; int32_t gainTable[32]; int16_t gatePrevious; int16_t agcMode; AgcVad vadNearend; AgcVad vadFarend;#ifdef WEBRTC_AGC_DEBUG_DUMP FILE* logFile; int frameCounter;#endif&#125; DigitalAgc;typedef struct &#123; // Configurable parameters/variables uint32_t fs; // Sampling frequency int16_t compressionGaindB; // Fixed gain level in dB int16_t targetLevelDbfs; // Target level in -dBfs of envelope (default -3) int16_t agcMode; // Hard coded mode (adaptAna/adaptDig/fixedDig) uint8_t limiterEnable; // Enabling limiter (on/off (default off)) WebRtcAgcConfig defaultConfig; WebRtcAgcConfig usedConfig; // General variables int16_t initFlag; int16_t lastError; // Target level parameters // Based on the above: analogTargetLevel = round((32767*10^(-22/20))^2*16/2^7) int32_t analogTargetLevel; // = RXX_BUFFER_LEN * 846805; -22 dBfs int32_t startUpperLimit; // = RXX_BUFFER_LEN * 1066064; -21 dBfs int32_t startLowerLimit; // = RXX_BUFFER_LEN * 672641; -23 dBfs int32_t upperPrimaryLimit; // = RXX_BUFFER_LEN * 1342095; -20 dBfs int32_t lowerPrimaryLimit; // = RXX_BUFFER_LEN * 534298; -24 dBfs int32_t upperSecondaryLimit; // = RXX_BUFFER_LEN * 2677832; -17 dBfs int32_t lowerSecondaryLimit; // = RXX_BUFFER_LEN * 267783; -27 dBfs uint16_t targetIdx; // Table index for corresponding target level#ifdef MIC_LEVEL_FEEDBACK uint16_t targetIdxOffset; // Table index offset for level compensation#endif int16_t analogTarget; // Digital reference level in ENV scale // Analog AGC specific variables int32_t filterState[8]; // For downsampling wb to nb int32_t upperLimit; // Upper limit for mic energy int32_t lowerLimit; // Lower limit for mic energy int32_t Rxx160w32; // Average energy for one frame int32_t Rxx16_LPw32; // Low pass filtered subframe energies int32_t Rxx160_LPw32; // Low pass filtered frame energies int32_t Rxx16_LPw32Max; // Keeps track of largest energy subframe int32_t Rxx16_vectorw32[RXX_BUFFER_LEN]; // Array with subframe energies int32_t Rxx16w32_array[2][5]; // Energy values of microphone signal int32_t env[2][10]; // Envelope values of subframes int16_t Rxx16pos; // Current position in the Rxx16_vectorw32 int16_t envSum; // Filtered scaled envelope in subframes int16_t vadThreshold; // Threshold for VAD decision int16_t inActive; // Inactive time in milliseconds int16_t msTooLow; // Milliseconds of speech at a too low level int16_t msTooHigh; // Milliseconds of speech at a too high level int16_t changeToSlowMode; // Change to slow mode after some time at target int16_t firstCall; // First call to the process-function int16_t msZero; // Milliseconds of zero input int16_t msecSpeechOuterChange; // Min ms of speech between volume changes int16_t msecSpeechInnerChange; // Min ms of speech between volume changes int16_t activeSpeech; // Milliseconds of active speech int16_t muteGuardMs; // Counter to prevent mute action int16_t inQueue; // 10 ms batch indicator // Microphone level variables int32_t micRef; // Remember ref. mic level for virtual mic uint16_t gainTableIdx; // Current position in virtual gain table int32_t micGainIdx; // Gain index of mic level to increase slowly int32_t micVol; // Remember volume between frames int32_t maxLevel; // Max possible vol level, incl dig gain int32_t maxAnalog; // Maximum possible analog volume level int32_t maxInit; // Initial value of &quot;max&quot; int32_t minLevel; // Minimum possible volume level int32_t minOutput; // Minimum output volume level int32_t zeroCtrlMax; // Remember max gain =&gt; don&apos;t amp low input int32_t lastInMicLevel; int16_t scale; // Scale factor for internal volume levels#ifdef MIC_LEVEL_FEEDBACK int16_t numBlocksMicLvlSat; uint8_t micLvlSat;#endif // Structs for VAD and digital_agc AgcVad vadMic; DigitalAgc digitalAgc;#ifdef WEBRTC_AGC_DEBUG_DUMP FILE* fpt; FILE* agcLog; int32_t fcount;#endif int16_t lowLevelSignal;&#125; LegacyAgc;","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"},{"name":"WebRTC","slug":"WebRTC","permalink":"http://tech.yushuai.xyz/tags/WebRTC/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"字节跳动互娱提前批面试笔记和反思记录","slug":"Bytedance-interview-record","date":"2019-08-05T11:29:27.000Z","updated":"2019-08-05T11:30:34.018Z","comments":false,"path":"2019/08/05/Bytedance-interview-record/","link":"","permalink":"http://tech.yushuai.xyz/2019/08/05/Bytedance-interview-record/","excerpt":"","text":"字节跳动互娱提前批面试笔记和反思记录7月1日投了字节跳动，然而直到提前批结束都没有收到一面通知，以为是挂了，没想到在7月18日收到了一面通知，然而当时自己很劳累，本来想推迟，结果没想到面试官也因为有事所以直接推迟了一面。于是乎实际一面是7月22日，二面是7月26日，三面是7月28日。最后在8月2日晚收到了字节跳动的offer call，收到了秋招的第一个offer。 字节跳动面试（一面）反思记录（7月22日）问题记录 C++中的虚函数是用来干什么的 多线程和多进程的区别 32位和64位操作系统编程的区别 PCM和WAV文件中存储的是啥 采样率和采样深度的物理意义 C++中malloc/free 和new/delete的区别 128点FFT变换，16kHz的音频，可以分为多少个子带？ 编程题： 查找缺失的最小的正整数 项目： WebRTC VAD中的GMM模型过程 维纳滤波和谱减法的区别 时延估计的实现 你用的VAD的是做什么用的，原理是什么，遇到突发噪声怎么处理？ WebRTC NS中的噪声估计用到的三个特征值是什么？它们分别的定义是什么？ 有没有了解WebRTC中的回声消除？ 研究生项目的下一步改进计划 问题点 对采样深度不懂。采样位深，音频的位深度决定动态范围。**我们常见的16Bit（16比特），可以记录大概96分贝的动态范围。那么，您可以大概知道，每一个比特大约可以记录6分贝的声音。同理，20Bit可记录的动态范围大概就是120dB；24Bit就大概是144dB。音频位速，也叫码率，或者比特率。位速是指在一个数据流中每秒钟能通过的信息量，也可以理解为：每秒钟用多少比特的数据量去表示。96kbps的WMA音频格式的音质明显要比96kbps的MP3音质好。为什么会这样呢？因为不同的压缩算法，对数据的利用率不同而造成的差异。再举例，假如MP3压缩至48kbps以下，已经惨不忍睹，而如果是AAC音频格式，同样是48kbps的位速下，音质明显比MP3好。 问题7答案继续查找。 WebRTC的VAD中GMM模型过程。 LRT均值的定义。 总结反思 Linux和C++基础必须重新看一遍。这些计划7月份大体完成。 WebRTC的VAD、NS部分必须重新回顾，再深入理解，推导，一遍一遍仔细看。 对音频的格式问题得有深入了解。 陆续对回声消除、AGC部分进行了解。 字节跳动面试（二面）反思记录（7月26日）问题记录 介绍自己的项目。 麦克风阵列的物理结构特性有哪些指标？你的麦克风阵列的指标都是怎样的？ 都用了哪些噪声种类？现在机器学习几百种噪声，为什么用这么少？ 在哪些噪声环境下语音增强的效果比较差？ 增强语音的结果的衡量标准是什么？ 指针和引用的区别 多线程（因为知道非计算机专业的，所以提了一下就没有问） TCP和UDP的区别？TCP的拥塞控制策略有哪些？ 一个绳子切三段，可以组成三角形的概率是多少？ 编程题 寻找第k个数字 问题点 对麦克风阵列物理结构了解不够。**由于个人偏向于做算法这一块，所以对麦克风阵列的相关性能指标理解较少，且没有考虑结合物理结构去完成语音增强这一块。 结合新技术的东西太少**。应该多阅读最新论文，了解问题的解决方案。 仍需要增加噪声种类进行全方位测试。** 计算机网络方面仍需要进行了解。** 总结反思 对麦克风阵列的物理指标进行广泛查询搜集，然后进行整理，确定自己使用的麦克风的参数。 广泛阅读最新论文，结合论文对算法进行优化。 增加测试噪声。 考虑对于多说话人的时候如何实现背景说话人的噪声。 对计算机网络的基本知识仍需要进行全方位的了解。 接下来对项目仍然需要深挖，以应对各种实际情况，并结合面试官问题，在下一步项目推进的时候做的更完善。 字节跳动面试（三面）反思记录（7月28日）问题记录 你平时是用VS多还是Linux编程多？VS你都是怎么调试？ 你知道VS下面断点调试的底层原理是什么吗？ 你项目中的时延估计是做什么的？ 编程题 12345678910111213141516171819class B&#123;int b;public:virtual ~B()&#123;cout &lt;&lt;&quot;B::~B()&quot;&lt;&lt;endl;&#125;&#125;;class D:public B&#123;int i;int j;public:virtual ~D() &#123; cout &lt;&lt;&quot;D::~D()&quot;&lt;&lt;endl;&#125;&#125;;int main(void)&#123;B *pb = new D[2];delete[] pb;return 0;&#125; 代码可否正确输出？ 递归写出n个数字的子集（包含空集） n个数字的子集有多少个？ 二叉树的右视图 问题点 对C++虚函数的基本还是有欠缺。**虽然知道代码能够正确输出，但是没有100%的理论确定这一点。 对递归编程这个领域熟悉还不够。** 总结反思下一步要做以下工作： 抓住C++基础不放松，特别是虚函数、多态、智能指针等这几个常问的关键点。 继续加快LeetCode编程题的学习工作，坚持每天刷3~5道题，把一些基本题型的medium和hard题都要刷且弄明白。","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"Bytedance","slug":"Bytedance","permalink":"http://tech.yushuai.xyz/tags/Bytedance/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"leetcode题目解析（190702）","slug":"leetcode190702","date":"2019-07-02T14:05:54.000Z","updated":"2019-07-02T14:10:14.143Z","comments":false,"path":"2019/07/02/leetcode190702/","link":"","permalink":"http://tech.yushuai.xyz/2019/07/02/leetcode190702/","excerpt":"","text":"leetcode9: Palindrome（回文数）题目描述判断一个整数是否是回文数。 题目解析我们通过观察可以看出，回文数有以下两种类型：ABA和ABBA。所以本质上它们都还是镜像对称的，所以可以想到一个结构，就是队列。我们可以把数字以中间位为对称轴拆成两部分，然后做下面这几步： 按顺序将对称轴右侧的几位push到一个queue里面（比如上面中的A/BA，剩下的就是AB/AB）。 然后判断这个数字的长度是奇数还是偶数，若是偶数，直接到下一步，若是奇数，操作x /=10，也就是把对称轴删掉（这样X剩下的就是A/AB了）。 然后将queue里面的数字按pop的顺序连起来，判断与原来那个数字剩下的几位是否相等，若相等就是回文数。 代码实现123456789101112131415161718192021222324252627282930 bool isPalindrome(int x) &#123; if (x &lt; 0) return false; queue&lt;int&gt; tmp; int len = 0; int copy = 0; //1.计算数字的长度 for (int i = x; i; i /= 10) ++len; //2.按顺序将对称轴右侧的push到queue中。 for (int j = len / 2; j &gt; 0; --j) &#123; tmp.push(x % 10); x /= 10; &#125; //3.若是奇数，则提取出来对称轴前面的数字 if (len % 2 == 1) x /= 10; //4.把pop出来的数字连起来 for (int j = len / 2; j &gt; 0; j--) &#123; copy = copy * 10 + tmp.front(); tmp.pop(); &#125; //5.与x剩下的部分对比 if (copy == x) return true; else return false;&#125; Leetcode 1：Two sum题目描述Given an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 代码解析代码实现123456789101112131415161718192021222324252627282930313233343536373839vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; vector&lt;int&gt;result; int nlen = numbers.size(); if (nlen &lt; 2) return result; vector&lt;int&gt;num; for (int i = 0; i &lt; nlen; i++) &#123; num.push_back(numbers[i]); &#125; sort(numbers.begin(), numbers.end()); int i = 0, j = nlen - 1,tmp1=INT_MIN,tmp2=INT_MIN; while (i &lt; j) &#123; if (numbers[i] + numbers[j] == target) &#123; tmp1 = numbers[i]; tmp2 = numbers[j]; break; &#125; else if (numbers[i] + numbers[j] &lt; target) ++i; else if (numbers[i] + numbers[j] &gt; target) --j; &#125; for (int k = 0; k &lt; nlen; k++) &#123; if (num[k] == tmp1) &#123; result.push_back(k + 1); continue; &#125; if (num[k] == tmp2) result.push_back(k+1); &#125; sort(result.begin(), result.end()); return result;&#125; 代码2：123456789101112131415vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt;res(2,-1); map&lt;int,int&gt; tmp; for(int i=0;i&lt;nums.size();i++) &#123; if(tmp.count(target-nums[i])) &#123; res[0]=tmp[target - nums[i]]; res[1]=i; break; &#125; tmp[nums[i]]=i; &#125; return res;&#125; Leetcode 50：计算x的n次幂题目描述实现pow(x,n)，即计算x的n次幂函数。 题目解析在剑指offer之中，我们可以使用二进制移位来实现相应的功能，但实际上，当数字过大的时候，这个方法已经不能使用了。这个时候我们可以用二分法。步骤如下： 依旧是先判断n是不是小于零，若是，令x等于原来的倒数，n变为原来的绝对值；否则不变，然后进入第2步。 执行一个fastPow()函数，这个函数是递归调用执行。首先如果此时n=0了，那么自然结果就是1.0；然后递归调用half=fastPow(x,n/2)，这实际上就是计算x的n/2次方的结果，然后这个时候判断n是奇数还是偶数，如果是偶数，那自然x的n次方就等于x的n/2次方乘x的n/2次方；如果是奇数，则结果就等于x的n次方就等于x的n/2次方乘x的n/2次方再乘x。 代码实现123456789101112131415161718192021222324double fastPow(double x, long long n)&#123; if (n == 0) return 1.0; double half = fastPow(x, n / 2); if (n % 2 == 0) return half*half; else return half*half*x;&#125;double myPow(double x, int n) &#123; if (x == 1.0) return x; if (n == 0) return 1.0; long long N = n; if (N &lt; 0) &#123; x = 1 / x; N = -N; &#125; return fastPow(x, N);&#125; leetcode 69：x的平方根（sqrt of x）题目描述实现int sqrt(int x)函数，计算并返回x的平方根，其中x是非负整数。由于返回类型是整数，所以结果只保留整数部分，将小数部分舍去。 题目解析 所以我们要做的事情就是让这个x(n+1)不断逼近x。由于只要求保留到整数，所以误差可以选择大一点，比如误差到0.5就可以结束逼近了。所以代码实现如下。 代码实现12345678910111213int mySqrt(int x) &#123; if(x&lt;0) return -1; double res=1.0; if(x==0||x==1) return x; while(fabs(res*res-x)&gt;0.5) &#123; res=(res+x/res)/2; &#125; return int(res); &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"Processing of WebRTC noise suppression","slug":"Processing-of-WebRTC-noise-suppression","date":"2019-07-01T13:47:30.000Z","updated":"2019-07-01T14:10:35.259Z","comments":false,"path":"2019/07/01/Processing-of-WebRTC-noise-suppression/","link":"","permalink":"http://tech.yushuai.xyz/2019/07/01/Processing-of-WebRTC-noise-suppression/","excerpt":"","text":"计算噪声功率谱程序（WebRtcNs_AnalyzeCore）计算信噪比函数之前的部分分别是： 1.对输入的时域帧数据进行加窗、FFT变换。 2.然后计算能量，若能量为0，返回；否则继续往下。 3.然后计算新的能量和幅度。 4.使用分位数噪声估计进行初始噪声估计。 5.然后取前50个帧，计算得到高斯白噪声、粉红噪声模型，联合白噪声、粉红噪声模型，得到建模的混合噪声模型。 计算信噪比（ComputeSnr）作用：根据分位数噪声估计计算前后信噪比 Inputs:|magn|.信号幅度谱估计|noise| 噪声幅度谱估计 Outputs:|snrLocPrior|先验SNR|snrLocPost| 后验SNR 后验信噪比指观测到的能量与噪声功率相关的输入功率相比的瞬态SNR： 其中Y是输入含噪声的频谱， N是噪声频谱，先验SNR是与噪声功率相关的纯净（未必是语音）信号功率的期望值，可表示为： 其中X是指输入的纯净信号，这里对应的指语音信号。在WebRTC实际的计算中，并没有采用平方数量级，而是采用了量级数量级。 由于纯净信号是未知信号，先验SNR的估计是上一帧经估计的先验SNR和瞬态SNR的平均值： 上式中H对应与代码中的smooth是上一帧的维纳滤波器，用于对瞬时SNR平滑，前一项是上一帧的先验SNR，后一项是先验SNR的瞬态估计。其通过判决引导DD进行跟新，时间平滑参数是 ，其值越大，流畅度越高，延迟也会越大，程序中选择的是0.98。 特征提取（FeatureUpdate）作用：提取平均LRT参数、频谱差异、频谱平坦度Inputs:// |magn| is the signal magnitude spectrum estimate.// |updateParsFlag| is an update flag for parameters. 计算频谱平坦度（ComputeSpectralFlatness）作用：频谱平坦度计算。原理：该算法假设语音比噪声有更多的谐波。语音频谱往往会在基频（基音）和谐波中出现峰值，而噪声频谱则相对平坦。因此其作为区分噪声和语音的一个特征。 频谱度计算时N表示STFT后频率点数，B代表频率带的数量，K是频点指数，j是频带指数。每个频带包括大量的频率点。就128个频率点可分成4个频带（低带，中低频带，中高频带，高频），每个频带32个频点。对于噪声Flatness偏大且为常数，而对于语音，计算出的数量则偏下且为变量。根据上面的公式，如果接近于1，则是噪声，（噪声的幅度谱趋于平坦），二对于语音，上面的N次根是对乘积结果进行N次缩小，相比于分母部分，缩小的数量级是倍数的，所以语音的平坦度较小，是趋近于0的。 计算频谱差异度（ComputeSpectralDifference）作用：计算输入谱模板（学习到的）噪声谱的差异程度。所参考的噪声谱是self-&gt;magnAvgPause[i]，返回值是正则化的频谱差异，为self-&gt;featureData[4]。 除了频谱平坦度特征的噪声相关假设之外，有关噪声频谱的另一个假设是，噪声频谱比语音频谱更稳定。因此，可假设噪声频谱的整体形状在任何给定阶段都倾向与保持相同。模板频谱通过更新频谱（最初被设为零）中极有可能是噪声或语音停顿的区段来确定。该比较结果是对噪声的保守估计，其中仅对语音概率确定低于阈值（如 的区段处跟新了噪声。在其它分布中，模板频谱也可能被导入到算法中，或从对应不同噪声的形状中筛选出来。考虑到输入频谱 和模板频谱（表示为 ），如想获得频谱模板差异特征，可首先将频谱差异测量定义为 ，其中α和u是形状参数，包括线性位移和振幅参数，是通过将J最小化获得的。(α,u) 通过线性方程获得，因此可对每个帧轻松抽取此参数。在某些示例中，这些参数可表明输入频谱（在音量增加的情况下）的任何简单位移/标度变化。之后该特征将成为标准话的测度。 语音噪声概率更新（SpeechNoiseProb）作用：计算语音/噪声概率，存储在probSpeechFinal。magn：输入幅度谱。noise：噪声谱 理论基础先推导语音/噪声概率计算方法，先来看语音/噪声的概率模型，定义语音状态为 ，定义噪声状态为 ，其中m是帧，k是频率，则语音/噪声的概率可以表示为： 。这一概率取决于观测到的额噪声输入频谱系数 以及所处理信号的一些特征数据（如信号的分类特征），也就是这里的{F}。特征数据可以是有噪输入频谱，过往频谱数据，模型数据等。如特征数据{F}可以包括频谱平坦度测量，谐振峰值距，LPC残余以及模板匹配等。根据贝叶斯准则，语音/噪声概率可表示为： 其中 是以信号的特征数据为基础的先验概率，该值在后续中被设为一个常数。 是特征数据 下的语音/噪声概率，在忽略 为基础的先验概率p{F}，简化语音概率和噪声概率为：语音概率： ，噪声概率 ，这样标准化的语音概率可以写为： LRT均值的计算前面计算了三个特征中的两个（频谱差异度和频谱平坦度），这里介绍第三个，也就是LRT均值，这也是这个函数代码最开始的部分。实际上在理论里面已经把LRT均值的计算理论公式给出，但是有时候帧与帧之间的频变似然比因子 会有很大波动，所以采用经过时间平滑处理的似然比因子： LRT均值同时也作为q公式的参数之一，用来计算q。 q的计算q的数值依赖于LRT均值、频谱差异度、频谱平坦度。在语音/噪声概率计算时，使用高斯假设作为语音PDF模型，从而获得似然比。在其它模型中，概率密度PDF模型也可以用作测量似然比的基础，包括拉普拉斯算子，伽马，超高斯。举个例子，当高斯假设可合理表示噪声时，该假设并不一定适用于语音，尤其是在较短的时帧中（如～10ms）。在这种情况下，可以使用另一种语音PDF模型，但这很可能会增加复杂性。要在噪声估计和过滤流程中确定语音/噪声的概率，这不仅需要本地SNR（即先验SNR和瞬态SNR）的引导，还要结合从特征建模中获得的语音模型/认知内容。将语音模型/认知内容并入到语音/噪声概率确定中，能让噪声抑制流程更好地处理和区分极不稳定的噪声水平。如果仅依靠本地SNR，可能会造成可能性偏差。这里对包含本地SNR和语音特征/模型 123456gainPrior = ((float)1.0 - inst-&gt;priorSpeechProb) / (inst-&gt;priorSpeechProb + (float)0.0001);for (i = 0; i &lt; inst-&gt;magnLen; i++) &#123; invLrt = (float)exp(-inst-&gt;logLrtTimeAvg[i]); invLrt = (float)gainPrior * invLrt; probSpeechFinal[i] = (float)1.0 / ((float)1.0 + invLrt);&#125; 更新噪声估计（UpdateNoiseEstimate）功能：更新噪声估计 输入：magn、snrLocPrior、snrLocPost 输出：noise：更新的噪声频谱估计 的平滑度。这个式子是使用了输入频谱和上次噪声估计的值对噪声进行估计，它的估计方法是这样的：当处于噪声可能性比较大的帧和频率槽的时候，进行更新；如果是语音可能性比较大的时候，就用上一个帧的估计作为噪声估计。噪声估计更新流程受到语音/噪声概率和平滑参数γ控制。对于语音概率超过阈值参数的地方，平滑参数可能会被增加到0.99，以防止语音开始处的噪声水平增加过高。 处理核心程序（WebRtcNs_ ProcessCore） 确定高低频。 加窗，计算带噪语音数据帧能量，同样若能量为0，那么进行特殊处理。 进行FFT变换。 基于引导更新计算维纳滤波器的系数。ComputeDdBasedWienerFilter(self, magn,theFilter);计算公式见公式（1.5）。 对维纳增益值根据用户设置的降噪等级进行下溢和上溢处理 进行维纳滤波，然后将频域数据（频率降噪）通过IFFT转为时域数据 对降噪等级进行判断，如果等级为0，则维纳滤波输出则为最后的降噪结果。否则，到第8步。 再来计算维纳滤波后每一帧的数据能量，然后与前面的能量做比值得到gain=sqrtf(energy2 /(energy1 + 1.f)); 计算factor1和factor2。 结合Analyze中的priorSpeechProb计算最终的增益因子：factor = self-&gt;priorSpeechProb factor1+(1.f - self-&gt;priorSpeechProb) factor2; 数据相乘，得到降噪结果：self-&gt;syntBuf[i] += factor * winData[i];","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"},{"name":"WebRTC","slug":"WebRTC","permalink":"http://tech.yushuai.xyz/tags/WebRTC/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"机器学习第2章：模型评估和选择（model evaluation and selection）笔记","slug":"machine-learning-chpater-2-model-evaluation-and-selection","date":"2019-06-29T09:51:24.000Z","updated":"2019-06-29T09:55:24.054Z","comments":false,"path":"2019/06/29/machine-learning-chpater-2-model-evaluation-and-selection/","link":"","permalink":"http://tech.yushuai.xyz/2019/06/29/machine-learning-chpater-2-model-evaluation-and-selection/","excerpt":"","text":"西瓜书阅读知识点整理第2章 模型评估与选择评估方法 学习器的实际预测输出与样本的真实输出之间的差异称为“误差”，其中在训练集上的误差称为“训练误差（training error）”或“经验误差(empirical error)”；在新样本上的误差称为“泛化误差（generalization error）”。往往训练误差为0的方法泛化误差都很大。 上述种训练误差极其小的往往泛化误差很大，称之为过拟合；反之对训练样本的一般性质尚未学好，就是欠拟合。欠拟合可以通过增加训练轮数等方式来解决，但是过拟合无法解决，只能缓解。 评估一种机器学习方法的时候，要保证测试集和训练集尽可能不一样。当我们含有一个包含有m个样例的数据集的时候，可以用下面的方法产生训练集S和测试集T： 留出法。直接将数据集D划分为两个互斥的集合，其中一个集合为训练集S，另一个为测试集T，即D=S∪T，且S∩T＝∅。要注意：一方面，训练集合测试集的划分要尽可能保持数据分布的一致性，避免数据划分过程中引入额外的偏差对最终结果产生影响。另一方面，即便在给定训练集和测试集样本比例后，仍存在多种划分方式对初始数据集进行分割。不同划分会导致不同的训练集/测试集，模型评估的结果也会有差别。因此一般使用留出法时，要采用若干次随机分隔、重复进行试验评估后取平均值作为留出法的评估结果。另外还有一个问题就在于，如果令S包含大多数样本，则训练出来的模型可能更接近于用D训练出来的模型，但由于T较小，评估结果可能不够稳定准确；若令测试集多一些样本，则训练集S与D差别更大了，被评估的模型与用D训练出来的模型相比可能有较大差别，从而降低了评估结果的保真性。一般是将2/3~4/5的样本用于训练，剩余样本用于测试。 交叉验证法。先将数据集D划分为k个大小相似的互斥子集，即D=D1∪D2∪…∪Dk，且Di∩Dj=∅（i≠j）。每个子集尽可能保持数据分布的一致性。然后每次用k-1个子集的并集做训练集，余下那个做测试集。这样就可以获得k组训练集/测试集，从而可以进行k次训练和测试，最终返回这k个厕所结果的平均值。k最常取指是10，此时称为10折交叉验证。同上，因为划分子集用多种方法，为了减少差别，k折交叉验证通常要随机使用不同的划分重复p次，最终的评估结果是这p次k折交叉验证的结果的均值。常见有10次10折交叉验证。 留一法（Leave-One-Out，简称LOO）。假设数据集D中包含m个样本，若令k=m，就是留一法。优点是：它不受随机样本划分方式的影响；使用训练集与初始数据集相比只少了一个样本，使得在绝大多数情况下，留一法中被实际评估的模型与期望评估的用D训练出的模型很相似。但是缺点是：在数据集较大的时候，训练m个模型的计算开销是难以忍受的；另外留一法估计的结果未必永远比其他方法准确。 自助法。直接以自助采样法（bootstrap sampling）为基础，给定包含m个样本的数据集D，对它进行采样产生数据集D’：每次随机从D中挑选一个样本，将其拷贝放入D’，再将该样本放回初始数据集D中，使得该样本在下次采样时仍有可能被采到；这个过程重复执行m次以后，就得到了包含m个样本的数据集D’。这样约有36.8%的样本没有出现在D’中，所以可以将D’用作训练集，D/D’（就是将D中除去D’的样本）用作测试集。这样，实际评估的模型与期望评估的模型都使用m个训练，而我们仍有数据总量约1/3的、没在训练集中出现的样本用于测试。这样的测试结果称为包外估计（out-of-bag estimate）。该方法在数据集较小、难以有效划分训练集和测试集的时候很有用，且对集成学习等方法有很大好处。但是这个方法改变了初始数据集的分部，会引入估计偏差，所以在初始数据多的情况下，留出法和交叉验证法更常用。 模型评估与选择种用于评估测试的数据集常被称为“验证集”。例如在研究对比不同算法泛化性能的时候，用测试集上的判别效果来估计模型在实际使用时的泛化能力，而把训练数据另外划分为训练集和验证集，基于验证集进行模型选择和调参。 性能度量性能度量反映了任务需求，用来衡量模型泛化能力。在对比不同模型能力时，使用不同的性能度量往往会导致不同的评判结果。回归任务中用的是均方误差（mean squared error），也就是 以上是对于数据分布D和概率密度函数p()来说的。 在分类任务重常用的性能度量有： 错误率与精度。 查准率（准确率Precision）、查全率（召回率，Recall）和F1。 查准率定义为：认为真且确实为真的样本数/（认为真切确实为真+认为真但是为假） 查全率定义为：认为真且确实为真/（认为真且确实为真+认为假但是为真）。官方写法如下： 查准率和查全率是一对矛盾的度量，除非非常简单的任务，否则不可能使查全率和查准率都很高。 P-R图直观显示出学习器在样本总体上的查全率和查准率。若一个学习器的P-R曲线被另一个学习器的曲线完全包住，则可断言后者的性能优于前者（例如A优于C），但是如果两个曲线发生了交叉，就难以一般性断言两者的性能，只能在具体的查准率或查全率条件下进行比较。平衡点（Break-Even Point，简称BEP）是查准率=查全率时的取值。基于BEP的比较，可以认为图中的A优于B。F1变量是基于查准率与查全率的调和平均，定义如下： 但是由于某些情况下，对于查准率和查全率的重视程度可能不同，F1有了一般形式，即Fβ，它是查准率与查全率的加权调和平均，定义如下： β值恒大于0，当β&gt;1的时候，查全率有更大影响；当β&lt;1的时候，查准率有更大影响。 很多时候我们有多个二分类混淆矩阵，我们希望估计算法的“全局”性能，这样有两种方法。一种方法是现在各混淆矩阵上分别计算Recall和Precision，分别即为（P1,R1）,(P2,R2)…,(Pn,Rn)，再计算平均值，这样就得到宏查准率（macro-P），宏查准率和相应的宏F1： ROC和AUC很多学习器是为测试样本产生一个实值或者概率预测，然后将这个预测值与一个分类阈值进行比较，若大于阈值则分为正类，否则为反类。这个实值或概率预测结果的好坏，直接决定了学习器的泛化能力。实际上，根据这个值我们可以将测试样本进行排序，“最可能”是正例的排在最前面，“最不可能”的是正例的排在最后面。这样，分类过程就相当于在这个排序中以某个“截断点”将样本分为两部分，前一部分判作正例，后面是反例。排序本身的质量好坏，体现了综合考虑学习器在不同任务下的“期望泛化性能“的好坏，或者说，一般情况下“泛化性能的好坏”。ROC曲线就是从这个角度来研究学习器泛化性能的工具。 ROC全称是“受试者工作特征”（Receiver Operating Characteristic）曲线。ROC曲线的纵轴是真正例率（True Positive Rate，TPR），横轴是假正例率（False Positive Rate, FPR）。两者定义分别是若一个学习器的ROC曲线被另一个学习器的曲线包住，则另一个学习器性能优于前者。如果两个学习器的ROC曲线发生交叉，则难以一般性判断两者孰优孰劣，此时如果一定要进行比较，则较为合理的判据是比较ROC曲线下的面积（AUC,Area Under ROC Curve）。 代价敏感错误率与代价曲线 不同类型的错误造成结果的严重程度不同。所以为了权衡不同类型错误所造成的不同损失，可以为错误赋予非均等代价（unequal cost）。例如我们可以对一个二分类代价矩阵做以下处理： 一般情况下，重要的是代价比而不是绝对值。 若将上面的第0类和第1类分别作为正类和反类，令D+和D-分别代表样例集D的正例自己和反例子集，则代价敏感（cost-sensitive）的错误率为类似的，可以给出基于分布定义的代价敏感错误率，以及其它一些性能度量，如京都的代价敏感版本。若令costij中的i,j取值不限于0/1，则可以定义出多分类任务的代价的敏感性能度量。 比较检验机器学习中性能检验涉及了以下几个重要因素： 我们要比较泛化性能，然而实验评估的是在测试集上的性能，测试集和泛化的性能未必相同。 测试集上的性能与测试集的选择有很大的关系，不同大小测试集、同样大小测试集的样例不同，测试结果都会不同。 很多机器学习算法具有随机性，即便相同参数在同一测试集上运行，多次运行结果可能也不一样。 统计假设检验（Hypothesis Test）可以提供给我们一些帮助，基于此，若在测试集上观测到A性能好于B，则A的泛化性能在统计意义上优于B，还能得到这个结论的把握有多大。（下面以错误率为性能度量，以ε表示） 1.假设检验假设是对学习器泛化错误率分布的某种判断或猜想。包含m个样本的测试集上，基于假设测试样本是从样本总体分布中独立采样的，那么泛化错误率为ε的学习器将其中m’个样本五分类，其余样本全都分类正确的概率是 由此可以估算其恰将ε’xm个样本误分类的概率如下式所示，这也表达了在包含m个样本的测试集上，泛化错误率为ε的学习器被测得测试错误率为ε’的概率： 给定测试错误率，则对上式求对ε的偏导，并令其等于0可得到P在ε=ε’时最大，|ε-ε’|增大时P减小，这符合二项分布。我们可以使用二项检验（Binomial Test）对ε&lt;=0.3（即泛化错误率是否不大于0.3）这也的假设来进行检验。更一般来说，我们考虑假设ε小于等于ε0，则在1-α概率内所能观测到的最大错误率如下式计算。这里1-α反映了结论的置信度(confidence)。 此时若测试错误率ε’小于临界值，则可以根据二项检验得到：在α显著度下，假设“ε≤ε0”不能被拒绝，即能以1-α的置信度认为，学习器的泛化错误率不大于ε0；否则该假设可被拒绝，即在α显著度下可认为学习器的泛化错误率大于ε0。 二项检验的临界值可以使用icdf(&#39;Binomial&#39;,1-α,m,ε0)来计算得到。 在很多时候，我们并非做一次留出法估计，而是多次重复留出法或者交叉验证法进行多次训练测试，这样会得到多个测试错误率，此时可以使用t检验来求解。 2.交叉验证t检验 3.McNemar检验对于二分类问题，使用留出法不仅可以估计出学习器A和B的测试错误率，还可以获得两学习器分类结果的差别，即两者都正确、都错误、一个正确一个错误的样本数，如下表所示。 算法B 算法A 算法A 正确 错误 正确 e00 e01 错误 e10 e11 若我们做的假设是两个学习器性能相同，也就是说e01=e10，那么|e01-e10|应该服从正态分布。McNemar检验考虑变量 因为e01+e10通常很小，需要考虑连续性校正，所以分子中有-1一项。这个服从的分部就是卡方分布。临界值在Matlab中可以使用icdf(&#39;Chisquare&#39;1-α,k-1)来计算。 4.Friedman检验和Nemenyi检验在一组数据及上对多个算法进行比较时，有两种方法：一是两两比较，在两两比较可以使用前面的方法；二是使用基于算法排序的Friedman检验。若“所有算法的性能相同”这个假设被拒绝，则说明算法的性能显著不同。这个时候需要使用“后续检验（post-hoc test）”来进一步区分算法，常用的有Nemenyi算法。 偏差与方差前面的检验是为了估计其泛化性能，而我们还希望了解它为什么具有这样的性能，偏差-方差分解（bias-variance decomposition）是解释学习算法泛化性能的一种重要工具。它试图对学习算法的期望泛化错误率进行拆解。我们知道，算法在不同训练集上学得的结果很可能不同，即便这些训练是来自同一个分布。 总结一下，偏差（2.40）度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的你和能力；方差（2.38）度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响；噪声（2.39）则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。偏差-方差分解说明，泛化性能是由学习算法的能力、数据的充分性和学习任务本身的难度共同决定的。给定学习任务，为了取得较好的泛化性能，则需要使偏差较小，即能够充分拟合数据，方差较小。使得数据扰动产生的影响小。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://tech.yushuai.xyz/tags/Machine-Learning/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"Algorithm and Hardware Co-Design for Energy-Efficient Deep Learning","slug":"Algorithm-and-Hardware-Co-Design-for-Energy-Efficient-Deep-Learning","date":"2019-06-27T07:41:51.000Z","updated":"2019-06-27T07:53:50.504Z","comments":false,"path":"2019/06/27/Algorithm-and-Hardware-Co-Design-for-Energy-Efficient-Deep-Learning/","link":"","permalink":"http://tech.yushuai.xyz/2019/06/27/Algorithm-and-Hardware-Co-Design-for-Energy-Efficient-Deep-Learning/","excerpt":"","text":"学术报告笔记整理（袁博）报告简介学术报告题目：From Matrix to Tensor: Algorithm and Hardware Co-Design for Energy-Efficient Deep Learning 主讲人：袁博，罗格斯大学电气与计算机工程系助理教授（Bo Yuan, Assistant professor in the Department of Electrical and Computer Engineering in Rutgers University） 报告内容笔记深度学习应用广泛，但是目前强调的多以深度学习的软件应用为主。但是随着深度学习深入人们的生活，现有单纯依赖GPU的软件算法成本非常高，而且随着要求精确度的提高，数据量和模型也在变得越来越大，这对于存储量和计算量要求也越来越高，因此需要有专门应用于深度学习的芯片产生。 为了解决存储量和计算量非常大的问题，引入了Sparsification（模型压缩）这样一种方法，这是基于实际上模型有大量的冗余这一事实。模型压缩主要有两种方法：一是剪枝（如图1所示）；二就是降低精度，例如ESE。如下图，Google的TPU-1也是用的这个，它是用的8bit量化。另外还有binarized model（1比特量化），例如YodaNN。但是这种方法压缩率有限，实践中精确度会损失较大。 图1 图2主讲人所在的实验室主要研究了解决这个问题的另外三种方法： 稠密矩阵构建神经网络一是用稠密矩阵构建神经网络。稠密矩阵是每一个元素不一样，但是可以转换成某种有结构性的矩阵（例如循环矩阵，比如说每个大矩阵是3*3小矩阵的循环，那么就有3倍压缩率），由此提出了Low Displacement Rank Matrix（LDR矩阵）。如图所示。 图3 它符合下面的特性：图4 它有以下优点：①空间复杂度由O(n2)降为了O(n)。②空间结构性更好，设计硬件的时候摆脱了要建立索引，可以节省空间。③利用了LDR矩阵有快速运算方法。 在使用LDR矩阵之前，我们需要回答三个问题： 通用近似属性是否仍然存在？（Does universal approximation property still exist?） 近似误差的界限是什么？（What is the bound of approximation error?） 我们应该如何获得LDR神经网络？（How should we get LDR neural networks?） 上面的答案分别是[1]：（1）是的。可以证明得到LDR网络的通用近似理论：（2） 基于LDR矩阵所提出来的方法叫CirCNN网络，其结构如下[2]：图5 Cir-LSTM与ESE性能比较如下[3]： 总的来说，LdrNN的框架如下： List Content Theory Theoretical Properties for Neural Networks with Weight Matrices of Low Displacement Rank Algorithm CircConv: A Structured Convolution with Low Complexity Design Space Exploration Energy-efficient, high-performance, highly-compressed deep neural network design using block-circulant matrices Computer Architecture CirCNN: Accelerating and Compressing Deep Neural Networks Using Block-CirculantWeight Matrices FPGA Design C-LSTM: Enabling Efficient LSTM using Structured Compression Techniques on FPGAs Chip Design 清华大学 基于稀疏矩阵构建神经网络二是基于稀疏矩阵构建神经网络。提出来的就是PermDNN算法。它是Block-Permuted Diagonal Weight Matrix（结构压缩），非零元素只存在于对角线或者偏移对角线的地方。其优点是不需要存储索引，只需要存储偏移量（利用偏移量进行简单取模运算得到索引）。它收到了编码里面的LDPC编码启发，其优点见下表： CirCNN PermDNN Arithmetic Operation Complex Number-based Real Number-based Comp Ratio for One Layer 2^n Flexible Time-domain Input Sparsity NO YES 从数值运算上说，第一种方法（CirNN）是基于复数的，而本方法基于实数，降低了整体系统的计算量。 从每一层的复杂度上来说，CirNN计算都是2的n次方，但是PermDNN则是灵活的，这一点PermDNN更好。 从时域输入压缩上来说，CirNN是没有压缩的，但是PermDnn是压缩的。TIE三是TIE：使用张量训练分解（Tensor Train Decomposition）的方法，如下图，基本上就是相当于对层的分解，具体因为目前不牵扯和自己相关的东西，所以没有做具体的整理。 本笔记所提到的论文包括以下： Theoretical Properties for Neural Networks with Weight Matrices of Low Displacement Rank CircConv: A Structured Convolution with Low Complexity Energy-efficient, high-performance, highly-compressed deep neural network design using block-circulant matrices CirCNN: Accelerating and Compressing Deep Neural Networks Using Block-CirculantWeight Matrices C-LSTM: Enabling Efficient LSTM using Structured Compression Techniques on FPGAs 这些论文已经上传至百度云，下载地址为：https://pan.baidu.com/s/12OStk9Id5AIH8P7ty-mhMw 密码请关注我的个人微信公众号，回复“袁博论文”即可得到密码。 参考文献[1] Zhao L , Liao S , Wang Y , et al. Theoretical Properties for Neural Networks with Weight Matrices of Low Displacement Rank[J]. 2017. [2] Ding C , Liao S , Wang Y , et al. CirCNN: Accelerating and Compressing Deep Neural Networks Using Block-CirculantWeight Matrices[J]. 2017. [3] Wang S , Li Z , Ding C , et al. C-LSTM: Enabling Efficient LSTM using Structured Compression Techniques on FPGAs[C]// Proceedings of the 2018 ACM/SIGDA International Symposium on Field-Programmable Gate Arrays. ACM, 2018.","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"LDR","slug":"LDR","permalink":"http://tech.yushuai.xyz/tags/LDR/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://tech.yushuai.xyz/tags/Machine-Learning/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"汉诺塔问题","slug":"hanoi-tower-question","date":"2019-06-26T06:55:08.000Z","updated":"2019-06-26T07:07:44.745Z","comments":false,"path":"2019/06/26/hanoi-tower-question/","link":"","permalink":"http://tech.yushuai.xyz/2019/06/26/hanoi-tower-question/","excerpt":"","text":"汉诺塔问题有三根杆子A，B，C。A杆上有N个(N&gt;1)穿孔圆环，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆：每次只能移动一个圆盘；大盘不能叠在小盘上面。 提示：可将圆盘临时置于B杆，也可将从A杆移出的圆盘重新移回A杆，但都必须遵循上述两条规则。 问：如何移？最少要移动多少次？ 为了解决这个问题，不妨假设已经知道怎样移动N-1个圆环了。现在，为了把起点盘上的圆环移动到目标盘，需要做如下操作： 1、把N-1个圆环从起点盘移动到（当前）没有任何圆环的过度盘；2、把最后一个圆环从起点盘移动到目标盘；3、把N-1个圆环从国度盘移动到目标盘（模仿1和2的操作方法来实现）。 可以借助网友的图示，如果三个圆盘的话： 如果四个圆盘的话： 代码实现如下：12345678910111213141516void hannoi(int n, char A, char B, char C)&#123; if (n == 1) &#123; //把最后一个圆环从起点盘移动到目标盘 cout &lt;&lt; &quot;移动圆盘&quot; &lt;&lt; n &lt;&lt; &quot;从盘&quot; &lt;&lt; A &lt;&lt; &quot;盘&quot; &lt;&lt; C &lt;&lt; endl; &#125; else &#123; hannoi(n - 1, A, C, B); //把N-1个圆环从起点盘移动到（当前）没有任何圆环的过度盘；通过B、C盘在此函数调用中调用位置的互换，来实现把N-1个圆环从A盘到B盘的转移【A--B】。 cout &lt;&lt; &quot;移动圆圈&quot; &lt;&lt; n &lt;&lt; &quot;从盘&quot; &lt;&lt; A &lt;&lt; &quot;盘&quot; &lt;&lt; C &lt;&lt; endl; hannoi(n - 1, B, A, C); // 把N-1个圆环从过渡盘移动到目标盘（模仿1和2的操作方法来实现）；通过A、B盘在此函数调用中位置的互换，来实现N-1个圆环从B盘到C盘的转移【B--C】。 &#125;&#125; 若输入n=3，则结果如下： 记不住想下面的口诀：递归-句子-递归。两个盘子：先把小的由A移到B（ACB递归），然后把大的由A移到C（AC句子），然后把小的由B移到C（BAC递归）。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}],"tags":[{"name":"汉诺塔","slug":"汉诺塔","permalink":"http://tech.yushuai.xyz/tags/汉诺塔/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}]},{"title":"鸡尾酒排序问题","slug":"Cock-tail-sort","date":"2019-06-26T06:49:09.000Z","updated":"2019-06-26T06:52:32.629Z","comments":false,"path":"2019/06/26/Cock-tail-sort/","link":"","permalink":"http://tech.yushuai.xyz/2019/06/26/Cock-tail-sort/","excerpt":"","text":"题目解释鸡尾酒排序问题实际上是冒泡排序的一个改进。冒泡排序是一个单向的递增或者递减的交换排序，而鸡尾酒排序则是双向的，也就是说，如果我们以要求一个数组有n个数字从小到大排序，则： 第一趟是正向排序，选出第n个值（最大值）； 第二趟是反向排序，选出第1个值（最小值）； 第三趟是正向排序，选出第n-1个值（次大值）； 第四趟是反向排序，先出第2个值（次小值）。 然后以此类推，最后得出整个序列，所以实际上就相当于将原来的冒泡排序有一段代码写成了两段。然后为了优化运行时间，所以设置一个标志位，当确定没有元素交换的时候，就自动停止运行输出结果。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243void Cocktail(vector&lt;int&gt;&amp; nums)&#123; bool flag = false; int cishu = 1;//输出需要而已 do &#123; flag = false; //正着走 for (int i = 0; i &lt; nums.size() - 1; i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; int temp = nums[i]; nums[i] = nums[i + 1]; nums[i + 1] = temp; flag = true; &#125; &#125; //输出第cishu次排序的结果，正式使用去掉这部分 cout &lt;&lt; &quot;第&quot; &lt;&lt; cishu &lt;&lt; &quot;次排序结果为：&quot;; showNums(nums); ++cishu; //展示结束 flag = false;、 //反过来走 for (int j = nums.size() - 1; j &gt; 0; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; int tmp = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = tmp; flag = true; &#125; &#125; //输出第cishu次排序的结果，正式使用去掉这部分 cout &lt;&lt; &quot;第&quot; &lt;&lt; cishu &lt;&lt; &quot;次排序结果为：&quot;; showNums(nums); ++cishu; //展示结 &#125; while (flag);&#125; 代码测试当我们输入的数组为9,5,7,4,2,1,8,12,33,21,3时，输出结果为","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}],"tags":[{"name":"鸡尾酒排序","slug":"鸡尾酒排序","permalink":"http://tech.yushuai.xyz/tags/鸡尾酒排序/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}]},{"title":"牛客网选择题整理20190624","slug":"nowcoder-choice-review-20190624","date":"2019-06-24T01:53:22.000Z","updated":"2019-06-24T01:56:32.360Z","comments":false,"path":"2019/06/24/nowcoder-choice-review-20190624/","link":"","permalink":"http://tech.yushuai.xyz/2019/06/24/nowcoder-choice-review-20190624/","excerpt":"","text":"排序 外排中使用置换选择排序的目的,是为了增加初始归并段的长度。√ 插入排序：需要有一个对比查找过程；选择排序直接插入指定位置。 快速排序中，第i趟排序结果至少确定i个元素的位置。 使用堆排序方法排序（45,78,57,25,41,89），初始堆为89,78,57,25,41,45。 将两个各有n个元素的有序表归并成一个有序表,最少的比较次数是n，最多是2n-1。 解析：方法： 首先将所有元素按照初始顺序填充到一个完全二叉树中 从“最后一个非终端节点”开始，调用siftdown方法，调整堆的结构，直到根节点为止。图示： 对于冒泡排序和插入排序来说，每一趟都能确定一个元素的最终位置。 设一组初始记录关键字序列为(25，50，15，35，80，85，20，40，36，70)，其中含有5个长度为2的有序子表，则用归并排序的方法对该记录关键字序列进行一趟归并后的结果为（ ）。 解析：序列分为了5组：25,50；15,35；80,85；20,40；36,70。对前两组进行归并，得到：15,25,35,50；对第3、4组归并得到：20,40,80,85；第5组直接输出：36，70。所以最后结果是：15,25,35,50,20,40,80,85,36,70。 图 连通图上各边权值均不相同，则改图的最少生成树是唯一的。 拓扑排序反映的是一个工程能否顺利进行的问题。表示工程的有向图，顶点表示活动，弧表示活动之间的优先关系，AOV网（Activity On Vertex Network）排序算法：从AOV网中选择入度为0的顶点输出，然后删除此顶点，并删除以此顶点为尾的弧，重复直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。采用的图的数据结构：邻接表，加一个存储入度的空间。关键路径：从源点到汇点的最长路径。 AOE（activity on Edge）以弧表示活动。AOV（activity on vertex network）以顶点表示活动。 在一个无向图中，所有顶点的度数之和等于图的边数的2倍。 拓扑序列和有向无环图的结构不是一一对应的。 设某无向图中有n个顶点e条边，则该无向图中所有顶点的度之和为2e。 已知无向图G有16条边，其中度为4的顶点个数为3，度为3的顶点个数为4，其他顶点的度均小于3。图G所含的顶点个数至少是11。 解析：已知图G有16条边，所以其度为32。由于计算顶点个数最少为多少，所以假设剩余的顶点度为2，这样才能保证顶点个数最少。假设度为2的顶点有x个，则可得出：4×3+3×4+x×2=32，解之得x=4。所以顶点个数为3+4+4=11个。 树 将森林转换为对应的二叉树，若在二叉树结点中，结点m是结点n的双亲结点的双亲结点，则在原来的森林中，m和n可能具有的关系是____。1.父子关系2.m的双亲结点与n的双亲结点是兄弟关系3.兄弟关系 解析：若在深林中m的父结点和n的父结点是兄弟关系。那么变成二叉树后，他们形成单边右斜关系，而u和v分别在他们各自的左子树内，不可能在一条路径上，所以2是不可能的。对于1、3来说，分别如下图： m阶B树的定义： 二叉树的线索化：对于二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前结点左，右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点的线索。前驱（pre）:以中序线索二叉树的建立为例，指针pre指向中序遍历时上一个刚刚访问过的结点。 若度为m的哈夫曼树中,其叶结点个数为n,则非叶结点的个数为((n-1)/(m-1)) 解析：哈夫曼树并不是局限于二叉树，可能也存在于多叉树。对于二叉树来说，哈夫曼树是最优二叉树（严格二叉树）；对于m叉树来说，是最优m叉树（严格m叉树）。对于度为m的哈夫曼树来说，节点的度要么为0，要么为m。设度不为零的点有a个，则总结点数为a+n。由于除根节点外，其余每一个结点都有一个分支连向一个节点，对于度为m的每个节点都有m个分支，而度为0的节点是没有分支的，所以从分支角度来看，总的结点数是am+1。am+1=a+n，所以a=(n-1)/(m-1)。 网络流图示是一个网络流从s到t的某时刻快照。此时t处一共接收到10+13+16=39单位流量。每条横线上的数字表示当前流量和管道的容量。那么，该网络最大的流量是多少？41。解析：第一层为s，朝着重点最大输出为11+22+10=43。第二层为结点1,2,3：节点一最多输出10，这是受了结点4的限制；结点2最多17，因为结点5发出最大为23；结点3最多为14，这是被结点3的入度所限制了，入度为14。所以总体是10+17+14=41。第三层为结点4,5,6：输出为10+16+16=42。min(43,41,42)=41。 一定要瞻前顾后（瞻前：看结点的入度是否限制；顾后：看后一结点的输出是否限制），不考虑回流。。","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"http://tech.yushuai.xyz/tags/牛客/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"语音信号处理笔记（2）","slug":"speech-process-learning-notes-day2","date":"2019-06-23T14:17:46.000Z","updated":"2019-06-23T14:21:17.575Z","comments":false,"path":"2019/06/23/speech-process-learning-notes-day2/","link":"","permalink":"http://tech.yushuai.xyz/2019/06/23/speech-process-learning-notes-day2/","excerpt":"","text":"语音和阵列信号的基础以下内容均为自己有关文献和论文整理，因为部分公式较难打出，所以整理成了图片。 语音信号及特点1.语音信号的几大特点： 噪声场不同噪声场中的噪声之间的相关程度不一样。定义噪声相关函数如下： 一般认为，在不考虑噪声的散射、幅度衰减等的情况下，相干噪声场中噪声直达各个麦克风。实际中，开放的、没有混响的环境通常为相干噪声场；非相干噪声场中，噪声互不相干，理想的非相干噪声场实际环境很少见，通常认为麦克风产生的电子噪声为非相干噪声。许多实际噪声环境可以看作散射场，如室内、车内环境等。 近场和远场 区分 特点 远场 一般认为信源到阵列中心的距离远大于信号波长为远场 声音信号是平面波，阵列接收的多路信号间主要存在时延差，忽略它们的幅度差。 近场 反之为近场。 考虑阵元接收信号间的幅度差，认为声音信号是球面波。 空间采样定理对于阵元间距相等的线性阵列来说，定义空间采样频率为 宽带信号接收模型假设空间中有一个M阵列的阵元，接收到一个直达的宽带信号，入射角为θ，那么第m个阵元接收到的信号可以表示为 就是导向矢量，其与信号频率和试验有关系，时延又和阵列结构以及入射角有关系。 接下来的内容可以将频域的窄带波束形成算法扩展到宽带。 如果我们将信号观察期间内接收到的数据进行分块，对每块信号进行K点变换，只要数据块比信号相关事件长，那么变换后的每块数据都不想管，那么向量形式的公式可以转化为短时分析的形式 式中分别是第l数据块的接受信号、第一个麦克风接收的源信号、噪声在fk处的DFT。fk是第k个频点对应的频率。 导向矢量估计导向矢量估计主要有以下几种方法： 直接估计导向矢量。这一类方法基于这一准则：期望信号相关矩阵的特征向量可以作为导向矢量的估计，估计出相关矩阵后进行广义特征值分解，找到最大特征值对应的特征向量，认为是导向矢量的估计。 时延估计。这是一种间接估计导向矢量的方法，得到每个麦克风相对参考阵元的时延后，便可计算出每个频率分量对应的导向矢量，时延估计更为简单，对于需要时间同步的算法，也更为直接。环境混响程度轻、信噪比高条件下，现有的时延估计算法能取得良好性能，但在低信噪比复杂环境下，鲁棒性不高，性能下降，而波束形成算法的同步操作对时延误差比较敏感。使用麦克风阵列进行语音增强，而不涉及其他需求（声源跟踪、定位等），计算时延是较为直接的导向矢量估计方法。 声学传递函数ATF估计。 波达方向估计。时延估计与DOA估计是等价问题，两者可以相互转换：DOA估计出信号入射角度后，在已知阵列结构条件下，便可计算出各阵元的相对时延，进而得到导向矢量。基于DOA的方法，理想情况下性能好，通常考虑信号为直达声，信噪比低、环境混响严重时，DOA性能急剧下降，另外阵列结构信息在有些运用中是未知的。尽管 DOA算法在实际中有较多运用，但在导向矢量估计方面并没有时延估计那么直接。 后置滤波后置滤波原因： 波束形成对于非相干噪声去除能力较差； 波束形成对于非稳态噪声处理能力有限。 后置滤波器的参数需要利用多路输入信号的信息来计算，可以进一步抑制波束形成输出的噪声，解决波束形成对非相干噪声抑制能力不足的问题，提高语音增强算法的性能。 Zelinski方法的维纳滤波器表达式如下： 上面Re后面的式子和下面那个式子分别表示相位同步之后的输入信号的互功率谱的估计和自功率谱的估计。整个方法的意思是：用阵列得到的多路信号的自相关和互相关功率谱密度的平均，来估计波束形成输出信号中的期望信号和噪声的功率谱。 这个方法存在两个问题： 如果噪声信号相关性较大，噪声功率就会欠估计，噪声去除不足。 如果噪声相关性较低，就会过估计，导致信号的失真。 所以在实际的散射场中，会存在低频去噪能力不足，有残留噪声。这是因为噪声往往在低频具有较高的相关性。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"牛客网选择题整理20190616","slug":"nowcoder-choice-review-20190616","date":"2019-06-16T13:15:18.000Z","updated":"2019-06-16T13:21:24.792Z","comments":false,"path":"2019/06/16/nowcoder-choice-review-20190616/","link":"","permalink":"http://tech.yushuai.xyz/2019/06/16/nowcoder-choice-review-20190616/","excerpt":"","text":"C++/C语言基础 对下列语句正确的描述是?12const int *x; //①int * const x; //② 答案：语句②的含义是指针变量x不能更改 解析：const修饰 左侧的时候，表示指向的数据类型为常量；当const修饰 右侧的时候，表示指针本身为常量。 下述静态数据成员的特征中，D是错误的。 解析： 静态数据成员在定义或说明时前面加关键字static。//静态变量的定义 静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下：1&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt; //静态变量的初始化 这表明：(1) 初始化在类体外进行，而前面不加static，（这点需要注意）以免与一般静态变量或对象相混淆。（更详细的，因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。）(2) 初始化时不加该成员的访问权限控制符private，public等。(3) 初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。 3.二进制数据文件流fdat读指针移到文件头的语句是：1fdat.seekg(0,ios::beg); 解析：对输入流操作：seekg和tellg；对输出流操作操作是seekp和tellp。seekg（）是对输入文件定位，它有两个参数：第一个参数是偏移量，第二个参数是基地址。 对于第一个参数，可以是正负数值，正的表示向后偏移，负的表示向前偏移。而第二个参数可以是： ios：：beg：表示输入流的开始位置 ios：：cur：表示输入流的当前位置 ios：：end：表示输入流的结束位置 tellg（）函数不需要带参数，它返回当前定位指针的位置，也代表着输入流的大小。 二叉树 n个结点的二叉链表中含有n+1(2n-(n-1)=n+1)个空指针域。利用二叉链表中的空指针域，存放指向节点在某种遍历次序下的前驱和后继结点的指针 若一棵完全二叉树有768 个结点，则该二叉树中叶结点的个数是384。解析：设二叉树中度为0的节点为n0，度为1的节点为n1，度为2的节点为n2，由于n2=n0-1，所以二叉树的节点为n0+n1+n2=2n0-1+n1=768。由于n0一定为偶数个，且n1要么为0，要么为1，所以n1=1，所以n0=768/2=384。 设在一棵度数为3的树中，度数为3的结点数有2个，度数为2的结点数有1个，度数为1的结点数有2个，那么度数为0的结点数有(6 )个。 解析： 总结点数等于1+n1 1+n2 2+n3 3，所以对于这个题来说，总结点数等于1+1 2+ 1 2 + 3 2 =11，所以说，读为0的结点为11-2-1-2=6个。 若将关键字1，2，3，4，5，6，7 依次插入到初始为空的平衡二叉树 T 中，则 T 中平衡因子为 0 的分支结点的个数是（ ）。 解析： 某二叉树结点的中序序列为A、B、C、D、E、F、G，后序序列为B、D、C、A、F、G、E。该二叉树对应的森林结点的层次序列为：E、G、A、C、D、F、B。 解析：首先是二叉树转换成森林。加入一棵二叉树的根节点有右孩子，则这颗二叉树能够转换成森林，否则将转换成一棵树。转换方法是：（1）从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…。直到所有这些根节点与右孩子的连线都删除为止。（2）将每棵分离后的二叉树转换为树。对于此题，结果如下： 第二步是二叉树转换为树。步骤如下：（1）加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。（2）去线。删除原二叉树中所有结点与其右孩子结点的连线。（3）层次调整。对于此题，结果如下： 有8个结点的无向图最多有28条边。解析：想象邻接矩阵除去对角线一共有8 * 8-8=56个点，然后无向图，所以56/2=28。我就是忘了除以2。 具有n个顶点的有向图，所有顶点的出度之和为m，则所有顶点的入度之和为m。解析：有向图的入度之和=出度之和。 8.有向图中，各列非零之和为入度，各行非零之和为出度。 在一个n阶B-树上，每个树根节点中所含的关键字数目最多为N-1个，最少为N/2-1（向上取整）个。 把一棵树转换成二叉树后，这棵二叉树的形态是唯一的。把一棵树转换成二叉树的方法如下：（1）加线。就是在所有兄弟结点之间加一条连线；（2）抹线。就是对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线；（3）旋转。就是以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。 图拓扑排序 已知有向图G=(V,E)，其中V={ V1 , V2 , V3 , V4 , V5 , V6 , V7 }，E={, , , , , , , , }G的拓扑序列是 V1, V3, V4, V6, V2, V5, V7。 解析： 取一个结点的要求是这个结点没有任何前驱。 其它 用相邻矩阵A表示图，判定任意两个顶点Vi和Vj之间是否有长度为m的路径相连，则只要检查（A^m）的第i行第j列的元素是否为零即可。 解析： 机器学习 SVM核函数主要包括：线性核函数、多项式核函数、径向基核(RBF）、傅里叶核函数、样条核、sigmoid核函数等。","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"http://tech.yushuai.xyz/tags/牛客/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"leetcode题目解析（190513）","slug":"leetcode190609","date":"2019-06-12T14:06:57.000Z","updated":"2019-07-02T14:11:00.031Z","comments":false,"path":"2019/06/12/leetcode190609/","link":"","permalink":"http://tech.yushuai.xyz/2019/06/12/leetcode190609/","excerpt":"","text":"Construct binary tree from preorder and inorder traversal题目描述Given preorder and inorder traversal of a tree, construct the binary tree.Note:You may assume that duplicates do not exist in the tree. 思路关于根据前序和中序如何得到二叉树的结构的计算方式，我就不重复了，之前的程序里面也有，这里就只说说代码里几个参数的思路。一定要做边界条件的判断！12root-&gt;left = build(preorder, pstart + 1, pstart + i - istart, inorder, istart, i - 1);root-&gt;right = build(preorder, pstart + i - istart + 1, pend, inorder, i + 1, iend); 对于左子树处理来说，中序遍历所要处理的位置就是根节点左侧的所有数字，所以自然起始位置就是istart，结束位置就是i-1；对于前序遍历来说表示就麻烦一些，起始位置还好，是pstart+1,结束位置是pstart+(i-istart)，其中i-istart是左子树的元素数。对于右子树处理来说，中序遍历所要处理的位置就是根节点右侧的所有数字，所以自然起始位置就是i+1，结束位置就是iend；对于前序遍历来说，就是从左侧子树最后一个元素后面那个数字到最后一个，所以起始位置是pstart + i - istart + 1，结束位置是pend。 代码实现1234567891011121314151617181920212223242526272829TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; int presize = preorder.size(); int insize = inorder.size(); if (presize == 0 || insize == 0) &#123; return NULL; &#125; else if (presize != insize) return NULL; return build(preorder, 0, presize - 1, inorder, 0, insize - 1);&#125;TreeNode* build(vector&lt;int&gt;&amp;preorder, int pstart, int pend, vector&lt;int&gt;&amp;inorder, int istart, int iend)&#123; if (pstart &gt; pend || istart &gt; iend) return NULL; int mid = preorder[pstart]; TreeNode* root = new TreeNode(mid); int i = istart; for (; i &lt;= iend; ++i) &#123; if (inorder[i] == mid) break; &#125; root-&gt;left = build(preorder, pstart + 1, pstart + i - istart, inorder, istart, i - 1); root-&gt;right = build(preorder, pstart + i - istart + 1, pend, inorder, i + 1, iend); return root;&#125; binary tree level order traversal ii题目描述Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). 题目解析代码实现1234567891011121314151617181920212223242526272829vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt;result; if(root==nullptr) return result; vector&lt;int&gt; temp; TreeNode *last=root; TreeNode *p; queue&lt;TreeNode *&gt;q; q.push(root); while(!q.empty()) &#123; p=q.front(); temp.push_back(p-&gt;val); q.pop(); if(p-&gt;left) q.push(p-&gt;left); if(p-&gt;right) q.push(p-&gt;right); if(p==last) &#123; result.push_back(temp); temp.clear(); last=q.back(); &#125; &#125; reverse(result.begin(),result.end()); return result; &#125; Minimum path sum题目描述Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.Note: You can only move either down or right at any point in time. 题目解析代码实现123456789101112131415161718192021222324int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123; int row = grid.size();//多少行 int col = grid[0].size();//多少列 vector&lt;vector&lt;int&gt; &gt;dp(row, vector&lt;int&gt;(col, 0)); dp[0][0] = grid[0][0]; //第一行 for (int i = 1; i &lt; col; i++) &#123; dp[0][i] = dp[0][i - 1] + grid[0][i]; &#125; //第一列 for (int i = 1; i &lt; row; i++) &#123; dp[i][0] = dp[i - 1][0] + grid[i][0]; &#125; for (int i = 1; i &lt; row; i++) &#123; for (int j = 1; j &lt; col; j++) &#123; dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; &#125; &#125; return dp[row-1][col-1];&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"vivo2020校招提前批开发笔试试题","slug":"vivo-2020-preexam-jun4th","date":"2019-06-05T08:46:20.000Z","updated":"2019-06-05T08:49:19.426Z","comments":false,"path":"2019/06/05/vivo-2020-preexam-jun4th/","link":"","permalink":"http://tech.yushuai.xyz/2019/06/05/vivo-2020-preexam-jun4th/","excerpt":"","text":"只能说自己水平太次，所以在笔试的时候只通过了1道题，复杂度还是O(n2)级别的。紧张什么的都不是理由。做完这道题，让我认识到我的水平距离秋招还太远太远。 vivo提前批笔试题整理寻找数组中不存在的元素题目描述A、B两个数组，要求输出A中存在而B中不存在的元素。例如 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void solution1(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123; int asize = a.size(); int bsize = b.size(); vector&lt;int&gt; result; for (int i = 0; i &lt; asize; i++) &#123; vector&lt;int&gt;::iterator it = find(b.begin(), b.end(), a[i]); if (it == b.end()) result.push_back(a[i]); &#125; int rsize = result.size(); if (rsize == 0) cout &lt;&lt; &quot;No match!\\n&quot;; else &#123; for (int i = 0; i &lt; rsize - 1; i++) cout &lt;&lt; result[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; result[rsize - 1] &lt;&lt; endl; &#125;&#125;int main()&#123; vector&lt;int&gt; a&#123; 3,2,8,5,7,4,9,1 &#125;; vector&lt;int&gt; b&#123; 3,8,1,9,5,10 &#125;; solution1(a,b); system(&quot;pause&quot;); return 0;&#125; 倒序链表中的两个元素之间的元素题目描述一个单向链表，输入m,n，要求在第m和第n区间之内的元素倒序存储并输出此链表。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x):val(x),next(NULL)&#123;&#125;&#125;;//vivo笔试中的解题方法//void reverseBetween(ListNode* head, int m, int n) &#123;// vector&lt;int&gt;temp;// ListNode *p=head;// while (p != NULL)// &#123;// temp.push_back(p-&gt;val);// p = p-&gt;next;// &#125;// reverse(temp.begin() + m - 1, temp.begin() + n);// int tsize = temp.size();// for (int i = 0; i &lt; tsize; i++)// &#123;// cout &lt;&lt; temp[i] &lt;&lt; &quot; &quot;;// &#125;// cout &lt;&lt; endl;//&#125;ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (!head || !head-&gt;next || n == m) return head; struct ListNode *L = (struct ListNode *)malloc(sizeof(struct ListNode)); L-&gt;next = head; //删除节点常用手段考虑加个头指针 struct ListNode* pre = NULL; struct ListNode* p = L; int temp_m = m; int temp_n = n; //将p转移到反转链表的第一个节点，pre保存前一个节点 while (temp_m-- &gt;= 1) &#123; pre = p; p = p-&gt;next; &#125; struct ListNode* reverse_head = NULL; struct ListNode* reverse_tail = p; struct ListNode* reverse_tail_after = NULL; struct ListNode* q = NULL; //进行反转 while (temp_n - m &gt; 0) &#123; q = p-&gt;next; reverse_tail_after = q-&gt;next; p-&gt;next = reverse_head; reverse_head = p; p = q; temp_n--; &#125; p-&gt;next = reverse_head; reverse_head = p; pre-&gt;next = reverse_head; reverse_tail-&gt;next = reverse_tail_after; return L-&gt;next;&#125;int main()&#123; ListNode *temp1 = new ListNode(1); ListNode *head = temp1; for (int i = 2; i &lt;= 10; i++) &#123; ListNode * newnode = new ListNode(0); newnode-&gt;val = i; newnode-&gt;next = NULL; temp1-&gt;next = newnode; temp1 = temp1-&gt;next; &#125; //reverseBetween(head, 3, 7); ListNode *result = reverseBetween(head, 3, 7); ListNode *p = head; while (p != NULL) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; &quot; &quot;; p = p-&gt;next; &#125; cout &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 0-1背包问题题目描述有n种礼品，每个礼品对应一个热度值，总金额为k，每个礼品只能买一次，如何购买可以使得所有礼品的总热度值最高。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** vivo2019提前批笔试第三题：* 小v负责一次活动礼品采购，每一款礼品的受欢迎程度(热度值)各不相同，现给出总金额以及各个礼品的单价* 和热度值，且每个礼品只购买一个，如何购买可以使得所有礼品的总热度值最高。* 输入：* 第一行是一个正整数，表示总金额(不大于1000)* 第二行是一个长度为n的正整数数组，表示礼品单价(n不大于100)* 第三行是一个长度为n的正整数数组，表示对应礼品的热度值* 输出：* 一个正整数，表示可以获得的最高总热度值** 样例输入：1000* 200 600 100 180 300 450* 6 10 3 4 5 8* 样例输出：21*/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution3(int total,int len, vector&lt;int&gt;price, vector&lt;int&gt;hot)&#123; vector&lt;vector&lt;int&gt; &gt; dp(len + 1, vector&lt;int&gt;(total + 1, 0)); for (int i = 1; i &lt;= len; i++) &#123; for (int j = 1; j &lt;= total; j++) &#123; if (price[i - 1]&gt;j) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - price[i - 1]] + hot[i - 1]); &#125; &#125; &#125; return dp[len][total];&#125;int main()&#123; int n, total;//商品数量和总价 int temp;//临时变量 cout &lt;&lt; &quot;请输入n和总价:&quot; &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; total;//输入商品数量值和商品总价 vector&lt;int&gt; hot; vector&lt;int&gt; price; //价格存入 cout &lt;&lt; &quot;请输入热度&quot; &lt;&lt; endl; for (int i = 0; i&lt;n; i++) &#123; cin &gt;&gt; temp; hot.push_back(temp); &#125; for (int i = 0; i&lt;n; i++) &#123; cin &gt;&gt; temp; price.push_back(temp); &#125; //下面开始进行处理 int result = solution3(total, n, price, hot); cout &lt;&lt; result &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"vivo","slug":"vivo","permalink":"http://tech.yushuai.xyz/tags/vivo/"},{"name":"exam","slug":"exam","permalink":"http://tech.yushuai.xyz/tags/exam/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"语音信号处理笔记（1）","slug":"speech-process-learning-notes-no1","date":"2019-05-31T07:42:50.000Z","updated":"2019-06-05T08:47:59.061Z","comments":false,"path":"2019/05/31/speech-process-learning-notes-no1/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/31/speech-process-learning-notes-no1/","excerpt":"","text":"1.声音三要素：音调、音色、响度。 2.汉明窗的好处：选择一个窗函数主要是看它的主瓣宽度和旁瓣衰减，理论上主瓣宽度越窄越好，旁瓣衰减越大越好。汉明窗是相比来说性能比较好的一个窗函数，比如矩形窗，虽然主瓣宽度较窄，但是旁瓣衰减不如汉明窗，所以谱泄漏比较严重。综合考虑来说汉明窗最好，它频谱泄露少，高频分量若，波动小，因而可以获得较平滑的谱。3.为何分帧：语音具有短时平稳性，但是长期来看并不平稳，为了利用这种平稳性，所以需要进行分帧，大约10~30ms。 4.为何重叠：实现两帧之间的平滑过渡、保持其连续性。 5.语音端点检测方法（语音活动检测）——两级判决法 （1）第一级判决。①先根据语音短时能量的轮廓选取一个较高的门限T1，进行一次粗判：语音起止点位于该门限与短时能量包络交点所对应的时间间隔之外。②根据背景噪声的平均能量确定一个较低的门限T2，并从A点往左、从B点往右搜索，分别找到短时能量包络与门限T2相交的两个点C和D，于是CD段就是用双门限方法根据短时能量所判断的语音段。 （2）第二级判决。以短时平均过零数为标准，从C点往左和D点往右搜索，找到短时平均过零数低于某个门限T3的两个点E和F，这便是语音段的起止点。门限T3是由背景噪声的平均过零数所确定的。6.语音信号的数字化和预处理。为了将模拟语音信号转化为数字信号，需要经过取样和量化两个步骤，以得到时间和幅度均离散的信号。 取样是将时间上连续的信号离散化为样本序列，根据奈奎斯特采样定理，取样频率大于信号两倍宽度时，取样过程不会丢失信息，且取样信号可精确地重构原信号。若不满足取样定理，将产生频谱混叠，此时信号中的高频成分将产生失真。 取样后需要对信号进行量化，即将时间上离散而幅度仍然连续的波形再离散化。其过程是将整个幅度值分割为有限个区间，将落入同一区间的样本赋予相同的幅度值。若量化阶梯选择的足够小(如64)，则信号幅度从一个取样值到相邻取样值的变化可能非常大，常跨越很多量化阶梯。这样产生的量化噪声接近平稳白噪声过程。一般而言，8bit时的噪声自相关函数几乎为冲激函数，与白噪声的过程相一致。 总的来说语音信号处理系统框图如下 为了防止混叠失真和噪声干扰，所以要设置一个反混叠滤波器。平滑滤波器的作用是对重构的语音波形的高次谐波起平滑作用。 7.短时能量分析 短时平均能量的定义： 8.基音周期估值 基音周期是表征语音信号本质特征的参数，只有准确分析病体区域出语音信号的特征参数，才能进行语音编码、语音合成和语音识别等处理。基音周期估值最基本的方法主要有两种：基于短时自相关法的基因周期估值和基于短时平均幅度差函数的基音周期估值。","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"Speech Process","slug":"Speech-Process","permalink":"http://tech.yushuai.xyz/tags/Speech-Process/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"Linux第八天：共享存储映射、匿名映射","slug":"linux-day-8-mmap","date":"2019-05-31T07:33:32.000Z","updated":"2019-05-31T07:34:57.707Z","comments":false,"path":"2019/05/31/linux-day-8-mmap/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/31/linux-day-8-mmap/","excerpt":"","text":"Linux第八天：共享存储映射、匿名映射知识点 共享内存mmap函数：参数、返回值。 借助共享内存访问磁盘文件：使用mmap将文件映射到内存，就可以使用指针来对文件进行操作。 父子进程（血缘关系进程）使用mmap通信 匿名映射区 共享存储映射文件进程间通信使用文件也可以完成IPC，理论依据是，fork后，父子进程共享文件描述符。也就共享打开的文件。 我们来看下面这段代码，这是一个父子进程共享打开的文件描述符（是结构体，不是那个数字），使用文件完成进程间通信。子进程向文件里面写入文件，父进程从文件里面读出信息来。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/wait.h&gt;int main(void)&#123; int fd1, fd2; pid_t pid; char buf[1024]; char *str = &quot;---test for shared fd in parent child process---\\n&quot;; pid = fork(); if (pid &lt; 0) &#123; perror(&quot;fork error&quot;); exit(1); &#125; else if (pid == 0) &#123; fd1 = open(&quot;test.txt&quot;, O_RDWR); if (fd1 &lt; 0) &#123; perror(&quot;open error&quot;); exit(1); &#125; write(fd1, str, strlen(str)); printf(&quot;child wrote over...\\n&quot;); &#125; else &#123; fd2 = open(&quot;test.txt&quot;, O_RDWR); if (fd2 &lt; 0) &#123; perror(&quot;open error&quot;); exit(1); &#125; sleep(1); //保证子进程写入数据 int len = read(fd2, buf, sizeof(buf)); write(STDOUT_FILENO, buf, len); wait(NULL); &#125; return 0;&#125; mmap函数函数功能： 函数原型：123#include &lt;sys/mman.h&gt;void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset);int munmap(void *addr, size_t length); 参数介绍：addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL length：欲创建映射区的大小 prot：映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE flags：标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区) MAP_SHARED: 会将映射区所做的操作反映到物理设备（磁盘）上。 MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。 fd：用来建立映射区的文件描述符 offset：映射文件的偏移(4k的整数倍)，可以把整个文件都映射到内存空间，也可以只把一部分文件内容映射到内存空间。 返回：成功：返回创建的映射区首地址；失败：MAP_FAILED宏 映射区：把磁盘空间上的一个文件映射到内存当中的一块缓冲区上。 munmap的作用就是释放掉所分配的内存。 例程：创建一个映射区，然后把字符串“abc”输出到硬盘字符文件中。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;//(f)truncate使用#include &lt;sys/types.&gt;//(f)truncate使用#include &lt;sys/mman.h&gt;int main(void)&#123; char *p = NULL;//我们想传一个字符串 int fd = open(&quot;mytest.txt&quot;, O_CREAT|O_RDWR, 0644); if(fd &lt;0)&#123; perror(&quot;open error:&quot;); exit(1); &#125; int ret = ftruncate(fd,4); if(ret == -1) &#123; perror(&quot;ftrucate error:&quot;); exit(1); &#125; p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);//void*可以和任何指针类型隐式转换，所以不需要强制转换 if(p == MAP_FAILED) &#123; perror(&quot;mmap error:&quot;); exit(1); &#125; strcpy(p,&quot;abc&quot;);//写数据，操作共享内存结束 int reet = munmap(p,len); if(ret == -1) &#123; perror(&quot;munmap error: &quot;); exit(1); &#125; close(fd); return 0; &#125; 使用mmap注意事项 使用malloc可以分配0字节大小的内存，但是用mmap却不能创建0字节大小的映射区。这要求我们：创建一个新文件以后一定要指定一定的大小才可以使用mmap。 如果我们分配映射区之后将首地址赋值给mem，这个时候我们将指针mem后移一位（++mem），那么输入内容还是可以输入的，但是munmap操作就会失败。这要求我们：在移动mem指针后，如果完成了所有操作，必须将mem移回初始位置。 如果open文件的时候设置的权限是只读（O_RDONLY），mmap的时候PROT参数指定为PROT_READ | PROT_WRITE，且设置为MAP_SHARED，那么就会报错，提示Permission denied。如果设置为MAP_PRIVATE，就会出现“总线错误（核心已转储）”。这要求我们：创建映射区的时候要小于等于打开文件的权限，映射区创建过程中隐含着一次对文件的读操作。 最后一个参数offset必须是4k的整数倍。这是因为映射是由MMU帮忙创建的，而MMU操作的基本单位就是4K，所以才会这样。 文件描述符先关闭，对mmap映射没有影响。所谓文件描述符是你用mmap进行映射的句柄，当映射建立以后，这个文件描述符就没有什么作用了。 mmap父子进程间的通信我们看如下例程：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/wait.h&gt;int var = 100;int main(void)&#123; int *p; pid_t pid; int fd; fd = open(&quot;temp&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644); if(fd &lt; 0)&#123; perror(&quot;open error&quot;); exit(1); &#125; unlink(&quot;temp&quot;); //删除临时文件目录项,使之具备被释放条件. ftruncate(fd, 4); p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); //p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0); if(p == MAP_FAILED)&#123; //注意:不是p == NULL perror(&quot;mmap error&quot;); exit(1); &#125; close(fd); //映射区建立完毕,即可关闭文件 pid = fork(); //创建子进程 if(pid == 0)&#123; *p = 2000;//将映射区第一个内存的值修改为2000 var = 1000; printf(&quot;child, *p = %d, var = %d\\n&quot;, *p, var); &#125; else &#123; sleep(1); printf(&quot;parent, *p = %d, var = %d\\n&quot;, *p, var); wait(NULL); int ret = munmap(p, 4); //释放映射区 if (ret == -1) &#123; perror(&quot;munmap error&quot;); exit(1); &#125; &#125; return 0;&#125; 这个例程的输出结果如下：child, p = 2000, var = 1000parent, p = 2000, var =100 为什么是这样的结果呢？这是由于我们在之前学习的时候就提到过：父子进程共享： 文件描述符(打开文件的结构体) mmap建立的映射区 (进程间通信详解) p位于映射区，而var是全局变量，位于0~3G的用户区，遵循读时共享写时复制的原则，子进程在修改的时候自动执行了复制操作，所以子进程只修改了自己复制的那一份的内容。 当我们把MAP_SHARED修改为MAP_PRIVATE时，父子进程独享内存映射区。所以次数的输出为child, p = 2000, var = 1000parent, p = 0, var =100 匿名映射通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。在mmap中使用MAP_ANONYMOUS (或MAP_ANON)参数。1p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0); 需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在其它类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。 fd = open(“/dev/zero”, O_RDWR); p = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); 其它类Unix系统包括IBM、苹果、惠普和sun等开发的商业版本以及BSD等。 mmap无血缘关系进程间通信实质上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。若想实现共享，当然应该使用MAP_SHARED了。 mmap_w.c1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;struct STU &#123; int id; char name[20]; char sex;&#125;;void sys_err(char *str)&#123; perror(str); exit(1);&#125;int main(int argc, char *argv[])&#123; int fd; struct STU student = &#123;10, &quot;xiaoming&quot;, &apos;m&apos;&#125;; char *mm; if (argc &lt; 2) &#123; printf(&quot;./a.out file_shared\\n&quot;); exit(-1); &#125; fd = open(argv[1], O_RDWR | O_CREAT, 0664); ftruncate(fd, sizeof(student)); mm = mmap(NULL, sizeof(student), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); if (mm == MAP_FAILED) sys_err(&quot;mmap&quot;); close(fd); while (1) &#123; memcpy(mm, &amp;student, sizeof(student)); student.id++; sleep(1); &#125; munmap(mm, sizeof(student)); return 0;&#125; mmap_r.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;struct STU &#123; int id; char name[20]; char sex;&#125;;void sys_err(char *str)&#123; perror(str); exit(-1);&#125;int main(int argc, char *argv[])&#123; int fd; struct STU student; struct STU *mm; if (argc &lt; 2) &#123; printf(&quot;./a.out file_shared\\n&quot;); exit(-1); &#125; fd = open(argv[1], O_RDONLY); if (fd == -1) sys_err(&quot;open error&quot;); mm = mmap(NULL, sizeof(student), PROT_READ, MAP_SHARED, fd, 0); if (mm == MAP_FAILED) sys_err(&quot;mmap error&quot;); close(fd); while (1) &#123; printf(&quot;id=%d\\tname=%s\\t%c\\n&quot;, mm-&gt;id, mm-&gt;name, mm-&gt;sex); sleep(2); &#125; munmap(mm, sizeof(student)); return 0;&#125; 最后在说几句，当我们新建了一块内存映射，我们应该把这块内存当做数组来看待。所谓mm或者说p指向了数组的首地址。 以上是我们针对非血缘关系进程在内存区进行操作，那么我们可否将文件作为通信的桥梁呢？答案是可以的。文件打开是得到文件结构体，文件结构体在内核中，a、b两个进程内核处于同一区域，所以是可以的。 strace函数1strace 可执行文件 可以追踪这个可执行文件使用到的系统调用有哪些。可以看到，我们在使用open/write/read函数的时候，系统底层都在使用mmap函数。","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://tech.yushuai.xyz/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://tech.yushuai.xyz/tags/centos/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"day7练习3:统计当前系统中进程由用户运行的进程并输出到文件中","slug":"linux-day-7-exercise3","date":"2019-05-31T07:29:00.000Z","updated":"2019-05-31T07:29:30.027Z","comments":false,"path":"2019/05/31/linux-day-7-exercise3/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/31/linux-day-7-exercise3/","excerpt":"","text":"day7练习3:统计当前系统中进程由用户运行的进程并输出到文件中题目描述统计当前系统中进程由用户运行的进程并输出到文件中。 题目解析统计当前系统中进程由用户运行的进程并输出到屏幕上的命令为：1ps -u xiaoao | wc -l 而在这里我们使用的代码有pipe()、fork()和dup2()等。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main()&#123; pid_t pid; pid_t wpid; int i; int n = 2; int fd[2]; //首先pipe int ret = pipe(fd); if(ret == -1) &#123; perror(&quot;pipe error:&quot;); exit(1); &#125; for(i=0;i&lt;n;i++) &#123; pid = fork(); if(pid == 0) break; &#125; //子进程1为兄，执行ps -u xiaoao if(i == 0) &#123; close(fd[0]); dup2(fd[1],STDOUT_FILENO); execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;-u&quot;,&quot;xiaoao&quot;,NULL); &#125; else if(i == 1) &#123; int fdff = open(&quot;day7out&quot;, O_RDWR | O_CREAT, 0644); if( fdff == -1) &#123; perror(&quot;File open error:&quot;); exit(1); &#125; close(fd[1]); dup2(fd[0],STDIN_FILENO); dup2(fdff,STDOUT_FILENO); execlp(&quot;wc&quot;,&quot;wc&quot;,&quot;-l&quot;,NULL); &#125; else &#123; close(fd[0]); close(fd[1]); do&#123; wpid = waitpid(-1, NULL, WNOHANG); if(wpid &gt; 0) n--; sleep(1); &#125;while(n &gt; 0); printf(&quot;Clean finished!!!\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://tech.yushuai.xyz/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://tech.yushuai.xyz/tags/centos/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"day7练习2：使用管道实现兄弟进程间通信","slug":"linux-day-7-exercise2","date":"2019-05-31T07:25:10.000Z","updated":"2019-05-31T07:35:08.171Z","comments":false,"path":"2019/05/31/linux-day-7-exercise2/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/31/linux-day-7-exercise2/","excerpt":"","text":"day7练习2问题描述使用管道实现兄弟进程间通信。 兄：ls 弟： wc -l 父：等待回收子进程。 题目解析与练习2题目类似，不再提供解析。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t pid; int i; int n=2; int fd[2]; int ret = pipe(fd); if(ret == -1) &#123; perror(&quot;pipe error:&quot;); exit(1); &#125; //创建两个子进程 for(i=0;i&lt;n;i++) &#123; pid = fork(); if(pid == 0) break; &#125; //子进程1：兄 if(i == 0) &#123; close(fd[0]); dup2(fd[1],STDOUT_FILENO); execlp(&quot;ls&quot;,&quot;ls&quot;,NULL); &#125; //子进程2：弟 else if(i == 1) &#123; close(fd[1]); dup2(fd[0],STDIN_FILENO); execlp(&quot;wc&quot;,&quot;wc&quot;,&quot;-l&quot;,NULL); &#125; //父进程 else &#123; close(fd[0]); close(fd[1]); sleep(2); for(i=0;i &lt; 2;i++) &#123; wait(NULL); &#125; &#125; return 0; &#125;","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://tech.yushuai.xyz/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://tech.yushuai.xyz/tags/centos/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"day7练习1：使用管道实现父子进程间通信，完成：ls | wc –l。","slug":"linux-day-7-exercise1","date":"2019-05-31T07:17:19.000Z","updated":"2019-05-31T07:35:12.565Z","comments":false,"path":"2019/05/31/linux-day-7-exercise1/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/31/linux-day-7-exercise1/","excerpt":"","text":"day7练习1题目说明使用管道实现父子进程间通信，完成：ls | wc –l。假定父进程实现ls，子进程实现wc 题目解析题目还是为了巩固我们对于pipe()以及fork()的使用，以及如何使用dup2()函数。这里面我就重点说一下pipe()和dup2()函数吧。其实正如学习笔记里面的那个例子，我们首先要新建一个int型的有两个元素的数组，这个数组作为pipe()的传出参数，担任着记录输入和输出的地址的重任。由于我们要求父进程担任传出端，子进程担任传入端，所以一定要记得分别关闭fd[0]和fd[1]（前者是读入，后者是写出）。 然后就是由于我们不再是在标准输入输出进行输入输出数据，所以要使用dup2对文件描述符的0和1进行重定向即可。 代码实现12345678910111213141516171819202122232425262728293031323334#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t pid; int fd[2]; int ret = pipe(fd); if(ret == -1) &#123; perror(&quot;pipe error:&quot;); exit(1); &#125; pid = fork(); //pid==0，即为子进程，从管道读数据 if(pid == 0) &#123; close(fd[1]);//关闭写端 dup2(fd[0],STDIN_FILENO);//本来wc从stdin读数据，现在把第0个文件描述符指向了fd[0] execlp(&quot;wc&quot;,&quot;wc&quot;,&quot;-l&quot;,NULL); &#125; //父进程，写数据到管道 else&#123; close(fd[0]);//关闭读端 dup2(fd[1],STDOUT_FILENO);//同理 execlp(&quot;ls&quot;,&quot;ls&quot;,NULL); &#125; return 0; &#125;","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://tech.yushuai.xyz/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://tech.yushuai.xyz/tags/centos/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"Linux第七天：exec、回收子进程和进程间通信","slug":"linux-day-7-exec","date":"2019-05-31T06:32:40.000Z","updated":"2019-05-31T07:35:27.118Z","comments":false,"path":"2019/05/31/linux-day-7-exec/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/31/linux-day-7-exec/","excerpt":"","text":"Linux第七天：exec、回收子进程和进程间通信exec函数族fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。 将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。 该函数族主要有以下六个：123456int execl(const char *path, const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *path, const char *arg, ..., char *const envp[]);int execv(const char *path, char *const argv[]);int execvp(const char *file, char *const argv[]);int execve(const char *path, char *const argv[], char *const envp[]); execlp函数功能：加载一个进程，借助PATH环境变量。参数说明：参数1：要加载的程序的名字。返回值：该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。该函数通常用来调用系统程序。如：ls、date、cp、cat等命令。该函数的参数数目是不确定的，file指的是传入的文件的名字（可执行参数的文件名），arg就是main(int argc, char[] argv)里面的argv[0]、argv[1]，argv[2]…以此类推。注意，以*NULL结尾。 测试代码：123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123; pid_t pid; pid = fork(); if(pid == -1) &#123; perror(&quot;Fork error:&quot;); exit(1); &#125; else if(pid &gt; 0) &#123; sleep(2); printf(&quot;This is parent process.\\n&quot;); &#125; else &#123; execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL); &#125; return 0;&#125; 输出结果： execl函数 功能：加载一个进程， 通过 路径+程序名 来加载。与execlp()函数相比，区别如下： execlp(“ls”, “ls”, “-l”, “-F”, NULL); 使用程序名在PATH中搜索。 execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL); 使用参数1给出的绝对路径搜索。 execle()函数：引入了环境变量表进行查询。 execv()函数：需要构建一个char* crgv[]数组。 execvp()函数：相当于execv()函数里面还需要借助PATH。 execve()函数：引入环境变量表进行查询。 例题：将当前系统中的进程信息，打印到文件中。 在bash中，我们可以执行这样的语句1ps aux &gt; out 这样就可以把当前进程信息打印到out文件中去了。但是使用exec编程的话就不能直接使用这个语句。 所以这个时候我们需要使用dup2()函数。即我们原来执行ps aux之后，系统将结果自动去找文件描述符为1的位置（也就是STDOUT），如果我们使用dup2()函数，将文件描述符为1的位置指向out的位置呢，那不就是结果会被输出到文件里面了吗。 所以总的来说我们的流程如下： 打开/新建out文件。若打开失败，则输出错误信息并退出，否则进行下一步。 执行dup2(fd,STDOUT_FILENO); 然后执行execlp程序。 最后无需关闭文件，因为execlp执行完就直接退出这个进程了，隐式回收自动把占用的内存回收。 代码如下：1234567891011121314151617181920212223242526#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main()&#123; //打开/创建文件 int fd=open(&quot;cenProcess&quot;,O_RDWR | O_CREAT|O_TRUNC,0644); if(fd == -1) &#123; perror(&quot;file open error:&quot;); exit(1); &#125; //dup2 dup2(fd,STDOUT_FILENO); //执行 execlp execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL); //如果没有错误就退出了，如果有错误就执行下面的语句 perror(&quot;Execlp error:&quot;); exit(1); return 0;&#125; exec函数族一般规律 exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，且返回值为-1。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。 exec后面的字符的意思如下： 参数 含义 l(list) 命令行参数列表 p(path) 搜索file的PATH变量 v(vector) 使用命令行参数组（charv()） e(environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量 只有execve是真正的系统调用，其它五个函数最终都调用execve，所以execve在man手册第2节，其它函数在man手册第3节。这些函数之间的关系如下图所示。 回收子进程孤儿进程：孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。 僵尸进程：进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。如下图所示。 kill只能终止进程，但是僵尸进程本身就已经终止了，那应该用怎样的方法来清除僵尸进程呢？使用wait()和waitpid()函数。 wait()函数一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。父进程调用wait函数可以回收子进程终止信息。该函数有三个功能： 阻塞等待子进程退出（父进程回收，如果子进程没死，那么父进程就在这里等着，父进程不做其他事情。） 回收子进程残留资源。 获取子进程结束状态(退出原因)。 函数原型：1234#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t wiat(int *status); 返回值：若成功则返回结束的子进程的PID，若失败则返回-1。 status是一个传出参数，它用来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组（前两组重点记住）： WIFEXITED(status) 为非0 → 进程正常结束WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数) WIFSIGNALED(status) 为非0 → 进程异常终止WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。 WIFSTOPPED(status) 为非0 → 进程处于暂停状态WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行 Linux中所有程序的终止都是接收到某个信号才会终止，父进程需要通过信号知道谁杀死了子进程才能进行回收。在接收到status信号的时候，执行以下的步骤： 先执行WIFEXITED(status)，判断进程是否是正常结束，若非0，则进程正常结束，然后调用WEXITSTATUS(status)来获取进程退出状态。 若为0，则判断WIFSIGNALED(status)，若非0，则是异常终止，执行WTERMSIG(status)，返回进程暂停的那个信号的编号。 waitpid()函数作用桶wait，但可以指定pid进程清理（第一个参数设置），可以不阻塞（第三个参数设置）。语法原型：1pid_t waitpid(pid_t pid, int *status, in options); 若成功，返回清理掉的子进程ID，若失败，则返回-1。若第三个参数为WNOHANG，且子进程正在进行，那么wiatpid就不会回收子进程，则返回0。 特殊参数和返回情况： 参数pid： pid 含义 &gt;0 回收指定ID的子进程 -1 回收指定ID的子进程 0 回收和当前调用waitpid一个组的所有子进程 &lt;-1 回收指定进程组的任意子进程 参数3：设置为0，则会阻塞；设置为WNOHANG就不会阻塞，去探测子进程是否结束，若结束就回收，否则不回收然后退出（如果想让它回收就得通过轮询方式，轮询方式见下面）；设置为WUNTRACED，若某实现支持作业控制，而由pid指定的任一子进程已处于暂停状态，但是其状态自暂停以后还未报告过，则返回其状态，WIFSTOPPED宏确定返回值是否对应一个暂停子进程；WCONTINUED-若支持作业控制，那么由pid指定的任一子进程在暂停后已经继续，但其状态未被报告，则返回其状态。 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。 轮询方式实现非阻塞进程回收：123456789pid_t wpid;int flag=5;//回收5个进程do&#123; wpid = waitpid(-1,NULL,WNOHANG); if(wpid &gt; 0) n--; //如果wpid==0说明子进程正在运行，前提是第三个参数设置为WNOHANG sleep(1);//为了不让这个轮询速度太快，所以加了个休眠时间&#125;while(n &gt; 0); 进程间通信前言部分Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，Inter Process Communication）。如下图所示： 在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有： 管道（使用最简单）。掌握pipe()函数，管道一般读写行为。 信号（开销最小）。fifo()（有名管道）用于非血缘关系进程间通信。 共享映射区（无血缘关系也可以传递）。共享内存：mmap()函数，父子之间或者非血缘关系进程之间通信，要注意函数参数使用注意事项，与管道相比，它可以反复读取。 本地套接字（最稳定，但时间复杂度最高、难度最大）。 假如我有两个程序（a.out和b.out）它们想要实现信息的传递，我们原来的方法可以是由于a.out和b.out共享一个打开的文件结构体，我可以在a.out打开一个文件，a.out有一个指向文件的文件描述符，然后把数据写入文件，然后b.out也打开这个文件，b.out就可以从这个文件读数据。a.out和b.out的4G进程空间是独立的。 它们的内核区虽然在虚拟内存区域不同，但是在物理内存上是同一块内存区域，所以我们可以通过一个管道实现信息的流出流入，实现一个单向的流入流出。 回顾下Linux里面的文件类型 符号 类型 是否占用存储空间 - 普通文件 √ d 目录 √ l 符号链接（软连接） √ s 套接字 × b 块设备 × c 字符设备 × p 管道 × 其中后面这四种（套接字、管道、字符设备、块设备）被称为伪文件，不占用存储空间。 管道管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质： 其本质是一个伪文件(实为内核缓冲区) 由两个文件描述符引用，一个表示读端，一个表示写端。 规定数据从管道的写端流入管道，从读端流出。 管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。 由于管道本质上是一个队列，所以它有先进先出的性质。由于它是一个队列，所以管道有以下局限性： 数据自己读不能自己写。 数据一旦被读走，便不在管道中存在，不可反复读取。 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。 只能在有公共祖先的进程间使用管道。 pipe()函数函数功能：创建管道,，同时将管道两端打开（两个文件描述符打开），并且作为函数参数传出来（pipefd[2]）。函数原型：12#include &lt;unistd.h&gt;int pipe(int pipefd[2]); 返回值：若执行成功则返回0，失败返回-1，错误记录在errno里面。 函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0]为读端； fd[1]为写端，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。 我们写一个例程，如下面代码所示。在这个例程，我们发现在fork()之前我们就执行了pipe()函数，也就是说我们的a.out掌握了读入和写出的两个文件描述符。 在pipe()函数之后，我们调用了一次fork()，创建出来了一个子进程，子进程也掌握着管道的两端（写入端、读出端）。形成了如下图所示的情况，我们发现对于同一个进程，它既可以读出来也可以写进去，并不是单向的。所以为了能够单向流动，我们需要规定除谁读谁写。 我们可以指定子进程读（需要将写端关闭掉），父进程写（需要将读端关闭掉）。由于人为规定（不是我规定的）了fd[0]为读端，fd[1]为写端，所以讲子进程的fd[1]close掉，将父进程的fd[0]close掉。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; int pipefd[2]; pid_t pid; int ret = pipe(pipefd); if(ret == -1)&#123; perror(&quot;pipe error:&quot;); exit(1); &#125; pid = fork(); if(pid == -1) &#123; perror(&quot;Fork error:&quot;); exit(1); &#125; //子，假设为读数据 else if(pid ==0) &#123; close(pipefd[1]); char* buff[1024]; ret = read(pipefd[0],buff,sizeof(buff));//从pipefd[0]也就三管道里面读取数据到buffer if(ret == 0) printf(&quot;-------\\n&quot;); write(STDOUT_FILENO,buff,ret); &#125; else &#123; close(pipefd[0]); char *str=&quot;This is your time.\\n&quot;; write(pipefd[1],&quot;This is your time.\\n&quot;,strlen(&quot;This is your time.\\n&quot;)); &#125; return 0;&#125; 管道的读写行为使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）： 如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。 如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。 如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。 如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。 总结： ① 读管道： 管道中有数据，read返回实际读到的字节数。 管道中无数据：(1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)(2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu) ② 写管道： 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止) 管道读端没有全部关闭：(1) 管道已满，write阻塞。(2) 管道未满，write将数据写入，并返回实际写入的字节数。 管道缓冲区的大小可以使用ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：pipe size (512 bytes, -p) 8 也可以使用fpathconf函数，借助参数 选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;1long fpathconf(int fd, int name); 成功：返回管道的大小 失败：-1，设置errno 管道的优缺点优点：简单，相比信号，套接字实现进程间通信，简单很多。 缺点： 只能单向通信，双向通信需建立两个管道。 只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。 FIFOFIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。 FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。 创建方式： 命令： mkfifo &lt;管道名&gt; 库函数： 1int mkfifo(const char *pathname, mode_t mode); 成功：0；失败：-1 一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://tech.yushuai.xyz/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://tech.yushuai.xyz/tags/centos/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"leetcode题目解析（190524）","slug":"leetcode190524","date":"2019-05-24T03:44:25.000Z","updated":"2019-07-02T14:10:55.984Z","comments":false,"path":"2019/05/24/leetcode190524/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/24/leetcode190524/","excerpt":"","text":"valid sudoku题目描述Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.The Sudoku board could be partially filled, where empty cells are filled with the character’.’. 题目解析数独具有以下规则： 每一行所有元素不能重复（1~9）； 每一列所有元素不能重复（1~9）； 由第3i~3(i)+2行和第3i~3(i)+2列组成的九宫格内元素不能重复（其中0&lt;=i&lt;n/3-1，元素仍为1~9）。 想到重复问题，自然而然我们想到了设置Flag的方法，由此我们可以设置3个n×n大小的矩阵来作为标志位： 第一个矩阵命名为fRow，作为判断每一行的数字是否重复的矩阵，因为元素只能为1~9，所以正好每行9个格子合适。 第二个矩阵命名为fCol，作为判断每一行列的数字是否重复的矩阵，因为元素只能为1~9，所以正好每行9个格子合适。 第三个矩阵命名为fMat，作为判断每个九宫格的数字是否重复的矩阵。 本题的特殊之处在于允许有空格的格子，且空格的地方以字符.表示，且所存储的数字都是char类型，因此首先要进行一个类型转换才能判断：12if(board[i][j] &gt;= &apos;1&apos; &amp;&amp; board[i][j]&lt;=&apos;9&apos;) int temp = board[i][j]-&apos;1&apos;; 若检测到该行出现这个数字，则设置该行这个位置为true，当又遍历到这个数字的时候，若检查发现这个位置已经设置为true了，则返回false。当然在实现代码的时候，要把判断放在前面，把设置标志位放在后面。 该方法的时间复杂度为O(n2)，空间复杂度为O(n2)。 代码实现12345678910111213141516171819202122232425bool isValidSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; int totalRows = board.size(); int totalCols = board[0].size(); if(totalRows == 0 || totalCols == 0) return false; vector&lt;vector&lt;bool&gt; &gt; fRow(totalRows,vector&lt;bool&gt;(totalCols,false));//行标志矩阵 vector&lt;vector&lt;bool&gt; &gt; fCol(totalRows,vector&lt;bool&gt;(totalCols,false));//列标志矩阵 vector&lt;vector&lt;bool&gt; &gt; fMat(totalRows, vector&lt;bool&gt;(totalCols,false));//9宫格标志矩阵 for(int i = 0;i &lt; totalRows; i++) &#123; for(int j = 0; j &lt; totalCols; j++) &#123; if(board[i][j] &gt;= &apos;1&apos; &amp;&amp; board[i][j]&lt;=&apos;9&apos;) &#123; int temp = board[i][j]-&apos;1&apos;; if(fRow[i][temp] || fCol[temp][j] || fMat[3*(i/3)+j/3][temp]) return false; fRow[i][temp] = true; fCol[temp][j] = true; fMat[3*(i/3)+j/3][temp] = true; &#125; &#125; &#125; return true; &#125; largest rectangle in histogram题目描述Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. For example,Given height =[2,1,5,6,2,3],return10. 题目解析我们以[2,1,5,6,2,3]为例来思考这个题目的思想。观察如图所示。 代码实现123456789101112131415161718192021222324252627282930313233int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; int maxarea = 0; stack&lt;int&gt;stk; for (int i = 0; i &lt; height.size(); i++) &#123; //如果堆栈是空的或者堆栈里面的最大数小于当前数组的元素，则当前数组元素入栈 if (stk.empty() || stk.top() &lt;= height[i]) stk.push(height[i]); else &#123; //如果堆栈非空且栈顶元素大于当前元素的话 int count = 0; while (!stk.empty() &amp;&amp; stk.top() &gt; height[i]) &#123; count++; maxarea = max(maxarea, stk.top()*count); stk.pop(); &#125; while (count--) stk.push(height[i]); stk.push(height[i]); &#125; &#125; int count = 1; while (!stk.empty()) &#123; maxarea = max(maxarea, stk.top()*count); stk.pop(); count++; &#125; return maxarea;&#125; pascals-triangle-ii题目描述Given an index k, return the k th row of the Pascal’s triangle.For example, given k = 3,Return[1,3,3,1]. 题目解析代码实现12345678910111213vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;vector&lt;int&gt; &gt; tempresult(rowIndex+1);//传回的二维数组 vector&lt;int&gt; result; for (int i = 0; i &lt;= rowIndex; ++i) &#123; tempresult[i].push_back(1); for (int j = 1; j &lt; i; j++) tempresult[i].push_back(tempresult[i - 1][j - 1] + tempresult[i - 1][j]); if (i &gt; 0) tempresult[i].push_back(1); &#125; return tempresult[rowIndex];&#125; Construct binary tree from preorder and inorder traversal题目描述Given preorder and inorder traversal of a tree, construct the binary tree.Note:You may assume that duplicates do not exist in the tree. 思路关于根据前序和中序如何得到二叉树的结构的计算方式，我就不重复了，之前的程序里面也有，这里就只说说代码里几个参数的思路。一定要做边界条件的判断！*12root-&gt;left = build(preorder, pstart + 1, pstart + i - istart, inorder, istart, i - 1);root-&gt;right = build(preorder, pstart + i - istart + 1, pend, inorder, i + 1, iend); 对于左子树处理来说，中序遍历所要处理的位置就是根节点左侧的所有数字，所以自然起始位置就是istart，结束位置就是i-1；对于前序遍历来说表示就麻烦一些，起始位置还好，是pstart+1,结束位置是pstart+(i-istart)，其中i-istart是左子树的元素数。对于右子树处理来说，中序遍历所要处理的位置就是根节点右侧的所有数字，所以自然起始位置就是i+1，结束位置就是iend；对于前序遍历来说，就是从左侧子树最后一个元素后面那个数字到最后一个，所以起始位置是pstart + i - istart + 1，结束位置是pend。 代码实现1234567891011121314151617181920212223242526272829TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; int presize = preorder.size(); int insize = inorder.size(); if (presize == 0 || insize == 0) &#123; return NULL; &#125; else if (presize != insize) return NULL; return build(preorder, 0, presize - 1, inorder, 0, insize - 1);&#125;TreeNode* build(vector&lt;int&gt;&amp;preorder, int pstart, int pend, vector&lt;int&gt;&amp;inorder, int istart, int iend)&#123; if (pstart &gt; pend || istart &gt; iend) return NULL; int mid = preorder[pstart]; TreeNode* root = new TreeNode(mid); int i = istart; for (; i &lt;= iend; ++i) &#123; if (inorder[i] == mid) break; &#125; root-&gt;left = build(preorder, pstart + 1, pstart + i - istart, inorder, istart, i - 1); root-&gt;right = build(preorder, pstart + i - istart + 1, pend, inorder, i + 1, iend); return root;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"论文阅读笔记20190521","slug":"paperreadnotes190521","date":"2019-05-21T12:46:52.000Z","updated":"2019-06-05T08:48:06.706Z","comments":false,"path":"2019/05/21/paperreadnotes190521/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/21/paperreadnotes190521/","excerpt":"","text":"Multi-channel signal enhancement with speech and noise covariance estimates computed by a probabilistic localization model前段时间阅读了一片来自于德国Carl von Ossietzky Universität Oldenburg的Jörn Anemüller和Hendrik Kayser的一篇论文，论文名字叫做《Multi-channel signal enhancement with speech and noise covariance estimates computed by a probabilistic localization model》，看完感觉还挺有借鉴意义的，所以做一个总结。 论文所提方法和旧方法的比较这篇文章提出了一种麦克风阵列语音增强的算法，这种算法也是基于传统MVDR算法改进而来，因为它采用了新的方式来估计所用的参数，所以效果相比传统方法来说好了很多。 我们都知道，MVDR算法所依赖的参数有两个，一个是噪声协方差矩阵Rnn，还有一个就是导向矢量h。这两个参数的估计准确度越高，自然波束形成的效果也就最好。传统方法对这两个参数的估计主要如以下： 对于噪声协方差矩阵来说，可以通过VAD进行语音段和噪声段的判断，然后在噪声段进行噪声协方差矩阵Rnn的计算，但是这种方法相对来说对VAD依赖很严重，一旦VAD性能下降，噪声协方差的估计自然也就下降，这种方法其实鲁棒性并不好。在单通道中，可以利用语音快于噪声功率谱密度的变化，所以可以用SPP算法来进行噪声估计。 对于导向矢量来说，可以使用时延估计模块，计算出到达各个麦克风的相对时延，然后代入公式进行计算；还有就是可以通过语音协方差矩阵变换来得到，也就是导向矢量可以近似表示为语音协方差矩阵最大特征值所对应的的特征向量。 对于这篇论文来说，它有以下这样几点新意： 论文中的方法利用了空间语音存在概率来获得导向矢量； 论文中的噪声协方差矩阵，本质上也是利用语音存在概率来获得的，具体方法在后面来说。 所以说这篇论文所提出的方法的参数只有一个，那就是语音存在概率map的估计。理论上来说，相比之前方法需要估计多个参数来说，这种只需要估计一个参数的方法只需要保证这个参数更加准确就好了。 论文所提方法的过程下面就来结合图来介绍下整个流程。 （自己画的图，为了防止不必要的麻烦就不放在这里了，直接借用论文里面的图） 第一步 Spatio-temporal speech probability map：使用GCC-PHAT（广义互相关函数-相位变换法）来进行时延估计，然后利用GCC-PHAT的结果，送入SVM进行训练得到source probability map，计算公式如下： 式中，θ表示位置索引、n表示时帧索引，k表示频宽索引，x(n,k)表示多通道语音的SFT。 第二步 Generalized speech and noise covariance estimation：上一步其实我们就得到了这个speech probability map，得到这个map之后，我们就可以带入下面这个公式来计算广义语音协方差矩阵： 在这里的xi和xj代表的是时域的信号，cij的定义如下 至于我们得到这个广义语音协方差矩阵是做什么用的呢？下一步就知道了。咱们接下来求解噪声协方差矩阵。我们知道了语音存在概率，那么我们就可以定义一个噪声存在概率。这个噪声存在概率的定义如下面的图中所示。其实这个时候我们要设置一个阈值p0：当ps≥p0的时候，噪声存在概率自然为0；当ps&lt;p0的时候，噪声存在概率为式中所述。记住无论是噪声存在概率还是语音存在概率，其都是第n帧的θ方向的概率。 根据噪声存在概率，仿照上面语音协方差矩阵的形式，就可以得到估计的噪声协方差矩阵，如下 到目前为止，MVDR算法所需要的两个参数中的噪声协方差矩阵这个参数已经求出来了。接下来求导向矢量。 第三步Steering Vector：前面说的语音协方差矩阵就是用到了这里，如下式所示： 其实就相当于求了一个单位向量而已。 然后把这个也带入MVDR的公示，就可以实现MVDR算法了。更多的内容可以参见论文，也就是参考文献中的论文。 【参考文献】 Anemüller J, Kayser H. Multi-channel signal enhancement with speech and noise covariance estimates computed by a probabilistic localization model[C]//2017 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP). IEEE, 2017: 156-160.","categories":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}],"tags":[{"name":"论文阅读笔记","slug":"论文阅读笔记","permalink":"http://tech.yushuai.xyz/tags/论文阅读笔记/"},{"name":"MVDR","slug":"MVDR","permalink":"http://tech.yushuai.xyz/tags/MVDR/"},{"name":"Spatio-temporal speech probability map","slug":"Spatio-temporal-speech-probability-map","permalink":"http://tech.yushuai.xyz/tags/Spatio-temporal-speech-probability-map/"},{"name":"noise covariance estimation","slug":"noise-covariance-estimation","permalink":"http://tech.yushuai.xyz/tags/noise-covariance-estimation/"}],"keywords":[{"name":"Speech Process Notes","slug":"Speech-Process-Notes","permalink":"http://tech.yushuai.xyz/categories/Speech-Process-Notes/"}]},{"title":"2019年牛客网校招全国同一模拟笔试（5月场）部分题目解析","slug":"nowcodermonimay","date":"2019-05-19T12:29:32.000Z","updated":"2019-05-19T12:37:00.608Z","comments":false,"path":"2019/05/19/nowcodermonimay/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/19/nowcodermonimay/","excerpt":"","text":"2019年牛客网校招全国同一模拟笔试（5月场）部分题目解析一、选择题部分1.有关多线程，多进程的描述错误的是 A.子进程获得父进程的数据空间，堆和栈的复制品B.线程可以与同进程的其他线程共享数据，但是它拥有自己的栈空间且拥有独立的执行序列C.线程执行开销小，但是不利于资源管理和保护D.进程适合在SMP机器上进行，而线程则可以跨机器迁移 解析： 对于A选项来说，创建子进程的时候，子进程会复制父进程用户空间的所有数据，子进程会复制父进程内核空间PCB中绝大多数数据（少部分例如进程ID、父进程的ID等数据不会复制）。数据空间、堆、栈都是在用户空间，故A选项正确。 对于B、C选项，在学习的时候有这句话原话，直接记住就好，D选项其实也有原话，但是下面解释一下。 SMP（Symmetric Multi Processing）是对称多处理系统，这种系统最大的特点就是共享所有资源；与之相对的是MPP SMP是Symmetric Multi Processing的简称，意为对称多处理系统，内有许多紧耦合多处理器，这种系统最大的特点就是共享所有资源。（Massively Parallel Processing），意为大规模并行处理系统，这样的系统是由许多松耦合处理单元组成的，这里指的是处理单元而不是处理器。每个单元内的CPU都有自己私有的资源，如总线、内存、硬盘灯。在每个单元内都有操作系统和管理数据库的实例副本。这种结构最大的特点在于不共享资源。 因而线程更适合在SMP机器上进行，而进程则可以跨机器迁移。 2.关于线程描述正确的是？ 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器,一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 重点：计算机网络（OSI层次、TCP/IP、数据包、UDP、子网划分、HTTP、HTTPS、TCP套接字和UDP套接字等）、加密解密算法（RSA等）、操作系统（进程、线程、操作系统调度、多进程多线程操作等）。 编程题一：牛牛数星星牛牛把星星图看成一个平面，左上角为原点（坐标(1,1)）。现在又n颗星星，他给每颗星星都标上坐标(xi,yi)，问m个问题，给你两个坐标(a1,b1)和(a2,b2)表示一个矩形的左上角和右下角。在这个矩形里面有多少个星星？（边界上的星星也算矩形内的）。 输入： 1234第一行输入n：星星数接下来n行，每行两个值分别代表星星的坐标，(1&lt;=xi,yi,&lt;=1000)然后输入m：表示m个问题接下来m行，每行4个数字分别代表a1,b1,a2,b2。 输出： 1输出m行分别代表m个问题的答案。 做题时的思路做题的时候我思考的更多是如何直接去解决这个问题，并没有观察一些规律。我当时的想法很简单，就是在这个矩形里进行遍历。 我首先新建一个1001*1001的矩阵，然后第0行和第0列全部置零（我是考虑因为题目说从坐标（1,1）开始，为了转换麻烦所以把第0行第0列置空，从第1行第1列开始），然后把所有对应星星的坐标处的值全部置为1，这样没有星星的地方全部为0。 然后针对每个问题，设置一个temp=0，遍历两个坐标所围成的矩形，然后判断当前点是否为1，如果为1则++temp，最后得到的temp值就为所需要的答案。 这个方法时间复杂度为O(n^3)，在实际运行中，通过率80%，显然出现了超时问题。 思路优化版本我上面这个版本其实非常糟糕，因为最多我们可能有10万颗星星，也就达标者最多10万次的查询，O(n^3)是非常可怕的。我们可以换一种思路。 如下图，是这个想法的一个总的示意图，右下角红色加粗黑框里面就是我们要求的矩形部分。 我们首先找这个点左上方有多少个星星，就是下图所示，至于我们为什么要求这部分面积，后面就知道了。 然后我们还可以求矩形右下角左上方里面的点，如下橘色部分所示然后再求矩形左下角那个点的左上方的部分，如下图紫色所示。再求矩形右上角左上方的部分，如下图绿色所示。 然后你就会发现下面两个点： 上面求各个矩形里面的有多少个星星，实际上都是求某一点左上方一直到边界有多少颗星星，这说明它们可以用同样的递推公式来求解。 我们所要求的的红色黑框部分的里面的星星=橘色框里面的星星-紫色框里面的星星-绿色框里面的星星+蓝色框里面的星星（因为紫色框和绿色框的重叠部分是蓝色框，所以蓝色框被多减了一次）。 那么实际上这样，我们只需要遍历一次1000*1000的地图就行了，每个查询可以O（1）来获取。实际复杂度降为了O(n^2)，大小还算可以接受。 代码实现（做题时的版本）123456789101112131415161718192021222324252627282930313233343536int main()&#123; long n,m; int x, y, a1, b1, a2, b2; cin &gt;&gt; n; vector&lt;int&gt;rows(1001, 0); vector&lt;vector&lt;int&gt; &gt; matrix(1001, rows); for (long i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; y; matrix[x][y] = 1; &#125; cin &gt;&gt; m; vector&lt;int&gt;result(m, 0); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; a2 &gt;&gt; b2; int temp=0; for (int j = a1; j &lt;= a2; j++) &#123; for (int k = b1; k &lt;= b2; k++) &#123; if (matrix[j][k] == 1) ++temp; &#125; &#125; result[i] = temp; &#125; //test for (int i = 0; i &lt; m; i++) &#123; cout &lt;&lt; result[i] &lt;&lt; endl; &#125; //system(&quot;pause&quot;); return 0;&#125; 代码实现（优化版本）123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int maxx = 1005; int n, m; int x, y, a1, b1, a2, b2; vector&lt;int&gt;rows(maxx, 0); vector&lt;vector&lt;int&gt; &gt; matrix(maxx, rows);//标志该位置是否有星星，有为1，没有为0 vector&lt;vector&lt;int&gt; &gt;num(maxx, rows);//点的坐标为num的x和y值，这一矩阵上的每一个点的值为左上方的星星点数 cin &gt;&gt; n; //第一步：存入值 for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; y; matrix[x][y] = 1; &#125; //计算Num的值 for (int i = 1; i &lt; maxx; i++) &#123; for (int j = 1; j &lt; maxx; j++) &#123; num[i][j] = num[i - 1][j] + num[i][j - 1] + matrix[i][j] - num[i - 1][j - 1]; &#125; &#125; cin &gt;&gt; m; vector&lt;int&gt;result; //红色黑框部分的里面的星星=橘色框里面的星星-紫色框里面的星星-绿色框里面的星星+蓝色框里面的星星 for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; a2 &gt;&gt; b2;; int temp = num[a2][b2] - num[a1 - 1][b2] - num[a2][b1 - 1] + num[a1 - 1][b1 - 1]; result.push_back(temp); &#125; for (int i = 0; i &lt; m; i++) cout &lt;&lt; result[i] &lt;&lt; endl; //system(&quot;pause&quot;); return 0;&#125; 编程题2：牛牛与世界杯门票牛牛叫n个小伙伴去莫斯科看世界杯，门票有m种套票，每种套票x元，包含y张门票，当然也可以单独购买门票，此时门票k元。请选择花费最少的方案。 输入12第一行输入n(0&lt;=n&lt;=999),m(1&lt;=m&lt;=1000),k(1&lt;=k&lt;=100000)。接下来m行，每行输入xi(1&lt;=xi&lt;=100000）和yi(2&lt;=yi&lt;=1000)表示套餐价格和门票数量。 输出1最少花费的价格。 做题思路我的做题思路是： 第一步，设置一个存储所有可能取到的价格的vector，命名为price。第二步，计算方案1：全部采用单买门票方式，价格push进入price。第三步，计算所有方案的性价比（包括只买门票的方式），并将它们按照单价从小到大排列。第四步，新建变量sum，表示每个方案的结果，新建变量i，表示第i个方案。然后使用for循环，从第1个方案开始（i=0），判断是否符合i&lt;m+1且剩余人数大于当前方案人数，若符合则将sum=sum+plan.value，剩余人数people=people-plan.person。第五步，判断剩余人数people是否等于0，若等于0，将sum数值push进入price，然后执行第六步；否则，分别计算再购买第i到第m-1（计数从0开始）个方案的价格，共m-i+1个数，push进入price，同时还有一种方案是使用单独买票来补充，push进入price。第六步，寻找sum中的最小值，即为最小的花费。 可能会存在第三到第五步里面重复了方案1，但是因为只是寻找最小值，所以重复也没关系。时间复杂度是O(nlogn)，虽然时间复杂度较低，但是空间复杂度较高。而且只通过了30%。 优化版做题思路这个题可以看做是一种完全背包问题。人的个数相当于背包的容量，票的价格相当于价值，dp[i]表示买到i张票时的最小花费为dp[i]，最后dp[n]就是买n张票时候的最小花费（n是加上牛牛自己）。这是采用动态规划来解决这个问题。动态规划就是两种情况，当我们第i个人的时候，我们可以有这样两种思路： 当前人数i小于该方案的人数y，那就判断当前方案的结果和只采用套餐的结果哪个更实惠。 如果当前人数i大于等于该方案的人数y，那么就判断当前方案的结果和i-y个人用原来的方案，后面y个人用当前套餐哪个更实惠。 所以就可以写出下面的代码。 代码实现（自己的思路）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct pack &#123; int sprice; int num; double price;&#125;p[1001];bool cmp(pack a, pack b)&#123; return a.price &lt; b.price;&#125;//假设实际有h个人，套餐已经按照平均价格从低到高进行了排序。我们要从平均价格最低的开始买，int main()&#123; int n, m,ans; vector&lt;int&gt; price;//设置一个存储所有可能取到的价格的vector，命名为price。 int k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;//输入n个人，m个方案，单买票价k元 //每个方案的总价、数量和单价 for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; p[i].sprice &gt;&gt; p[i].num; p[i].price = (double)(p[i].sprice / p[i].num); &#125; //第二步：计算方案1：全部采用单买门票的方式，价格push进入price。 int alldan = k*(n + 1); price.push_back(alldan); //第三步：把他们按照单价从小到大排列 sort(p, p + m, cmp); //第四步：新建变量sum，表示每个方案的结果，新建变量i，表示第i个方案。 int sum = 0; int i=0; int people = n + 1; for (; (i &lt; m) &amp;&amp; (people &gt;= p[i].num); i++) &#123; sum+=p[i].sprice; people -= p[i].num; &#125; //第五步：判断剩余人数people是否等于0，若等于0，将sum数值push进入price，然后执行第六步 if (people &lt;= 0) &#123; ans = min(alldan, sum); &#125; else &#123; //否则，分别计算再购买第i到第m-1（计数从0开始）个方案的价格，共m-i+1个数，push进入price int sum1 = sum; for (; i &lt; m; i++) &#123; sum += p[i].sprice; price.push_back(sum); &#125; //同时还有一种方案是使用单独买票来补充，push进入price sum1 += people*k; price.push_back(sum1); &#125; sort(price.begin(), price.end()); ans = price[0]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 优化版代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n, m, k, x, y; vector&lt;int&gt;dp(1005,0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; ++n; for (int i = 1; i &lt;= n; i++) &#123; dp[i] = i*k; &#125; while (m--) &#123; cin &gt;&gt; x &gt;&gt; y; for (int i = 1; i &lt;= n; i++) &#123; if (i - y &gt;= 0) dp[i] = min(dp[i], dp[i - y] + x); else dp[i] = min(dp[i], x); &#125; &#125; int result = dp[n]; cout &lt;&lt; result &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 编程题3：牛牛游玩记又是晴朗的一天，牛牛的小伙伴们都跑来找牛牛去公园玩。但是牛牛想呆在家里看E3展，不想出去逛公园，可是牛牛又不想鸽掉他的小伙伴们，于是找来了公园的地图，发现公园是由一个边长为n的正方形构成的，公园一共有m个入口，但出口只有一个。公园内有一些湖和建筑，牛牛和他的小伙伴们肯定不能从他们中间穿过，所以只能绕行。牛牛想知道他需要走的最短距离并输出这个最短距离。 输入1234第一行输入一个数字n(1≤n≤1000)表示公园的边长接下来会给你一个n*n的公园地图，其中 . 表示公园里的道路，@表示公园的入口，*表示公园的出口，#表示公园内的湖和建筑。牛牛和他的小伙伴们每次只能上下左右移动一格位置。输入保证公园入口个数m(1≤m≤10000)且所有的入口都能和出口相连。 输出：1牛牛行走的最短距离 代码思路这个题虽然有很多个入口，1个出口，但是我们可以很容易想到加上一个源点，将所有的入口与源点相连接，这样就形成一个我们熟悉的图像了。我们只要把所有起点在一开始就放入到深度优先搜寻的队列中，后面按照普通的深度优先（BFS）写即可。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 1e3 + 5;const int dx[] = &#123; 0, 1, 0, -1 &#125;;const int dy[] = &#123; -1, 0, 1, 0 &#125;;struct node &#123; int x, y;&#125;;int n, m;int dis[maxn][maxn];char mp[maxn][maxn];node a, ed;int main() &#123; memset(mp, 0, sizeof(mp)); memset(dis, -1, sizeof(dis)); queue&lt;node&gt; q; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; mp[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (mp[i][j] == &apos;@&apos;) &#123; a.x = i; a.y = j; q.push(a); dis[i][j] = 0; &#125; if (mp[i][j] == &apos;*&apos;) &#123; ed.x = i; ed.y = j; &#125; &#125; &#125; while (q.size()) &#123; node p = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) &#123; int px = p.x + dx[i]; int py = p.y + dy[i]; if (dis[px][py] == -1 &amp;&amp; px &gt;= 0 &amp;&amp; px &lt; n &amp;&amp; py &gt;= 0 &amp;&amp; py &lt; n &amp;&amp; mp[px][py] != &apos;#&apos;) &#123; node pp; pp.x = px; pp.y = py; q.push(pp); dis[px][py] = dis[p.x][p.y] + 1; if (px == ed.x &amp;&amp; py == ed.y) break; &#125; &#125; if (dis[ed.x][ed.y] != -1) break; &#125; cout &lt;&lt; dis[ed.x][ed.y]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"模拟笔试","slug":"模拟笔试","permalink":"http://tech.yushuai.xyz/tags/模拟笔试/"},{"name":"C++","slug":"C","permalink":"http://tech.yushuai.xyz/tags/C/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"leetcode题目解析（190513）","slug":"leetcode190513","date":"2019-05-13T02:13:22.000Z","updated":"2019-10-21T08:23:25.575Z","comments":false,"path":"2019/05/13/leetcode190513/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/13/leetcode190513/","excerpt":"","text":"Search for a range题目描述Given a sorted array of integers, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n).If the target is not found in the array, return[-1, -1].For example,Given[5, 7, 7, 8, 8, 10]and target value 8,return[3, 4]. 题目解析关键词：有序数组、复杂度O(logn)。这就很明显说明了一件事，题目想让我们使用二分查找的方法来实现。在C++的STL里面，已经由现成的函数帮我们实现返回第一个位置和最后一个位置的函数，也就是low_bound()和upper_bound()。 low_bound()和upper_bound()都是使用二分查找实现查找工作，两者都是返回一个迭代器（iterator），但是不同的是，low_bound()返回的是第一个大于或等于num的数字，找到返回该数字的地址，（若数组中没有该元素，则返回end），upper_bound()返回第一个大于num的数字的位置（如果数组没有该元素，同理）。因此，如果我们对low_bound()返回的地址减去起始地址，就得到了第一次出现目标数字的位置，对upper_bound()减去起始地址，就得到了目标数字下一个位置，再减1，得到最后一次出现目标数字的位置。代码实现见代码实现1。 这是一种取巧的方法，使用了STL中的Algorithm。但是，这样除了展示你会使用STL中的algorithm之外没有任何用处，所以还是需要去实现这个寻找过程。这个过程就是实现二分查找。 其实现具体过程很基础，不再重述。 代码实现1123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;//故意把所需要包含的头文件注明了using namespace std;vector&lt;int&gt; searchRange(int A[], int n, int target) &#123; vector&lt;int&gt; result(2,-1);//默认2个值，均为-1 //若传递过来的参数不合理，直接返回result if(A==nullptr || n&lt;=0) return result; //数组不是STL标准的容器，其没有真正的iterator，所以退化为了指针，用指针来表示 auto low=lower_bound(A,A+n,target)-A;//auto类型应该为int if(low==n||A[low]!=target) return result; //以上是说若在数组内没有找到target，那么high也不用找，直接返回result auto high=upper_bound(A,A+n,target)-A-1; result[0]=low; result[1]=high; return result;&#125; 代码实现2123456789101112131415161718192021222324252627282930vector&lt;int&gt; searchRange(int A[], int n, int target) &#123; vector&lt;int&gt;result(2, -1); if (A == nullptr || n &lt;= 0) return result; int low = 0, high = n - 1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;1; if (A[mid] &lt; target) low = mid + 1; else high = mid - 1; &#125; int low2 = 0; int high2 = n - 1; while (low2 &lt;= high2) &#123; int mid2 = (low2 + high2) &gt;&gt; 1; if (A[mid2] &lt;= target) low2 = mid2 + 1; else high2 = mid2 - 1; &#125; if (low &lt;= high2) &#123; result[0] = low; result[1] = high2; &#125; return result;&#125; Validate Binary Search Tree题目描述Given a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows:The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than the node’s key.Both the left and right subtrees must also be binary search trees. 题目解析代码实现1123456789101112131415161718192021bool isValidBST(TreeNode *root) &#123; if(root==nullptr) return true; if(root-&gt;left) if(toRight(root-&gt;left)-&gt;val&gt;=root-&gt;val) return false; if(root-&gt;right) if(toLeft(root-&gt;right)-&gt;val&lt;=root-&gt;val) return false; return isValidBST(root-&gt;left)&amp;&amp;isValidBST(root-&gt;right);&#125;TreeNode* toLeft(TreeNode* root)&#123; while(root-&gt;left) root=root-&gt;left; return root;&#125;TreeNode* toRight(TreeNode *root)&#123; while(root-&gt;right) root=root-&gt;right; return root;&#125; 代码实现2","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"平遥-灵石王家大院-太原三日游记","slug":"pingyao-lingshi-taiyuan-3days","date":"2019-05-12T07:41:34.000Z","updated":"2019-05-12T07:42:35.503Z","comments":false,"path":"2019/05/12/pingyao-lingshi-taiyuan-3days/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/12/pingyao-lingshi-taiyuan-3days/","excerpt":"","text":"平遥+王家大院+太原游记 一直以来都特别希望去平遥玩，但是都是因为没有时间+自己各种懒而作罢，今年终于确定下来要清明节去玩，但是在清明节之前突然宣布五一放四天假，于是果断把行程修改到了五一假期。图片使用GITHUB的服务器存储，故国内访问速度可能较慢，请谅解。 Day 1: 西安-平遥乘坐车次：D2510（西安北-太原南）游览景点：平遥古城-&gt;雷履泰旧居-&gt;平遥县衙-&gt;中国镖局博物馆-&gt;日升昌记-&gt;蔚泰厚 我们是乘坐动车（西安到太原一线因大西高铁降标，最高设计时速只有250km/h），车次是D2510次列车，由西安北开往太原南方向，值乘列车是CRH2G，车号是4106，就是下面就是关于这个车次的信息，小盘和车号。 特别注意：感觉自己一定要提醒自己，就是节假日的早晨在西安一定要早出发。我们是9点46分的高铁，从学校出发的时候8点10分，按理说正常应该是50分钟就可以到达，但是实际磨蹭磨蹭走的时候就差不多8点半了，然后只能果断打车，打车但是因为节假日，路上还是比较堵的，所以到最后能按时到达西安北站实属不易。 正点12点07抵达了平遥古城站。可以说平遥古城站门口的马路真的是十分宽敞，几乎都没有一辆车通行，大量出租车排队等着接客，但是我们还是选择了乘坐黑车，直接送到了古城的西北门。不得不说，平遥古城站门口的宽敞的路≠平遥县城里面的马路宽敞，县城马路稍显破旧。下面给平遥古城站一个正面照。 下车之后，并没有把行李放在酒店，而是直接进入古城开始浏览。有意思的是，在刚入古城以及在古城中，还看到不少推着车子卖周村烧饼的，突然有一种亲切感，因为小时候，家乡的路边也有不少人推着一模一样的车子卖着周村烧饼，当然由于时间限制并没有去尝一尝。 古城还是很有气息的，走进城墙不久，就看到这样的大牌坊，颇有一种明清之风（虽然应该是现代修修建）。然后我们就用学生证购买了平遥古城的门票。平遥古城全价门票旺季130元，（网上购买可以到123~125元不等），学生票65，所以买来学生票还是比较划算的。 其实原来是有计划游玩路线，就是从北门入然后一路走过来，但实际上因为计划赶不上变化，就放弃了。实际上我们进的第一个景点就是雷履泰旧居。 雷履泰故居 雷履泰是中国第一家票号——日升昌的创始人，是中国金融业的泰斗。他其实从小就在赌场干伙计，后被东家发掘，由东家出钱创办了日升昌票号。有意思的是，“日升昌”这个名字据说是有一天傍晚雷履泰吃完晚饭后溜了一圈回屋睡觉，突然看见铺面斜对门的火器厂内着火了，他急忙赶到木器厂前看，原来是一个金碧辉煌的大院，然后他一下惊醒，发现竟是一个梦，他根据这个梦思索想到了“日升昌”这个名字。后来，由于雷履泰太过于霸道的管理风格，在一次雷履泰病了之后，东家请二掌柜毛鸿翙主持事务，但是雷履泰不愿意放权，毛鸿翙变离开创办了蔚泰厚票号，成为了平遥城内的第二家票号。 平遥县衙 在离开雷履泰故居之后，我便来到了平遥县衙。平遥县衙是现存最完整的一个古代县衙。正如图中所示，平遥县衙人真的是多得很，所以五一期间平遥古城也取消了著名的县太爷升堂表演，让我感觉很遗憾没有看到这个过程，我一直很期待的。看下图，平遥县衙其实很大的，他里面包括了大堂、二堂、牢狱（应该也是国内现存唯一完整的牢狱）、十王庙、督捕厅、内宅、大仙楼、花厅等。大堂是进行刑事审判的地方，而二堂就是进行民事调解的地方。在大堂两侧，还有中国古代文官和武官官服的介绍，很有意思，内宅就是县太爷住的地方，大仙楼花厅等，就相当于县太爷的“御花园”。 大堂楹联：“吃百姓之饭穿百姓之衣莫道百姓可欺自己也是百姓”；“得一官不荣失一官不辱勿说一官无用地方全靠一官”。二堂楹联“与百姓有缘才到此地”；“期寸心无愧不负斯民”。 在县衙看到，古代的县太爷年薪非常少，他还要承担师爷等人的报酬，因此往往自己都没有钱花，所以经常会压榨老百姓。后来清朝雍正年间推出了养廉银制度，县太爷每年可以发4000两银子（我记得如此），突然想到，现在不也是有一些人提出高薪养廉吗？其实如出一辙。说实话，理论上这确实可以避免大部分底层贪污的人，但是我感觉，对于高层贪污来说，可能作用不是很大。不过话说回来，我其实挺支持公务员工资能够适当提高，待遇还是该有要有。很多人说公务员有五险一金，大部分普通工作者都没有五险一金，所以公务员不应该提高待遇。但是实际上，难道不应该是普通工作者来要求保证五险一金吗？也许这确实很难，但是并不能说自己得不到，别人有的，就说这是别人的福利，这明明是最基本的权利。特别是现在基层公务员，尤其是应急岗位的公务员，常常是007工作制，24小时待命，加班到很晚，却不可能会有任何加班费，难道他们就应该白干活？说实话，我认为当别人的权利能得到一些保障，而自己权利完全得不到保障的时候，不应该是让别人变得和自己一样，而应该让自己的权利得到维护才可以。 从县衙出来，中午没吃饭的我们便快速赶到了位于南大街上的晋升炉食铺，购买了网红双人套餐，有平遥牛肉、栲栳栳、碗托、两杯晋升炉油茶等，还是感觉不错。 中国镖局博物馆 吃完饭之后，就去了旁边的中国镖局博物馆。镖局博物馆位于原来镖局，真实再现了当年镖局的许多场景。镖局走镖，北至塞外大漠，南达江汉海滨，水旱两路行镖，既辛苦又十分危险。平遥先后有同兴公镖局等，镖局大都是习武之人或者退伍之人。博物馆里面还展示了他们当时的饮食内容，有猪肉、牛肉、鸡鸭、海产品等，可以说已经是非常丰盛了。 日升昌记 五一的平遥古城简直太多人了，街道就像济南的芙蓉街、西安的回民街一样拥挤。原计划很快浏览完多个景点，实际快到下班了才浏览了3个。最后选择了区浏览日升昌记，了解中国第一票号的历史。 入门右侧便见：谨防假票冒取，勿忘细视书章。 看来在近代中国还没有先进防伪技术的时候，大家还是会通过书章来进行辨别真伪。 日升昌的出现，结束了中国镖局押送现银的落后金融局面，极大地加速了商业运转和货币流通，有力地推动了社会经济迅猛发展。光绪二十六年，八国联军攻占北京，平遥票号全力承担了国家财政职能，协同庆票号为慈禧太后和光绪皇帝设置行宫等行为，为号后来得到官方大力支持奠定了基础。 然而，民国时期，处在半殖民地半封建社会的中国，风雨飘零，平遥的各大票号也难以逃脱，平遥票号开始走向衰落。可以说，平遥的票号见证了中国近代金融业的发展、壮大和衰落。 Day 2：平遥-灵石王家大院-太原游览景点：平遥古城墙、王家大院车次：D2563次（太原南-宝鸡南）、D1960次（重庆西-太原南）。 以上是在城墙上拍的平遥古城照片，就此别过平遥。离开平遥前，吃了平遥的手擀面牛肉，自我感觉并不好吃。 赶到高铁站，乘坐了D2563次快速赶往了灵石。一般情况下，从平遥可以坐长途汽车去往灵石，也可以坐高铁到介休然后转车到王家大院，但是我们选择坐高铁到灵石然后去往王家大院。这次乘坐的车次依旧是CRH2G，当然编号改为了2423。10几分钟就到达了灵石东站。可能由于灵石本身不如平遥有名，所以灵石东站的规模也非常小了。 王家大院 凡语必忠信，凡行必笃敬。饮食必慎节，字画必楷正。容貌必端正，衣冠必肃整。步履必安详，居处必正静。作事必谋始，出言必顾行。常德必固持，然诺必重应。见善如己出，见恶如己病。凡此十四者，我皆来深省。书此当坐隅，朝夕视为警。 前往王家大院的方式我们选择了打车。五一期间正常打车应该非常贵的，几乎所有车辆是无法进入王家大院附近区域。我们打车找了一个师傅，约定好往返一共30块钱，相对来说还是比较合算的。灵石王家大院是静升（现灵石县静升镇）王氏家族明清两朝300多年修建的家族建筑，包括五巷六堡一条街，面积要远远大于注明的乔家大院，但是票价却远远低于乔家大院。旺季门票55元，我们买了学生票是30元。王家大院总体布局如下，图来自于百度地图。我们租了讲解器，所以是按照所推荐的线路来玩。要想知道当天客流量有多少，看图中排队就知道了。 王家大院作为王氏家族的住宅，将对子女的教育和房屋的设计充分融合在了一起。可以看到，在不少院子的墙上、柱子上、门上的装饰，都是展现了对子女教育的重视，自然结果是王家为官者居多，特别是清康熙、乾隆、嘉庆年间，王家入宦者仅五品至二品官员就有42人，包括授、封、赠在内的各种大夫达101人，还有两人分别于康熙六十一年（1722年）和嘉庆元年（1796年）参加了朝廷举办的千叟宴。 王家大院的牌匾也是一大特色。与其他地方牌匾用来展示自家被奖赏的功绩不同，王家大院的牌匾仍然以教育子女为主。就像下面的“规圆矩方”，矩中多一点，意为规矩多一点，烦恼少一些。 勤治生俭养德四时足用，忠持己恕及物终身可行。这是位于恒贞堡二甲西司马第后院隔墙上的石雕联，意为：以勤谋生计，经营家业，以简朴养德性，一年四季就可以财用富足；以诚实的态度立身修身，严格要求自己，以宽容的态度恩济万物，这是一个人一生应该践行的高尚品德。 男女有别、长幼有序、尊卑有分，内外有异，王家大院处处彰显着中国传统的家文化。 最后用一张王家大院照片作为结尾。历经几百年繁荣发展，即便是如此重视教育的王氏家族，在清末也走上了坐吃山空的道路。子弟不争，日趋奢靡，最后经沉迷于鸦片不能自拔，甚至最后靠卖宅院为生，流落街头，真的是令人唏嘘。 离开灵石，我们便乘坐由重庆西开往太原南的D1960次列车前往本次旅程的重点——太原。乘坐的列车是CRH380A，编号2690。 抵达太原已经是快8点了，在太原南站吃过庆丰包子之后，便匆匆去往酒店。非常值得一提的是，在坐公交车的时候看到了由莱钢房地产开发的小区，还看到了茂业天地，然后在买完水果回酒店的路上，竟然遇到了卖油酥火烧的，非常开心，当然，它不仅是山东莱芜泰安地区的特色美食，这也是当地的一款特色美食。 Day 3：太原-西安浏览景点：柳巷（美食街）-&gt;山西博物院乘坐车次：D2529次 一大早起床，我们就赶往了柳巷和美食街。在路上，遇到了女朋友一直跟我推荐的太原注明的板栗品牌——岭峥炒栗。 岭峥炒栗确实比较实在，明显感觉出量要比学校附近购买的板栗要足，同时颗粒也非常饱满好剥皮，真的是非常喜欢。 在之后，我们又在美食街门口遇到了太原非常注明的名吃——上帝炸鸡。 上帝炸鸡最著名的就是它的鸡腿，但是由于条件和时间关系，我们没有买鸡腿，而是买了鸡排和鸡块，总体感觉还是鸡块好吃一些。 美食街 美食街是太原一大小吃一条街，类似于西安回民街和济南的芙蓉街、青岛的劈柴院，但是因为是现代建设，所以马路还是比较宽敞。小吃也比较多。 山西博物院 由于时间原因，我们放弃了中国煤炭博物馆的参观，直接来到了山西博物院，了解山西和晋商的历史。 山西位于中国中部，其北面均为大山，中南部地势较为平缓，所以形成了北部较为贫穷落后、中南部发达人口稠密的布局。山西西接古都西安，东临海滨山东，北接都城，南临江南之地，所以在历史上成为了重要的战略要地，自古以来就是文明的发源地之一。周时有强大的诸侯国晋国，魏晋南北朝时期成为北魏首都所在地（今山西大同），同时有丰富的佛教雕像，明清时期产生了许多著名的晋商，成为当时中国商业最为发达的地区之一。当时的票号分布遍及中国，甚至还分布在朝鲜和日本。 个人感悟任何辉煌都无法逃脱最后衰败的现实，即便是盛极一时的晋商中的日升昌、蔚泰厚等票号，还有出过上百名官宦的灵石王氏家族。历史就是这么令人唏嘘。 初到平遥古城，看到宽敞而又干净的马路，感觉心旷神怡，但是进入平遥县城，缺乏县城稍显破旧。古城中没有路灯，全靠居住城中的人私接线路，酒吧许许多多，但厕所仍按人次收费，古城中不少现代的房屋，很多房子也有一种岌岌可危的感觉，曾闻古城墙也有坍塌多处，即便是限制除了参观区之外的古城墙也有落土块的危险。进入几个收费的博物馆，在墙上挂着展示的当时的书信和文献（不知是原件还是复制品）有的都已掉落，上面布满灰尘，可以说屋内即便是下午三四点钟都漆黑一片，怪不得晚上6点就会关门。其实说实话在平遥古城还是稍微有一些失望的，也许跟当地政府只是一个县城有关系，但是作为世界文化遗产的平遥古城，也应该值得更好的保护和有序的开发吧。 来到灵石，位于乡镇上的王家大院可谓交通非常不方便，但是除此之外，其它仍然还算好。王家大院是我所欣赏的官员耿彦波比较出名的第一个作品，可以看出其对于灵石王家大院的保护和重视，作为一个中国传统士大夫性格的官员，其对于中国传统文化的保护和发展还是值得肯定的。 王家大院中关于做人、做事的教育可谓遍布所有建筑的设计之中，在其中漫步，感受到了古人的思想，感受到了其实古人所谓修身养性的正确性。也许在这样一个浮躁的社会中，这样一个凡事都要被喷的社会中，也需要经常来这里看看走走，才能提示自己保持真正奋斗的自我。 来到太原，三晋大地之上最为繁华的都市，也是耿彦波仕途的最后一站。与曾经作为中国煤炭主产地的印象中那种脏乱差不同，现在的太原真的是一座充满生机与活力的城市。到处的高架、宽敞的道路，为太原的发展注入了新的活力，城市的发展感觉是日新月异，这与济南是截然不同。 耿彦波是一个非常具有争议的官员。支持他的人，认为他推动了经济转型，挖掘了当地的历史文化，为灵石、大同后来的发展，特别是大同蓝奠定了基础；反对他的人认为他大拆大建，浪费人力物力，有些地方破坏了历史的原貌。 其实在我看来，应该从多方面来看待这个问题，我们对任何事情都不能以一个标准来判断。在大同期间，耿彦波强制拆迁了大量的贫民窟和楼房，重建起来了北魏古城，虽然都是现代建筑，但是保留了历史的传承，让中国人真正回顾发生在自己祖国土地上的历史。建筑只是载体，而不是历史本身，如果你只是要历史年代感，脚下的土地都是上万年的，不也一样？ 对于大同这样一个煤都城市，城市发展转型刻不容缓，也正因为耿彦波的抓住历史机遇，才让大同迎来了新的发展，太原也是同样。反观我的故乡山东，和山西一样是能源大省，另外也是制造业大省，但是却没有抓住转型的机会，特别是我的家乡莱芜，更是得到了最后被合并的结局。曾经我以为，别的省份的发展是因为国家的政策偏倚，山东并没有政策偏倚。后来我发现我错了。山东的发展问题、人才流失问题，本质上不在于国家的政策问题，而在于其自身问题。国家给予山东“国家新旧动能转换综合试验区”这一光荣使命之后的2年，山东本质上的发展仍然停留在纸面上，行动上不是没有，而是非常缓慢，其主要体现在如下几点： 规划混乱、空洞，定位不明。在2018年1月，国务院正式批复《山东新旧动能转换综合试验区建设总体方案》后，山东到目前为止已经公布过多个发展规划，在这些规划中，对于城市的发展布局是非常混乱的，经常一个规划里面说这个城市发展这个行业，到了另一个规划就布局另一个产业，甚至规划一些没有基础的行业，让我感觉是纸上谈兵。 规划执行力严重滞后。就拿2011年通过的《山东半岛城市群城际轨道交通线网规划（2011~2020）》来说，近期规划了济南至青岛、济南至德州、济南至泰安、济南至莱芜、青岛至日照、济南-聊城、济南-滨州、滨州-东营、泰安-济宁、东营-潍坊等城际铁路，虽然后来进行了调整，但除了国铁部分的济青高铁、青连铁路之外，没有一条哪怕是开始修建的。2014年，国家发改委批复《环渤海地区山东省城际轨道交通网规划（调整）》，里面的近期项目，除了国铁济青高铁、鲁南高铁、潍莱高铁之外，剩余5条高铁一条也没有开工，甚至说剩余5条高铁只有一条（济莱高铁）完成了前期工作（前期工作做了至少5年），一条高铁处在预可研阶段，其它3条毫无动静。济南省会城市群成立到现在5年时间，至今没有一条可以便捷快速连接济南与城市群其它城市的快速通道，省会城市群除了济南莱芜实现了同城化（后合并），济南与其它城市没有任何同城化的实质性操作。2018年，山东省在《山东省综合交通网中长期发展规划（2018-2035）》提出建设“四横六纵三环”综合通道布局，包括北部沿海通道、济青通道、鲁中通道、鲁南通道、东部沿海通道、京沪二通道、滨临通道、京沪通道、京九通道、省会环、半岛环、省际环，又画了一张大饼，前途堪忧。 基础设施严重落后。现有铁路、高铁通道太少，济南因为位于京沪高铁线路之上所以才通达率很高，机场标准低、数量少。看兄弟省份，虽然山西高铁仅有大西高铁和青太客专，但山西已经实现了太原到周边城市的通航直达；河南郑州已建成“米”字型高铁网络，陕西高铁近年来开工率很高，建设加速，“米”字型高铁网络已经初具规模，同时也实现了部分省内城市间的通航。以上三省至少省会机场等级高、配套设施完善、交通、中转服务完善。反观山东的机场，除了即将启用的青岛胶东国际机场，其它城市（包括济南）的机场都十分落后，标准低，配套服务设施、交通、中转服务极度不完善甚至压根没有。 创新观念缺失，对于人才缺乏重视的诚意。即便进入了新旧动能转换这一新时期，仍然拘泥于原来的重能源、重制造，对于先进制造业的重视程度仍然不够，对于新思想新东西仍然难以接受，凤凰茶社的事情就足以说明这些问题，可笑的是，从各地政府对于凤凰茶社事件的反思整改来看，仍然都是明显应付，没有真正认识到创新的重要性，提出的整改政策大都十分空洞，没有可执行性。另外，人才引进政策缺乏诚意，难以留住人才，更别说引进人才。 可以说，山东只有敞开心扉，改革、开放才能真正实现凤凰涅槃、浴火重生。 作为一个游记，写了这么多，也是把自己很多心里话写了出来，终于也算完成了一个任务吧。","categories":[{"name":"Life","slug":"Life","permalink":"http://tech.yushuai.xyz/categories/Life/"}],"tags":[{"name":"life","slug":"life","permalink":"http://tech.yushuai.xyz/tags/life/"},{"name":"history","slug":"history","permalink":"http://tech.yushuai.xyz/tags/history/"}],"keywords":[{"name":"Life","slug":"Life","permalink":"http://tech.yushuai.xyz/categories/Life/"}]},{"title":"Linux第六天：进程（下）","slug":"Linuxday6-process-2","date":"2019-05-08T07:12:02.000Z","updated":"2019-05-08T07:01:30.856Z","comments":false,"path":"2019/05/08/Linuxday6-process-2/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/08/Linuxday6-process-2/","excerpt":"","text":"Linux第六天：进程（下）进程控制fork函数 作用：创建一个子进程。 原型：12#include &lt;unistd.h&gt;pid_t fork(void); 描述：成功返回两个值： 父进程返回子进程的ID(非负) 子进程返回 0 返回值-1表示出错。 pid_t类型表示进程ID，但为了表示-1，它是有符号整型。(0不是有效进程ID，init最小，为1) 实际上，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子需各自返回一个。如下图所示。 创建的一个子进程，从fork()函数后开始执行，而不是从头开始执行。 示例1：创建一个子进程测试代码：1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123; printf(&quot;xxxxxxxx\\n&quot;); pid_t pid; pid = fork(); if(pid == -1) &#123; perror(&quot;Fork Error:&quot;); exit(1); &#125; else if(pid == 0) &#123; printf(&quot;This is child process. My pid = %u\\n&quot;,getpid()); printf(&quot;And my parent process is %u\\n&quot;, getppid()); &#125; else &#123; printf(&quot;This is parent process, and pid is %u\\n&quot;,getpid()); printf(&quot;My parent process is %u\\n&quot;,getppid()); sleep(1); &#125; printf(&quot;This is the end of this process.\\n&quot;); return 0;&#125; 测试结果： 可执行程序的运行结果正如我们前文所述。首先执行fork()前面的语句，只执行一遍，打印出来了xxxxxxxx。然后开始打印输出父进程的东西，打印出来了父进程的PID和父进程的父进程的PID，（由于这个时候对父进程执行了休眠1秒钟，所以父进程的This is the end of this process被延迟到最后来执行了。）然后打印子进程的信息，输出子进程的This is the end of this process。 注意，如果父进程不执行sleep(1)的话，父进程的最后那句This is the end of this process可能会穿插在子进程输出信息中输出。 父进程的父进程是什么呢？我们执行ps aux | grep 7921 就可以看到了7921实际上是bash的进程PID。 示例2：循环创建3个子进程 假如我们是这样设计的，那么正确吗？1234for(int i=0;i&lt;3;i++)&#123; fork();&#125; 实际上，是创建了7个子进程（还有1个父进程）,即(2n-1)个子进程，如图所示。 修改为：12345678910111213141516171819202122232425int main(void)&#123; int i; pid_t pid; printf(&quot;xxxxxxxxxxx\\n&quot;); for (i = 0; i &lt; 5; i++) &#123; pid = fork(); if (pid == 0) &#123; break; &#125; &#125; if (i &lt; 5) &#123; sleep(i); printf(&quot;I&apos;am %d child , pid = %u\\n&quot;, i+1, getpid()); &#125; else &#123; sleep(i); printf(&quot;I&apos;m parent\\n&quot;); &#125; return 0;&#125; 这个程序在进入for循环的含义是：当i=0的时候，执行fork()函数，创建出一个子进程来（将子进程命名为子0），此时子进程返回的pid=0，然后判断符合pid==0，执行break语句，跳出for循环，父进程则因为不符合这个if语句，因而进行下一个循环；当i=1的时候，执行fork()函数，创建出一个子进程来（将子进程命名为子1），此时子进程返回的pid=0，然后判断符合pid==0，执行break语句，跳出for循环，父进程则因为不符合这个if语句，因而进行下一个循环；当i=2的时候，执行fork()函数，创建出一个子进程来（将子进程命名为子2），此时子进程返回的pid=0，然后判断符合pid==0，执行break语句，跳出for循环，父进程则因为不符合这个if语句，因而进行下一个循环……一直到i=4执行完成后退出，后续又产生了子3、子4。 对于子0来说，此时i=0，执行if(i&lt;5)里面的语句，休眠0秒钟，输出子进程0的信息；对于子1来说，休眠1秒钟，输出子进程1的信息，以此类推。对于父进程来说，执行完for循环之后，i=5，因此休眠5秒钟。所以将按照子进程0~4、父进程的顺序显示。 其实父进程和子进程没有优先级，谁都有可能抢到，但是无论谁抢到了，其都需要挂起i秒，所以到最后还是按照我们想要的顺序来输出结果。 但是如果我们去掉挂起i秒这个语句，五个进程和1个父进程是可以看做共同争夺CPU，不会存在父进程因为循环五次而慢于5个子进程的情况。 如上图所示，之所以在输出I’m parent之后就又显示出bash等待命令的界面是因为，bash在执行命令后就会切到后台，但是只要看到父进程的return 0后就会自动切换前台，但是它这个时候并不知道还有子进程在运行，所以才会出现它和剩余的子进程进行抢夺CPU资源，结果就是它有可能比所有剩余的子进程优先抢到CPU，得到图中的结果，也有可能某个子进程先抢到，所以会出现下图的样子。 父子进程共享父子进程之间在fork后。有哪些相同，那些相异之处呢？刚fork之后：父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式…父子不同处: 进程ID fork返回值 父进程ID 进程运行时间 闹钟(定时器) 未决信号集 似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？ 当然不是!父子进程间遵循读时共享写时复制的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。 【重点】：父子进程共享： 文件描述符(打开文件的结构体) mmap建立的映射区 (进程间通信详解) 特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法。 GDB调试使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。 设置gdb在fork之后跟踪子进程：1set follow-fork-mode child 设置跟踪父进程：1set follow-fork-mode parent 注意，一定要在fork函数调用之前设置才有效。 如果是在多个子线程中跟踪第3个子进程，那么直接在相应的判断语句中设置条件断点即可。","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://tech.yushuai.xyz/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://tech.yushuai.xyz/tags/centos/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"Linux第六天：进程（上）","slug":"Linuxday6-process","date":"2019-05-08T06:50:32.000Z","updated":"2019-05-08T07:01:32.776Z","comments":false,"path":"2019/05/08/Linuxday6-process/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/08/Linuxday6-process/","excerpt":"","text":"Linux第六天：进程（上）课程知识点框架本部分课程的知识体系： 进程相关的概念 并发 单道程序设计 多道程序设计 cpu/mmu 进程控制块-进程状态 环境变量 常用的环境变量/作用 函数（了解） 进程控制原语 fork函数：循环创建子进程的架构。 exec函数族：了解各个函数的参数使用方法和作用 wait/waitpid：回收子进程的一般方式。 程序、进程和并发程序，是指编译好的二进制文件，在磁盘上，不占用系统资源（cpu、内存、打开的文件、设备、锁……）。 进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程) 打个比方，程序就相当于一个剧本，而进程就相当于上演的一出戏（包括舞台、演员、灯光等就是系统资源）。剧本可以在多个舞台同时上演，同样，同一个程序也可以加载为不同的进程（彼此之间互不影响）。 所谓并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但任一个时刻点上仍只有一个进程在运行。 单道程序设计就是所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。 多道程序设计就是在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。总体来看（宏观上）它们是并行执行，从具体某个时间点来看（微观上），是串行的。 每个程序被分为了多个时间轮片，然后在CPU控制下执行完这个程序的时间轮片，再去执行另一个，然后循环往复，也就是分时复用。多道程序设计必须有硬件基础作为保证。 时钟中断即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。 CPU和MMUCPU的架构（具体参加计算机组成原理课程内容，在这里不做笔记）： MMU（内存管理单元）位于CPU内，图如下： 功能主要是： 实现虚拟内存和物理内存的映射。 设置修改内存访问级别。虚拟内存中分为用户区（0~3G）和内核区（3G~4G），两个区域的访问权限不一致，MMU可以设置CPU的内存访问级别。 MMU分配内存最小单位是page，是4kb。在MMU进行映射的时候，对于用户区，不同的进程映射不同的区域，但是对于内核区，不同的进程映射同一块区域，但是两个进程的PCB是不同的，只是在同一块内存里面。 进程控制块（PCB）进程控制块（PCB）也被称为进程描述符。每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。 这个结构体内部成员有很多，可以重点掌握以下部分： 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。 进程的状态，有就绪、运行、挂起、停止等状态。 进程切换时需要保存和恢复的一些CPU寄存器。 描述虚拟地址空间的信息。MMU维护，存储在PCB里面。 描述控制终端的信息。 当前工作目录（Current Working Directory）。 umask掩码。 文件描述符表，包含很多指向file结构体的指针。 和信号相关的信息。 用户id和组id。 会话（Session）和进程组。 进程可以使用的资源上限（Resource Limit）。可以使用ulimit -a来查看当前使用系统资源的上线。 进程基本的状态有5种。分别为初始态（进程准备），就绪态（准备结束，等待CPU分配时间片），运行态（占用CPU运行），挂起态（等待除CPU以外的其它资源，主动放弃CPU）与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。 环境变量环境变量，是指在操作系统中用来指定操作系统运行环境的一些参数。通常具备以下特征：① 字符串(本质) ② 有统一的格式：名=值[:值] ③ 值用来描述进程环境信息。存储形式：与命令行参数类似。char *[]数组，数组名environ，内部存储字符串，NULL作为哨兵结尾。 使用形式：与命令行参数类似。 加载位置：与命令行参数类似。位于用户区，高于stack的起始位置。 引入环境变量表：须声明环境变量。extern char ** environ; 编写程序，实现输出环境变量的程序。 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;extern char **environ;int main(void)&#123; int i; for (i = 0; environ[i] != NULL; i++) printf(&quot;%s\\n&quot;, environ[i]); return 0;&#125; 常用的环境变量： PATH：可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out，这是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值 SHELL：当前Shell，它的值通常是/bin/bash。 TERM：当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程序的输出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。 LANG：语言和locale，决定了字符编码以及世界、货币等信息的显示格式。 HOME：当前用户主目录的路径。 常用的环境变量函数： getenv函数：获取环境变量值 函数原型：1char *getenv(const char *name); 函数返回值：成功：返回环境变量的值；失败：NULL (name不存在) setenv函数：设置环境变量 函数原型：1int setenv(const char *name, const char *value, int overwrite); 参数overwrite取值：1位覆盖原有环境变量；0为不覆盖（改参数常用于设置新的环境变量）。 函数返回值：成功：返回0；失败：返回-1。 unsetenv函数：删除环境变量name的定义 函数原型：1int unsetenv(const char *name); 注意事项：name不存在仍返回0(成功)，当name命名为”ABC=”时则会出错。 函数返回值：成功：返回0；失败：返回-1。 测试代码如下：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *val; const char *name=&quot;ABCD&quot;; val = getenv(name); printf(&quot;1,%s = %s\\n&quot;, name ,val); setenv(name,&quot;I-love-you&quot;,1); printf(&quot;setenv()以后的结果\\n&quot;); val = getenv(name); printf(&quot;2, %s = %s\\n&quot;,name,val);#if 0 int ret = unsetenv(&quot;ABCDEFG&quot;); printf(&quot;ret = %d\\n&quot;, ret); val = getenv(name); printf(&quot;3, %s = %s\\n&quot;,name,val);#else int ret = unsetenv(&quot;ABCD&quot;); printf(&quot;ret = %d\\n&quot;,ret); val = getenv(name); printf(&quot;3, %s = %s\\n&quot;,name, val);#endif return 0;&#125;","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://tech.yushuai.xyz/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://tech.yushuai.xyz/tags/centos/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"递归读目录获取普通文件个数","slug":"di-gui-du-mu-lu-wen-jian-ge-shu","date":"2019-05-06T13:48:21.000Z","updated":"2019-05-06T13:49:47.648Z","comments":false,"path":"2019/05/06/di-gui-du-mu-lu-wen-jian-ge-shu/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/06/di-gui-du-mu-lu-wen-jian-ge-shu/","excerpt":"","text":"递归读目录获取普通文件个数功能说明递归进入当前目录及其子目录，遇到普通文件就对计数加1，遇到目录就进入目录，但并不做加1操作，最后输出普通文件个数。 使用的函数1.opendir()函数：打开一个目录2.readdir()函数：读目录。这个函数为核心，判断当前目录是否是普通文件，根据其返回的结构体中的d_type来进行判断。3.closedir()函数：关闭目录。 使用到的头文件对每个函数使用man命令查看帮助，或者在.c文件中将光标放在该函数名上，按shift+k也可以查看帮助。 1234#include &lt;sys/types.h&gt;//opendir、closedir使用#include &lt;dirent.h&gt;//opendir、closedir使用#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; 打开目录、遍历目录和关闭目录打开目录打开目录类似于打开文件，同样需要对是否出现错误进行判断，若出现错误则输出错误信息，然后退出。12345678//打开目录 DIR* dir = NULL; dir = opendir(root); if(dir == NULL) &#123; perror(&quot;Open dir error:&quot;); exit(1); &#125; 遍历目录 由于readdir()函数的返回值是一个结构体，且当文件已经读完的时候返回NULL，因此可以利用是否返回NULL来作为判断循环结束的条件。 12345struct dirent* dr = NULL;while((dr = readdir(dir))!= NULL) &#123; ... &#125; 关闭目录直接执行关闭目录即可：1closeret = closedir(dir); 设计程序的时候的注意事项 在读到普通目录的时候，我们要进入子目录，但是若读到.（当前目录）和..（上一级目录），我们就需要将它们排除在外。其原理就是使用strcmp()函数判断当前的名称是否是.或者..，若是则直接跳过，进行下一次循环。实现如下： 1234if(strcmp(dr-&gt;d_name, &quot;.&quot;) == 0 || strcmp(dr-&gt;d_name, &quot;..&quot;) == 0 ) &#123; continue; &#125; 读普通目录，进入子目录进行递归计数。子目录的文件名需要我们进行拼接，也就是使用sprintf()函数。代码如下： 123456if(dr-&gt;d_type == DT_DIR) &#123; //递归读目录 sprintf(path,&quot;%s/%s&quot;,root,dr-&gt;d_name); total += getFileNum(path); &#125; 对于遇到普通文件，则直接对total进行+1，实现如下： 1234if(dr-&gt;d_type == DT_REG) &#123; total++; &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;int getFileNum(char* root)&#123; //打开目录 DIR* dir = NULL; dir = opendir(root); if(dir == NULL) &#123; perror(&quot;Open dir error:&quot;); exit(1); &#125; int total=0; //遍历当前目录 struct dirent* dr = NULL; char path[1024] = &#123;0&#125;; while((dr = readdir(dir))!= NULL) &#123; //过滤.和.. if(strcmp(dr-&gt;d_name, &quot;.&quot;) == 0 || strcmp(dr-&gt;d_name, &quot;..&quot;) == 0 ) &#123; continue; &#125; //遇到目录，进入目录 if(dr-&gt;d_type == DT_DIR) &#123; //递归读目录 sprintf(path,&quot;%s/%s&quot;,root,dr-&gt;d_name); total += getFileNum(path); &#125; //如果是普通文件 if(dr-&gt;d_type == DT_REG) &#123; total++; &#125; &#125; //关闭目录 int closeret = closedir(dir); if(closeret == -1) &#123; perror(&quot;Close File error:&quot;); exit(1); &#125; return total;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2) &#123; printf(&quot;Usage: ./filecount &lt;dir&gt;\\n&quot;); exit(1); &#125; int result = getFileNum(argv[1]); printf(&quot;目录 %s 共有普通文件 %d 个\\n&quot;,argv[1],result); return 0;&#125; 实现结果","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://tech.yushuai.xyz/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://tech.yushuai.xyz/tags/centos/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"利用stat函数实现ls- l filename功能","slug":"ls-lfilenamebystat","date":"2019-05-05T14:32:54.000Z","updated":"2019-05-05T14:33:38.267Z","comments":false,"path":"2019/05/05/ls-lfilenamebystat/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/05/ls-lfilenamebystat/","excerpt":"","text":"利用stat函数实现ls- l filename功能功能&amp;函数介绍在我们使用 ls -l 命令的时候，会输出下面的结果： 在这里，我使用stat函数来实现这一功能。我们知道，stat函数提供了一个结构体，其内容为： 123456789101112131415struct stat &#123; dev_t st_dev; //文件的设备编号 ino_t st_ino; //节点 mode_t st_mode; //文件的类型和存取的权限 nlink_t st_nlink; //连到该文件的硬连接数目，刚建立的文件值为1 uid_t st_uid; //用户ID gid_t st_gid; //组ID dev_t st_rdev; //(设备类型)若此文件为设备文件，则为其设备编号 off_t st_size; //文件字节数(文件大小) blksize_t st_blksize; //块大小(文件系统的I/O 缓冲区大小) blkcnt_t st_blocks; //块数 time_t st_atime; //最后一次访问时间 time_t st_mtime; //最后一次修改时间 time_t st_ctime; //最后一次改变时间(指属性)&#125;; 基于此，我们就可以获取到我们想要的信息。根据图片中使用ls -l获得到的信息，我们知道我们需要获得的是块数、文件的类型和存取的权限、硬连接数目、用户ID、组ID、最后一次修改时间、文件名等信息。接下来我们可以分别来进行写。 下面开始讲解这个程序。 头文件首先是所用到的头文件12345678#include &lt;stdio.h&gt; //perror和printf等使用#include &lt;unistd.h&gt; //stat使用#include &lt;sys/stat.h&gt; //stat使用#include &lt;sys/types.h&gt; //stat、getpwuid、getgrgid使用#include &lt;pwd.h&gt;//getpwuid使用#include &lt;grp.h&gt;//getgrgid使用#include &lt;time.h&gt; //输出时间ctime使用#include&lt;stdlib.h&gt; //exit使用 文件类型我们知道，首先要显示的是文件类型，而文件类型则可使用stat结构体中的st_mode与上S_IFMT即可得到相应的文件类型，然后我们可以使用一个switch判断即可。相应的文件类型分别是： 字符表示 八进制表示 文件类型名称 S_IFSOCK 0140000 套接字 S_IFLINK 0120000 符号链接（软连接） S_IFREG 0100000 普通文件 S_IFBLK 0060000 块设备 S_IFDIR 0040000 目录 S_IFCHR 0020000 字符设备 S_IFIFO 0010000 管道 代码实现可以写为（因为是示例，所以就用两种常用的文件格式来演示）： 123456789switch(st.st_mode &amp; S_IFMT) &#123; case S_IFREG: printf(&quot;-&quot;); break; case S_IFDIR: printf(&quot;d&quot;); break; &#125; 权限输出（以及输出.）我们知道用户、用户组、其它的权限信息仍然是保存在st._st_mode中，且其分布分别是： 所有者权限（6~8bit） 所属组权限（3~5bit） 其它人权限（0~2bit） 所以我们可以通过取某一位，然后判断其除以3的余数情况来判断其是否可以读写执行。由于我们输出顺序为所有者、所有者的用户组、其他人，所以我们要先从高位进行取，取的方式就是将st_mode与某一位为1其它位为0的数字相与（为1的位置就是我们想取的那个位置），然后进行判断。若该部分余0，则说明没有该权限，所以为“-”代码如下： 123456789101112131415161718192021int i = 0; for(i = 8;i &gt;= 0;i--) &#123; if(st.st_mode &amp; (1 &lt;&lt; i)) &#123; switch(i%3) &#123; case 2: printf(&quot;r&quot;); break; case 1: printf(&quot;w&quot;); break; case 0: printf(&quot;x&quot;); break; &#125; &#125; else printf(&quot;-&quot;); &#125; 用于在权限后面有一个“.”，所以我们直接输出它：1printf(&quot;.&quot;); 硬连接数目接下来就是要输出硬链接的数目，直接读取结构体中的st_nlink即可。所以实现代码如下（记得前面有一个空格）： 12int hardlin = (int)st.st_nlink; printf(&quot; %d&quot;,hardlin); 输出所有者名由于结构体中存储的是用户的uid，所以要想输出所有者名，我们就需要根据uid来获取用户的用户名。我们可以利用读取/etc/passwd进行查找，也可以采用下面的方法，即使用getpwuid()这个函数。 基础知识：函数原型：123struct passwd *getwnam(const char *name);struct passwd *getwuid(uid_t uid); 关于getwnam 项目 内容 功能 用来逐一搜索参数name 指定的账号名称, 找到时便将该用户的数据以passwd 结构返回。 返回值 返回 passwd 结构数据, 如果返回NULL 则表示已无数据, 或有错误发生。 关于getpwuid 项目 内容 功能 用来逐一搜索参数uid指定的用户识别码, 找到时便将该用户的数据以passwd结构体返回。 返回值 返回 passwd 结构数据, 如果返回NULL 则表示已无数据, 或有错误发生。 关于passwd结构体 12345678910struct passwd&#123; char * pw_name; //用户账号 char * pw_passwd; //用户密码 uid_t pw_uid; //用户识别码 gid_t pw_gid; //组识别码 char * pw_gecos; //用户全名 char * pw_dir; //家目录 char * pw_shell; //所使用的shell 路径&#125;; 根据以上，我们可以直接写出以下代码： 12struct passwd *pw = getpwuid(st.st_uid); printf(&quot; %s&quot;,pw-&gt;pw_name); 输出所属组名同上面一样，结构体里面只提供了所属组的GID，所以我们需要根据GID去查找所属组名。方法依然有两种，一为读取/etc/passwd进行查找；二为使用getgrgid()函数进行返回。 基础知识函数原型：12struct group *getgrnam(const char *name)；struct group *getgrgid(gid_t gid); 关于getgrnam 项目 内容 功能 用来以指定的用户组名来搜索组文件, 找到时便将该组的数据以group 结构返回。 返回值 返回 group 结构数据, 如果返回NULL 则表示已无数据, 或有错误发生。 关于getgrgid 项目 内容 功能 用来以指定的gid参数来逐一搜索组文件, 找到时便将该组的数据以group 结构返回。 返回值 返回 group 结构数据, 如果返回NULL 则表示已无数据, 或有错误发生。 关于group结构体 1234567struct group&#123; char *gr_name; //组名称 char *gr_passwd; //组密码 gid_t gr_gid; //组识别码 char **gr_mem; //组成员账号&#125; 所以实现代码如下：12struct group *gp=getgrgid(st.st_gid); printf(&quot; %s&quot;,gp-&gt;gr_name); 输出文件大小、最后修改时间、文件名文件大小在stat的结构体里面为st.st_size。 输出最后修改时间我们可以直接使用结构体里面的st.st_mtime即可，但是要转换成标准的日期输出方式，我们就需要用到ctime()函数。 其原型如下：1char *ctime(const time_t *timep); 其功能为：ctime()将参数timep所指的time_t 结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果以字符串形态返回。此函数已经由时区转换成当地时间，字符串格式为”Wed Jun 30 21 :49 :08 1993\\n”。 所以可以直接写出如下代码：1printf(&quot; %s %s\\n&quot;,ctime(&amp;(st.st_mtime)),argv[1]); 至此，我们使用stat实现ls-l filename功能的程序便写完了。我们的程序的运行结果如下： 代码参见这里","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://tech.yushuai.xyz/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://tech.yushuai.xyz/tags/centos/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"Linux基础学习第四天：C库函数和系统函数","slug":"linuxfundamentalday4","date":"2019-05-05T14:31:42.000Z","updated":"2019-05-05T14:32:33.506Z","comments":false,"path":"2019/05/05/linuxfundamentalday4/","link":"","permalink":"http://tech.yushuai.xyz/2019/05/05/linuxfundamentalday4/","excerpt":"","text":"Linux第四天之C库函数和系统函数 FILE其实本质上是一个结构体，它里面有： 文件描述符（整型值）。索引到对应的磁盘文件。 文件读写位置指针：读写文件过程中指针的实际位置。 I/O缓冲区（内存地址）：通过寻址找到对应的内存块。大小默认是8个byte。设置I/O缓冲区是为了减少对内存的读写访问，节省时间。 Linux的系统函数是没有缓冲区的，需要我们自己提供。 文件描述符 Linux每一个运行的程序（进程），操作系统都会为其分配一个0~4G（232）的地址空间（虚拟地址空间）。文件描述符大小是1024。文件描述符就是在内核区，如上图所示。第0、1、2个是标准输入、标准输出和标准错误，默认是打开状态，也可以被关闭。每打开一个新文件，则占用一个文件描述，而且使用的是空闲的最小的一个文件描述符。例如我们打开3个文件分别用了3、4和5，这个时候我们关闭了第一个文件，第3个空闲了，再打开第4个文件，那么就占用的是第3个。 用户区Linxu下可执行文件格式是ELF。 查看文件类型可以使用file app就可以了。如图所示就是ELF。ELF主要包含的三个段.bss、.data、.text，其他还有一些只读数据段和符号段等。然后下面就是受保护的地址，地址是0~4K。程序在读的时候首先从代码段开始，全局变量就放在.bss或者.data，局部变量是在栈空间，栈空间是向下增长。用户使用new或者malloc分配的内存是从堆空间分配，堆空间是向上增长。 C库函数与系统函数的关系 上图中展示了C语言中printf函数是如何实现的。如图所示，printf函数相当于是一个stdout，它需要通过FILE* 来进行操作。我们知道一个FILE本质上是一个结构体，里面有文件描述符（FD）、文件读写位置指针、I/O缓冲区（C库函数维护的）。当我们使用printf的时候，它调用了Linux系统的API： 首先调用了应用层的write函数，printf将文件描述符传递给应用层的write，然后将字符串和字符串的长度传递给了write。write只能在0~3G的用户空间操作，它会帮我们做一个空间转换，将用户空间转换到内核空间。 然后从应用层又调用了系统调用层里面的sys_wirte()。这个sys_write()是可以对系统内核进行操作，也就是说对3G~4G范围内进行操作 到内核层以后，会调用显示器的驱动，然后让驱动把字符串显示出来。 以上是整个的工作流程。 Linux的API又分为三层，由上层到底层分别是： - 应用层，包括write,open之类，操作的是用户空间。 - 系统调用。 - 内核层。操作设备驱动函数等。 open函数open是用来打开和创建一个文件或设备。语法如下：123456#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode); 在上述使用方式里面，pathname顾名思义是路径名，flags是打开方式，有O_RDONLY，O_WRONLY或者O_RDWR（分别是只读、只写和读写），当然还有其它的一些打开方式。 第一个语句用于打开已经存在的文件，而第二个语句用于创建一个不存在的文件。第二个语句flags至少应该是一个可写的，并且需要提供一个O_CREAT，创建不存在的文件需要提供mode参数，也就是访问权限。 参数mode具体指明了使用权限，它通常也会被umask修改，所以一般新建文件的权限为（mode&amp;~umask）。注意模式只被应用于将来对这个文件的使用中。open调用创建一个新的只读文件，但仍将返回一个可读写文件描述符。 open()通常用于将路径名转换为一个文件描述符，当open()调用成功的时候，它会返回一个新的文件描述符（永远取未用描述符中的最小值）。如果出现错误则返回-1，并在errno设置错误信息。 这个调用创建一个新的打开文件，即分配一个新的独一无二的文件描述符，不会与运行中的任何其他程序共享（但可以通过for(2)系统调用实现共享）。这个心的文件描述符在其后对打开文件操作的函数中调用。文件的读写指针被置于文件头。 errno是一个全局变量，当函数调用失败后，errno就会被赋值，值就是对应的错误信息。 open函数中的errnoerrno定义在头文件errno.h中（地址为/usr/include/errno.h），它是一个全局变量，任何标准C库函数都能对其进行修改（Linux系统函数更可以）。 其错误宏定义位置： 第1~34个错误定义：/usr/include/asm-generic/errno-base.h 第35~133个错误定义：/usr/include/asm-generic/errno.h 我们以errno-base.h截图来看一下，内容如下所示： 我们又改如何查看错误信息呢？我们可以用perror函数来实现。 项目 说明 头文件 stdio.h 函数定义 void perror(const char *s) 函数说明 用来将上一个函数发生错误的原因输出到标准设备（stderr）；参数s所指的字符串会首先被打印出，后面再加上错误原因字符串；此处错误原因依照全局变量errno的值来决定要输出的字符串。 我们来用实际操作实践一下以下三点： 打开一个不存在的文件 打开一个已经存在的文件 创建一个新文件 下面的第一张图显示的是源代码，第二张图显示的是操作和操作结果。 可以看出以下问题： 为什么我设置了新建文件的权限为777，而实际生成的文件的权限是775？如前面我们在介绍open()中的mode中所说，其实本地还有一个掩码umask，这个umask值为0002（如第二张图所示），所以我们实际的权限的计算公式为（mode&amp;~umask），umask取反后做按位与操作。 接下来再进行一个实践，在新建一个文件前来判断下文件是否存在。就是在open()函数中第二个参数中对O_CREAT和O_EXCL进行连用来判断，即1fd=open(&quot;newfile&quot;, O_RDWR | O_CREAT | O_EXCL, 0777); 如果文件存在，则返回File exists信息。当然判断文件是否存在不只这一种方法。 还有一种操作就是将文件截断为0，使用参数为O_TRUNC。 read函数read函数的使用格式如下： 12#include&lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count); 参数中，fd是文件描述符；buf是一个缓冲区，可以通过新建一个数组并将该参数设置为数组名，或者malloc一个内存块，然后把指针名设置为改参数；count是字节数。 项目 内容 函数功能 在文件描述符上执行读操作 函数描述 read()从文件描述符fd中读取count字节的数据并放入从buf开始的缓冲区。如果count为零，read()返回0并不执行其他操作，如果count大于SSZIE_MAX，则结果不可预料。 返回值 成功时返回读取到的字节数（为0表示读到文件描述符，即文件已经读完了），此返回值受文件剩余字节数限制，当返回值小于指定的字节数时并不意味着错误，这可能因为当前可读取的字节数小于指定的字节数。发生错误时返回-1，并置errno为相应值，在这种情况下无法得知文件偏移位置是否有变化。 write函数write函数的使用格式如下： 12#include&lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t count); 参数中，fd是文件描述符；buf是一个缓冲区，可以通过新建一个数组并将该参数设置为数组名，或者malloc一个内存块，然后把指针名设置为改参数；count是字节数。 项目 内容 函数功能 在文件描述符上执行写操作 函数描述 write()向文件描述符fd所引用的文件中写入从buf开始的缓冲区中count字节的数据。POSIX规定，当使用了write()之后在使用read()，那么读取到的应该是更新后的数据。 返回值 成功时返回所写入的字节数（为0表示没有写入数据）。发生错误时返回-1，并置errno为相应值。若count为零，对普通文件没任何影响，但对特殊文件将产生不可预料的后果。 lseek函数函数功能是用来重新定位文件读写的位移 语法：1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); lseek()函数会重新定位被打开文件的位移量，根据参数offset以及whence的组合来决定： SEEK_SET: 从文件头部开始偏移offset个字节。SEEK_CUR： 从文件当前读写的指针位置开始，增加offset个字节的偏移量。SEEK_END： 文件偏移量设置为文件的大小加上偏移量字节。 项目 内容 函数功能 在文件描述符上执行写操作 函数描述 write()向文件描述符fd所引用的文件中写入从buf开始的缓冲区中count字节的数据。POSIX规定，当使用了write()之后在使用read()，那么读取到的应该是更新后的数据。 返回值 成功时返回所写入的字节数（为0表示没有写入数据）。发生错误时返回-1，并置errno为相应值。若count为零，对普通文件没任何影响，但对特殊文件将产生不可预料的后果。","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://tech.yushuai.xyz/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://tech.yushuai.xyz/tags/centos/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"把CentOS7中的vim打造成C++IDE","slug":"vimtocppide","date":"2019-04-28T09:55:04.000Z","updated":"2019-04-28T09:56:34.717Z","comments":false,"path":"2019/04/28/vimtocppide/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/28/vimtocppide/","excerpt":"","text":"把CentOS7中的vim打造成C++IDE由于我个人平时常使用C/C++进行编程，所以我决定把CentOS下面的VIM这个强大的编辑器改造成一个强大的C++的IDE。下面是具体的步骤。 安装pathogen该插件地址为：https://github.com/tpope/vim-pathogen 安装命令为：123mkdir -p ~/.vim/autoload ~/.vim/bundle &amp;&amp; \\curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim 安装完成之后，打开~/.vimrc文件，然后输入：123execute pathogen#infect()syntax onfiletype plugin indent on 然后保存退出，这个插件就安装完成了。此时如果在~/.vim文件夹里面执行tree命令，则会得到这样的结果： .├── autoload│ └── pathogen.vim└── bundle 这里面autoload这个目录存放的就是我们的这个pathogen这个插件，其实这个插件就是一个脚本。当vim启动时，由于刚刚我们在~/.vimrc里面配置了execute pathogen#infect()这个功能，所以它会自动加载这个脚本并执行里面的函数。 安装auto-pairs插件项目地址：https://github.com/jiangmiao/auto-pairs 它的功能是成对插入或删除括号，引号等。安装方式如下： 1git clone git://github.com/jiangmiao/auto-pairs.git ~/.vim/bundle/auto-pairs 安装NERDTree功能：显示目录树 项目地址：https://github.com/scrooloose/nerdtree 安装：1git clone https://github.com/scrooloose/nerdtree.git ~/.vim/bundle/nerdtree 为了方便打开NERDTree，我们可以设置快捷键，还是打开~/.vimrc，插入下面一行1map &lt;C-n&gt; :NERDTree&lt;CR&gt; MiniBufExplorer功能：显示已经打开的buffer项目地址：https://www.vim.org/scripts/script.php?script_id=159 安装：1mkdir -p ~/.vim/bundle/minibufexplorer/plugin &amp;&amp; wget &quot;http://www.vim.org/scripts/download_script.php?src_id=3640&quot; -O ~/.vim/bundle/minibufexplorer/plugin/minibufexpl.vim 命令解释：在~/.vim/bundle中新建一个目录minibufexplorer，并在其中创建一个plugin，然后下载网址中的内容，-O表示指定下载目录和文件名如后面所示。然后我们打开两个文件，可以看到如图所示上面有了一个标志。 在~/.vimrc文件中插入下面一行： 1let g:miniBufExplMaxSize = 2 ctags+taglist+omnicppcomplete1.首先安装ctags 执行以下命令：1sudo yum install ctags 创建索引：在你代码的根目录执行如下命令，会生成一个tags文件，此时在代码根目录下打开一个文件（vim默认只加载工作目录下的tags文件），将光标置于一个函数或结构体名字上，按ctr+]即可跳转到该名称的定义处，如果出现多个选项，可以输入编号选择对应跳转的地方，按ctr+o可回到光标之前的位置。ctags -R –sort=yes –c++-kinds=+p –fields=+iaS –extra=+q –language-force=C++ 2.安装taglist 功能：可以将代码内的函数、变量等按照规律列出来，方便查找。 下载地址：http://www.vim.org/scripts/script.php?script_id=273 安装：1cd ~/.vim/bundle &amp;&amp; wget &quot;http://www.vim.org/scripts/download_script.php?src_id=19574&quot; -O taglist.zip &amp;&amp; unzip taglist.zip -d taglist 命令意义：改变当前目录为~/.vim/bundle，然后下载压缩包并命名为taglist.zip，然后将压缩包解压到taglist文件夹中。 打开~/.vimrc，输入以下内容： 1234let Tlist_Show_One_File=1 &quot; 只展示一个文件的taglistlet Tlist_Exit_OnlyWindow=1 &quot; 当taglist是最后以个窗口时自动退出let Tlist_Use_Right_Window=1 &quot; 在右边显示taglist窗口let Tlist_Sort_Type=&quot;name&quot; &quot; tag按名字排序 **3.OmniCppComplete 对C++语法补全的插件，可以对function、namespace、class member等进行补全。omni补全需要依赖tags文件，需要你用ctags命令自己生成。 下载地址：http://www.vim.org/scripts/script.php?script_id=1520 安装：1cd ~/.vim/bundle &amp;&amp; wget &quot;http://www.vim.org/scripts/download_script.php?src_id=7722&quot; -O omnicppcomplete.zip &amp;&amp; unzip omnicppcomplete.zip -d omnicppcomplete 由于命令格式和上面的一致，所以这里不再解释。该命令还需要进行以下配置，打开~/.vimrc文件，输入 123456filetype plugin indent onset completeopt=longest,menulet OmniCpp_NamespaceSearch = 2 &quot; search namespaces in the current buffer and in included fileslet OmniCpp_ShowPrototypeInAbbr = 1 &quot; 显示函数参数列表let OmniCpp_MayCompleteScope = 1 &quot; 输入 :: 后自动补全let OmniCpp_DefaultNamespaces = [&quot;std&quot;, &quot;_GLIBCXX_STD&quot;] 前面说过，omni插件的补全是依赖于tags文件的，因此需要我们手动建立tags文件，方法见前面所示。 当输入hello.h和hello.cpp中的函数或结构体时，通过按ctr+x ctr+o就可以自动补全了。通过按ctr+n和ctr+p可以对候选项进行上下选择。通过这种方式可以实现对函数、结构体的补全。另外，我们还可以实现对STL补全，这才是我们需要的。 4.对STL补全 执行以下命令： 1mkdir -p ~/.vim/tags &amp;&amp; cd ~/.vim/tags &amp;&amp; wget &quot;http://www.vim.org/scripts/download_script.php?src_id=9178&quot; -O - | tar jxvf - 然后我们在~/.vim/tags/cpp_src目录下执行ctags命令：1ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ 然后打开~/.vimrc添加下面一行：1set tags+=~/.vim/tags/cpp_src/tags 这种方式显然是不友好的，需要使用ctrl+x和ctrl+o，所以我们可以学习shell中使用TAB补全的方式进行补全，这里就需要使用到SuperTAB。 SuperTab项目地址：https://github.com/ervandew/supertab 安装： 1cd ~/.vim/bundle &amp;&amp; git clone https://github.com/ervandew/supertab.git ~ /.vim/bundle/supertab 无需任何配置即可使用，这时你想要补全变量名或函数名只需按一下TAB键即可，出现候选窗口之后也可以用TAB键进行选择。注意：由于TAB键被映射成了补全快捷键，也就无法通过TAB键直接输入制表符，这时如果想要输入制表符可以通过ctr+v TAB即可，即先输入ctr+v再输入TAB键，在vim下通过ctl+v可以输入很多不可见字符，比如试试ctr+v ctr+w。 安装colorschemes功能：可以给vim更换配色方案 项目地址： https://github.com/flazz/vim-colorschemes 安装：12cd ~/.vim/bundle &amp;&amp; git clone https://github.com/flazz/vim-colorschemes.git ~ /.vim/bundle/colorschemes 在~/.vim/colors中有许多配色方案，你可以任选其一来应用。例如我们使用molokai这个配色方案，我们可以在~/.vimrc中添加这个语句：1colorscheme molokai 以上，就搭建成功了一个功能强大的C/C++的IDE。","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://tech.yushuai.xyz/tags/centos/"},{"name":"vim","slug":"vim","permalink":"http://tech.yushuai.xyz/tags/vim/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"leetcode题目解析（190425）","slug":"leetcode190425","date":"2019-04-25T06:36:09.000Z","updated":"2019-07-02T14:11:34.631Z","comments":false,"path":"2019/04/25/leetcode190425/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/25/leetcode190425/","excerpt":"","text":"Remove Duplicates from sorted Array II题目描述Follow up for “Remove Duplicates”:What if duplicates are allowed at most twice?For example,Given sorted array A =[1,1,1,2,2,3],Your function should return length =5, and A is now[1,1,2,2,3]. 题目解析类似于Remove Duplicates from sorted Array，但是这个题目要求重复的数字要保留两位。所以做适当修改即可。 代码实现1234567891011int removeDuplicates(int A[], int n) &#123; if(n&lt;=2) return n; int count=2; for(int i=2;i&lt;n;i++) &#123; if(A[i]!=A[count-2]) A[count++]=A[i]; &#125; return count;&#125; Sqrx题目说明求一个数字的平方根 题目解析利用牛顿逼近法。 代码实现123456 int sqrt(int x) &#123; long r=x;while(r*r&gt;x) r=(r+x/r)/2;return r; &#125; Length of last word题目描述Given a string s consists of upper/lower-case alphabets and empty space characters’ ‘, return the length of last word in the string.If the last word does not exist, return 0.Note: A word is defined as a character sequence consists of non-space characters only.For example,Given s =”Hello World”,return5. 题目解析这个题的关键就是抓住最后一个单词有什么特征，最后一个单词一定是它的前面有一个单词和空格，而后面没有单词（本题允许最后有空格），所以我们可以根据这个特点，很容易想到两种复杂度为O(n)的解题方法。第一种是最容易想到的，也就是从前往后走的方法，这个方法我们可以走这样的路子：判断当前字符不是空格，就对计数加1，如果是空格，就把计数重新置0，然后再开始计数。如果最后一个字符是空格怎么办呢？那我们就可以考虑空格是最后一个字符与不是一个字符时的区别： 情况 是最后一个字符 不是最后一个字符 s[i] ‘ ’ ‘ ’ s[i+1 ‘\\0’ 某个字符 所以可以基于上面这两个条件来进行判断，即若s[i]=’ ‘且s[i+1]!=’\\0’的时候，那就是中间的空格符，所以可以计数置零。具体见代码1。 还有一种思路就是从后往前走，因为题目要求的是最后一个单词，所以在一般情况下，这种方法的时间都要快于第一种方法，特别是语句中单词特别多的时候。这种思路就是直接寻找除了最后一个字符位置之外第一个空字符的位置，得到这个位置后直接break即可。所以这个方法的步骤就是： 不断对计数加1，直到遇到第1个空格。 然后判断此时count是否为0，若为0，说明空格是最后一个字符，所以循环不跳出，继续进行；若count不为零，说明第一个单词已经结束，直接break跳出，返回count。 代码实现11234567891011121314151617int lengthOfLastWord(const char *s) &#123; if (s == nullptr) return 0; int count = 0; int len = strlen(s); for (int i = 0; i &lt; len; i++) &#123; if (s[i] != &apos; &apos;) ++count; else if (s[i] == &apos; &apos;&amp;&amp;s[i + 1] != &apos;\\0&apos;) count = 0; else break; &#125; return count;&#125; 代码实现2123456789101112131415 int lengthOfLastWord(const char *s) &#123;if (s == nullptr) return 0;int count = 0;int len = strlen(s);for (int i = len - 1; i &gt;= 0; i--)&#123; if (s[i] != &apos; &apos;) ++count; else if(count) break;&#125;return count; &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"trapping rain water","slug":"trapping-rain-water","date":"2019-04-23T14:03:06.000Z","updated":"2019-04-23T14:21:09.103Z","comments":false,"path":"2019/04/23/trapping-rain-water/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/23/trapping-rain-water/","excerpt":"","text":"Trapping Rain Water题目描述Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.For example,Given[0,1,0,2,1,0,1,3,2,1,2,1], return6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcosfor contributing this image! 题目分析这个题目的想法，最容易想到的就是将它以最高的地方为基准分为左右两列进行相加计算，因为相加不可能跨过最高的那个地方。对于左侧，我们从0向最高值靠拢，首先判断当前位置的值是否小于left（left刚开始是第0个，判断从第0个开始判断没问题），如果小于，那么就将suml累加上left-A[i]即可，如果不是小于，那么代表着从这一点开始，又要重新计算一个容量，所以令left=A[i]。如下所示： 1234if (A[i] &lt; left) suml += left - A[i]; else left = A[i]; 对于右侧同理，从最右侧n-1开始往左判断，过程与上面相同，不再重复。代码如下： 1234if (A[i] &lt; right) sumr += right - A[i];else right = A[i]; 代码实现12345678910111213141516171819202122232425262728int trap(int A[], int n) &#123; int maxHeight = 0; int left = 0;//由左往最大值计算 int right = 0;//由右往最大值计算 int suml = 0; int sumr = 0; //寻找到高度的最大值，将区间分为左侧和右侧两部分进行分别处理 for (int i = 0; i &lt; n; i++) if (A[i] &gt; A[maxHeight]) maxHeight = i; //先计算左侧的容量 for (int i = 0; i &lt; maxHeight; i++) &#123; if (A[i] &lt; left) suml += left - A[i]; else left = A[i]; &#125; for (int i = n-1; i &gt; maxHeight; i--) &#123; if (A[i] &lt; right) sumr += right - A[i]; else right = A[i]; &#125; return suml + sumr;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"jump game","slug":"jump-game","date":"2019-04-23T14:02:55.000Z","updated":"2019-04-23T14:11:40.714Z","comments":false,"path":"2019/04/23/jump-game/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/23/jump-game/","excerpt":"","text":"Jump Game题目说明Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.Determine if you are able to reach the last index.For example:A =[2,3,1,1,4], returntrue.A =[3,2,1,0,4], returnfalse. 题目解析这个题解析起来我的想法很容易，复杂度为O(n)。就是：我记录当前A[i]的值，然后把i加上这个值，就相当于从当前这个位置往前走相应的步数。退出循环的判断条件有两个： 当前是第i个元素，但是i已经大于n-1了（下标从0开始，所以第n个数是第n-1）。 A[i]为0：这里面又分两种情况，一种是如题目所给的第2种情况，在中间为0的这个位置不走了，还有一种情况是我这个数组一共1个元素，就是0。那么跳出。 交给下面的return语句后面判断。就是判断当做的位置是否是越过了最后一个位置？若越过了或者正好在最后一个位置，自然是return true；否则return false。 代码展示123456789101112bool canJump(int A[], int n) &#123; int i = 0; while (A[i] != 0) &#123; int jumpNum = A[i]; i += jumpNum; if (i &gt;= n-1) break; &#125; return i &gt;= n-1 ? true : false;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"remove duplicates from sorted list","slug":"remove-duplicates-from-sorted-list","date":"2019-04-23T14:02:44.000Z","updated":"2019-04-23T14:11:29.059Z","comments":false,"path":"2019/04/23/remove-duplicates-from-sorted-list/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/23/remove-duplicates-from-sorted-list/","excerpt":"","text":"Remove duplicates from sorted list题目描述Given a sorted linked list, delete all duplicates such that each element appear only once.For example,Given1-&gt;1-&gt;2, return1-&gt;2.Given1-&gt;1-&gt;2-&gt;3-&gt;3, return1-&gt;2-&gt;3.（保留1个） 题目解析对于当前节点和下一节点的值不相等的情况，那就一直往下走，代码中是p1移动到下一个节点的操作。代码如下：1234if(p1-&gt;val != p2-&gt;val) &#123; p1 = p1-&gt;next; continue;&#125; 当然如果当前节点和下一节点相同的情况下，我们就需要做两件事： 不断判断下面有几个点和当前点相等，代码如下： 1while(p2-&gt;next != NULL &amp;&amp; p1-&gt;val == p2-&gt;next-&gt;val) p2 = p2-&gt;next; 找到最后一个点和当前点相等的时候，直接把那个点的next赋值给当前点的next，然后那些点。即： 12p1-&gt;next = p2-&gt;next;delete p2; 代码实现12345678910111213141516ListNode *deleteDuplicates(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode* p1 = head; while(p1 != NULL &amp;&amp; p1-&gt;next != NULL) &#123; ListNode* p2 = p1-&gt;next; if(p1-&gt;val != p2-&gt;val) &#123; p1 = p1-&gt;next; continue; &#125; while(p2-&gt;next != NULL &amp;&amp; p1-&gt;val == p2-&gt;next-&gt;val) p2 = p2-&gt;next; p1-&gt;next = p2-&gt;next; delete p2; p1 = p1-&gt;next; &#125; return head;&#125; 删除链表中重复的节点（全部删除）题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 题目解析代码实现1234567891011121314151617181920ListNode* deleteDuplication(ListNode* pHead) &#123; if(pHead == NULL) return NULL; if(pHead-&gt;next== NULL) return pHead; if(pHead-&gt;val==pHead-&gt;next-&gt;val) &#123; ListNode* pNode = pHead-&gt;next; while(pNode!=NULL &amp;&amp; pNode-&gt;val==pHead-&gt;val) pNode=pNode-&gt;next; return deleteDuplication(pNode); &#125; else &#123; pHead-&gt;next=deleteDuplication(pHead-&gt;next); return pHead; &#125; &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"merge sorted array","slug":"merge-sorted-array","date":"2019-04-23T14:02:26.000Z","updated":"2019-04-23T14:11:08.711Z","comments":false,"path":"2019/04/23/merge-sorted-array/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/23/merge-sorted-array/","excerpt":"","text":"merge sorted array题目描述Given two sorted integer arrays A and B, merge B into A as one sorted array.Note:You may assume that A has enough space to hold additional elements from B. The number of elements initialized in A and B are mand n respectively. 题目解析由于数组A的空间足够，为了不使用额外空间，我们很容易想到从后往前进行。该题目分为两步完成。第一步：从后往前进行插入，也就是说比较的时候从A和B已有元素的最后一个元素开始比较，大的插入到A的未插入的最后一个位置。完成上述操作的前提是，A和B的待排元素都还有，所以判断条件就是下面的1x1&gt;=0 &amp;&amp; x2&gt;=0 对于上述操作的实现如下：1A[index--] = A[x1] &gt; B[x2] ? A[x1--] : B[x2--]; 这句话其实就是下面这段话的意思：123456789101112if(A[x1]&gt;B[x2])&#123; A[index]=A[x1]; --index; --x1;&#125;else&#123; A[index]=B[x2]; --index; --x2;&#125; 第二步：在第一步完成情况下存在两种情况： 原来的A和B都已经完整插入到A中，即x1=-1且x2=-1。 原来B已经插入完毕了但是A还没有，即x2=-1且x1&gt;=0，此时A剩下的数字都在正确的位置，不需要再排序了。 原来的A插入完毕了，B还没有，即x1=-1且x2&gt;=0，那就直接把B插入到剩下的位置即可。 代码实现123456789101112void merge(int A[], int m, int B[], int n) &#123; int total = m + n; int x1 = m - 1; int x2 = n - 1; int index = total - 1; while (x1 &gt;= 0 &amp;&amp; x2 &gt;= 0) &#123; A[index--] = A[x1] &gt; B[x2] ? A[x1--] : B[x2--]; &#125; while (x2 &gt;= 0) A[index--] = B[x2--]; &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"n queens ii","slug":"n-queens-ii","date":"2019-04-23T14:02:13.000Z","updated":"2019-04-23T14:10:42.160Z","comments":false,"path":"2019/04/23/n-queens-ii/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/23/n-queens-ii/","excerpt":"","text":"n queens ii题目描述Follow up for N-Queens problem.Now, instead outputting board configurations, return the total number of distinct solutions. 题目解析我们令x[i]的值为第i个皇后所在的列数。那么我们第一个皇后的位置可以在第一行任意一个位置任选，所以我们试出来第一个皇后在第1到第n个列位置下的不同情况（一共有n颗n叉树）。然后安排完第一个皇后位置后，第二个皇后位置在第二行也是从第1到第n列分别试一遍，看是否满足要求。若满足要求则进行第三个皇后，否则该树是没有结果的。当不断递归到t&gt;n的时候，那说明在上一步已经安排完了，那么久直接对计数加1，然后返回。 123456789101112131415161718192021222324252627void Backtrack(int t,int num) &#123; if(t&gt;num) &#123; countn++; &#125; else for(int i=1;i&lt;=num;i++) &#123; x[t]=i; if(Place(t)) Backtrack(t+1,num); &#125; &#125;void Backtrack(int t,int num) &#123; if(t&gt;num) &#123; countn++; &#125; else for(int i=1;i&lt;=num;i++) &#123; x[t]=i; if(Place(t)) Backtrack(t+1,num); &#125; &#125; 题目要求就是每一个皇后不能跟上一行的那个皇后同一列和对角线，所以在获得下一列真实的位置的时候，需要判断是不是在同一列或者对角线，即：12345678910111213bool Place(int t) &#123; bool ok=true; for(int j=1;j&lt;t;j++) &#123; if(x[t]==x[j]||t-j==fabs(x[t]-x[j]))//判断列对角线是否冲突 &#123; ok=false; break; &#125; &#125; return ok; &#125; 代码实现1234567891011121314151617181920212223242526272829303132333435public: int countn=0; int x[200]; bool Place(int t) &#123; bool ok=true; for(int j=1;j&lt;t;j++) &#123; if(x[t]==x[j]||t-j==fabs(x[t]-x[j]))//判断列对角线是否冲突 &#123; ok=false; break; &#125; &#125; return ok; &#125; void Backtrack(int t,int num) &#123; if(t&gt;num) &#123; countn++; &#125; else for(int i=1;i&lt;=num;i++) &#123; x[t]=i; if(Place(t)) Backtrack(t+1,num); &#125; &#125; int totalNQueens(int n) &#123; Backtrack(1,n); return countn; &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"rotate image","slug":"rotate-image","date":"2019-04-23T14:02:00.000Z","updated":"2019-04-23T14:05:19.561Z","comments":false,"path":"2019/04/23/rotate-image/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/23/rotate-image/","excerpt":"","text":"rotate image题目描述You are given an n x n 2D matrix representing an image.Rotate the image by 90 degrees (clockwise).Follow up:Could you do this in-place? 题目解析旋转90°，可以当做两步：第一步是关于对角线取对称；第二步是关于水平线取上下对称。记住这个原理。 代码实现123456789101112void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; //对角线对称 int n=matrix.size(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n-i;j++) swap(matrix[i][j],matrix[n-1-j][n-1-i]); //上下交换 for(int i=0;i&lt;n/2;i++) for(int j=0;j&lt;n;j++) swap(matrix[i][j],matrix[n-1-i][j]); &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"unique paths","slug":"unique-paths","date":"2019-04-23T14:01:45.000Z","updated":"2019-04-23T14:09:24.336Z","comments":false,"path":"2019/04/23/unique-paths/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/23/unique-paths/","excerpt":"","text":"unique path题目描述A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there?Note: m and n will be at most 100. 题目解析自己就是想不出来动态规划里面的问题如何来划分为合适的子问题（也就是写不出递推公式）。每次都是看了答案恍然大悟。其实这个题的递推公式非常之简单。就是：当前点的路径=上面一个点的路径+左边一个点的路径。也就是 1path[i][j]=path[i-1][j]+path[i][j-1]; 代码实现123456789int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt;path(m,vector&lt;int &gt;(n,1)); for(int i=1;i&lt;m;i++) for(int j=1;j&lt;n;j++) &#123; path[i][j]=path[i-1][j]+path[i][j-1]; &#125; return path[m-1][n-1];&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"unique binary search tree","slug":"unique-binary-search-tree","date":"2019-04-15T15:12:33.000Z","updated":"2019-04-16T00:51:21.530Z","comments":false,"path":"2019/04/15/unique-binary-search-tree/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/15/unique-binary-search-tree/","excerpt":"","text":"unique binary search trees题目描述Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?For example,Given n = 3, there are a total of 5 unique BST’s. 题目解析我们可以发现，只需求出左、右子树各有多少种，二者相乘即为以 i 作为root时BST的总数。所以我们可以用动态规划来实现。当节点数为0个的时候，子树为0个，节点为1个的时候，子树为1个，节点数为2个的时候，子树为2个。当n&gt;=3的时候，左右子树种类之积就是结果。所以我们只需要由下至上求解即可。 代码实现1234567891011121314151617181920int numTrees(int n) &#123; vector&lt;int&gt;num; num.push_back(1); for(int i=1; i&lt;=n; i++) &#123; num.push_back(0); if(i&lt;3) &#123; num[i]=i; &#125; else&#123; for(int j=1;j&lt;=i;j++) &#123; num[i]+=num[j-1]*num[i-j]; &#125; &#125; &#125; return num[n];&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"same tree","slug":"same-tree","date":"2019-04-15T15:12:17.000Z","updated":"2019-04-15T15:15:19.244Z","comments":false,"path":"2019/04/15/same-tree/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/15/same-tree/","excerpt":"","text":"Same Tree题目描述Given two binary trees, write a function to check if they are equal or not.Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 思路说明其实这个题非常简单，算是判断一个树是不是另一个树子树的基础版，不需要调用另一个子程序，直接递归自己这个程序即可。就是判断树上每一个结点当前的情况： p当前节点为空且q当前节点为空，true； p为空q不为空，或q为空p不为空，false； p-&gt;val==q-&gt;val，那么就判断它的左右子树； p-&gt;val!q-&gt;val，false。 判断完成后，逐层向上返回bool结果。 代码实现12345678910bool isSameTree(TreeNode *p, TreeNode *q) &#123; if(p==nullptr &amp;&amp; q==nullptr) return true; if(p==nullptr || q==nullptr) return false; if(p-&gt;val==q-&gt;val) return isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right); else return false;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"roman to integer","slug":"roman-to-integer","date":"2019-04-15T15:12:08.000Z","updated":"2019-04-15T15:15:28.364Z","comments":false,"path":"2019/04/15/roman-to-integer/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/15/roman-to-integer/","excerpt":"","text":"Roman to Integer题目描述Given a roman numeral, convert it to an integer.Input is guaranteed to be within the range from 1 to 3999. 题目解析罗马数字的规律如下： 罗马数字 阿拉伯数字 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 另外还要注意的是： 相同的数字连写、所表示的数等于这些数字相加得到的数、如：Ⅲ=3； 小的数字在大的数字的右边、所表示的数等于这些数字相加得到的数、 如：Ⅷ=8、Ⅻ=12； 小的数字、（限于 Ⅰ、X 和 C）在大的数字的左边、所表示的数等于大数减小数得到的数、如：Ⅳ=4、Ⅸ=9； 正常使用时、连写的数字重复不得超过三次； 在一个数的上面画一条横线、表示这个数扩大 1000 倍。 由于这个题的范围限制到了3999，所以用不上最后一条主要事项。另外，由于本题是给定的罗马数字，所以不要考虑连写的数字重复超过三次的情况。假设一个罗马数字是由A和B组成，我们可以发现以下的现象： A=B：结果为int(A)+int(B)； A&gt;B：结果为int(A)+int(B)； A&lt;B：结果为-int(A)+int(B)。 注意：在这里int()不是强制类型转换的意思，而是我自己定义的将罗马数字转换成整型数字的一个标志而已。 所以我们可以这样想：使用一个for循环遍历从0~len-1（字符串长度-1），如果当前位置i的数字小于下一位置i+1的数字的时候，则直接从sum里面减去第i个数字（加1个数字再减一个数字等同于减一个数字再加一个数字）；否则就加上i。这样，字符串的最后一个元素所代表的数字没有加，在循环结束之后加上即可。代码实现如下。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576int strToint(char c)&#123; switch (c) &#123; case &apos;I&apos;: return 1; case &apos;V&apos;: return 5; case &apos;X&apos;: return 10; case &apos;L&apos;: return 50; case &apos;C&apos;: return 100; case &apos;D&apos;: return 500; case &apos;M&apos;: return 1000; default: return 0; &#125;&#125;int romanToInt(string s) &#123; int len = s.size(); int sum=0; for (int i = 0; i &lt; len-1; ++i) &#123; int tem1 = strToint(s[i]); int tem2 = strToint(s[i + 1]); if (tem1 &lt; tem2) sum -= tem1; else sum += tem1;//若大于则直接相加，若等于也相加。 //因为已经是罗马数字，所以不用考虑相同的会超过3个 &#125; sum += strToint(s[len - 1]); return sum; &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"populating next right pointer in each node","slug":"populating-next-right-pointer-in-each-node","date":"2019-04-15T15:11:49.000Z","updated":"2019-04-16T00:51:54.136Z","comments":false,"path":"2019/04/15/populating-next-right-pointer-in-each-node/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/15/populating-next-right-pointer-in-each-node/","excerpt":"","text":"populating next right pointers in each node题目描述题目描述 Given a binary tree 12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set toNULL. Initially, all next pointers are set toNULL. Note: You may only use constant extra space.You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). For example,Given the following perfect binary tree, 12345 1 / \\ 2 3 / \\ / \\4 5 6 7 After calling your function, the tree should look like: 12345 1 -&gt; NULL / \\ 2 -&gt; 3 -&gt; NULL / \\ / \\4-&gt;5-&gt;6-&gt;7 -&gt; NULL 原理解释刚开始，我这个题想用递归。但是递归不满足要求（使用线性的额外空间）。所以就不用递归。.我们可以这样考虑，用两个指针，假设为m和n。可以借鉴层序遍历的思想，我们添加next指针是完成一层厚进行下一层。那么我们就令m来指向每一层的左侧第一个元素，然后让n从左侧第一个元素一直往右进行处理。实际上，我们m和n在第i行的时候，操作的元素是第i+1行，所以当我们操作i+1行的时候，就可以用next指针实现n往右移动了。所以思路就可以这样：我们定义m和n，其中m指向root。然后判断当m-&gt;left不为空的时候，我们才有必要进行本程序的操作。以下的步骤都是建立在m-&gt;left不为空的时候： 我们令n等于m，就是相当于要从当前的m这个节点开始往右操作。当n不为空的时候，我们就直接n-&gt;left-&gt;next=n-&gt;right。建立起如下图所示，红色为当前m和n指向的结点，3就是n-&gt;left的结点，4就是n-&gt;right的这个节点： 接下里就是连接上图中的4和5直接的结点。首先要判断此时1右侧有没有结点，也就是n-&gt;next是否存在（若为根节点就是不存在的），存在的话那么就是n-&gt;right-&gt;next=n-&gt;next-&gt;left。这句话还是很容易明白的。即这条紫色的线。 在完成对1的连接之后，n就可以向右移动，对第二个结点进行相同的操作了。所以这个可以写成一个while循环。 当然，为了鲁棒性，开头别忘了一句话检测root是否为空，为空就返回。 下面是实现代码，其中left_point就是上面的m，flag就是上面的n。 代码实现1234567891011121314151617181920void connect(TreeLinkNode *root) &#123; if (!root) return ; TreeLinkNode *left_point=root,*flag; while(left_point-&gt;left) &#123; flag=left_point; while(flag) &#123; flag-&gt;left-&gt;next=flag-&gt;right; if(flag-&gt;next) &#123; flag-&gt;right-&gt;next=flag-&gt;next-&gt;left; &#125; flag=flag-&gt;next; &#125; left_point=left_point-&gt;left; &#125; &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"balanced binary tree","slug":"balanced-binary-tree","date":"2019-04-15T15:11:04.000Z","updated":"2019-04-15T15:13:00.708Z","comments":false,"path":"2019/04/15/balanced-binary-tree/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/15/balanced-binary-tree/","excerpt":"","text":"题目描述Given a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 题目解析见剑指offer题解（平衡二叉树） 代码实现123456789101112131415161718int getDepth(TreeNode *root)&#123; if(root == NULL) return 0; int leftDepth=getDepth(root -&gt; left); int rightDepth=getDepth(root-&gt;right); return leftDepth &gt; rightDepth ? leftDepth + 1 : rightDepth + 1;&#125;bool isBalanced(TreeNode *root) &#123; if(root == NULL) return true; int leftDepth = getDepth(root -&gt; left); int rightDepth = getDepth(root -&gt; right); if(leftDepth &gt; rightDepth + 1 || leftDepth + 1 &lt; rightDepth) return false; else return isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right);&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"copy list with random pointer","slug":"copy-list-with-random-pointer","date":"2019-04-11T15:09:57.000Z","updated":"2019-04-16T00:52:42.208Z","comments":false,"path":"2019/04/11/copy-list-with-random-pointer/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/11/copy-list-with-random-pointer/","excerpt":"","text":"题目描述A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.Return a deep copy of the list. 题目解析其实这个题目跟剑指offer里面题目35复制复杂链表是一样的。我们以下图为例 所以这个题也是分为三步： 第一步：逐一复制A和B和C和D，复制后为A’、B’、C’和D’（加’是为了表示方便，实际上还是原来的值’），并把他们分别插入到原节点后面。代码如下：12345for(p=head;p;p=p-&gt;next)&#123; copy = new RandomListNode(p-&gt;label); copy-&gt;next = p-&gt;next; // insert new at old next p = p-&gt;next = copy;&#125; for循环中的p=head就实现了这样的功能： for循环里面第一个语句就是新建一个节点（例如A’），第二行就是把这个A’的next指针指向B（因为原本A的next就是B的地址），然后把A’的地址赋值给p-&gt;next，也就是说head-&gt;的next是A’（即第三行里面的p-&gt;next=copy）。 然后的把p-&gt;next的地址给p，也就是把copy的地址（A’）给p，这个时候p又指向了A’。然后判断p是否是空呢？不是，那么就把p移动到下一个节点，也就是B了。然后再同理进行操作，直到最后一个节点复制完成，退出循环。这个时候结果如下： 第二步：复制random结点。这一部分其实就是很简单，遍历A/B/C/D，然后判断这个节点（假设为X）的random指针有没有指向某个地方（也就是!nullptr），如果有的话就复制到相应的节点（A’）的random上。这部分也是很巧妙的利用了for循环的第三个参数和函数体里面的第一个语句实现了copy指向X’，p指向X（这里，假如此时p指向X,那么运行copy=p-&gt;next之后，copy指向了X，然后执行p=copy-&gt;next之后，p指向了（X+1），以此类推）。 1234for(p=head;p;p=copy-&gt;next)&#123; copy = p-&gt;next; // copy random point copy-&gt;random = (p-&gt;random?p-&gt;random-&gt;next:NULL);&#125; 此时的结果为 第三步：断链。实现A-&gt;B-&gt;C-&gt;D，和A’-&gt;B’-&gt;C’-&gt;D’。先让p指向head，head是原本的ABCD那条链。因为我们要返回head，所以我们可以把head指向copy，然后操作copy即可。在for后面的第一个条件语句执行之后，p指向了A，copy和head指向了A’。然后下面自然就是进行断链操作了。断链结果如图所示。head指向的是copy，所以return head返回的就是图中下面的链。 代码实现1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list with a random pointer. * struct RandomListNode &#123; * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; RandomListNode *copy,*p; if (!head) return NULL; for(p=head;p;p=p-&gt;next)&#123; copy = new RandomListNode(p-&gt;label); copy-&gt;next = p-&gt;next; // insert new at old next p = p-&gt;next = copy; &#125; for(p=head;p;p=copy-&gt;next)&#123; copy = p-&gt;next; // copy random point copy-&gt;random = (p-&gt;random?p-&gt;random-&gt;next:NULL); &#125; for(p=head,head=copy=p-&gt;next;p;)&#123; p = p-&gt;next = copy-&gt;next; // split list copy = copy-&gt;next = (p?p-&gt;next:NULL); &#125; return head; &#125;&#125;;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"single word ii","slug":"single-word-ii","date":"2019-04-03T15:14:08.000Z","updated":"2019-04-03T15:15:48.569Z","comments":false,"path":"2019/04/03/single-word-ii/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/03/single-word-ii/","excerpt":"","text":"single-number-iiGiven an array of integers, every element appears three times except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 12345678910111213141516171819202122232425int singleNumber(int A[], int n) &#123;int ones = 0;//记录只出现过1次的bitsint twos = 0;//记录只出现过2次的bitsint threes = 0;for(int i = 0; i &lt; n; i++)&#123; twos |= ones&amp;A[i];//要在更新ones前面更新twos ones ^= A[i]; threes = ones&amp;twos;//ones和twos中都为1即出现了3次 ones &amp;= ~threes;//抹去出现了3次的bits twos &amp;= ~threes; &#125;return ones;&#125; 解析： 用3个整数来表示INT的各位的出现次数情况，one表示出现了1次，two表示出现了2次。当出现3次的时候该位清零。最后答案就是one的值。 ones 代表第ith 位只出现一次的掩码变量 twos 代表第ith 位只出现两次次的掩码变量 threes 代表第ith 位只出现三次的掩码变量 假设现在有一个数字1，那么我们更新one的方法就是‘亦或’这个1，则one就变成了1，而two的更新方法是用上一个状态下的one去‘与’上数字1，然后‘或’上这个结果，这样假如之前one是1，那么此时two也会变成1，这make sense，因为说明是当前位遇到两个1了；反之如果之前one是0，那么现在two也就是0。注意更新的顺序是先更新two，再更新one，不理解的话只要带个只有一个数字1的输入数组看一下就不难理解了。然后我们更新three，如果此时one和two都是1了，那么由于我们先更新的two，再更新的one，two为1，说明此时至少有两个数字1了，而此时one为1，说明了此时已经有了三个数字1，这块要仔细想清楚，因为one是要‘亦或’一个1的，值能为1，说明之前one为0，实际情况是，当第二个1来的时候，two先更新为1，此时one再更新为0，下面three就是0了，那么‘与’上three的相反数1不会改变one和two的值；那么当第三个1来的时候，two还是1，此时one就更新为1了，那么three就更新为1了，此时就要清空one和two了，让它们‘与’上three的相反数0即可，最终结果将会保存在one中。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"gas station","slug":"gas-station","date":"2019-04-03T15:13:48.000Z","updated":"2019-04-03T15:16:22.774Z","comments":false,"path":"2019/04/03/gas-station/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/03/gas-station/","excerpt":"","text":"gas stationThere are N gas stations along a circular route, where the amount of gas at station i isgas[i]. You have a car with an unlimited gas tank and it costscost[i]of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1. Note: The solution is guaranteed to be unique. 解析 定义一个全局的剩余油量total，定义一个 记录i到i+1是否可行（即加上在本加油站加油的数量-本加油站到下一加油站加油之前消耗的油量），定义一个站点的索引值index。我们注意到，如果sum&lt;0，也就是说从第i到第i+1个点不可行，那肯定我们原先定义的那个index的位置是无法能够转完一圈的（因为在第i点和第i+1点这里断了）。我们就令sum=0，然后令index=i，相当于说从i+1个点开始了（所以在下面return的时候是Index+1），然后开始继续往下走，如果i还没有走到最后一个，sum又小于0了，那么与前面一样，肯定要从下一个点开始，假定为起点。当一直到最后一个sum都没有小于0的话，且total也大于等于0的话，那么自然从i+1开始往后到最后一个点，再从最后一个点到起点一直到i，再到i+1是可以构成一个圈。若total&lt;0的话，则铁定i到i+1所用的油量无法用total补充回来，因此还是断开的，所以无法完成一圈，故返回-1。 1234567891011121314151617int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int total=0; int sum=0; int index=-1; for(int i=0;i&lt;gas.size();i++) &#123; sum+=gas[i]-cost[i]; total+=gas[i]-cost[i]; if(sum&lt;0) &#123; sum=0; index=i; &#125; &#125; return (total&gt;=0)?index+1:-1; &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"wordbreak","slug":"wordbreak","date":"2019-04-03T15:13:34.000Z","updated":"2019-04-03T15:15:10.418Z","comments":true,"path":"2019/04/03/wordbreak/","link":"","permalink":"http://tech.yushuai.xyz/2019/04/03/wordbreak/","excerpt":"","text":"word breakGiven a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words. For example, given s =”leetcode”, dict =[“leet”, “code”]. Return true because”leetcode”can be segmented as”leet code”. 题解：这个题其实就是可以用动态规划来进行解决，简单来说：就是将字符串分为0~j和j~i， 其中范围 [0, j) 就是dp[j]，范围 [j, i) 就是s.substr(j, i-j)，其中dp[j]是之前的状态，我们已经算出来了，可以直接取，只需要在字典中查找s.substr(j, i-j)是否存在了，如果二者均为true，将dp[i]赋为true，并且break掉，此时就不需要再用j去分[0, i)范围了，因为[0, i)范围已经可以拆分了。最终我们返回dp数组的最后一个值，就是整个数组是否可以拆分的布尔值了。 1234567891011121314151617181920bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123; int len = s.size(); if(len == 0 || dict.size() == 0) return false; vector&lt;bool&gt; isright(len+1,false);//表示字符串s[0~i-1]是否可分的bool值 isright[0] = true;//空串的情况 //将字符串分为0~j,和j~i；然后不断递归细分，不断细分之后再从最小的开始判断，再恢复回来。类似于归并排序（去学算法里面的矩阵连乘） for(int i = 1;i &lt;= len; i++) &#123; for(int j = i-1; j &gt;= 0; j--) &#123; if(isright[j] &amp;&amp; dict.find(s.substr(j,i-j))!= dict.end())//substr第二个参数表示有多少个 &#123; isright[i] = true;//若可分，则当前位置设为true， break; &#125; &#125; &#125; return v[len]; &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tech.yushuai.xyz/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"腾讯应用开发岗一轮面试面经","slug":"tencentappdevinterview","date":"2019-03-28T03:41:49.000Z","updated":"2019-03-28T03:47:14.108Z","comments":true,"path":"2019/03/28/tencentappdevinterview/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/28/tencentappdevinterview/","excerpt":"","text":"面试的部门是：云与智慧产业事业群（CSIG，即Cloud and Smart Industries Group）。我也不知道凉没凉， 总的来说， 确实有一些部分回答的不是很好，特别是自己存在以下问题： 1.对于没用到但了解的方面，没有深入去说，即便知道一个方法，也应该把它的原理说出来。 2.对于不了解具体方法的，起码要把基本原理说出来。我太实在了，应该说一句我了解基本原理，可以说一下。 3.面试太紧张，说话太没有自信，说话不流畅。 我感觉得找时间专门总结一下自己在面试时候存在的非技术性问题，必须加以改正。 具体问了一下问题，时间为23分钟： 1.自我介绍 2.知道有哪些DOA算法（回答较差） 3.转向介绍我的项目（包括VAD、时延估计、波束形成、后置滤波） 4.重点介绍了波束形成算法（介绍比较详细） 5.评价语音质量的标准？PESQ、分段噪声比、分段干扰比、语音失真度（回答的感觉不错） 6.分段噪声抑制、分段干扰抑制是怎么实现？（回答的感觉不错） 7.去除混响方法？（回答较差，但起码回答了一些东西，应该把自己知道的基本知识说出来） 8.去除回声干扰方法？（回答的较差，回答了很少东西，应该把自己知道的基本知识说出来） 9.麦克风阵列是开发板还是自己设计制作的？开发板是哪家公司的？ 10.WebRTC单声道语音消除是怎样实现的？（回答较好） 11.有什么问题想问我？ 无论是否挂了，我都又一次认识到了自己的许多问题。如果能继续下一轮最好，如果不能，我就要继续总结自己的问题，尽量在秋招避免这些问题。不怕在正式开始之前踩坑，就怕自己在正式开始之后面对曾经踩过的坑和未知的坑没有应对经验。加油，自己！","categories":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}],"tags":[{"name":"tencent","slug":"tencent","permalink":"http://tech.yushuai.xyz/tags/tencent/"},{"name":"application develop","slug":"application-develop","permalink":"http://tech.yushuai.xyz/tags/application-develop/"},{"name":"interview","slug":"interview","permalink":"http://tech.yushuai.xyz/tags/interview/"}],"keywords":[{"name":"Learning Notes","slug":"Learning-Notes","permalink":"http://tech.yushuai.xyz/categories/Learning-Notes/"}]},{"title":"线性规划2","slug":"lineprograming2","date":"2019-03-20T13:20:12.000Z","updated":"2019-03-20T13:23:00.612Z","comments":true,"path":"2019/03/20/lineprograming2/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/20/lineprograming2/","excerpt":"","text":"圆桌问题X集合中的点到Y集合中的每个点都有连线，所有连线容量都是1，保证两个点只能匹配一次（一个餐桌上只能有同一个单位的一个人）。这种在一个二分图中每个结点可以有多个匹配结点的问题称为二分图多重匹配问题。求解时需要添加源点和汇点，源和汇的边容量分别限制X、Y集合中每一个点匹配的个数。 简历一个二分图，每个代表团为X集合中的结点，每个会议桌为Y集合中的结点，增设源点s和汇点t。从源点s向每个xi结点链接一条容量为该店标团人数ri的有向边，从每个yi结点向汇点t链接一条容量为该会议桌容量cj的有向边。X集合中每个结点向Y集合中每个结点链接一条容量为1的有向边。 算法设计 构建网络。根据输入的数据，建立二分图，每个代表团为X集合中的结点，每个会议桌为Y集合中的结点，增设源点s和汇点t。从源点s向每个xi结点链接一条容量为该店标团人数ri的有向边，从每个yi结点向汇点t链接一条容量为该会议桌容量cj的有向边。X集合中每个结点向Y集合中每个结点链接一条容量为1的有向边。创建混合网络。 求网络最大流。 输出安排方案。如果最大流值等于源点s与X集合所有结点边容量之和，则说明X集合每个结点都有完备的多重匹配，否则无解。对于每个代表团来说，从X集合对应点出发的所有流量为1的边指向的Y集合的结点就是该代表团人员的安排情况（一个可行解）。 完美图解 假设代表团数M=4，每个代表团人数依次为2、4、3、5；会议桌数n=5，每个会议桌可安排人数依次为3、4、2、5、4. 构建网络。 求最大网络流。使用ISAP算法求网络最大流，找到14条增广路径。 增广路经：10-9-4-0。增流1。 增广路经：10-8-4-0。增流1。 增广路经：10-7-4-0。增流1。 增广路经：10-6-4-0。增流1。 增广路经：10-5-4-0。增流1。 增广路经：10-9-3-0。增流1。 增广路经：10-8-3-0。增流1。 增广路经：10-7-3-0。增流1。 增广路经：10-9-2-0。增流1。 增广路经：10-8-2-0。增流1。 增广路经：10-6-2-0。增流1。 增广路经：10-5-2-0。增流1。 增广路经：10-9-1-0。增流1。 增广路经：10-8-1-0。增流1。 增流后的实流网络如下图所示。 输出安排方案。最大流值等于源点s与X几何所有结点边容量之和14，说明每个代表团都有完备的多重匹配。对于每个代表团，从代表团结点出发的所有流量为1的边指向的结点就是该代表团人员的会议桌号。在程序中，会议桌储存编号=代表团数m+实际编号，输出时需要输出会议桌实际编号。 代码实现（1）构建混合网络。 cout&lt;&lt;&quot;请输入代表团数m和会议桌数n:&quot;&lt;&lt;endl; cin&gt;&gt;m&gt;&gt;n; init(); total=m+n; cout&lt;&lt;&quot;请依次输入每个代表团人数:&quot;&lt;&lt;endl; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;cost; sum+=cost; add(0, i, cost);//源点到代表团的边，容量为该代表团人数 } cout&lt;&lt;&quot;请依次输入每个会议桌可安排人数:&quot;&lt;&lt;endl; for(int j=m+1;j&lt;=total;j++) { cin&gt;&gt;cost; add(j, total+1, cost);//会议桌到汇点的边，容量为会议桌可安排人数 } for(int i=1;i&lt;=m;i++) for(int j=m+1;j&lt;=total;j++) add(i, j, 1);//代表团到会议桌的边，容量为1 （3）输出安排方案 if(sum==Isap(0,total+1,total+2)) { cout&lt;&lt;&quot;会议桌安排成功！&quot;; cout&lt;&lt;endl; print(m,n);//输出最佳方案 cout&lt;&lt;endl; printg(total+2);//输出最终网络邻接表 } else cout&lt;&lt;&quot;无法安排所有代表团！&quot;; void print(int m,int n)//输出安排方案 { cout&lt;&lt;&quot;----------安排方案如下：----------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;每个代表团的安排情况：&quot;&lt;&lt;endl; for(int i=1;i&lt;=m;i++)//读每个代表团的邻接表 { cout&lt;&lt;&quot;第&quot;&lt;&lt;i&lt;&lt;&quot;个代表团安排的会议桌号:&quot;; for(int j=V[i].first;~j;j=E[j].next)//读第i个代表团的邻接表 if(E[j].flow==1) cout&lt;&lt;E[j].v-m&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } } 算法复杂度时间复杂度：找到一条可增广路时间为O(V)，最多会执行O(VE)次，因为关键边的总数为O(VE)，因此总的时间复杂度为O(V2E)，其中V为结点个数，E为边的数量。 空间复杂度O(V)。 试题库问题这仍然是一个二分图多重分配问题。 算法设计 构建网络。根据输入的数据，简历二分图，每个题型为X集合中的结点，每个实体为Y集合中的结点，增设源点s和汇点t。从源点s向每个xi有一条有向边，容量为该题型选出的数量ci。从每个yi向t连接一条有向边，容量为1，以保障每道题只能选中一次。Y集合中的题属于哪些题型，则xi就和yi之间有一条有向边，容量为1，创建混合网络。 求网络最大流。 输出抽取方案。如果最大流值等于源点s与X集合所有结点边容量之和，则说明实体抽取成功，否则无解。对于每个题型来说，从X集合对应点出发的所有流量为1的边指向的Y集合的结点就是该题型选中的试题号（一个可行解）。 完美图解假设题型数m=4，实体总数n=15，我们要在每种题型依次选择2、0、3、2个实体。上述的15个实体中，每个实体所属的题型依次是：1/2；2/3；1/4；2/3；2/4；1/2/3；3；4；4；2/3/4；3；2；1；1、4；4。 构建网络。 使用ISAP算法求网络最大流，找到7条增广路径。 增广路经：20-19-4-0。增流：1。 增广路经：20-18-4-0。增流：1。 增广路经：20-15-3-0。增流：1。 增广路经：20-14-3-0。增流：1。 增广路经：20-11-3-0。增流：1。 增广路经：20-17-1-0。增流：1。 增广路经：20-10-1-0。增流：1。 输出抽取方案。最大流值等于抽取的试题数之和，说明试题抽取成功。 算法复杂度时间复杂度：找到一条可增广路时间为O(V)，最多会执行O(VE)次，因为关键边的总数为O(VE)，因此总的时间复杂度为O(V2E)，其中V为结点个数，E为边的数量。 空间复杂度O(V)。 最大收益问题问题分析经过分析，又根据最大流最小割定理，最大流的流值等于最小割容量。即：实验方案净收益=所有实验项目收益-最大流值。所以只需要求出最大流值即可、 算法设计 构建网络。根据输入的数据，添加源点和汇点，从源点s到每个实验项目Ei有一条有向边，容量是项目产生的收益pi。从每个实验仪器Ij到汇点t有一条有向边，容量是仪器费用cj，每个实验项目到该实验项目用到的仪器有一条有向边容量是∞，创建混合网络。 基于ISAP算法求网络最大流。 输出最大收益及实验方案。最大收益实验方案就是最小割中的S集合去掉源点。在最大流对应的混合网络中，从选点开始，沿着cap&gt;flow的边深度优先遍历，遍历到的结点就是S集合，即对应的实验项目和仪器就是选中的实验方案。 代码实现 输出最大收益方案 123456789101112131415161718192021222324252627void DFS(int s)//深度搜索最大获益方案&#123; for(int i=V[s].first;~i;i=E[i].next)//读当前结点的邻接表 if(E[i].cap&gt;E[i].flow) &#123; int u=E[i].v; if(!flag[u]) &#123; flag[u]=true; DFS(u); &#125; &#125;&#125;void print(int m,int n)//输出最佳方案&#123; cout&lt;&lt;&quot;----------最大获益方案如下：----------&quot;&lt;&lt;endl; DFS(0); cout&lt;&lt;&quot;选中的实验编号：&quot;&lt;&lt;endl; for(int i=1;i&lt;=m;i++) if(flag[i]) cout&lt;&lt;i&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; cout&lt;&lt;&quot;选中的仪器编号：&quot;&lt;&lt;endl; for(int i=m+1;i&lt;=m+n;i++) if(flag[i]) cout&lt;&lt;i-m&lt;&lt;&quot; &quot;;&#125; 构建混合网络 12345678910111213141516171819cout&lt;&lt;&quot;请输入实验数m和仪器数n:&quot;&lt;&lt;endl; cin&gt;&gt;m&gt;&gt;n; init(); total=m+n; cout&lt;&lt;&quot;请依次输入实验产生的效益和该实验需要的仪器编号(为0结束):&quot;&lt;&lt;endl; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;cost; sum+=cost; add(0, i, cost);//源点到实验项目的边，容量为该项目效益 while(cin&gt;&gt;num,num) //num为该项目需要的仪器编号 add(i, m+num, INF);//实验项目到需要仪器的边，容量为无穷大 &#125; cout&lt;&lt;&quot;请依次输入所有仪器的费用:&quot;&lt;&lt;endl; for(int j=m+1;j&lt;=total;j++) &#123; cin&gt;&gt;cost; add(j, total+1, cost);//实验仪器到汇点的边，容量为实验仪器费用 &#125; 算法复杂度时间复杂度：找到一条可增广路时间为O(V)，最多会执行O(VE)次，因为关键边的总数为O(VE)，因此总的时间复杂度为O(V2E)，其中V为结点个数，E为边的数量。 空间复杂度O(V)。 方格取数问题问题简介从一个矩阵中选取一些数，要求满足任意两个数不相邻，使这些数的和最大。实际上就是讲矩阵中的数分为两部分，对矩阵中的点进行黑白着色。 问题分析黑色方格作为一个集合X，白色方格作为一个集合Y，可以将一个图分为两部分，构成一个二分图。添加源点和汇点，从源点向黑色方格连一条边，容量为该黑色方格的权值，从白色方格向汇点连一条边，容量为该白色方格的权值，对于每一对相邻的黑白方格，从黑方格向白方格连一条边，容量为无穷大。 同样是求出最小割，选中方格的最大权值=所有方格权值之和-最小割容量。 算法设计 构建网络 求网络最大流。 输出选中物品的最大价值、物品选择方案。 选中物品的最大价值=所有物品价值之和-最大流值注意：切割线切到的边容量是没选中的方格权值。 物品选择方案就是最小割中的S集合中的黑色方格和T集合中的白色方格。找到最小割后，从源点出发，沿着cap&gt;flow的边DFS，遍历到的结点就是S集合，没有遍历到的结点就是T集合。输出S集合中的黑色方格和T集合中的白色方格。如上图所示。 算法详解假设整个图如下图所示。 构建网络，根据输入的数据，绘制二分图，添加源点s和汇点t，从黑方格向白方格连一条边，容量为∞，创建网络。 在混合网络上用ISAP算法求网络最大流，找到如下6条增广路径。 增广路径：10-6-9-0.增流5。 增广路径：10-8-9-0.增流15。 增广路径：10-4-7-0.增流34。 增广路径：10-2-5-0.增流70。 增广路径：10-2-3-0.增流21。 增广路径：10-2-1-0.增流75。 切割线中被选中的就是红色圈圈的结点，选择的道路是从源点出发，按照cap&gt;flow的结点（这里面只有7和9两个结点）去深度遍历，这就是S集合；1、3、5和2是T集合。所以选中的黑点为7、9，白色为2。 代码实现（1）构建网络 12345678910111213141516171819202122//创建混合网络for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) &#123; if((i+j)%2==0)//染黑色 &#123; add(0,(i-1)*n+j,map[i][j]);//从源点到当前物品加边，容量为物品价值 flag[(i-1)*n+j]=1;//染色 //当前物品结点到四个相邻物品结点发出一条有向边，容量为无穷大 for(int k=0;k&lt;4;k++) &#123; int x=i+dir[k][0]; int y=j+dir[k][1]; if(x&lt;=m &amp;&amp; x&gt;0 &amp;&amp; y&lt;=n &amp;&amp; y&gt;0) add((i-1)*n+j,(x-1)*n+y,INF); &#125; &#125; else //染白色，也就相当于flag为0，不需要专门的语句 //从源点到当前物品加边，容量为物品价值 add((i-1)*n+j,total+1,map[i][j]); &#125; （2）输出挑选物品的最大价值 1cout&lt;&lt;&quot;挑选物品的最大价值：&quot;&lt;&lt;sum-Isap(0,total+1,total+2)&lt;&lt;endl; （3）输出选中的物品编号。12345678910111213141516171819202122232425void DFS(int s)&#123; //读取当前结点的邻接表 for(int i=V[s].first;~i;i=E[i].next) &#123; if(E[i].cap&gt;E[i].flow) &#123; int u=E[i].v; if(!dfsflag[u]) &#123; dfsflag[u]=true; DFS(u); &#125; &#125; &#125;&#125;//输出最佳方案void print(int m,int n)&#123; cout&lt;&lt;&quot;-----最佳方案：-----&quot;&lt;&lt;endl; cout&lt;&lt;&quot;选中物品编号&lt;&lt;endl; DFS(0); for(int i=1;i&lt;=m*n;i++) if(())&#125; 算法复杂度时间复杂度：找到一条可增广路时间为O(V)，最多会执行O(VE)次，因为关键边的总数为O(VE)，因此总的时间复杂度为O(V2E)，其中V为结点个数，E为边的数量。 空间复杂度O(V)。 旅游路线问题问题分析给定一张地图，图中结点代表景点，边代表景点可以直达。现要求找到满足下面要求且途径景点最多的一条旅游线路： 从最东端起点出发，从东往西经过若干个景点到达最西端的景点，然后再从西向东回到家（可途径若干景点）； 除起点外，任何景点只能访问1次。 算法设计 构建网络。根据输入的数据，按顺序对景点进行编号，即景点i对应结点i，对每个结点拆点，拆为两个结点i和i’，且从i到i’连接一条边，边容量为1，单位流量费用为0；源点和终点拆点时，边的容量为2，单位流量费用为0；如果景点i到景点j可以直达，则从结点i’到结点j连接一条边，边的容量为1，单位流量费用为-1，创建混合网络。 求网络最小费用最大流。 求出最优的旅游线路。从源点出发，沿着flow&gt;0且cost≤0的方向深度优先遍历，到达终点后，再沿着flow＜0且cost≥0的方向深度优先遍历，返回源点。 代码实现 构建网络 12345678910111213141516171819202122232425262728293031323334cout&lt;&lt;&quot;请输入景点个数n和直达线路数m:&quot;&lt;&lt;endl; cin&gt;&gt;n&gt;&gt;m; init();//初始化 maze.clear(); cout&lt;&lt;&quot;请输入景点名str&quot;&lt;&lt;endl; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;str[i]; maze[str[i]]=i; if(i==1||i==n) add(i,i+n,2,0); else add(i,i+n,1,0); &#125; cout&lt;&lt;&quot;请输入可以直达的两个景点名str1,str2&quot;&lt;&lt;endl; for(i=1;i&lt;=m;i++) &#123; cin&gt;&gt;str1&gt;&gt;str2; int a=maze[str1],b=maze[str2]; if(a&lt;b) &#123; if(a==1&amp;&amp;b==n) add(a+n,b,2,-1); else add(a+n,b,1,-1); &#125; else &#123; if(b==1&amp;&amp;a==n) add(b+n,a,2,-1); else add(b+n,a,1,-1); &#125; &#125; 求网络最小费用最大流 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374bool SPFA(int s, int t, int n)//求最小费用路的SPFA&#123; int i, u, v; queue &lt;int&gt; qu; // 队列，STL实现 memset(vis,0,sizeof(vis));//访问标记初始化 memset(c,0,sizeof(c)); //入队次数初始化 memset(pre,-1,sizeof(pre)); //前驱初始化 for(i=1;i&lt;=n;i++) &#123; dist[i]=INF; //距离初始化 &#125; vis[s]=true; //结点入队vis要做标记 c[s]++; //要统计结点的入队次数 dist[s]=0; qu.push(s); while(!qu.empty()) &#123; u=qu.front(); qu.pop(); vis[u]=false; //队头元素出队，并且消除标记 for(i=V[u].first; i!=-1; i=E[i].next)//遍历结点u的邻接表 &#123; v=E[i].v; if(E[i].cap&gt;E[i].flow &amp;&amp; dist[v]&gt;dist[u]+E[i].cost)//松弛操作 &#123; dist[v]=dist[u]+E[i].cost; pre[v]=i; //记录前驱 if(!vis[v]) //结点v不在队内 &#123; c[v]++; qu.push(v); //入队 vis[v]=true; //标记 if(c[v]&gt;n) //超过入队上限，说明有负环 return false; &#125; &#125; &#125; &#125; cout&lt;&lt;&quot;最短路数组&quot;&lt;&lt;endl; cout&lt;&lt;&quot;dist[ ]=&quot;; for(int i=1;i&lt;=n;i++) cout&lt;&lt;&quot; &quot;&lt;&lt;dist[i]; cout&lt;&lt;endl; if(dist[t]==INF) return false; //如果距离为INF，说明无法到达，返回false return true;&#125;int MCMF(int s,int t,int n) //minCostMaxFlow&#123; int d; //可增流量 maxflow=mincost=0;//maxflow 当前最大流量，mincost当前最小费用 while(SPFA(s,t,n))//表示找到了从s到t的最短路 &#123; d=INF; cout&lt;&lt;endl; cout&lt;&lt;&quot;增广路径：&quot;&lt;&lt;t; for(int i=pre[t]; i!=-1; i=pre[E[i^1].v]) &#123; d=min(d, E[i].cap-E[i].flow); //找最小可增流量 cout&lt;&lt;&quot;--&quot;&lt;&lt;E[i^1].v; &#125; cout&lt;&lt;&quot;增流：&quot;&lt;&lt;d&lt;&lt;endl; cout&lt;&lt;endl; for(int i=pre[t]; i!=-1; i=pre[E[i^1].v])//修改残余网络，增加增广路上相应弧的容量，并减少其反向边容量 &#123; E[i].flow+=d; E[i^1].flow-=d; &#125; maxflow+=d; //更新最大流 mincost+=dist[t]*d; //dist[t]为该路径上单位流量费用之和 ，最小费用更新 &#125; return maxflow;&#125; 输出最优的旅游路线 123456789101112void print(int s,int t)&#123; int v; vis[s]=1; for(int i=V[s].first;~i;i=E[i].next) if(!vis[v=E[i].v]&amp;&amp;((E[i].flow&gt;0&amp;&amp;E[i].cost&lt;=0)||(E[i].flow&lt;0&amp;&amp;E[i].cost&gt;=0))) &#123; print(v,t); if(v&lt;=t) cout&lt;&lt;str[v]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"},{"name":"线性规划","slug":"线性规划","permalink":"http://tech.yushuai.xyz/tags/线性规划/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}]},{"title":"线性规划1","slug":"lineprograming1","date":"2019-03-20T13:20:06.000Z","updated":"2019-03-20T13:22:51.066Z","comments":true,"path":"2019/03/20/lineprograming1/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/20/lineprograming1/","excerpt":"","text":"线性规划问题遇到一个线性规划问题，该如何解决呢？ 确定决策变量。 确定目标函数。 找出约束条件。 求最优解。 一般线性规划问题可以表示为如下形式。 约束条件为： 变量满足约束条件的一组值成为线性规划问题的一个可行解。 所有可行解构成的集合成为线性规划的可行区域。 使目标函数取得极值的可行解称为最优解。 在最优解处目标函数的值成最优值。 线性规划解的情况： 有唯一最优解。 有无数多个最优解。 没有最优解。 线性规划的标准型标准型如下： 四个要求： 目标函数为最大值（即为max）； 约束条件常数项bi&gt;=0； 约束条件全部为等式约束； 决策变量xi非负约束。 线性规划标准型转化方法： 一般线性规划行驶中目标函数如果求最小值，那么令z’=-z，得到最优解后，加负号即可。 右端常数项小于零时，则不等式两边同乘-1，将其变成大于零；同时改变不等号的方向，保证恒等变形。 约束条件为大于与等于约束条件时，则在不等式左侧减去一个新的非负变量将不等式约束改为等式约束。例如2x1-3x2≥10，修改为：2x1-3x2-x3=10，x3&gt;0。 约束条件为小于等于约束时，则在不等式左侧加去一个新的非负变量将不等式约束改为等式约束。 无约束的决策变量x，即可正可负的变量，则引入两个新的非负变量x’和x’’，令x-x’-x’’，其中x’≥0，x’’≥0，将x带入线性规划模型。例如：2x1-3x2+x3=10，x3无约束，则可以修改为：x3=x4-x5，x4&gt;0,x5&gt;0，带入方程得到2x1-3x2+x4-x5=10，x4&gt;0,x5&gt;0。注意：引入的新的非负变量称为松弛变量。 单纯形算法图解基本概念： 基本变量：每个约束条件中的系数为正，且只出现在一个约束条件中的变量。 非基本变量：除基本变量以外的变量。 基本可行解：满足标准形式约束条件的可行解称为基本可行解。 检验数：目标函数中非基本变量的技术。 基本定理： 最优解判别定理：若目标函数中关于非基本变量的所有系数小于等于0，则当前基本可行解就是最优解。 无穷多最优解判别定理：若目标函数中关于费基本变量的所有检验数小于等于0，同时存在某个非基本变量的检验数等于0，则线性规划问题有无穷多个最优解。 无界解定理：如果某个检验数cj大于0，而cj所对应的列向量的各分量a1j,a2j,…,amj都小于等于0，则该线性规划问题有无界解。 约束标准型线性规划问题单纯形算法步骤如下： 建立初始单纯形表。找出基本变量和非基本变量，将目标函数由非基本变量表示，建立初始单纯形表。注意：如果目标函数含有基本变量，要通过约束条件方程转换为非基本变量。 还要注意：基本变量的系数要转化为1 ，否则不能按照下面的计算方法。基本变量做行，非基本变量做列，检验数放第一行，常数项放低1列，约束条件中非基本变量的系数作为值，构造初始单纯形表。如下所示： b x2 x3 x4 c 0 -1 3 -2 x1 7 3 -1 2 x5 12 -2 4 0 x6 10 -4 3 8 判断是否得到最优解。判别并检查目标函数的所有系数。 如果所有的cj&lt;=0，则已经获得最优解，算法结束。 若在检验数cj中，有些为正数，但其中某一正的检验数所对应的列向量的各分量均小于等于0，则线性规划问题无界，算法结束。 若在检验数cj中，有些为正数且它们对应的列向量中有正的分量，则转到第3步。 选入基变量。选取所有正检验数中最大的一个，记为ce，其对应的非基本变量为xe，称为入基变量，xe对应的列向量[a1e,a2e,…,ame]T为入基列。在本例中，x3为入基变量，x3对应的列向量为入基列，如下所示。 b x2 x3 x4 c 0 -1 3 -2 x1 7 3 -1 2 x5 12 -2 4 0 x6 10 -4 3 8 选离基变量、选取“常数列元素/入基列元素”正比值最小者，所对应的基本变量xk为离基变量。xk对应的行向量为离基行。在本例中，x5为离基变量，对应的行向量为离基行。 换基变换。在单纯形表上将入基变量和离基变量互换位置，即在本例中将x3和x5交换位置，换基变换后如下所示。 b x2 x5 x4 c 0 -1 3 -2 x1 7 3 -1 2 x3 12 -2 4 0 x6 10 -4 3 8 计算新的单纯形表。按照下面的方法计算新的单纯形表，然后转第2步。4个特殊位置如下： 入基列：-原值/交叉位值（不包括交叉位）。 离基行=原值/交叉位值（不包括交叉位） 交叉位=原值取倒数。 c0位：原值+同行入基列元素*同列离基行元素/交叉位值。 一般位置元素=原值-同行入基列元素*同列离基行元素/交叉位值。 b x2 x5 x4 c 9 0.5 -0.75 -2 x1 10 2.5 0.25 2 x3 3 -0.5 0.25 0 x6 1 -2.5 -0.75 8 判断是否得到最优解，若没有继续第3~6步，直到找到最优解或判定无界解停止。在本例中，再次选定基列变量x2和离基变量x1，将他们互换位置，重新计算单纯形表，得到下面的表。 b x1 x5 x4 c 11 -0.2 -0.8 -2.4 x2 4 0.4 0.1 0.8 x3 5 0.2 0.3 0.4 x6 11 1 -0.5 10 可以看出目标函数的检验数全部都小于0，得到最优解。c0就是我们要的最优值（11），而最优解是由基本变量对应的常数项组成的，即x2=4，x3=5，x6=11，非基本变量全部置零。以上算法获得的是max z’，而本题要求是min z，所以答案是-11。 工厂最大效益——单纯形算法题目描述某食品加工厂有三个车间，第一车间用1个单位的原料N可以加工5个单位的产品A或者2个单位的产品B。产品A若直接出售，价格10元，如果第二车间继续加工，加工费5元，加工后售价19元，产品B直接出售16元，第三车间继续加工加工费4元，然后售价24元。原料N的单位购入价为5元，每工时工资为15元，第一车间加工一个单位N，需要0.05工时，第二个0.1工时，第三个0.08工时，每个月最多得到12000个N，工时最多为1000工时。如何生产，收益最大？ 问题分析假设变量：x1：产品A的售出量。x2：产品A在第二车间加工后售出量.x3：产品B售出量。x4：产品B在第三车间加工后售出量。x5：第一车间所用原材料数量。 第一车间所有原材料费和人工费为：5x5+0.05×15x5=5.75x5（下面计算盈利时，均已除去第一车间的材料和人工费） A直接售出，盈利：10x1。 A加工后售出，因为有额外加工费、人工费：5+0.1×15=6.5，售价-额外成本=19-6.5=12.5，盈利12.5x2。 B直接售出，盈利16x3。 B加工后售出，额外费用4+0.08×15=5.2，售价-成本=24-5.2=18.8，盈利18.8x4。 总盈利：z=10x1+12.5x2+16x3+18.8x4-5.75x5。 所以目标函数和约束条件如下： 完美图解转化为标准型，目标函数也重新表示： 基本变量为：x1，x3，x6，x7。非基本变量：x2，x4，x5。 建立单纯形表如下：||b|x2|x4|x5||–|–|–|–|–||c|0|2.5|2.8|76.25||x1|0|1|0|-5||x3|0|0|1|-2||x6|12000|0|0|1||x7|1000|0.1|0.08|0.05| 具体图解过程不再重述。 代码实现全局变量如下： float kernel[100][100];//存储非单纯形表 char FJL[100] = {};//非基本变量 char JL[100] = {};//基本变量 int n, m, i, j; 代码内容如下： void print()//输出单纯型表 { cout&lt;&lt;endl; cout&lt;&lt;&quot;----------单纯形表如下：----------&quot;&lt;&lt;endl; cout&lt;&lt;&quot; &quot;; cout&lt;&lt;setw(7)&lt;&lt;&quot;b &quot;; for(i=1;i&lt;=m;i++) cout&lt;&lt;setw(7)&lt;&lt;&quot;x&quot;&lt;&lt;FJL[i]; cout&lt;&lt;endl; cout&lt;&lt;&quot;c &quot;; for(i=0;i&lt;=n;i++) { if(i&gt;=1) cout&lt;&lt;&quot;x&quot;&lt;&lt;JL[i]; for(j=0;j&lt;=m;j++) cout&lt;&lt;setw(7)&lt;&lt;kernel[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } } void DCXA() { float max1; //max1用于存放最大的检验数 float max2; //max2用于存放最大正检验数对应的基本变量的最大系数 int e=-1; //记录入基列 int k=-1; //记录离基行 float min; //循环迭代，直到找到问题的解或无解为止 while(true) { max1=0; min=100000000; for(j=1;j&lt;=m;j++) //找入基列(最大正检验数对应的列) { if(max1&lt;kernel[0][j]) { max1=kernel[0][j]; e=j; } } if(max1&lt;=0) //最大值小于等于0，即所有检验数小于等于0，满足获得最优解的条件 { cout&lt;&lt;endl; cout&lt;&lt;&quot;获得最优解:&quot;&lt;&lt;kernel[0][0]&lt;&lt; endl; print(); break; } for(j=1;j&lt;=m;j++) //判断正检验数对应的列是否都小于等于0，如果是则无界解 { max2=0; if(kernel[0][j]&gt;0) { for(i=1;i&lt;=n;i++) //搜索正检验数对应的列 if(max2&lt;kernel[i][j]) max2=kernel[i][j]; if(max2==0) { cout&lt;&lt;&quot;解无界&quot;&lt;&lt;endl; return;//退出函数，不能用break，因为它只是退出当前循环 } } } for(i=1;i&lt;=n;i++) //找离基行(常数列/入基列正比值最小对应的行) { float temp=kernel[i][0]/kernel[i][e]; //常数项在前,temp=fabs(temp); if(temp&gt;0&amp;&amp;temp&lt;min) //找离基变量 { min=temp; k=i; } } cout&lt;&lt;&quot;入基变量：&quot;&lt;&lt;&quot;x&quot;&lt;&lt;FJL[e]&lt;&lt;&quot; &quot;; cout&lt;&lt;&quot;离基变量：&quot;&lt;&lt;&quot;x&quot;&lt;&lt;JL[k]&lt;&lt;endl; //换基变换(转轴变换) char temp=FJL[e]; FJL[e]=JL[k]; JL[k]=temp; for(i=0;i&lt;=n;i++) //计算除入基列和出基行的所有位置的元素 { if(i!=k) { for(j=0;j&lt;=m;j++) { if(j!=e) { if(i==0&amp;&amp;j==0) //计算特殊位c0,即目标函数的值 kernel[i][j]=kernel[i][j]+kernel[i][e]*kernel[k][j]/kernel[k][e]; else //一般位置 kernel[i][j]=kernel[i][j]-kernel[i][e]*kernel[k][j]/kernel[k][e]; } } } } for(i=0;i&lt;=n;i++) //计算特殊位,入基列的元素 { if(i!=k) kernel[i][e]=-kernel[i][e]/kernel[k][e]; } for(j=0;j&lt;=m;j++) //计算特殊位,离基行的元素 { if(j!=e) kernel[k][j]=kernel[k][j]/kernel[k][e]; } //计算特殊位,交叉位置 kernel[k][e]=1/kernel[k][e]; print(); } } 复杂度分析 时间复杂度：在输入基本变量和非基本变量中用了n+m循环次数，在输入单纯形表时有nm此循环，打印最优解时有n+nm次的时间打印结果，在寻找入基列和离基行中，最坏情况下有O(n*m)次循环，在循环迭代中最坏情况需要2n迭代，则时间复杂度为O(2n)。 空间复杂度：O(1)。 最大网络流——最短增广路算法问题描述设有向带权图G=(V,E)，V={s,v1,v2,v3,…,t}。在G中有两个特殊的结点s和t。s称为源点，t为汇点。图中各边的方向表示允许的流向，边上的权值表示该边允许通过的最大可能流量cap，且cap≥0，称它为边的容量。而且如果边集合E含有一条边(u,v)，则比如不存在反方向的(v,u)，我们称这样的有向带权图为网络。网络是一个有向带权图，包含一个源点和一个汇点，没有反平行边。网络流：网络流即网络上的流，是定义在网络边集E上的一个非负函数flow={flow(u,v)},flow(u,v)是边上的流量。可行流：满足下面两个性质的网络流flow称为可行流： 容量约束。每个管道的实际流量flow不能超过该管道的最大容量cap。 流量守恒。除源点s和汇点t外，所有内部结点流入量=流出量。 网络最大流：在满足容量约束和流量守恒前提下，在流网络中找到一个净输出最大的网络流。 增广路算法（Ford-Fulkerson算法）基本概念 实流网络：实际流量的网络。 残余网络：每个网络G及其上的一个流flow，都对应一个残余网络G。G和G结点集相同，而网络G中的每条边对应G中的一条边或两条边。*在残余网络中，与网络边对应的同向边是可增量（即还可以增加多少），反向边是实际流量。 可增广路是残余网络G*中一条从源点s到汇点t的简单路径。 可增广量是指在可增广路p上每条边可以增加的流量最小值。 可增广路增流增流操作分为两个过程：一是在实流网络中增流；二是在残余网络中减流。 增广路算法增广路定理：设flow是网络G的一个可行流，如果不存在从源点s到汇点t关于flow的可增广路，则flow是G的一个最大流。增广路算法基本思想是在残余网络中找到可增广路，然后在实流网络中沿可增广路增流，在残余网络中沿可增广路减流；继续在残余网络中找可增广路，直到不存在可增广路为止。 最短增广路算法Edmonds-Karp算法是以广度优先的增广路算法，又称为最短增广路算法（Shortest Augment Path, SAP）。算法步骤如下：采用队列q来存放已访问未检查的结点。bool数组vis[]标注结点是否被访问过，pre[]数组记录可增广路上结点的前驱。pre[v]=u表示可增广路上v结点的前驱是u，最大流值maxflow=0。 初始化可行流flow为零流，即实流网络中全是零流边，残余网络中全是最大容量边。初始化vis[]=false，pre[]数组为-1。 令vis[s]=true，s加入队列q。 如果队列不空，继续下一步，否则算法结束，找不到可增广路。当前的实流网络就是最大流网络，返回最大流值maxflow。 队头元素new出队，在残余网络中检查new的所有邻接结点i。如果未被访问，则访问它，令vis[i]=true，pre[i]=new；如果i=t，说明已经到达汇点，找到一条可增广路，转向第5步；否则结点i加入队列q，，转向第3步。 从汇点开始，通过前驱数据pre[]，逆向找可增广路上每条边值的最小值，即可增量d。 在实流网络中增流，在残余网络中减流，maxflow+=d，转向第2步。 算法设计在求解的时候需要先初始化一个可行流，然后在可行流上不断找可增广路增流即可。初始化为任何一个可行流都可以，但需要满足容量约束和平衡约束。通常初始化可行流为0流。 数据结构。网络G邻接矩阵为g[][]。 ∞ 12 10 ∞ ∞ ∞ ∞ ∞ ∞ 8 ∞ ∞ ∞ 2 ∞ ∞ 13 ∞ ∞ ∞ 5 ∞ ∞ 18 ∞ ∞ ∞ 6 ∞ 4 ∞ ∞ ∞ ∞ ∞ ∞ 初始化。初始化可行流flow为零流，即实流网络中全是零流边，残余网络全是最大容量边，初始化vis[]=false，pre[]数组为-1。 vis[i] 1 2 3 4 5 6 0 0 0 0 0 0 0 pre[i] 1 2 3 4 5 6 -1 -1 -1 -1 -1 -1 令vis[1]=true，1加入队列q。 队头元素1出队。在残余网络G*中依次检查1的所有邻接结点2和3，两个结点都未被访问，令vis[2]=true，pre[2]=1，结点2加入队列q；vis[3]=true,pre[3]=1，结点3加入队列q。此时vis[i]、pre[i]和q如下所示。 vis[i] 1 2 3 4 5 6 1 1 1 0 0 0 0 pre[i] 1 2 3 4 5 6 -1 1 1 -1 -1 -1 序号 0 1 2 3 q 2 3 队头元素2出队。在残余网络中依次检查2的所有邻接结点4，4未被访问，令vis[4]=1,pre[4]=2，结点4加入队列q。 队头元素3出队。在残余网络中依次检查3的所有邻接结点2和5。2已经被访问，5未被访问，令vis[5]=1,pre[5]=3，结点5加入队列q。此时vis[i]、pre[i]和q如下所示。 vis[i] 1 2 3 4 5 6 1 1 1 1 1 0 0 pre[i] 1 2 3 4 5 6 -1 1 1 2 3 -1 序号 0 1 2 3 q 4 5 队头元素4出队。在残余网络中依次检查4的所有邻接结点3和6。3已经被访问，6未被访问，令vis[6]=1,pre[6]=4。结点6就是汇点，找到一条增广路。此时vis[i]、pre[i]和q如下所示。 vis[i] 1 2 3 4 5 6 1 1 1 1 1 1 1 pre[i] 1 2 3 4 5 6 -1 1 1 2 3 4 序号 0 1 2 3 q 5 读取钱取数组，得到1-2-4-6，找到该路径上的最小边值为8，即可增量d=8。 实流网络增流，残余网络减流。可增广路通向的边增流d，反向边减流d。 重复2~8步，找到第2条可增广路1-3-5-6，找到最小边值，即可增量=4，进行第9步。 重复2~8步，找到第3条可增广路1-3-5-4-6，找到最小边值，即可增量=6，进行第9步。 重复2~8步，找不到可增广路，算法结束，最大流值为所有的增量之和18。 为什么要采用残余网络+实流网络？在网络G及可行流直接找可增广路，有可能得不到最大流。 为什么要用实流网络？从残余网络中无法判断哪些是实流边，哪些是可增量边，如果想知道实际的网络流量，就需要借助于实流网络。 整个过程是采用：在残余网络找可增广路，在实流网络中增流相结合的方式，求解最大流。 代码实现1.找可增广路。采用普通队列实现对残余网络的广度搜索，从源点u开始，s搜索邻接点v。如果v被访问，则标记已访问，且记录v结点的前驱为u；如果u结点不是汇点则入队；如果u结点恰好是汇点，则返回，找到汇点时则找到一条可增广路。如果队列为空，则说明已经找不到可增广路。 bool bfs(int s,int t) { memset(pre,-1,sizeof(pre)); memset(vis,false,sizeof(vis)); queue&lt;int&gt;q; vis[s]=true; q.push(s); while(!q.empty()) { int now=q.front(); q.pop(); for(int i=1;i&lt;=n; i++)//寻找可增广路 { if(!vis[i]&amp;&amp;g[now][i]&gt;0)//未被访问且有边相连 { vis[i] = true; pre[i] = now; if(i==t) return true;//找到一条可增广路 q.push(i); } } } return false;//找不到可增广路 } 2.沿可增广路增流。根据钱取数组，从汇点向前，一直到源点，找到可增广路上所有边的最小值，即为可增量d。然后从汇点向前，一直到源点，残余网络中同向边减流，反向边增流，实流网络中如果是反向边，则减流，否则正向边增流。 int EK(int s, int t) { int v,w,d,maxflow; maxflow = 0; while(bfs(s,t))//可以增广 { v=t; d=INF; while(v!=s)//找可增量d { w=pre[v];//w记录v的前驱 if(d&gt;g[w][v]) d=g[w][v]; v=w; } maxflow+=d; v=t; while(v!=s)//沿可增广路增流 { w=pre[v]; g[w][v]-=d; //残余网络中正向边减流 g[v][w]+=d; //残余网络中反向边增流 if(f[v][w]&gt;0) //实流网络中如果是反向边,则减流,否则正向边增流 f[v][w]-=d; else f[w][v]+=d; v=w; } } return maxflow; } 3.输出实流网络 void print()//输出实流网络 { cout&lt;&lt;endl; cout&lt;&lt;&quot;----------实流网络如下：----------&quot;&lt;&lt;endl; cout&lt;&lt;&quot; &quot;; for(int i=1;i&lt;=n;i++) cout&lt;&lt;setw(7)&lt;&lt;&quot;v&quot;&lt;&lt;i; cout&lt;&lt;endl; for(int i=1;i&lt;=n;i++) { cout&lt;&lt;&quot;v&quot;&lt;&lt;i; for(int j=1;j&lt;=n;j++) cout&lt;&lt;setw(7)&lt;&lt;f[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } } 算法复杂度分析 时间复杂度：找到一条可增广路时间是O(E)，最多会执行O(VE)此，因此关键边总数为O(VE)，因此总的时间复杂度为O(VE2)。其中V为结点个数，E为边的数量。 空间复杂度：使用了一个二维数组，所以复杂度为O(V2)。 优化扩展——重贴标签算法ISAP首先对所有的结点标记到汇点的最短距离，称之为高度。标高从汇点开始，用BFS方式，汇点的邻接点高度为1，继续访问的结点高度是2，一直到源点结束。 贴好标签之后，就可以从源点开始，沿着高度h(u)=h(v)+1且具有可行邻接边（cap&gt;flow)的方向前进。我们找到了1-2-4-6。 我们再次从源点开始搜索，沿着高度h(u)=h(v)+1且具有可行邻接边（cap&gt;flow)的方向前进，h(1)=3,h(2)=2，走到这里无法走到4号结点，因为没有邻接边，3号结点不近没有邻接边，而且高度也不满足条件，也不能走到1号结点，怎么办呢？ 可以用重贴标签的方法。当前结点无法前进时，令当前结点的高度=所有邻接点高度的最小值+1；如果没有邻接边，则令当前结点的高度=结点数；退回一步，重新搜索。 算法设计 确定合适的数据结构。采用邻接表存储网络。 对网络结点贴标签，即标高操作。 如果源点的高度≥结点数，则转向第6步；否则从源点开始，沿着高度h(u)=h(v)+1且具有可行邻接边（cap&gt;flow)的方向前进，如果到达汇点，则转向第4步；如果无法进行，则第5步。 增流操作：沿着找到的可增广路同向边增流，反向边减流。注意：在原网络上操作。 重贴标签：如果拥有当前结点高度的结点只有一个，转向第6步；令当前结点的高度=所有邻接点高度的最小值+1；如果没有邻接边，则令当前结点的高度=结点数；退回一步；转向第3步。 算法结束，已经找到最大流。 算法实现 const int inf = 0x3fffffff; const int N=100; const int M=10000; int top; int h[N], pre[N], g[N]; struct Vertex { int first; }V[N]; struct Edge { int v, next; int cap, flow; }E[M]; void init() { memset(V, -1, sizeof(V)); top = 0; } void add_edge(int u, int v, int c) { E[top].v = v; E[top].cap = c; E[top].flow = 0; E[top].next = V[u].first; V[u].first = top++; } void add(int u,int v, int c) { add_edge(u,v,c); add_edge(v,u,0); } void set_h(int t,int n) { queue&lt;int&gt; Q; memset(h, -1, sizeof(h)); memset(g, 0, sizeof(g)); h[t] = 0; Q.push(t); while(!Q.empty()) { int v = Q.front(); Q.pop(); ++g[h[v]]; for(int i = V[v].first; ~i; i = E[i].next) { int u = E[i].v; if(h[u] == -1) { h[u] = h[v] + 1; Q.push(u); } } } cout&lt;&lt;&quot;初始化高度&quot;&lt;&lt;endl; cout&lt;&lt;&quot;h[ ]=&quot;; for(int i=1;i&lt;=n;i++) cout&lt;&lt;&quot; &quot;&lt;&lt;h[i]; cout&lt;&lt;endl; } int Isap(int s, int t,int n) { set_h(t,n); int ans=0, u=s; int d; while(h[s]&lt;n) { int i=V[u].first; if(u==s) d=inf; for(; ~i; i=E[i].next) { int v=E[i].v; if(E[i].cap&gt;E[i].flow &amp;&amp; h[u]==h[v]+1) { u=v; pre[v]=i; d=min(d, E[i].cap-E[i].flow); if(u==t) { cout&lt;&lt;endl; cout&lt;&lt;&quot;增广路径：&quot;&lt;&lt;t; while(u!=s) { int j=pre[u]; E[j].flow+=d; E[j^1].flow-=d; u=E[j^1].v; cout&lt;&lt;&quot;--&quot;&lt;&lt;u; } cout&lt;&lt;&quot;增流：&quot;&lt;&lt;d&lt;&lt;endl; ans+=d; d=inf; } break; } } if(i==-1) { if(--g[h[u]]==0) break; int hmin=n-1; //cur[u]=V[u].first; for(int j=V[u].first; ~j; j=E[j].next) if(E[j].cap&gt;E[j].flow) hmin=min(hmin, h[E[j].v]); h[u]=hmin+1; cout&lt;&lt;&quot;重贴标签后高度&quot;&lt;&lt;endl; cout&lt;&lt;&quot;h[ ]=&quot;; for(int i=1;i&lt;=n;i++) cout&lt;&lt;&quot; &quot;&lt;&lt;h[i]; cout&lt;&lt;endl; ++g[h[u]]; if(u!=s) u=E[pre[u]^1].v; } } return ans; } void printg(int n)//输出网络邻接表 { cout&lt;&lt;&quot;----------网络邻接表如下：----------&quot;&lt;&lt;endl; for(int i=1;i&lt;=n;i++) { cout&lt;&lt;&quot;v&quot;&lt;&lt;i&lt;&lt;&quot; [&quot;&lt;&lt;V[i].first; for(int j=V[i].first;~j;j=E[j].next) cout&lt;&lt;&quot;]--[&quot;&lt;&lt;E[j].v&lt;&lt;&quot; &quot;&lt;&lt;E[j].cap&lt;&lt;&quot; &quot;&lt;&lt;E[j].flow&lt;&lt;&quot; &quot;&lt;&lt;E[j].next; cout&lt;&lt;&quot;]&quot;&lt;&lt;endl; } } void printflow(int n)//输出实流边 { cout&lt;&lt;&quot;----------实流边如下：----------&quot;&lt;&lt;endl; for(int i=1;i&lt;=n;i++) for(int j=V[i].first;~j;j=E[j].next) if(E[j].flow&gt;0) { cout&lt;&lt;&quot;v&quot;&lt;&lt;i&lt;&lt;&quot;--&quot;&lt;&lt;&quot;v&quot;&lt;&lt;E[j].v&lt;&lt;&quot; &quot;&lt;&lt;E[j].flow; cout&lt;&lt;endl; } } 算法复杂度分析时间复杂度：找到一条可增广路时间为O(V)，最多会执行O(VE)次，因为关键边的总数为O(VE)，因此总的时间复杂度为O(V2E)，其中V为结点个数，E为边的数量。 空间复杂度O(V)。 最小费用路算法——最小费用最大流问题分析除了流量之外，还定义了一个单位流量的费用。对于网络上的一个流flow，其费用为 $\\cos t(flow)=\\sum\\limits_{&lt;x,y&gt;\\in E}{\\cos t(x,y)*flow(x,y)}$ 网络流的费用=单位流量费用*每条边的流量 算法设计有两种思路： 先找最小费用路，在该路径上增流，增加到最大流，称为最小费用路算法。 先找最大流，然后找负费用圈，消减费用，减少到最小费用，称为消圈算法。最小费用路算法，是在残余网络上寻找从源点到汇点的最小费用路，即从源点到汇点的以单位费用为权的最短路，然后沿着最小费用路增流，直到找不到最小费用路为止。 算法解释 创建混合网络。先初始化为零流，零流对应混合网络中，正向边容量为cap，流量为0，费用为cost，反向边容量为0，流量为0，费用为-cost。 找最小费用路。先初始化每个结点的距离为无穷大，然后令源点的距离dist[v1]=0。在混合网络中，从源点出发，沿可行边（E[i].cap&gt;E[i].flow）广度搜索每个邻接点，如果当前距离dist[v]&gt;dist[u]+E[i].cost，则更新为最短距离：dist[v]=dist[u]+E[i].cost，并记录前驱。根据前驱数组，找到一条最短费用路，增广路经：1-2-5-6。 然后沿着增广路经正向增流d，反向减流d。从汇点逆向找最小可增流量d=min(d,E[i].cap-E[i].flow)，增流量d=3，产生费用为mincost+=dist[v6]d=83=24。 找最小费用路。先初始化每个结点距离为无穷大，然后令源点的距离dist[v1]=0。在混合网络中，从源点出发，沿可行边（E[i].cap&gt;E[i].flow）广度搜索每个邻接点，如果当前距离dist[v]&gt;dist[u]+E[i].cost，则更新为最短距离：dist[v]=dist[u]+E[i].cost，并记录前驱。根据前驱数组，找到一条最短费用路，增广路经：1-3-4-6。 然后沿着增广路经正向增流d，反向减流d。从汇点逆向找最小可增流量d=min(d,E[i].cap-E[i].flow)，增流量d=4，产生费用为mincost+=24+dist[v6]d=24+164=88。 找最小费用路。先初始化每个结点距离为无穷大，然后令源点的距离dist[v1]=0。在混合网络中，从源点出发，沿可行边（E[i].cap&gt;E[i].flow）广度搜索每个邻接点，发现从源点出发已经没有可行边，结束，得到的网络流就是最小费用最大流。把混合网络中flow&gt;0的边输出，就是我们要的实流网络。 代码实现（1）定义结构体。结构体的定义与ISAP中结构体相同，边只是多了一个cost域，fisrt指向第一个邻接边，next是吓一跳邻接边，该结构体用于创建邻接表。 struct Vertex { int first; }V[N]; struct Edge { int v, next; int cap, flow,cost; }E[M]; （2）创建残余网络边。正向边的容量为cap，流量为0，费用为cost，反向边容量为0，流量为0，费用为-cost。 void add_edge(int u, int v, int c,int cost) { E[top].v = v; E[top].cap = c; E[top].flow = 0; E[top].cost = cost; E[top].next = V[u].first; V[u].first = top++; } void add(int u,int v, int c,int cost) { add_edge(u,v,c,cost); add_edge(v,u,0,-cost); } （3）求最小费用路。先初始化每个结点距离无穷大，然后令源点的距离dist[v1]=0。在混合网络中，从源点出发，沿可行边（E[i].cap&gt;E[i].flow）广度搜索每个邻接点，如果当前距离dist[v]&gt;dist[u]+E[i].cost，则更新为最短距离：dist[v]=dist[u]+E[i].cost，并记录前驱。 bool SPFA(int s, int t, int n)//求最短费用路的SPFA { int i, u, v; queue &lt;int&gt; qu; // 队列，STL实现 memset(vis,false,sizeof(vis));//访问标记初始化 memset(c,0,sizeof(c)); //入队次数初始化 memset(pre,-1,sizeof(pre)); //前驱初始化 for(i=1;i&lt;=n;i++) { dist[i]=INF; //距离初始化 } vis[s]=true; //顶点入队vis要做标记 c[s]++; //要统计顶点的入队次数 dist[s]=0; qu.push(s); while(!qu.empty()) { u=qu.front(); qu.pop(); vis[u]=false; //队头元素出队，并且消除标记 for(i=V[u].first; i!=-1; i=E[i].next)//遍历顶点u的邻接表 { v=E[i].v; if(E[i].cap&gt;E[i].flow &amp;&amp; dist[v]&gt;dist[u]+E[i].cost)//松弛操作 { dist[v]=dist[u]+E[i].cost; pre[v]=i; //记录前驱 if(!vis[v]) //顶点v不在队内 { c[v]++; qu.push(v); //入队 vis[v]=true; //标记 if(c[v]&gt;n) //超过入队上限，说明有负环 return false; } } } } cout&lt;&lt;&quot;最短路数组&quot;&lt;&lt;endl; cout&lt;&lt;&quot;dist[ ]=&quot;; for(int i=1;i&lt;=n;i++) cout&lt;&lt;&quot; &quot;&lt;&lt;dist[i]; cout&lt;&lt;endl; if(dist[t]==INF) return false; //如果距离为INF，说明无法到达，返回false return true; } （4）沿着最小费用路增流。从汇点逆向找最小可增流量d=min(d,E[i].cap-E[i].flow)。沿着增广路径正向边增流d，反向边减流d，产生费用为mincost+=dist[t]*d。 int MCMF(int s,int t,int n) //minCostMaxFlow { int d; //可增流量 int i,mincost;//maxflow 当前最大流量，mincost当前最小费用 mincost=0; while(SPFA(s,t,n))//表示找到了从s到t的最短路 { d=INF; cout&lt;&lt;endl; cout&lt;&lt;&quot;增广路径：&quot;&lt;&lt;t; for(i=pre[t]; i!=-1; i=pre[E[i^1].v]) { d=min(d, E[i].cap-E[i].flow); //找最小可增流量 cout&lt;&lt;&quot;--&quot;&lt;&lt;E[i^1].v; } cout&lt;&lt;&quot;增流：&quot;&lt;&lt;d&lt;&lt;endl; cout&lt;&lt;endl; maxflow+=d; //更新最大流 for(i=pre[t]; i!=-1; i=pre[E[i^1].v])//修改残余网络，增加增广路上相应弧的容量，并减少其反向边容量 { E[i].flow+=d; E[i^1].flow-=d; } mincost+=dist[t]*d; //dist[t]为该路径上单位流量费用之和 ，最小费用更新 } return mincost; } 复杂度分析 时间复杂度：找到一条可增广路时间为O(E)，最多会执行O(VE)次，因为关键边的总数为O(VE)，因此总的时间复杂度为O(VE2)，其中V为结点个数，E为边的数量。 空间复杂度：O(V)。 消圈算法算法设计三个过程： 找给定网络的最大流。 在最大流对应的混合网络找负费用圈。 消负费用圈：负费用圈同方向的边流量加d，反方向的边流量减d。d为负费用圈所有边的最小可增量cap-flow。 算法的核心是在残余网络中找负费用圈。 算法解释 求最大流。用最大流求解算法求解最大流。 在最大流对应的混合网络中找负费用圈。在最大流的混合网络中，沿着cap&gt;flow的边找负费用圈，就是各边费用之和为负的圈。 负费用圈同方向的边流量加d，反方向的边流量减d。沿找到的负费用全增流，其增量为组成负费用圈的所有边的最小可增量cap-flow。负费用圈说明费用较高，可以对费用为负的边减流，因为该残余网络为特殊的残余网络，负费用的边流量也是负值，减流实际上需要加上增流量d，为了维持平衡性，负费用圈同方向的边流量加d，反方向的边流量减d。 在混合网络中继续找负费用圈。在混合网络中，沿着cap&gt;flow的边找负费用圈，已经找不到负费用圈，算法结束。把混合网络中flow&gt;0的边输出，就是我们需要的实流网络。 复杂度分析 时间复杂度：最大流方法为O(V2E)，如果每次消去负费用圈至少使费用下降一个单位，最多执行ECM此找负费用圈和增减流操作（C为每条边费用上界，M为每条边容量上界）。该算法时间复杂度为O(V2E2CM)。 空间复杂度O(V)。 配对方案问题问题分析先了解几个概念。二分图：又称二部图。设G=(V,E)是一个无向图，如果结点集V客分割为两个互不相交的子集（V1,V2），并且图中的每条边（i,j）所关联的两个结点i和j分别属于这两个不同的结点集（i∈V1，j∈V2），则称图G是一个二分图。匹配：在图论中，一个匹配是一个边的集合，其中任意两条边都没有公共结点。最大匹配：一个图所有匹配中，边数最多的匹配，成为这个图的最大匹配。 最佳推销员配对方案要求两个推销员男女搭配，相当于男女推销员形成了两个不相交的集合，可以配合工作的男女推销员有连线，求最大配对数，实际上这就是一个简单的二分图最大匹配问题。可以借助最大流算法，通过下面的变换，把二分图转化成网络，求最大流即可。 将二分图左边添加1个源点，右边添加一个汇点，将左边的点全部与源点相连，有边的点和汇点相连，所有边容量均为1.前面为女推销员编号，后面为男推销员编号，有连线表示两个人可以配合，男男之间、女女之间没有连线，构成网络。然后求网络最大流即可。 算法设计 构建网络：根据输入的数据，增加源点和汇点，每条边的容量设置为1，创建混合网络。 求网络最大流。 输出最大流值就是最大的配对数。 搜索女推销员结点的邻接表，流量为1的边对应的邻接点就是该女推销员的配对方案。 算法解释如图1所示的关系。 图1 构建网络。构建网络如图所示。 图2 求网络最大流。使用优化的ISAP算法求网络最大流，找到5条可增广路径。分别是： 13-10-5-0，增流：1。 13-9-4-0，增流：1。 13-7-3-0，增流：1。 13-11-2-0，增流：1。 13-8-1-0，增流：1。增流后的实流网络如图3所示。 输出最大流值就是最多的配对数。搜索女推销员结点的邻接表，流量为1的边对应的邻接点就是该女推销员的配对方案。最大配对数5。配对方案：1-8,2-11,3-7,4-9，5-10。 图3 代码实现（1）创建混合网络邻接表 for(int i=1;i&lt;=m;i++) add(0, i, 1);//源点到女推销员的边 for(int j=m+1;j&lt;=total;j++) add(j, total+1, 1);//男推销员到汇点的边 cout&lt;&lt;&quot;请输入可以配合的女推销员编号u和男推销员编号v(两个都为-1结束):&quot;&lt;&lt;endl; while(cin&gt;&gt;u&gt;&gt;v,u+v!=-2) add(u,v,1); （2） 求网络最大流。 int Isap(int s, int t,int n) { set_h(t,n); int ans=0, u=s; int d; while(h[s]&lt;n) { int i=V[u].first; if(u==s) d=inf; for(; ~i; i=E[i].next) { int v=E[i].v; if(E[i].cap&gt;E[i].flow &amp;&amp; h[u]==h[v]+1) { u=v; pre[v]=i; d=min(d, E[i].cap-E[i].flow); if(u==t) { cout&lt;&lt;endl; cout&lt;&lt;&quot;增广路径：&quot;&lt;&lt;t; while(u!=s) { int j=pre[u]; E[j].flow+=d; E[j^1].flow-=d; u=E[j^1].v; cout&lt;&lt;&quot;--&quot;&lt;&lt;u; } cout&lt;&lt;&quot;增流：&quot;&lt;&lt;d&lt;&lt;endl; ans+=d; d=inf; } break; } } if(i==-1) { if(--g[h[u]]==0) break; int hmin=n-1; //cur[u]=V[u].first; for(int j=V[u].first; ~j; j=E[j].next) if(E[j].cap&gt;E[j].flow) hmin=min(hmin, h[E[j].v]); h[u]=hmin+1; cout&lt;&lt;&quot;重贴标签后高度&quot;&lt;&lt;endl; cout&lt;&lt;&quot;h[ ]=&quot;; for(int i=1;i&lt;=n;i++) cout&lt;&lt;&quot; &quot;&lt;&lt;h[i]; cout&lt;&lt;endl; ++g[h[u]]; if(u!=s) u=E[pre[u]^1].v; } } return ans; } （3）输出最佳配对数 cout&lt;&lt;&quot;最大配对数:&quot;&lt;&lt;Isap(0,total+1,total+2)&lt;&lt;endl; cout&lt;&lt;endl; （4）输出最佳配对方案如下： void printflow(int n)//输出配对方案 { cout&lt;&lt;&quot;----------配对方案如下：----------&quot;&lt;&lt;endl; for(int i=1;i&lt;=n;i++) for(int j=V[i].first;~j;j=E[j].next) if(E[j].flow&gt;0) { cout&lt;&lt;i&lt;&lt;&quot;--&quot;&lt;&lt;E[j].v&lt;&lt;endl; break; } } 算法复杂度分析（1）时间复杂度：O(V2E)。（2）空间复杂度：O(V)。 算法优化拓展——匈牙利算法在匹配问题中，增广路经是指一条可以使匹配数变多的路径。匈牙利算法的思想是不停地找增广路经，并增加匹配的个数，可以证明，当不能再找到增广路经时，就得到了一个最大匹配。 算法设计 根据输入的数据，创建邻接表。 初始化所有结点为未访问，检查第一个集合中的每一个结点u。 依次检查u的邻接点v。如果v未被访问，则标记已访问，然后判断如果v未匹配，则令u、v匹配，即match[u]=v,match[v]=u，返回true；如果v已匹配，则从v的邻接点出发，查找是否有增广路径，如果有则沿增广路径反色，然后令u、v匹配，即match[u]=v,match[v]=u，返回true。否则返回false，转第2步。 当找不到增广路径的时候，即得到一个最大匹配。 完美图解 根据输入的数据，创建邻接表。 初始化访问数组vis[i]=0,i=1,2,3,…,12。检查1的第一个邻接点6,6未被访问，标记vis[6]=1.6未匹配，则令1和6匹配，即match[6]=1,match[1]=6,return true。 初始化访问数组vis[i]=0；检查2的第一个邻接点7，7未被访问，标记vis[7]=1。7未匹配，则令2和7匹配，即match[7]=2，match[2]=7,return true。 初始化访问数组vis[i]=0；检查3的第一个邻接点7，7未被访问，标记vis[7]=1。7已匹配，match[7]=2，即7的匹配点为2，从2出发寻找增广路径。实际上这就是为2再找一个匹配点，如果找到了，就把之前匹配的那个点让给3号，如果2没有找到，那么就拒绝3的请求，让3继续往下找。从2出发，检查2的第一个邻接点7,7已访问，然后检查第二个邻接点8,8未访问，标记vis[8]=1。8未匹配，则令2和8匹配，即match[8]=2，match[2]=8，返回true。2号找到一个结点之后就把原来的匹配点7让给了3，令match[3]=7，match[7]=3，返回true。 初始化访问数组vis[i]=0；检查4的第一个邻接点9，9未被访问，标记vis[9]=1。9未匹配，则令4和9匹配，即match[4]=9，match[9]=4,return true。 初始化访问数组vis[i]=0；检查5的第一个邻接点10，10未被访问，标记vis[10]=1。10未匹配，则令5和10匹配，即match[5]=10，match[10]=5,return true。 反色过程：检查4号的邻接点8，发现8已匹配，match[8]=3，从3出发，检查3号的邻接点7，发现7已经匹配，match[7]=2，检查2号的邻接点6，发现6已经匹配，match[6]=1，检查1号的邻接点5，发现5未匹配，找到一条增广路经：3-7-2-6-1-5，立即反色。令match[5]=1,1h奥找到了匹配点就把原来的匹配点6让给了2号，match[2]=6；2号找到了匹配点就立即把原来的匹配点7让给了3号，match[3]=7；3号找到了匹配点就立即把8号让给了4号，match[4]=8。 复杂度分析 时间复杂度：找到一条增广路经的复杂度最坏为O(E)，最多有V条增广路，所以时间复杂度O(VE)，与最大网络流算法的时间复杂度O(V2E)相比下降不少。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"},{"name":"线性规划","slug":"线性规划","permalink":"http://tech.yushuai.xyz/tags/线性规划/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}]},{"title":"动态规划","slug":"dprograming","date":"2019-03-20T13:19:38.000Z","updated":"2019-03-20T13:22:36.049Z","comments":true,"path":"2019/03/20/dprograming/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/20/dprograming/","excerpt":"","text":"关于最长公共子序列（LCS）最长公共子序列和最长公共子串是有区别的，之前我一直把它们混淆。 最长公共子串举例：假设S1={A,D,C,B,E,X,Q}，S2={H,P,D,C,B,E,M,L}那么它们的最长公共子串就是{D,C,B,E}。这是我通常理解的东西。最长公共子序列。 最长公共子序列举例：假设S1={A,B,C,A,D,A,B}，S2={B,A,C,D,B,A}，那么它们的LCS就是{B,A,D,B}。 求解最长公共子序列这是一个动态规划问题。如何求解最长公共子序列（以下用LCS代替）呢？我们假设已经知道Z={z1,z2,…zk}是X={x1,x2,…,xm}和Y={y1,y2,…,yn}的LCS，那么可以分以下三种情况讨论（具体每种情况证明不再累述）： xm=yn=zk：那么Zk-1是Xm-1和Yn-1的LCS。 xm≠yn，yn≠zk：我们可以把yn去掉，那么Zk是Xm和Yn-1的LCS。 xm≠yn，xm≠zk：我们可以把xm去掉，那么Zk是Xm-1和Yn的LCS。 基于以上情况，我们可以得到LCS递归式。我们假设c[i][j]表示Xi和Yi的LCS长度，那么： c[i][j]=0(i=0或j=0)； c[i][j]=c[i-1]c[j-1]+1(i,j&gt;0且xi=yi）； c[i][j]=max{c[i-1][j],c[i],[j-1]}；（i,j&gt;0且xi≠yi）。 这样我们就可以得到LCS的长度。如何得到具体内容是什么呢？我们可以借用一个辅助数组b[i][j]，这个数组用来记录c[i][j]的来源，分别有如下情况： c[i][j]=c[i-1][j-1]+1，则b[i][j]=1； c[i][j]=c[i][j-1]，则b[i][j]=2； c[i][j]=c[i-1][j]，则b[i][j]=3。 这样就可以根据b[m][n]反向追踪LCS，当b[i][j]=1，输出xi；当b[i][j]=2，追踪c[i][j-1]；当b[i][j]=3，追踪c[i-1][j]，直到i=0或j=0停止。 算法设计（1）初始化。初始化c[][]第1行和第1列为0。（2）开始操作。具体是将s1[i]分别与s2[j-1]（j=1,2,…,len2）进行比较，若字符相等c[i][j]=左上角数值+1，且b[i][j]=1；若不相等，则c[i][j]等于左侧或者上侧重最大的一个数值，若左侧和上侧相等，则取左侧，且b[i][j]=2或3（当取左侧为2，取上侧为3）。最后的c[][]和b[][]如下所示：下表是c[][]： 0 1 2 3 4 5 6 0 0 0 0 0 0 0 A 0 0 1 1 1 1 1 B 0 1 1 1 1 2 2 C 0 1 1 2 2 2 2 A 0 1 2 2 2 2 3 D 0 1 2 2 3 3 3 A 0 1 2 2 3 3 4 B 0 1 2 2 3 4 4 下表是b[][]： 0 1 2 3 4 5 6 0 0 0 0 0 0 0 1 0 2 1 2 2 2 1 2 0 1 2 2 2 1 2 3 0 3 2 1 2 2 2 4 0 3 1 2 2 2 1 5 0 3 3 2 1 2 2 6 0 3 1 2 3 2 1 7 0 1 3 2 3 1 2 根据c[][]可以得出，LCS的长度为4（也就是c[][]最后一个值）。然后开始判断内容是什么，这是要根据b[][]来。首先，b[7][6]=2，向左找b[7][5]=1，所以向左上角找b[6][4]，得到字母为s1[6]=[B]；b[6][4]=3，向上找b[5][4]=1，向左上角找b[4][3]，得到字母s1[4]=[D]；b[4][3]=2，向左找b[4][2=1，向左上角找b[3][1]，得到字母s1[3]=[A]；b[3][1]=3，向上找b[2][1]=1，向左上角找b[1][0]，得到字母s1[1]=[B].由于b[1][0]=0，所以算法停止，返回结果为“BADB”。 代码演示void LCSL() { int i, j; for(i=1;i&lt;len1;i++) for (j = 1; j &lt; len2; j++) { if (s1[i - 1] == s2[j - 1]) { c[i][j] = c[i - 1][j - 1] + 1; b[i][j] = 1; } else { if (c[i][j - 1] &gt;= c[i - 1][j]) { c[i][j] = c[i][j - 1]; b[i][j] = 2; } else { c[i][j] = c[i - 1][j]; b[i][j] = 3; } } } } void print(int i, int j) { if (i == 0 || j == 0) return; if (b[i][j] == 1) { print(i - 1, j - 1); cout &lt;&lt; s1[i - 1]; } else if (b[i][j] == 2) print(i, j - 1); else print(i - 1, j); } 编辑距离编辑距离和LCS的不同点 编辑距离的d[][]取值公式如下：（一个前提，若xi=yj，则diff=0；否则为1）d[i][j]=min{d[i - 1][j] + 1, d[i][j - 1] + 1,d[i-1][j-1]+diff} 构造最优解：编辑距离是从右下角开始，逆向查找d[i][j]的来源：上面表示需要删除，左侧表示需要插入；左上角要判断字符是否相等，若相等，不做任何操作，若不相等，执行替换。 两者的时间复杂度都是O(n*m)。 代码实现int min(int a, int b,int c) { int temp = (a &lt; b) ? a : b; return (temp &lt; c) ? temp : c; } //编辑距离函数 int editdistance(char *str1, char *str2) { int i, j; int len1 = strlen(str1); int len2 = strlen(str2); for (i = 0; i &lt;= len1; i++) { d[i][0] = i; } for (j = 0; j &lt;= len2; j++) { d[0][j] = j; } for (i = 1; i &lt;= len1; i++) { for (j = 1; j &lt;= len2; j++) { int diff; if (str1[i - 1] == str2[j - 1]) diff = 0; else diff = 1; d[i][j] = min(d[i - 1][j] + 1, d[i][j - 1] + 1,d[i-1][j-1]+diff); } } return d[len1][len2]; } 游艇租赁问题假设在一条河上有n个游艇出租站，游客可以在这些游艇出租站租游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到j之间的租金为r(i,j)，i&lt;=i&lt;=j&lt;=n。设计一个算法，计算从游艇出租站i到出租站j所需要的租金最少。 问题分析（1）分析最优解的结构特征（2）简历最优值的递归式m[i][j]=0(j=i);r[i][j];j=i+1;min{m[i][k]+m[k][j],r[i][j],j&gt;i+1。 算法设计（1）确定合适的数据结构：采用二维数组r[][]输入数据，二维数组m[][]存放各个子问题的最优值，二维数组s[][]存放各个子问题的最优决策（停靠站点）。（2）初始化：m[i][j]=r[i][j]，然后再找有没有比m[i][j]小的值，如果有，则记录该最优值和最优解即可，s[i][j]=0.（3）循环阶段： 按照递归关系式计算3个站点i,i+1,j(j=i+2)的最优值，并将其存入m[i][j]，同时将最优策略存入s[i][j]，i=1,2,…,n-2。 按照递归关系式计算4个站点i,i+1,i+2,j(j=i+3)的最优值，并将其存入m[i][j]，同时将最优策略存入s[i][j]，i=1,2,…,n-3。 以此类推，直到求出n个站点的最优值m[1][n]。 （4）构造最优解。根据s[][]递归构造最优解。s[1][n]是第一个站点到底n个站点）1,2,…,n）的最优解的停靠站点，即停靠了第s[1][n]个站点，我们在递归构造两个子问题(1,2,…,k）和（k,k+1,…,n）的最优解停靠站点，一直递归到只包含一个站点为止。 代码实现void rent() { int i, j, k, d; for (d = 3; d &lt;= n; d++) { for (i = 1; i &lt;= n - d + 1; i++) { j = i + d - 1; for (k = i + 1; k &lt; j; k++) { int temp; temp = m[i][k] + m[k][j]; if (temp &lt; m[i][j]) { m[i][j] = temp; s[i][j] = k; } } } } } void print(int i, int j) { if (s[i][j] == 0) { cout &lt;&lt; &quot;-- &quot; &lt;&lt; j; return; } print(i, s[i][j]); print(s[i][j], j); } 代码实现2：最贵的租金其实只是把总结的递归式中的j&gt;i+1的时候的min改为了max。所以只是修改了代码中的 if (temp &lt; m[i][j]) 将其改为了 if (temp &gt; m[i][j]) 快速计算——矩阵连乘最优递归式：当i=j时，只有一个矩阵，m[i][j]=0；当i&lt;j的时候，m[i][j]=min{m[i][k]+m[k+1][j]+pip(k+1)qj} 算法设计（1）确定合适的数据结构。用一维数组p[]记录矩阵的行和列，第i个矩阵的行数存在数组的第i-1位置，列存在第i位置。二维数组m[][]用来存放各个子问题的最优值，二维数组s[][]来存放各个子问题的最优决策（加括号的位置）。（2）初始化。m[i][i]=0，s[i][i]=0。（3）循环阶段。 按照递归关系式计算2个矩阵Ai、Ai+1相乘时的最优值，j+i+1，并将其存入m[i][j]；同时将最优策略计入s[i][j]。i=1,2,3,..,n-1。 按照递归关系式计算3个矩阵相乘Ai、Ai+1、Ai+2,相乘时的最优值，j+i+2，并将其存入m[i][j]，同时将最优策略记入s[i][j]，i=1,2,3,…,n-2。 以此类推，直到求出n个矩阵相乘的最优值m[1][n]。 （4）构造最优解 根据最有决策信息数组s[][]递归构造最优解。s[1][n]表示A1A2…An最优解的加括号位置，我们在递归构造两个子问题的最优解加括号位置，一直低轨道子问题只包含一个矩阵为止。 举例图解 矩阵 A1 A2 A3 A4 A5 规模 3*5 5*10 10*8 8*2 2*4 （1）初始化m[i][i]=0,s[i][i]=0（2）计算两个矩阵相乘的最优值 m[][]如下： m[][] 1 2 3 4 5 1 0 150 390 290 314 2 0 400 260 300 3 0 160 240 4 0 64 5 0 s[][]如下： s[][] 1 2 3 4 5 1 0 1 2 1 4 2 0 2 2 4 3 0 3 4 4 0 4 5 0 （3）构造最优解类似于游艇租赁 代码实现void matrixchain() { int i,j,r,k; memset(m,0,sizeof(m)); memset(s,0,sizeof(s)); for(r = 2; r &lt;= n; r++) //不同规模的子问题 { for(i = 1; i &lt;= n-r+1; i++) { j = i + r - 1; m[i][j] = m[i+1][j] + p[i-1] * p[i] * p[j]; //决策为k=i的乘法次数 s[i][j] = i; //子问题的最优策略是i; for(k = i+1; k &lt; j; k++) //对从i到j的所有决策，求最优值，记录最优策略 { int t = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j]; if(t &lt; m[i][j]) { m[i][j] = t; s[i][j] = k; } } } } } void print(int i,int j) { if( i == j ) { cout &lt;&lt;&quot;A[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;; return ; } cout &lt;&lt; &quot;(&quot;; print(i,s[i][j]); print(s[i][j]+1,j); cout &lt;&lt; &quot;)&quot;; } 最优三角剖分与矩阵连乘的不同点不同点就在于递归公式的不同，最优三角剖分的递归公式如下：当i=j的时候，m[i][j]=0；当i&lt;j的时候，m[i][j]=min{m[i][k]+m[k+1][j]+w(v(i-1)vkvj)} 图解示例我们以一个凸多边形为例，其每条边的权重如下表所示| g[][] | 0 | 1 |2 |3 |4|5| —— | —— | —— | —— | —— | —— | —— ||0| 0 | 2|3 | 1|5|6|1|2 | 0|3 | 4|8|6|2|3| 3|0 | 10|13|7|3|1 | 4|10 | 0|12|5|4|5 | 8|13 | 12|0|3|5|6 | 6|7 | 5|3|0 （1）初始化：令m[i][i]=0，s[i][i]=0（2）计算赋值如下： m[][] 1 2 3 4 5 1 0 8 22 40 54 2 0 17 41 52 3 0 35 42 4 0 20 5 0 3 s[][] 1 2 3 4 5 1 0 1 2 3 3 2 0 2 3 3 3 0 3 3 4 0 4 5 0 所以最优权值为m[1][5]=54（3）构造最优解。过程与矩阵快速相乘类似，都是根据s[][]对应的位置来分成子问题，所以首先是看到s[1][5]=3，所以分为了v0~ v3 和 v3~v5。 因为v0~v3中有结点，所以子问题1不为空，输出该弦v0v3；同理，输出v3v5。 对于子问题1进行递归，读取s[1][3]=2，因为v0~v2有结点，所以输出v0v2…… 最后输出的最优解为v0v3,v3v5,v0v2。 代码实现 void Convexpolygontriangulation() { for(int i = 1 ;i &lt;= n ; i++) // 初始化 { m[i][i] = 0 ; s[i][i] = 0 ; } for(int d = 2 ;d &lt;= n ; d++) // 枚举点的个数 for(int i = 1 ;i &lt;= n - d + 1 ; i++) // 枚举起始点 { int j = i + d - 1 ; // 终点 m[i][j] = m[i+1][j] + g[i-1][i] + g[i][j] + g[i-1][j] ; s[i][j] = i ; for(int k = i + 1 ;k &lt; j ; k++) // 枚举中间点 { double temp = m[i][k] + m[k+1][j] + g[i-1][k] + g[k][j] + g[i-1][j] ; if(m[i][j] &gt; temp) { m[i][j] = temp ; // 更新最优值 s[i][j] = k ; // 记录中间点 } } } } void print(int i , int j) // 输出所有的弦 { if(i == j) return ; if(s[i][j]&gt;i) cout&lt;&lt;&quot;{v&quot;&lt;&lt;i-1&lt;&lt;&quot;v&quot;&lt;&lt;s[i][j]&lt;&lt;&quot;}&quot;&lt;&lt;endl; if(j&gt;s[i][j]+1) cout&lt;&lt;&quot;{v&quot;&lt;&lt;s[i][j]&lt;&lt;&quot;v&quot;&lt;&lt;j&lt;&lt;&quot;}&quot;&lt;&lt;endl; print(i ,s[i][j]); print(s[i][j]+1 ,j); //cout&lt;&lt;&quot;{ v&quot;&lt;&lt;i-1&lt;&lt;&quot; , v&quot;&lt;&lt;s[i][j]&lt;&lt;&quot; , v&quot;&lt;&lt;j&lt;&lt;&quot; }&quot;&lt;&lt;endl; //输出所有剖分后的三角形 } 石子合并 递归公式：设Min[i][j]代表从第i堆石子到第j堆石子合并的最小花费，Min[i][k]代表从第i堆石子到底k堆石子合并的最小花费，Min[k+1][j]代表从第k+1堆石子到第j堆石子合并的最小花费。那么递推式如下：Min[i][j]=0,i=jMin[i][j]=min{m[i][k]+m[k+1][j]+w(i,j)} i&lt;j同理，设Max[i][j]代表从第i堆石子到第j堆石子合并的最大花费，Max[i][k]代表从第i堆石子到底k堆石子合并的最大花费，Max[k+1][j]代表从第k+1堆石子到第j堆石子合并的最大花费。那么递推式如下：Max[i][j]=0,i=jMax[i][j]=max{m[i][k]+m[k+1][j]+w(i,j)} i&lt;j 代码实现void straight(int a[],int n) { for(int i=1;i&lt;=n;i++) // 初始化 Min[i][i]=0, Max[i][i]=0; sum[0]=0; for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i]; for(int v=2; v&lt;=n; v++) // 枚举合并的堆数规模 { for(int i=1; i&lt;=n-v+1; i++) //枚举起始点i { int j = i + v-1; //枚举终点j Min[i][j] = INF; //初始化为最大值 Max[i][j] = -1; //初始化为-1 int tmp = sum[j]-sum[i-1];//记录i...j之间的石子数之和 for(int k=i; k&lt;j; k++) { //枚举中间分隔点 Min[i][j] = min(Min[i][j], Min[i][k] + Min[k+1][j] + tmp); Max[i][j] = max(Max[i][j], Max[i][k] + Max[k+1][j] + tmp); } } } } void Circular(int a[],int n) { for(int i=1;i&lt;=n-1;i++) a[n+i]=a[i]; n=2*n-1; straight(a, n); n=(n+1)/2; min_Circular=Min[1][n]; max_Circular=Max[1][n]; for(int i=2;i&lt;=n;i++) { if(Min[i][n+i-1]&lt;min_Circular) min_Circular=Min[i][n+i-1]; if(Max[i][n+i-1]&gt;max_Circular) max_Circular=Max[i][n+i-1]; } } 时间复杂度为O(n3) 改进算法最小值可以用四边形不等式来优化。复杂度为O(n2) void get_Min(int n) { for(int v=2; v&lt;=n; v++) // 枚举合并的堆数规模 { for(int i=1; i&lt;=n-v+1; i++) //枚举起始点i { int j = i + v-1; //枚举终点j int tmp = sum[j]-sum[i-1];//记录i...j之间的石子数之和 int i1=s[i][j-1]&gt;i?s[i][j-1]:i; int j1=s[i+1][j]&lt;j?s[i+1][j]:j; Min[i][j]=Min[i][i1]+Min[i1+1][j]; s[i][j]=i1; for(int k=i1+1; k&lt;=j1; k++) //枚举中间分隔点 if(Min[i][k]+ Min[k+1][j]&lt;Min[i][j]) { Min[i][j]=Min[i][k]+Min[k+1][j]; s[i][j]=k; } Min[i][j]+=tmp; } } } void get_Max(int n) { for(int v=2; v&lt;=n; v++) // 枚举合并的堆数规模 { for(int i=1; i&lt;=n-v+1; i++) //枚举起始点i { int j = i + v-1; //枚举终点j Max[i][j] = -1; //初始化为-1 int tmp = sum[j]-sum[i-1];//记录i...j之间的石子数之和 if(Max[i+1][j]&gt;Max[i][j-1]) Max[i][j]=Max[i+1][j]+tmp; else Max[i][j]=Max[i][j-1]+tmp; } } } void straight(int a[],int n) { for(int i=1;i&lt;=n;i++) // 初始化 Min[i][i]=0, Max[i][i]=0, s[i][i]=0; sum[0]=0; for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i]; get_Min(n); get_Max(n); } void Circular(int a[],int n) { for(int i=1;i&lt;=n-1;i++) a[n+i]=a[i]; n=2*n-1; straight(a, n); n=(n+1)/2; min_Circular=Min[1][n]; max_Circular=Max[1][n]; for(int i=2;i&lt;=n;i++) { if(Min[i][n+i-1]&lt;min_Circular) min_Circular=Min[i][n+i-1]; if(Max[i][n+i-1]&gt;max_Circular) max_Circular=Max[i][n+i-1]; } } 用动态分析解决0-1背包问题有n个物品，每个物品的重量为w[i]，价值为v[i]，购物车容量为W。选若干个物品放入购物车，在不超过容量的前提下使获得的价值最大。 问题分析（1）分析最优解的结构特征（2）建立具有最优值的递归式可以对每个物品依次检查是否放入或者不放入，对于第i个物品的处理状态：用c[i][j]表示前i件物品放入一个容量为j的购物车可以获得的最大价值。 不放入第i件物品，xi=0，装入购物车的价值不增加。那么问题就转化为“前i-1件物品放入容量为j的背包中”，最大价值为c[i-1][j]。 放入第i件物品，xi=1，装入购物车的价值增加vi。 那么问题就转化为了“前i-1件物品放入容量为j-w[i]的购物车中”，此时能获得的最大价值就是c[i-1][j-w[i]]，再加上放入第i件物品获得的价值v[i]。即c[i-1][j-w[i]]+v[i]。购物车容量不足，肯定不能放入；购物车容量组，我们要看放入、不放入哪种情况获得的价值更大。所以，递归函数可以写为：c[i][j]=c[i-1][j]（当j&lt;wi）；c[i][j]=max{c[i-1][j-w[i]]+v[i],c[i-1][j]}（当j&gt;wi） 算法设计（1）确定合适的数据结构采用一维数组w[i]、v[i]分别记录第i个物品的重量和价值；二维数组用c[i][j]表示前i个物品放入一个容量为j的购物车可以获得的最大价值。（2）初始化初始化c[][]数组0行0列为0，其中i=01,2,…,n，j=0,1,2,…,W。（3）循环阶段 按照递归式计算第1个物品的处理情况，得到c[1][j]，j=1,2,…,W； 按照递归式计算第2个物品的处理情况，得到c[2][j]，j=1,2,…,W； 以此类推，按照递归式计算第n个物品的处理情况，得到c[n][j]，j=1,2,…,W。 （4）构造最优解c[n][W]就是不超过购物车容量能放入物品的最大价值。如果还想知道具体放入了哪些物品，就需要根据c[][]数组逆向构造最优解，我们可以用一维数组x[i]来存储解向量。 首先i=n，j=W，如果c[i][j]&gt;c[i-1][j]，则说明第n个物品放入了购物车，令x[n]=1，j-=w[n]；如果c[i][j]≤c[i-1][j]，则说明第n个物品没有放入购物车，令x[n]=0. i–，继续查找答案。 直到i=1处理完毕。 图解假设现在有5个物品，每个物品重量为（2,5,4,2,3），价值为（6,3,5,4,6），购物车容量为10。c[][]如下表： c[][] 0 1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 6 6 6 6 6 6 6 6 6 2 0 0 6 6 6 6 6 9 9 9 9 3 0 0 6 6 6 6 11 11 11 11 11 4 0 0 6 6 10 10 11 11 15 15 15 5 0 0 6 6 10 12 12 16 16 17 17 所以最大价值为c[n][W]=17。首先读取c[5][10]&gt;c[4][10]，说明第5个物品装入了购物车，即x[5]=1，然后j=10-w[5]=10-3=7然后去c[4][7]；c[4][7]=c[3][7]，说明第4个物品没有装入购物车，即x[4]=0；然后去找c[3][7]，依次类推。 代码实现#include &lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; #define maxn 10000 #define M 105 int c[M][maxn];//c[i][j] 表示前i个物品放入容量为j购物车获得的最大价值 int w[M],v[M];//w[i] 表示第i个物品的重量，v[i] 表示第i个物品的价值 int x[M]; //x[i]表示第i个物品是否放入购物车 int main(){ int i,j,n,W;//n表示n个物品，W表示购物车的容量 cout &lt;&lt; &quot;请输入物品的个数 n:&quot;; cin &gt;&gt; n; cout &lt;&lt; &quot;请输入购物车的容量W:&quot;; cin &gt;&gt; W; cout &lt;&lt; &quot;请依次输入每个物品的重量w和价值v，用空格分开:&quot;; for(i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i]; for(i=1;i&lt;=n;i++)//初始化第0列为0 c[i][0]=0; for(j=1;j&lt;=W;j++)//初始化第0行为0 c[0][j]=0; for(i=1;i&lt;= n;i++)//计算c[i][j] for(j=1;j&lt;=W;j++) if(j&lt;w[i]) //当物品的重量大于购物车的容量，则不放此物品 c[i][j] = c[i-1][j]; else //否则比较此物品放与不放是否能使得购物车内的价值最大 c[i][j] = max(c[i-1][j],c[i-1][j-w[i]] + v[i]); cout&lt;&lt;&quot;装入购物车的最大价值为:&quot;&lt;&lt;c[n][W]&lt;&lt;endl; //用于测试 for (i=1; i&lt;=n; i++ ) { for (j=1; j&lt;=W; j++ ) cout &lt;&lt; c[i][j]&lt;&lt;&quot;\\t&quot; ; cout &lt;&lt; endl; } cout &lt;&lt; endl; //逆向构造最优解 j=W; for(i=n;i&gt;0;i--) if(c[i][j]&gt;c[i-1][j]) { x[i]=1; j-=w[i]; } else x[i]=0; cout&lt;&lt;&quot;装入购物车的物品序号为:&quot;; for(i=1;i&lt;=n;i++) if(x[i]==1) cout&lt;&lt;i&lt;&lt;&quot; &quot;; return 0; } 算法分析及改进1.算法复杂度分析（1）时间复杂度：O(nW)（2）空间复杂度O(nW)2.算法优化改进使用一个数组dp[]保证第i次循环结束后dp[j]中表示的就是我们定义的c[i][j]。所以代码如下： void opt1(int n,int W) { for(i=1;i&lt;=n;i++) for(j=W;j&gt;0;j--) if(j&gt;=w[i]) //当物品的重量大于购物车的容量，比较此物品放与不放是否能使得购物车内的价值最大 dp[j] = max(dp[j],dp[j-w[i]]+v[i]); } 我们可以缩小范围，因为只有当购物车的容量大于等于物品重量的时候才要更新，所以代码如下： void opt2(int n,int W) { for(i=1;i&lt;= n;i++) for(j=W;j&gt;=w[i];j--) //当物品的重量大于购物车的容量 //比较此物品放与不放是否能使得购物车内的价值最大 dp[j] = max(dp[j],dp[j-w[i]]+v[i]); } 我们还可以再缩小范围，确定搜索的下界bound void opt3(int n,int W) { int sum[n];//sum[i]表示从1...i的物品重量之和 sum[0]=0; for(i=1;i&lt;=n;i++) sum[i]=sum[i-1]+w[i]; for(i=1;i&lt;=n;i++) { int bound=max(w[i],W-(sum[n]-sum[i-1])); //w[i]与剩余容量取最大值, //sum[n]-sum[i-1]表示从i...n的物品重量之和 for(j=W;j&gt;=bound;j--) //当物品的重量大于购物车的容量 //比较此物品放与不放是否能使得购物车内的价值最大 dp[j] = max(dp[j],dp[j-w[i]]+v[i]); } } 快速定位—最优二叉搜索树（OBST）问题分析递归表达式：c[i][j]=0（j=i-1）；c[i][j]=min{c[i][k-1]+c[k+1][j]}+w[i][j]（j≥i）w[i][j]=qi-1（j=i-1）；w[i][j]=w[i][j-1]+pj+qj 算法设计（1）确定合适的数据结构一维数组：p[]、q[]分别表示实结点和虚结点的搜索概率二维数组：c[i][j]表示最优二叉搜索树T(i,j)的搜索成本，w[i][j]表示最优二叉搜索树T(i,j)中的所有实结点和虚结点的搜索概率之和，s[i][j]表示最优二叉搜索树T(i,j)的根节点序号。（2）初始化。c[i][i-1]=0.0，w[i][i-1]=q[i-1]，其中i=1,2,3,…,n+1。（3）循环阶段。 按照递归式计算元素规模是1的{si}（j=i）的最优二叉搜索树的搜索成本c[i][j]，并记录最优策略，即树根s[i][j]，i=1,2,3,..,n。 按照递归式计算元素规模是2的{si,si+1}（j=i）的最优二叉搜索树的搜索成本c[i][j]，并记录最优策略，即树根s[i][j]，i=1,2,3,..,n-1。 以此类推，直到求出所有元素{s1,s2,…,sn}的最优二叉搜索树的搜索成本c[1][n]和最优策略s[1][n]。 （4）构造最优解。 首先读取s[1][n]，令k=s[1][n]，输出sk为最优二叉搜索树的根。 判断如果k-1&lt;1，表示虚结点ek-1是sk的左子树；否则，递归求解左子树Construct_Optimal_BST(1,k-1,1)。 判断如果k≥n，表示虚结点ek是sk的右孩子。；否则，输出s[k+1][n]是sk的右孩子，递归求解右子树Construct_Optimal_BST(k+1,n,1)。 w[][] 0 1 2 3 4 5 6 1 0.06 0.18 0.37 0.52 0.59 0.76 1.00 2 0.08 0.27 0.42 0.49 0.66 0.90 3 0.10 0.25 0.32 0.49 0.73 4 0.07 0.14 0.31 0.55 5 0.05 0.22 0.46 6 0.05 0.29 7 0.10 c[][] 0 1 2 3 4 5 6 1 0 0.18 0.55 0.95 1.23 1.76 2.52 2 0 0.27 0.67 0.90 1.38 2.09 3 0 0.25 0.46 0.94 1.48 4 0 0.14 0.45 0.98 5 0 0.22 0.68 6 0 0.29 7 0 s[][] 0 1 2 3 4 5 6 1 1 2 2 2 3 5 2 2 2 3 3 5 3 3 3 3 5 4 4 5 5 5 5 6 6 6 7 代码实现void Optimal_BST() { for(i=1;i&lt;=n+1;i++) { c[i][i-1]=0.0; w[i][i-1]=q[i-1]; } for(int t=1;t&lt;=n;t++)//t为关键字的规模 //从下标为i开始的关键字到下标为j的关键字 for(i=1;i&lt;=n-t+1;i++) { j=i+t-1; w[i][j]=w[i][j-1]+p[j]+q[j]; c[i][j]=c[i][i-1]+c[i+1][j];//初始化 s[i][j]=i;//初始化 //选取i+1到j之间的某个下标的关键字作为 //从i到j的根，如果组成的树的期望值当前最小 //则k为从i到j的根节点 for(k=i+1;k&lt;=j;k++) { double temp=c[i][k-1]+c[k+1][j]; if(temp&lt;c[i][j]&amp;&amp;fabs(temp-c[i][j])&gt;1E-6) //C++中浮点数因为精度问题不可以直接比较 { c[i][j]=temp; s[i][j]=k;//k即为从下标i到j的根节点 } } c[i][j]+=w[i][j]; } } void Construct_Optimal_BST(int i,int j,bool flag) { if(flag==0) { cout&lt;&lt;&quot;S&quot;&lt;&lt;s[i][j]&lt;&lt;&quot; 是根&quot;&lt;&lt;endl; flag=1; } int k=s[i][j]; //如果左子树是叶子 if(k-1&lt;i) { cout&lt;&lt;&quot;e&quot;&lt;&lt;k-1&lt;&lt;&quot; is the left child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl; } //如果左子树不是叶子 else { cout&lt;&lt;&quot;S&quot;&lt;&lt;s[i][k-1]&lt;&lt;&quot; is the left child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl; Construct_Optimal_BST(i,k-1,1); } //如果右子树是叶子 if(k&gt;=j) { cout&lt;&lt;&quot;e&quot;&lt;&lt;j&lt;&lt;&quot; is the right child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl; } //如果右子树不是叶子 else { cout&lt;&lt;&quot;S&quot;&lt;&lt;s[k+1][j]&lt;&lt;&quot; is the right child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl; Construct_Optimal_BST(k+1,j,1); } } 复杂度分析及改进时间复杂度为O(n3)，空间复杂度为O(n2)。又可以用四边形不等式优化（后续研究一下）时间复杂度减少到O(n2)。 void Optimal_BST() { for(i=1;i&lt;=n+1;i++) { c[i][i-1]=0.0; w[i][i-1]=q[i-1]; } for(int t=1;t&lt;=n;t++)//t为关键字的规模 //从下标为i开始的关键字到下标为j的关键字 for(i=1;i&lt;=n-t+1;i++) { j=i+t-1; w[i][j]=w[i][j-1]+p[j]+q[j]; int i1=s[i][j-1]&gt;i?s[i][j-1]:i; int j1=s[i+1][j]&lt;j?s[i+1][j]:j; c[i][j]=c[i][i1-1]+c[i1+1][j];//初始化 s[i][j]=i1;//初始化 //选取i1+1到j1之间的某个下标的关键字 //作为从i到j的根，如果组成的树的期望值当前 //最小，则k为从i到j的根节点 for(k=i1+1;k&lt;=j1;k++) { double temp=c[i][k-1]+c[k+1][j]; if(temp&lt;c[i][j]&amp;&amp;fabs(temp-c[i][j])&gt;1E-6) //C++中浮点数因为精度问题不可以直接比较 { c[i][j]=temp; s[i][j]=k;//k即为从下标i到j的根节点 } } c[i][j]+=w[i][j]; } } void Construct_Optimal_BST(int i,int j,bool flag) { if(flag==0) { cout&lt;&lt;&quot;S&quot;&lt;&lt;s[i][j]&lt;&lt;&quot; 是根&quot;&lt;&lt;endl; flag=1; } int k=s[i][j]; //如果左子树是叶子 if(k-1&lt;i) { cout&lt;&lt;&quot;e&quot;&lt;&lt;k-1&lt;&lt;&quot; is the left child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl; } //如果左子树不是叶子 else { cout&lt;&lt;&quot;S&quot;&lt;&lt;s[i][k-1]&lt;&lt;&quot; is the left child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl; Construct_Optimal_BST(i,k-1,1); } //如果右子树是叶子 if(k&gt;=j) { cout&lt;&lt;&quot;e&quot;&lt;&lt;j&lt;&lt;&quot; is the right child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl; } //如果右子树不是叶子 else { cout&lt;&lt;&quot;S&quot;&lt;&lt;s[k+1][j]&lt;&lt;&quot; is the right child of &quot;&lt;&lt;&quot;S&quot;&lt;&lt;k&lt;&lt;endl; Construct_Optimal_BST(k+1,j,1); } } 动态规划算法总结动态规划关键总结如下： 最优子结构判定 做出一个选择。 假定已经知道了哪种选择是最优的。 最优的会产生哪些子问题。 证明原问题的最优解包含其子问题的最优解。 如何得到最优解递归式 分析原问题最优解和子问题最优解的关系。 考察有多少种选择。 得到最优解递归式。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"http://tech.yushuai.xyz/tags/动态规划/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}]},{"title":"分支限界法","slug":"branchbound","date":"2019-03-20T13:19:20.000Z","updated":"2019-03-20T13:22:22.931Z","comments":true,"path":"2019/03/20/branchbound/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/20/branchbound/","excerpt":"","text":"广度优先广度优先搜索，其实就是层次遍历，程序采用队列来实现。 算法思想从根开始，常以BF或以最小耗费（即最大收益）优先的方式搜索问题的解空间树。首先将根结点加入活结点表，接着从活结点表中取出根结点，使其成为当前扩展结点，一次性生成其所有孩子结点，判断孩子结点是舍弃还是保留，舍弃哪些导致不可行解或导致非最优解的孩子结点，其余的被保留在活结点表中。再从活结点表中取出一个活结点作为当前扩展结点，重复上述扩展过程，直到找到所需的解或活结点表为空时为止。每一个活结点最多只有一次机会成为扩展结点。 算法步骤算法解题步骤为： 定义问题的解空间。 确定问题的解空间组织结构。 搜索解空间。搜索前要定义判断标准（约束函数或限界函数），如果选优优先队列式分支限界法，则必须确定优先级。 回溯法与分支限界法的异同1.相同点： 均需要先定义问题的解空间，确定的解空间组织结构一般都是树和图； 在问题的解空间树上搜索问题解。 搜索前均需要确定判断条件，该判断条件用于判断扩展生成的结点是否为可行结点。 搜索过程中必须判断扩展生成的结点是否满足判断条件，如果满足则保留该扩展结点，否则舍弃。 2.不同点 搜索目标不同：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支界限法的求解目标则是找出满足约束条件的一个解，或者是在满足约束条件的解中找出在某种意义下的最优解。 搜索的方式不同：回溯法以深度优先搜索方法搜索空间树，分支限界法采用广度优先法或者最小消耗优先搜索解空间树。 扩展方式不同：回溯法搜索，扩展结点一次只生成一个孩子结点，而分支限界法则一次生成所有孩子结点。 0-1背包问题问题分析前面有，不再重述， w[] 1 2 3 4 2 5 4 2 v[] 1 2 3 4 6 3 5 4 购物车重量W=10。商品的结构体定义为： struct Goods { int weight; int value; } goods[N]; weight 2 5 4 2 value 6 3 5 4 算法设计 定义问题的解空间。问题解空间为{x1,x2,…,xi,…,xn}，显约束为：xi=0或者1。 确定解空间的组织结构：子集树。 搜索解空间： 约束条件为：wixi≤W（i=1~n） 限界条件：cp+rp&gt;bestp（cp为当前已经装入购物车的物品的总价值，rp为第t+1~第n种物品的总价值，bestp为最大价值） 搜索过程：从根节点开始，以BFS方式进行搜索。根节点首先成为活结点，也是当前的扩展结点。一次性生成所有孩子结点，由于子集树中约定左分支上的值为“1”，因此沿着扩展结点的左分支扩展，则代表装入物品；右分支的值为“0”，代表不装入物品。此时判断是否满足约束条件和限界条件，如果满足，则将其加入队列中；反之舍弃。然后再从队列中取出一个元素，作为当前扩展结点，搜索过程队列为空时结束。 步骤解释 初始化。sumw=2+5+4+2=13，sumv=6+3+5+4=18，因为sumw&gt;W，所以不能装完，所以需要进行后续的操作。初始化cp=0,rp=sumv，当前剩余重量rw=W；当前处理物品序号为1；当前最优值bestp=0.解向量为x[]=(0,0,0,0)，创建一个根结点Node(cp,rp,rw,id)，标记为A，加入先进先出队列q中。cp为装入购物车的物品价值，rp为剩余物品的总价值，rw为剩余容量，id为物品号，x[]为当前解向量。 //定义结点。每个节点来记录当前的解。struct Node { int cp, rp; //cp背包的物品总价值，rp剩余物品的总价值 int rw; //剩余容量 int id; //物品号 bool x[N];//解向量 Node() {} Node(int _cp, int _rp, int _rw, int _id){ cp = _cp; rp = _rp; rw = _rw; id = _id; memset(x, 0, sizeof(x));//解向量初始化为0 } }; 扩展A结点。队头元素A出队，该结点的cp+rp≥bestp，满足限界条件，可以扩展。rw=10&gt;goods[1].weight=2，剩余容量大于1号物品，满足约束条件，可以放入购物车，cp=0+6=6。rp=18-6=12，rw=10-2=8，t=2，x[1]=1，解向量更新为x[]=(1,0,0,0)，生成左孩子B，加入q队列，更新bestp=6。再扩展右分支，cp=0,rp=18-6=12,cp+rp&gt;=bestp=6，满足限界条件，不放入1号物品，cp=0,rp=12,rw=10,t=2,x[1]=0，解向量为x[]=(0,0,0,0)，创建新结点C，加入q队列。如下表所示，X表示为空。 B X X X B C X X 扩展B结点。队头元素B出队，该结点cp+rp&gt;=bestp，满足限界条件，可以扩展。rw=8&gt;goods[2].weight=5，剩余容量大于2号物品重量，满足约束条件，可以放入购物车，cp=6+3=9。rp=12-3=9，rw=8-5=3，t=3，x[2]=1，解向量更新为x[]=(1,1,0,0)，生成左孩子D，加入q队列，更新bestp=9。再扩展右分支，cp=6,rp=12-3=9,cp+rp&gt;=bestp=9，满足限界条件，不放入2号物品，cp=6,rp=9,rw=8,t=3,x[2]=0，解向量为x[]=(1,0,0,0)，创建新结点E，加入q队列。如下表所示。 C D E X 扩展C结点。队头元素C出队，该结点cp+rp&gt;=bestp，满足限界条件，可以扩展。rw=10&gt;goods[2].weight=5，剩余容量大于2号物品重量，满足约束条件，可以放入购物车，cp=0+3=3。rp=12-3=9，rw=10-5=5，t=3，x[2]=1，解向量更新为x[]=(0,1,0,0)，生成左孩子F，加入q队列。再扩展右分支，cp=0,rp=12-3=9,cp+rp&gt;=bestp=9，满足限界条件，不放入2号物品，cp=6,rp=9,rw=10,t=3,x[2]=0，解向量为x[]=(0,0,0,0)，创建新结点G，加入q队列。如下表所示。 D E F G 扩展D结点。队头元素D出队，该结点cp+rp&gt;=bestp，满足限界条件，可以扩展。但是rw=3&gt;goods[3].weight=4，所以不满足约束条件，舍弃左分支。扩展右分支，cp=9,rp=9-5=4,cp+rp&gt;=bestp=9，满足限界条件，不放入3号物品，cp=9,rp=4,rw=3,t=4,x[3]=0，解向量为x[]=(1,1,0,0)，创建新结点H，加入q队列。如下表所示。 E F G H 扩展E结点。同理可得cp=11,rp=4,rw=4,t=4,x[3]=1，更新解向量为x[]=(1,0,1,0)，生成左孩子I，加入q队列，更新bestp=11。扩展右分支，cp=6,rp=9-5=4,cp+rp=10&lt;bestp=11，所以不满足限界条件，舍弃。 扩展F结点。同理得到左分支，cp=8,rp=4,rw=1,t=4,x[3]=1，解向量为x[]=(0,1,1,0)，生成左孩子J，加入q队列。扩展右分支，cp+rp&lt;11，舍弃。 扩展G结点。该结点cp+rp&lt;bestp=11，不满足限界条件，不再扩展。 扩展H结点。队头H结点出队，该结点cp+rp&gt;=bestp，满足限界条件，rw=3&gt;goods[4].weight=2，满足约束条件，令cp=9+4=13,rp=4-4=0,rw=3-2=1,t=5,x[4]=1，解向量更新为x[]=(1,1,0,1)，生成孩子K，加入q队列，更新bestp=13。右分支不满足限界条件舍弃。 扩展I结点。 队头I结点出队，该结点cp+rp&gt;=bestp，满足限界条件，rw=4&gt;goods[4].weight=2，满足约束条件，令cp=11+4=15,rp=4-4=0,rw=4-2=2,t=5,x[4]=1，解向量更新为x[]=(1,0,1,1)，生成孩子L，加入q队列，更新bestp=15。右分支不满足限界条件舍弃。 队头元素J出队，该结点cp+rp=12&lt;15，不满足限界条件，不再扩展。 队头元素K出队，扩展K结点：t=5，已经处理完毕，cp&lt;bestp，不是最优解。 队头元素K出队，扩展K结点：t=5，已经处理完毕，cp=bestp，是最优解，输出该向量(1,0,1,1)。 队列为空，算法结束。 代码实现int bestp, W, n, sumw, sumv; /* bestp 用来记录最优解。 W为购物车最大容量。 n为物品的个数。 sumw 为所有物品的总重量。 sumv 为所有物品的总价值。 */ //bfs 来进行子集树的搜索。 int bfs() { int t, tcp, trp, trw; queue&lt;Node&gt; q; //创建一个普通队列(先进先出) q.push(Node(0, sumv, W, 1)); //压入一个初始结点 while (!q.empty()) //如果队列不空 { Node livenode, lchild, rchild;//定义三个结点型变量 livenode = q.front();//取出队头元素作为当前扩展结点livenode q.pop(); //队头元素出队 //cp+rp&gt;bestp当前装入的价值+剩余物品价值小于当前最优值时，不再扩展。 cout &lt;&lt; &quot;当前结点的id值:&quot; &lt;&lt; livenode.id &lt;&lt; &quot;当前结点的cp值:&quot; &lt;&lt; livenode.cp &lt;&lt; endl; cout &lt;&lt; &quot;当前结点的解向量:&quot;; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; livenode.x[i]; } cout &lt;&lt; endl; t = livenode.id;//当前处理的物品序号 // 搜到最后一个物品的时候不需要往下搜索。 // 如果当前的购物车没有剩余容量(已经装满)了，不再扩展。 if (t&gt;n || livenode.rw == 0) { if (livenode.cp &gt;= bestp)//更新最优解和最优值 { for (int i = 1; i &lt;= n; i++) { bestx[i] = livenode.x[i]; } bestp = livenode.cp; } continue; } if (livenode.cp + livenode.rp&lt;bestp)//判断当前结点是否满足限界条件，如果不满足不再扩展 continue; //扩展左孩子 tcp = livenode.cp; //当前购物车中的价值 trp = livenode.rp - goods[t].value; //不管当前物品装入与否，剩余价值都会减少。 trw = livenode.rw; //购物车剩余容量 if (trw &gt;= goods[t].weight) //满足约束条件，可以放入购物车 { lchild.rw = trw - goods[t].weight; lchild.cp = tcp + goods[t].value; lchild = Node(lchild.cp, trp, lchild.rw, t + 1);//传递参数 for (int i = 1; i&lt;t; i++) { lchild.x[i] = livenode.x[i];//复制以前的解向量 } lchild.x[t] = true; if (lchild.cp&gt;bestp)//比最优值大才更新 bestp = lchild.cp; q.push(lchild);//左孩子入队 } //扩展右孩子 if (tcp + trp &gt;= bestp)//满足限界条件，不放入购物车 { rchild = Node(tcp, trp, trw, t + 1);//传递参数 for (int i = 1; i&lt;t; i++) { rchild.x[i] = livenode.x[i];//复制以前的解向量 } rchild.x[t] = false; q.push(rchild);//右孩子入队 } } return bestp;//返回最优值。 } 算法分析时间复杂度为O(2n+1)，空间复杂度O(n*2n+1)。 算法优化拓展——优先队列式分支限界法优先队列优化，简单来说就是以当前结点的上界为优先值，把普通队列改成优先队列。 算法设计。约束条件没有改变。优先级定义为活结点代表的部分解锁描述的装入物品价值的上界，该价值上界越大，优先级越高。活结点的价值上界up=活结点的cp+剩余物品装满购物车剩余容量的最大价值rp’。限界条件变为up=cp+rp’&gt;=bestp。 解题步骤（简略版） 初始化。sumw和sumv分别用来统计所有物品的总重量和总价值。sumw=13,sumv=18,sumw&gt;W，所以不能全部装完，需要搜索求解。 按价值重量比非递增排序。排序结果如下表所示。 后续不再详细叙述。 weight 2 2 4 5 value 6 4 5 3 3.代码实现 //定义辅助物品结构体，包含物品序号和单位重量价值,用于按单位重量价值(价值/重量比)排序、 struct Object { int id; //物品序号 double d;//单位重量价值 }S[N]; //定义排序优先级按照物品单位重量价值由大到小排序 bool cmp(Object a1,Object a2) { return a1.d&gt;a2.d; } //定义队列的优先级。 以up为优先，up值越大，也就越优先 bool operator &lt;(const Node &amp;a, const Node &amp;b) { return a.up&lt;b.up; } int bestp,W,n,sumw,sumv; /* bestv 用来记录最优解。 W为背包的最大容量。 n为物品的个数。 sumw 为所有物品的总重量。 sumv 为所有物品的总价值。 */ double Bound(Node tnode) { double maxvalue=tnode.cp;//已装入购物车物品价值 int t=tnode.id;//排序后序号 //cout&lt;&lt;&quot;t=&quot;&lt;&lt;t&lt;&lt;endl; double left=tnode.rw;//剩余容量 while(t&lt;=n&amp;&amp;w[t]&lt;=left) { maxvalue+=v[t]; // cout&lt;&lt;&quot;malvalue=&quot;&lt;&lt;maxvalue&lt;&lt;endl; left-=w[t]; t++; } if(t&lt;=n) maxvalue+=double(v[t])/w[t]*left; //cout&lt;&lt;&quot;malvalue=&quot;&lt;&lt;maxvalue&lt;&lt;endl; return maxvalue; } //priorbfs 为优先队列式分支限界法搜索。 int priorbfs() { int t,tcp,trw; double tup; //当前处理的物品序号t，当前装入购物车物品价值tcp， //当前装入购物车物品价值上界tup，当前剩余容量trw priority_queue&lt;Node&gt; q; //创建一个优先队列,优先级为装入购物车的物品价值上界up q.push(Node(0, sumv, W, 1));//初始化,根结点加入优先队列 while(!q.empty()) { Node livenode, lchild, rchild;//定义三个结点型变量 livenode=q.top();//取出队头元素作为当前扩展结点livenode q.pop(); //队头元素出队 cout&lt;&lt;&quot;当前结点的id值:&quot;&lt;&lt;livenode.id&lt;&lt;&quot;当前结点的up值:&quot;&lt;&lt;livenode.up&lt;&lt;endl; cout&lt;&lt;&quot;当前结点的解向量:&quot;; for(int i=1; i&lt;=n; i++) { cout&lt;&lt;livenode.x[i]; } cout&lt;&lt;endl; t=livenode.id;//当前处理的物品序号 // 搜到最后一个物品的时候不需要往下搜索。 // 如果当前的购物车没有剩余容量(已经装满)了，不再扩展。 if(t&gt;n||livenode.rw==0) { if(livenode.cp&gt;=bestp)//更新最优解和最优值 { cout&lt;&lt;&quot;更新最优解向量:&quot;; for(int i=1; i&lt;=n; i++) { bestx[i]=livenode.x[i]; cout&lt;&lt;bestx[i]; } cout&lt;&lt;endl; bestp=livenode.cp; } continue; } //判断当前结点是否满足限界条件，如果不满足不再扩展 if(livenode.up&lt;bestp) continue; //扩展左孩子 tcp=livenode.cp; //当前购物车中的价值 trw=livenode.rw; //购物车剩余容量 if(trw&gt;=w[t]) //满足约束条件，可以放入购物车 { lchild.cp=tcp+v[t]; lchild.rw=trw-w[t]; lchild.id=t+1; tup=Bound(lchild); //计算左孩子上界 lchild=Node(lchild.cp,tup,lchild.rw,lchild.id);//传递参数 for(int i=1;i&lt;=n;i++) { lchild.x[i]=livenode.x[i];//复制以前的解向量 } lchild.x[t]=true; if(lchild.cp&gt;bestp)//比最优值大才更新 bestp=lchild.cp; q.push(lchild);//左孩子入队 } //扩展右孩子 rchild.cp=tcp; rchild.rw=trw; rchild.id=t+1; tup=Bound(rchild); //右孩子计算上界 if(tup&gt;=bestp)//满足限界条件，不放入购物车 { rchild=Node(tcp,tup,trw,t+1);//传递参数 for(int i=1;i&lt;=n;i++) { rchild.x[i]=livenode.x[i];//复制以前的解向量 } rchild.x[t]=false; q.push(rchild);//右孩子入队 } } return bestp;//返回最优值。 } 旅行商问题问题分析带权邻接矩阵g[][]如下所示，空表示为无穷，即没有路径。 15 30 5 15 6 12 30 6 3 5 12 3 算法设计可以使用优先队列分支限界法，加快搜索速度。设置优先级：当前已走过的城市所有的路径长度cl。cl越小，优先级越高。从根节点开始，以广度优先的方式进行搜索。根节点首先成为活结点，也是当前的扩展结点。一次性生成所有的孩子结点，判断孩子结点是否满足约束条件和限界条件，如果满足，将其加入到队列中，反之，舍弃。然后再从队列中取出一个元素，作为当前扩展结点，搜索过程队列为空时为止。 代码实现struct Node//定义结点,记录当前结点的解信息 { double cl; //当前已走过的路径长度 int id; //景点序号 int x[N];//记录当前路径 Node() {} Node(double _cl,int _id) { cl = _cl; id = _id; } }; //定义队列的优先级。 以cl为优先级，cl值越小，越优先 bool operator &lt;(const Node &amp;a, const Node &amp;b) { return a.cl&gt;b.cl; } //Travelingbfs 为优先队列式分支限界法搜索 double Travelingbfs() { int t; //当前处理的景点序号t Node livenode,newnode;//定义当前扩展结点livenode,生成新结点newnode priority_queue&lt;Node&gt; q; //创建一个优先队列,优先级为已经走过的路径长度cl,cl值越小，越优先 newnode=Node(0,2);//创建根节点 for(int i=1;i&lt;=n;i++) { newnode.x[i]=i;//初时化根结点的解向量 } q.push(newnode);//根结点加入优先队列 cout&lt;&lt;&quot;按优先级出队顺序：&quot;&lt;&lt;endl;//用于调试 while(!q.empty()) { livenode=q.top();//取出队头元素作为当前扩展结点livenode q.pop(); //队头元素出队 //用于调试 cout&lt;&lt;&quot;当前结点的id值:&quot;&lt;&lt;livenode.id&lt;&lt;&quot;当前结点的cl值:&quot;&lt;&lt;livenode.cl&lt;&lt;endl; cout&lt;&lt;&quot;当前结点的解向量:&quot;; for(int i=1; i&lt;=n; i++) { cout&lt;&lt;livenode.x[i]; } cout&lt;&lt;endl; t=livenode.id;//当前处理的景点序号 // 搜到倒数第2个结点时个景点的时候不需要往下搜索 if(t==n) //立即判断是否更新最优解， //例如当前找到一个路径(1243)，到达4号结点时，立即判断g[4][3]和g[3][1]是否有边相连， //如果有边则判断当前路径长度cl+g[4][3]+g[3][1]&lt;bestl，满足则更新最优值和最优解 { //说明找到了一条更好的路径，记录相关信息 if(g[livenode.x[n-1]][livenode.x[n]]!=INF&amp;&amp;g[livenode.x[n]][1]!=INF) if(livenode.cl+g[livenode.x[n-1]][livenode.x[n]]+g[livenode.x[n]][1]&lt;bestl) { bestl=livenode.cl+g[livenode.x[n-1]][livenode.x[n]]+g[livenode.x[n]][1]; cout&lt;&lt;endl; cout&lt;&lt;&quot;当前最优的解向量:&quot;; for(int i=1;i&lt;=n;i++) { bestx[i]=livenode.x[i]; cout&lt;&lt;bestx[i]; } cout&lt;&lt;endl; cout&lt;&lt;endl; } continue; } //判断当前结点是否满足限界条件，如果不满足不再扩展 if(livenode.cl&gt;=bestl) continue; //扩展 //没有到达叶子结点 for(int j=t; j&lt;=n; j++)//搜索扩展结点的所有分支 { if(g[livenode.x[t-1]][livenode.x[j]]!=INF)//如果x[t-1]景点与x[j]景点有边相连 { double cl=livenode.cl+g[livenode.x[t-1]][livenode.x[j]]; if(cl&lt;bestl)//有可能得到更短的路线 { newnode=Node(cl,t+1); for(int i=1;i&lt;=n;i++) { newnode.x[i]=livenode.x[i];//复制以前的解向量 } swap(newnode.x[t], newnode.x[j]);//交换x[t]、x[j]两个元素的值 q.push(newnode);//新结点入队 } } } } return bestl;//返回最优值。 } （1）时间复杂度：O(n!)。空间复杂度：O(n*n!)。 算法优化拓展 算法开始时创建一个用于表示活结点优先队列。每个结点的费用下界zl=cl+rl值作为优先级。cl表示已经走过的路径长度，rl表示剩余路径长度的下界，rl用剩余每个结点的最小出边之和来计算。初始时先计算图中每个顶点i的最小出边，并用minout[i]数组记录，minsum记录所有结点的最小出边之和。如果所给的有向图中某个顶点没有出边，则该图不可能有回路，算法立即结束。 限界条件：zl&lt;bestl，zl&lt;cl+rl。 优先级：zl指已经走过的路径长度+剩余路径长度的下界。zl越小，优先级越高。 算法优化代码实现1.定义节点结构体 //定义结点,记录当前结点的解信息 struct Node { double cl; //当前已走过的路径长度 double rl; //剩余路径长度的下界 double zl; //当前路径长度的下界zl=rl+cl int id; //景点序号 int x[N];//记录当前解向量 Node() {} Node(double _cl,double _rl,double _zl,int _id) { cl = _cl; rl = _rl; zl = _zl; id = _id; } }; 2.定义队列优先级 bool operator &lt;(const Node &amp;a, const Node &amp;b) { return a.zl&gt;b.zl; } 3.计算下界 bool Bound()//计算下界（即每个景点最小出边权值之和） { for(int i=1;i&lt;=n;i++) { double minl=INF;//初时化景点点出边最小值 for(int j=1;j&lt;=n;j++)//找每个景点的最小出边 if(g[i][j]!=INF&amp;&amp;g[i][j]&lt;minl) minl=g[i][j]; if(minl==INF) return false;//表示无回路 minout[i]=minl;//记录每个景点的最少出边 cout&lt;&lt;&quot;第&quot;&lt;&lt;i&lt;&lt;&quot;个景点的最少出边:&quot;&lt;&lt;minout[i]&lt;&lt;&quot; &quot;&lt;&lt;endl; minsum+=minl;//记录所有景点的最少出边之和 } cout&lt;&lt;&quot;每个景点的最少出边之和:&quot;&quot;minsum= &quot;&lt;&lt;minsum&lt;&lt;endl; return true; } 4.Travelingbfsopt 为优化的优先队列式分支限界法 double Travelingbfsopt() { if(!Bound()) return -1;//表示无回路 Node livenode,newnode;//定义当前扩展结点livenode,生成新结点newnode priority_queue&lt;Node&gt; q; //创建一个优先队列,优先级为当前路径长度的下界zl=rl+cl,zl值越小，越优先 newnode=Node(0,minsum,minsum,2);//创建根节点 for(int i=1;i&lt;=n;i++) { newnode.x[i]=i;//初时化根结点的解向量 } q.push(newnode);//根结点加入优先队列 while(!q.empty()) { livenode=q.top();//取出队头元素作为当前扩展结点livenode q.pop(); //队头元素出队 cout&lt;&lt;&quot;当前结点的id值:&quot;&lt;&lt;livenode.id&lt;&lt;&quot;当前结点的zl值:&quot;&lt;&lt;livenode.zl&lt;&lt;endl; cout&lt;&lt;&quot;当前结点的解向量:&quot;; for(int i=1; i&lt;=n; i++) { cout&lt;&lt;livenode.x[i]; } cout&lt;&lt;endl; int t=livenode.id;//当前处理的景点序号 // 搜到倒数第2个结点时个景点的时候不需要往下搜索 if(t==n) //立即判断是否更新最优解， //例如当前找到一个路径(1243)，到达4号结点时，立即判断g[4][3]和g[3][1]是否有边相连， //如果有边则判断当前路径长度cl+g[4][3]+g[3][1]&lt;bestl，满足则更新最优值和最优解 { //说明找到了一条更好的路径，记录相关信息 if(g[livenode.x[n-1]][livenode.x[n]]!=INF&amp;&amp;g[livenode.x[n]][1]!=INF) if(livenode.cl+g[livenode.x[n-1]][livenode.x[n]]+g[livenode.x[n]][1]&lt;bestl) { bestl=livenode.cl+g[livenode.x[n-1]][livenode.x[n]]+g[livenode.x[n]][1]; cout&lt;&lt;endl; cout&lt;&lt;&quot;当前最优的解向量:&quot;; for(int i=1;i&lt;=n;i++) { bestx[i]=livenode.x[i]; cout&lt;&lt;bestx[i]; } cout&lt;&lt;endl; cout&lt;&lt;endl; } continue; } //判断当前结点是否满足限界条件，如果不满足不再扩展 if(livenode.cl&gt;=bestl) continue; //扩展 //没有到达叶子结点 for(int j=t; j&lt;=n; j++)//搜索扩展结点的所有分支 { if(g[livenode.x[t-1]][livenode.x[j]]!=INF)//如果x[t-1]景点与x[j]景点有边相连 { double cl=livenode.cl+g[livenode.x[t-1]][livenode.x[j]]; double rl=livenode.rl-minout[livenode.x[j]]; double zl=cl+rl; if(zl&lt;bestl)//有可能得到更短的路线 { newnode=Node(cl,rl,zl,t+1); for(int i=1;i&lt;=n;i++) { newnode.x[i]=livenode.x[i];//复制以前的解向量 } swap(newnode.x[t], newnode.x[j]);//交换两个元素的值 q.push(newnode);//新结点入队 } } } } return bestl;//返回最优值。 } 算法复杂度分析时间复杂度最坏为O(nn!)，空间复杂度为O(n2*(n+1)!)。 最优工程布线问题问题描述在3×3的方格阵列，灰色表示封锁，不能通过。将每个方格抽象为一个结点，方格和相邻4个方向（上下左右）中能通过的方格用一条线连接起来，不能通过的方格不连线。这样，可以把问题的解空间定义为一个图，如下图所示。 该问题是特殊的最短路径问题，特殊之处在于用布线走过的方格数代表布线的长度，布线时每一个方格，布线长度累加1.我们可以看出，从a到b有多种布线方案，最短的布线长度即从a到b的最短路径长度为4。既然只能朝四个方向布线，也就是说如果从树型搜索的角度来看，我们可以把它看做为m叉树，那么问题的解空间就变成了一颗m叉树。 算法设计（1）定义问题的解空间。可以把最优工程布线问题解的形式为n元组{x1,x2,…,xi,…,xn}，分量xi表示最优布线方案经过的第i个方格，而方格也可以用(x,y)表示第x行第y列。因为方格不可重复布线，所以在确定xi的时候，前面走过的方格{x1,x2,…,xi-1}都不可以再走，xi的取值范围为S-{x1,x2,…,xi-1}。 注意：和前面问题不同，因为不知道最优布线长度，所以n是未知的。 （2）解空间的组织结构：一颗m叉树，m=4，树的深度n未知。 （3）搜索解空间。搜索从起始结点a开始，到目标节点b结束。 约束条件：非障碍物或边界未曾布线。 限界条件：最先碰到的一定是距离最短的，因此无限界条件。 搜索过程：从a开始将其作为第一个扩展结点，沿a的右、下、左、上4个方向的相邻结点扩展。判断约束条件是否成立，若成立，则放入活结点中，并将这个方格标记为1。接着从活结点队列中取出队首结点作为下一个扩展结点，并沿当前扩展结点的右、下、左、上四个方向的相邻结点扩展，将满足约束条件的方格记为2，依此类推，一直继续搜索到目标方格或活结点为空为止，目标方格里的数据就是最优的布线长度。 构造最优解过程从目标节点开始，沿着右、下、左、上四个方向。判断如果某个方向方格里的数据比扩展结点方格的数据小1，则进入该方向方格，使其成为当前的扩展结点。以此类推，搜索过程一直持续到起始结点结束。 算法实现//定义结构体position typedef struct { int x; int y; } Position;//位置 int grid[100][100];//地图 bool findpath(Position s, Position e, Position *&amp;path, int &amp;PathLen) { if ((s.x == e.x) &amp;&amp; (s.y == e.y))//开始位置就是结束位置 { PathLen = 0; return true; } Position DIR[4], here, next; //定义方向数组DIR[4]，当前位置here，下一个位置next DIR[0].x = 0; DIR[0].y = 1; DIR[1].x = 1; DIR[1].y = 0; DIR[2].x = 0; DIR[2].y = -1; DIR[3].x = -1; DIR[3].y = 0; here = s; grid[s.x][s.y] = 0;//标记初始为0，未布线为-1，墙壁为-2 queue&lt;Position&gt; Q;//所使用队列 //按四个方向进行搜索 for (;;) { for (int i = 0; i &lt; 4; i++)//四个方向前进，右下左上 { next.x = here.x + DIR[i].x; next.y = here.y + DIR[i].y; if (grid[next.x][next.y] == -1)//未布线 { grid[next.x][next.y] = grid[here.x][here.y] + 1; Q.push(next); } if ((next.x == e.x) &amp;&amp; (next.y == e.y)) break;//找到了我们需要的目标 } if ((next.x == e.x) &amp;&amp; (next.y == e.y)) break;//找到了我们需要的目标 if (Q.empty()) return false; else { here = Q.front(); Q.pop();//把Q队头的元素弹出 } } //逆向找回最短布线方案 PathLen = grid[e.x][e.y];//最短的长度 path = new Position[PathLen]; here = e; for (int j = PathLen - 1; j &gt;= 0; j--) { path[j] = here; //沿着四个方向寻找，右下左上 for (int i = 0; i &lt; 4; i++) { next.x = here.x + DIR[i].x; next.y = here.y + DIR[i].y; if (grid[next.x][next.y] == j) break; } here = next; } return true; } //初始化地图，标记大于0表示已经布线，-1未布线，-2墙壁 void init(int m, int n) { for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) grid[i][j] = -1; //上面是先将所有的格子都初始化为-1 //然后把本问题为了方便加上的第0行和第0列都设置为墙 for (int i = 0; i &lt;= n + 1; i++) grid[0][i] = grid[m + 1][i] = -2; for (int i = 0; i &lt;= m + 1; i++) grid[i][0] = grid[i][n + 1] = -2; } 复杂度分析时间复杂度O(nm)，构造最短布线需要O(L)，空间复杂度O(n)。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"},{"name":"分支限界法","slug":"分支限界法","permalink":"http://tech.yushuai.xyz/tags/分支限界法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}]},{"title":"回溯法","slug":"回溯法","date":"2019-03-20T13:16:05.000Z","updated":"2019-03-20T13:17:14.648Z","comments":true,"path":"2019/03/20/回溯法/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/20/回溯法/","excerpt":"","text":"回溯法回溯法的思想是：能进则进，进不了换，换不了退。隐约束指对能否得到问题的可行解和最优解做出的约束。隐约束包括约束函数和限界函数。关键步骤是： 定义解空间； 确定解空间的组织结构（子集树、排列数、m叉树等）； 搜索解空间。 回溯法阶梯的关键是设计有效的显约束和隐约束。 大卖场购物（0-1背包问题）问题举例每个物品重量w和价值v如下表所示，购物车容量为W，求不超过购物车重量的最大价值。 w[] 1 2 3 4 2 5 4 2 w[] 1 2 3 4 6 3 5 4 问题分析 解空间={x1,x2,…,xi,…,xn}的所有子集（包括{0,0,0}这种子集），你像这里面就是{0,0,0,0},{0,0,0,1},{0,0,1,0},{0,0,1,1},…{1,1,1,1}。显约束为xi=0或1。 确定解空间的组织结构。由于显约束的缘故，可以看出解空间为子集树。 搜索解空间 约束条件为：wixi≤W（i=1~n） 限界条件：cp+rp&gt;bestp（cp为当前已经装入购物车的物品的总价值，rp为第t+1~第n种物品的总价值，bestp为最大价值） 搜索过程见问题求解。 问题求解（1）首先初始化。w[]={2,5,4,2}，v[]={6,3,5,4}，sumw=2+5+4+2=13，sumv=6+3+5+4=18，因为sumw&gt;W，所以不能装完，所以需要进行后续的操作。此时定义一个cp=rp=bestp=0，x[i]=0，cw=0。注意：在这里w[]和v[]的下标都是从1开始。并且以左子树为xi=1，右子树xi=0。 （2）开始搜索第一层（t=1）。cw=cw+w[1]=2&lt;W，所以令x[1]=1，cp=cp+v[1]=6，将2号结点加入左子树。(2号结点是第一个商品） （3）拓展2号结点。考虑cw+w[2]=7&lt;W，所以令x[2]=1，cp=cp+v[2]=9，将3号结点加入左子树。（3号结点是第2个商品） （4）拓展3号结点。考虑cw+w[3]=11&gt;W，所以x[3]=0，然后计算cp+rp=9+4=13&gt;bestp（此时bestp还是0），所以将4号结点加入右子树。（4号结点是第3个商品） （5）拓展4号结点。考虑cw+w[4]=9&lt;W，所以x[4]=1，然后计算cp=cp+v[4]=13，所以将5号结点加入左子树。（5号结点是第4个商品） （6）拓展5号结点。由于此时t&gt;n，故已经找到了一个当前的最优解，令bestp=cp（值为13），5号结点成为死结点。返回到上一结点。 （7）回溯拓展4号。此时cp=9，若将5号结点加入右子树，cp+rp=9&lt;bestp，故该结点不满足限界条件，成为死结点，继续回溯到3号结点。由于3号结点已经研究过，左子树不可行，所以回溯到2号结点。 （8）扩展2号结点（t=2）。之前扩展了左子树，所以现在考虑右子树。此时cp=6，bound(t+1)=cp+rp=15&gt;bestp，因此满足限界条件，扩展右子树，令x[2]=0，生成6号结点。（也就是第2个商品不要了） （9）扩展6号结点（t=3）。cw+w[3]=6&lt;W，满足约束条件，扩展左分支，令x[3]=1，cw=cw+w[3]=6，cp=cp+v[3]=11，生成7号结点加入左子树。（7号结点是第3件商品）。 （10）拓展7号结点（t=4）cw+w[4]=8&lt;W，满足约束条件，扩展到左子树。令x[4]=1，cw=cw+w[4]=8，cp=cp+v[4]=15。（8号结点是第4件商品） （11）拓展8号结点（t=5）。由于此时t&gt;n，故已经找到了一个当前的最优解，令bestp=cp（值为15），8号结点成为死结点。返回到上一结点。 （12）拓展7号结点（t=4）。考察bound(t+1)=cp+rp=11&lt;15，成为死结点。 （13）拓展6号结点（t=3）。bound(t+1)=cp+rp=10&lt;15，成为死结点。 （14）拓展1号结点（t=1），bound(t+1)=12&lt;15，成为死结点。算法结束。 代码实现double Bound(int i)//计算上界 { int rp=0;//剩余重量 while (i &lt;= n) { rp += v[i]; i++; } return rp+cp; } void Backtrack(int t)//t当前在第t层 { if (t &gt; n) { for (i = 1; i &lt;= n; i++) { bestx[i] = x[i]; } bestp = cp; return; } if (cw + w[t] &lt;= W)//还未到重量，可以搜索左子树 { x[t] = true; cw += w[t]; cp += v[t]; Backtrack(t + 1); cw -= w[t];//回溯 cp -= v[t];//回溯 } //若左子树不满足，然后看右子树，判断限界条件 if (Bound(t + 1) &gt; bestp) { x[t] = false; Backtrack(t + 1); } } void initial_parameter(double W, int n) { cw = 0;//初始化当前重量为0 cp = 0;//初始化当前价值为0 bestp = 0;//初始化当前最好价值为0 int sumw = 0;//统计所有物品的总重量 int sumv = 0;//统计所有物品价值 //这里上面两个参数可以根据具体情况确定为int或者double等 for (i = 1; i &lt;= n; i++) { sumw += w[i]; sumv += v[i]; } if (sumw &lt;= W) { bestp = sumv; cout &lt;&lt; &quot;所有物品均放入购物车&quot;; cout &lt;&lt; &quot;放入购物车的最大价值为&quot; &lt;&lt; bestp &lt;&lt; &quot;元。&quot; &lt;&lt; endl; return; } Backtrack(1); cout &lt;&lt; &quot;放入购物车的最大价值为&quot; &lt;&lt; bestp &lt;&lt; &quot;元。&quot; &lt;&lt; endl; cout &lt;&lt; &quot;放入购物车的物品序号为：&quot;; for (i = 1; i &lt;= n; i++) { if (bestx[i] == true) cout &lt;&lt; i &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } 算法复杂度和改进1.算法复杂度（1）时间复杂度：O(12n+n 2n)=O(n 2n)。（2）空间复杂度：O(n)。2.算法优化实际上，经常我们在计算bound()函数的时候对于rp多算太多了，因为很有可能rp到某一步就超过了购物车的中梁，所以我们可以缩小上界，从而加快剪枝速度，提高搜索效率。上界函数bound()：当前价值cp+剩余容量可容纳的剩余物品的最大价值brp（为了能装最大价值，所以在计算上界函数的时候可以对商品分割，*但实际的时候不允许），即修改为 double bound(int i) { //剩余物品为第i~n种物品 double cleft=W-cw;//剩余容量 while(i&lt;=n &amp;&amp; w[i]&lt;cleft) { cleft-=w[i]; brp+=v[i]; i++ } //下面是采用切割的方式装满背包，这里是求上界， //所以可以这样做。实际是不允许的 if(i&lt;=n) { brp+=v[i]/w[i]*cleft; } return cp+brp; } 为了更好地计算和运用上界函数剪枝，先将物品按照其单位重量价值（价值/重量）从大到小排序，然后按照排序后的顺序考察各个物品。即定义这样一个结构体： struct Object { int id;//物品序号 double ;//单位重量价值 }; bool cmp(Object a1, Object a2) { return a1.d&gt;a2.d; } 然后将 initial_parameter(double W, int n)的if(sumw&lt;=W)这个语段后面加入： sort(Q,Q+n,cmp); for(i=1;i&lt;=n;i++) { a[i]=w[Q[i-1].id];//把排序后的数据传递给辅助数组 b[i]=v[Q[i-1].id]; } for(i=1;i&lt;=n;i++) { w[i]=a[i]; v[i]=b[i]; } 然后将 for (i = 1; i &lt;= n; i++) { if (bestx[i] == true) cout &lt;&lt; i &lt;&lt; &quot; &quot;; } 修改为 for (i = 1; i &lt;= n; i++) { if (bestx[i] == true) cout &lt;&lt; Q[i-1].id &lt;&lt; &quot; &quot;; } 最大团问题描述部落酋长希望组织一支保卫部落的卫队，要在居民中选出最多的居民加入，并保证卫队中任何两个人都不是仇敌。编程计算构建部落护卫队的最佳方案。 问题分析 完全子图：给定无向图G(V,E)，其中V是结点集，E是边集。G’=(V’,E’)。如果结点集V’⊆V，E’⊆E，且G’*中的任意两个结点都有边相连，则成G’是G的完全子图。 当且仅当G’不包含在G的更大的完全子图中时，G的完全子图G’ 是 G的团，就是说G’ 是 G的极大完全子图。 最大团：G的最大团是指G所有团中，含结点数最多的团。 算法设计 定义问题的解空间。问题的解空间为 {x1,x2,…,xi,…,xn}的所有子集（包括{0,0,0}这种子集），你像这里面就是{0,0,0,0},{0,0,0,1},{0,0,1,0},{0,0,1,1},…{1,1,1,1}。显约束为xi=0或1。 解空间的组织结构：子集树，深度为n。 搜索解空间： 约束条件：假设当前扩展结点位于解空间树的第t层，那么从第1到第t-1层的结点情况都已经确定，接下来是按照扩展结点的左分支进行扩展，此时需要判断是否将第t个结点放到团里，只要第t和结点和前面t-1个结点中被选中的结点都有边连接，那么就能放到团里，即x[i]=1，否则不能放到团里，即x[i]=0。 限界条件：根据前t个结点的状态确定当前已经放入团中的结点个数（用cn表示），假想t+1个结点到第n结点全部放入团内，放入的节点个数（fn表示），fn=n-t，则cn+fn是所有从根出发的路径中经过中间结点z的可行解所包含结点个数的上界。若cn+fn&gt;bestn，则需要向子孙结点搜索，否则不需要。所以限界条件为cn+fn&gt;bestn。 代码实现bool isPlace(int t) { bool status = true; for (int j = 1; j &lt; t; j++) { if (x[j] &amp;&amp; a[t][j] == 0) { status = false; break; } } return status; } //回溯法主体 void backtrack(int t) { //到达叶结点 if (t &gt; n) { for (int i = 1; i &lt;= n; i++) bestx[i] = x[i]; bestn = cn; return; } if (isPlace(t)) { x[t] = 1; cn++; backtrack(t + 1); cn--; } if (cn + n - t &gt; bestn)//这里可以进行优化 { x[t] = 0; backtrack(t + 1); } } 算法复杂度分析1.时间复杂度：O(n* 2n)，空间复杂度为O(n)。 着色问题问题分析假设地图共有7个区域，分别是A/B/C/D/E/F/G，对上面顺序进行编号，每个区域用一个结点表示，相邻的区域有连线，那么地图就转化成一个无向连接图。 算法设计 定义问题的解空间。图的m着色问题解空间形式为n元组{x1,x2,…,xi,…,xn}，每个分量取值为1,2,3,…,m，即问题的解是一个n元向量。由此可得，问题的解空间为{x1,x2,…,xi,…,xn}，其中显约束为xi=1,2,…,m。 确定解空间的组织结构：一颗满m叉树，树的深度为n。 搜索解空间 约束条件：假设当前扩展结点位于解空间树的第t层，那么从第1到第t-1层的结点情况都已经确定，接下来是按照扩展结点的第一个分支进行扩展，此时需要判断是否将第t个结点着色情况。第t个结点的色号要与前t-1个结点中与其有边相连的结点颜色不同，如果有颜色相同的，则第t个结点不能用这个色号，换下一个色号尝试。 限界条件：无。 搜索过程：扩展结点沿着第一个分支扩展，判断约束条件，满足则进入深一层继续搜索；如果不满足，则扩展生成的结点被剪掉，换下一个色号尝试。如果所有色号都尝试完毕，该结点变成死结点，向上回溯到距离其最近的活结点，继续搜索。搜索到叶子结点时，找到一种着色方案，搜索过程直到全部活结点变成死结点为止。 解题过程地图7个区域，3种颜色。 开始搜索第1层（t=1）。扩展A结点第一个分支，首先判断是否满足约束条件，因为之前还未着色任何结点，所以满足约束条件，扩展该分支，令1号结点着1号色，即x[1]=1，生成B。 拓展B结点（t=2）。扩展第一个分支x[2]=1，首先判断2号结点是否和前面已经确定色号的结点（1号）有边相连且色号相同，不满足约束条件，剪掉该分支，然后沿着x[2]=2扩展，2号结点和前面已经确定色号的结点（1号）有边相连，但色号不同，满足约束条件，扩展该分支，令x[2]=2。 扩展C结点（t=3）。扩展第一个分支x[3]=1，首先判断3号结点是否和前面已经确定色号的结点（1、2号）有边相连且色号相同，不满足约束条件，剪掉该分支；同理剪掉x[3]=2分支。然后沿着x[3]=3扩展，3号结点和前面已经确定色号的结点（1、2号）有边相连，但色号不同，满足约束条件，扩展该分支，令x[3]=3。生成D。 扩展D结点（t=4）。扩展第一个分支x[4]=1，首先判断4号结点是否和前面已经确定色号的结点（1、2、3号）有边相连且色号相同，不满足约束条件（4余1相连），剪掉该分支；然后令x[4]=2，符合条件，生成E。 扩展E结点（t=5）。扩展第一个分支x[5]=1，首先判断4号结点是否和前面已经确定色号的结点（1、2、3号）有边相连且色号相同，确定5与2、3、4相连但色号不同，满足约束条件，扩展该分支，生成F。 扩展F结点（t=6）。扩展第一个分支x[6]=1，同理不满足，剪掉分支；然后沿着x[6]=2扩展，6与5号有边相连但色号不同，故满足约束条件，扩展该分支，令x[6]=2，生成G。 扩展G结点（t=7）。扩展第一个分支x[7]=1，剪掉x[7]=1和x[7]=2的分支，然后令x[7]=3，符合要求，生成H。 扩展H结点（t=8）。t&gt;n，找到一个可行解，输出该可行解{1,2,3,2,1,2,3}，回溯到最近的活结点G。 重新扩展G结点（t=7）。G已经考察完毕，成为死结点，回溯到最近的活结点F。 继续搜索，又找到第二种着色方案，输出可行解{1,3,2,3,1,3,2}。 继续搜索，又找到4个可行解。 代码实现//约束条件 bool isRight(int t) { for (int j = 1; j &lt; t; j++) { if (map[t][j]) { if (x[j] == x[t]) return false; } } return true; } //回溯方法函数 void Backtrack(int t) { if (t &gt; n) { sum++; cout &lt;&lt; &quot;第&quot; &lt;&lt; sum &lt;&lt; &quot;种方案：&quot;; for (int i = 1; i &lt;= n; i++)//输出该着色方案 { cout &lt;&lt; x[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } else { for (int i = 1; i &lt;= m; i++) { x[t] = i; if (isRight(t)) Backtrack(t + 1); } } } 算法复杂度分析 时间复杂度：O(nmn)。 空间复杂度：O(n)。 n皇后问题问题介绍在n×n的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋规则，皇后可以攻击与之在同一行、同一列、同一斜线上的棋子。现在在n*n的棋盘上放置n个皇后，使其不受攻击。 问题分析 求解策略： 以行为主导： 在第1行第1列放置第一个皇后。 在第2行放置第2个皇后。第2个皇后的位置不能和前面的皇后同列、同斜线，不用再判断同行了，因为每行我们本来就只放一个。 在第3行放置第3个皇后。第3个皇后的位置不能和前面的皇后同列、同斜线。 …… 在第t行放置第t个皇后。第t个皇后的位置不能和前面的皇后同列、同斜线。 …… 在第n行放置第n个皇后。第n个皇后的位置不能和前面的皇后同列、同斜线。 算法设计（1）定义问题的解空间。n皇后问题解的形式为n元组：{x1,x2,…,xi,…,xn}，分量xi表示第i个皇后放置在第i行第xi列，xi取值为1,2,3,…,n。显约束为不同行。 （2）解空间的组织结构：一颗m(m=n)叉树，树深度为n。 （3）搜索解空间。约束条件：在第t行放置第t个皇后时，第t个皇后的位置不能和前t-1个皇后同列、同斜线。第i个皇后和第j个皇后不同列，即xi!=xj。 限界条件：不需要设置。 搜索过程： 从根开始，以DFS的方式进行搜索。根节点是活结点，并且是当前的扩展结点。在搜索过程中，当前的扩展结点沿纵深方向移向一个新结点，判断该新结点是否满足隐约束。如果满足，则该新结点成为活结点，并且成为当前的扩展结点，继续深一层的搜索；如果不满足，则换到该新结点的兄弟结点继续搜索；如果新结点没有兄弟结点，或其兄弟结点已全部搜索完毕，则扩展结点成为死结点，搜索回溯到其父结点处继续进行。搜索过程直到找到问题的根结点变成死结点为止。 代码实现bool isPlace(int t) { bool place = true; for (int j = 1; j &lt; t; j++) { if (x[t] == x[j] || t - j == fabs(x[t] - x[j]))//判断列、对角线是否冲突 { place = false; break; } } return place; } void backtrack(int t) { if (t &gt; n) { countn++; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; x[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl; } else {//分别判断n个分支，特别注意i不要定义为全局变量，否则递归调用有问题 for (int i = 1; i &lt;= n; i++) { x[t] = i; if (isPlace(t)) backtrack(t + 1); //上面说的是不冲突就进行下一行搜索 } } } 算法复杂度分析 时间复杂度：O(nn+1）。 空间复杂度：O(n)。 最优加工顺序问题描述现在有3个机器零件{J1,J2,J3}，在第一台机器上的加工时间分别为2、5、4，在第二台机器上的加工时间分别为3、1、6.如何安排零件加工顺序，使第一个零件从机器1上加工开始到最后一个零件在机器2上加工完成，所需的总加工时间最短？ 问题分析我们通过分析可以发现，第一台机器可以连续加工，而第二台机器开始加工的时间是当前第一台机器的下线时间和第二台机器下线时间的最大值。实际上就是找到n个机器零件的一个排列，使总的加工时间最短。 算法设计 定义问题的解空间。解的形式为n元组：{x1,x2,…,xi,…,xn}，分量xi表示第i个加工的零件号，n个零件组成的集合为S={1,2,…,n}，xi取值为S-{x1,x2,…,xi-1}。 解空间的组织形式为一颗排列数，深度为n。 搜索解空间。 约束条件：无约束条件。 限界条件：用f2表示当前已完成的零件在第二台机器加工结束所用的时间，用bestf表示当前找到的最优加工方案的完成时间。显然，继续向深处搜索时，f2不会减少，只会增加。因此，当f2≥bestf时，没有继续向深处搜索的必要。限界条件可以描述为：f2&lt;bestf。f2初值为0，bestf的初值为无穷大。 搜索过程。扩展结点沿着某个分支扩展时需要判断限界条件，如果满足，则进入深一层继续搜索；如果不满足，则剪掉该分支。搜索到叶子结点的时候，即找到当前最优解。搜索直到全部活结变成死结点为止。 代码实现1.数据结构 struct node { //机器零件在第一台机器上的加工时间x和第二胎机器上的加工时间y int x,y; }T[MAX]; 2.按限界条件进行搜索求解：t表示当前扩展结点在第t层，f1表示当前第一台机器上加工的完成时间，f2表示当前第二台机器上加工的完成时间。如果t&gt;n表示已经到达叶子结点，记录最优值和最优解，返回。否则，分别判断每个分支是否满足约束条件，若满足则进入下一层backtrack(t+1)；如果不满足则反操作复位，考察下一个分支（兄弟结点）。 void Backtrack(int t) { if(t&gt;n) { for(int i=1;i&lt;=n;i++) bestx[i]=x[i];//记录最优队列 bestf=f2;//更新最优值 return ; } for(int i=t;i&lt;=n;i++) { f1+=T[x[i].x; int temp=f2; f2=max(f1,f2)+T[x[i]].y; if(f2&lt;bestf)//满足限界条件 { swap(x[t],x[i]);//交换 Backtrack(t+1);//继续搜索 swap(x[t],x[i]);//复位，反操作 } f1-=T[x[i]].x;//复位，反操作 f2=temp;//复位，反操作 } } 算法复杂度分析时间复杂度为O(nn!)≈O((n+1)!)，空间复杂度为O(n)。 算法优化改进新的算法的时间复杂度为O(nlogn)，空间复杂度为O(n)。利用贝尔曼规则，代码如下： #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std ; const int MX=10000+5 ; int n; struct node { int id; int x,y; }T[MX] ; bool cmp(node a,node b) { return min(b.x,a.y)&gt;=min(b.y,a.x);//按照贝尔曼规则排序 } int main() { cout&lt;&lt;&quot;请输入机器零件的个数 n:&quot;; cin&gt;&gt;n; cout&lt;&lt;&quot;请依次输入每个机器零件在第一台机器上的加工时间x和第二台机器上的加工时间y:&quot;; for(int i=0;i&lt;n;i++) { cin&gt;&gt;T[i].x&gt;&gt;T[i].y; T[i].id=i+1; } sort(T,T+n,cmp); //排序 int f1=0,f2=0; for(int i=0;i&lt;n;i++) //计算总时间 { f1+=T[i].x; f2=max(f1,f2)+T[i].y; } cout&lt;&lt;&quot;最优的机器零件加工顺序为:&quot;; for(int i=0;i&lt;n;i++) //输出最优加工顺序 cout&lt;&lt;T[i].id&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; cout&lt;&lt;&quot;最优的机器零件加工的时间为:&quot;; cout&lt;&lt;f2&lt;&lt;endl; return 0 ; } 旅行商问题问题描述假设有5个点，这五个点之间是用无向边来连接的，但是每一个边是有权重的，这实际上是一个无向带权图。我们希望在最小权重的情况下走过这5个点，且不重复，那应该怎样来实现呢？ 算法设计 定义问题的解空间：问题解的形式为n元组{x1,x2,…,xi,…,xn}，分量xi表示第i个要去的旅游景点编号，景点的集合为S={1,2,…,N}。因为景点不可重复走，因此在确定xi时，前面走过的景点{x1,x2,…,xi,…,xi-1}不能再走。xi的取值为S-{x1,x2,…,xi,…,xi-1}。 解空间的组织形式：解空间是一颗排列树，树的深度为n=5。除了开始结点1之外，一共有24种排列方式。 搜索解空间：约束条件：用二维数组g[][]储存无向带权图的邻接矩阵，如果g[i][j]≠无穷表示城市i和城市j又边相连，能走通。限界条件：cl&lt;bestl。cl的初始值为0，表示当前已经走过的城市所用的路径长度；bestl初始值为无穷，表示当前找到的最短路径的路径长度。 搜索过程：扩展结点沿着某个分支扩展时需要判断约束条件和限界条件，如果满足，则进入深一层继续搜索，如果不满足，则剪掉该分支。搜索到叶子结点时，即找到了当前最优解。搜索直到全部的活结点变成死结点为止。 完美图解（1）数据结构：如下表所示的邻接矩阵。 3 8 9 3 3 10 5 3 4 3 8 10 4 20 9 5 3 20 （图中未填的就是无穷） （2）初始化：cl=0,bestl=无穷，解分量x[i]和最优解bestx[i]初始化为： i 1 2 3 4 5 x[i] 1 2 3 4 5 i 1 2 3 4 5 bestx[i] 0 0 0 0 0 （3）开始搜索第一层（t=1） 扩展A0结点，因为我们是从1号结点出发，所以x[1]=1，生成A结点。 （4）扩展A结点（t=2）沿着x[2]=2分支扩展，因为1号结点和2号结点有边相连，且cl+g[1][2]=0+3&lt;bestl，满足限界条件，生成B结点。 （5）扩展B结点（t=3）沿着x[3]=3分支扩展，因为2号结点和3号结点有边相连，且cl+g[2][3]=3+3=6&lt;bestl，满足限界条件，生成C结点。 （6）扩展C结点（t=4）沿着x[4]=4分支扩展，因为3号结点和4号结点有边相连，且cl+g[3][4]=6+4=10&lt;bestl，满足限界条件，生成D结点。 （7）扩展D结点（t=5）沿着x[5]=5分支扩展，因为4号结点和5号结点有边相连，且cl+g[3][4]=10+20=30&lt;bestl，满足限界条件，生成E结点。 （8）扩展E结点（t=6）t&gt;n，判断5号结点是否和1号结点相连，确认有，且cl+g[5][1]=30+9=39&lt;bestl，找到一个当前最优解（1,2,3,4,5,1），更新bestl=39。 （9）向上回溯到D，D的孩子已经生成完毕，成为死结点，继续回溯到C，C结点还有一个孩子未生成。（10）重新扩展C结点（t=4）。沿着x[4]=5分支扩展，因为3号结点和5号结点有边相连，且cl+g[3][5]=6+3=9&lt;bestl=39，满足限界条件，生成F结点。 （11）扩展F结点（t=5）。沿着x[5]=4分支扩展，因为5号结点和4号结点有边相连，且cl+g[5][4]=9+20=29&lt;bestl=39，满足限界条件，生成G结点。 （12）扩展G结点（t=6）。t&gt;n，判断4号结点是否和1号结点相连，确认有，且cl+g[4][1]=29+8=37&lt;bestl=39，找到一个当前最优解（1,2,3,5,4,1），更新bestl=37。 不断搜索下去，到最后有以下组合和其值。 i 1 2 3 4 5 权值 结点组合 1 2 3 4 5 39 结点组合 1 2 3 5 4 37 结点组合 1 2 4 3 5 29 结点组合 1 2 5 3 4 23 结点组合 1 4 3 2 5 29 结点组合 1 4 3 5 2 23 结点组合 1 5 2 3 4 29 综上所述，bestl=23，路径为1-2-5-3-4-1。 代码实现//初始化 void init() { bestl = INF; cl = 0; for (int i = 1; i &lt;= n; i++) for (int j = i; j &lt;= n; j++) g[i][j] = g[j][i] = INF; for (int i = 0; i &lt;= n; i++) { x[i] = i; bestx[i] = 0; } } //邻接矩阵赋值 void createMatrix() { int u, v, w;//结点u和v，权值w cout &lt;&lt; &quot;请依次输入两个结点u和v之间的权值w。&quot; &lt;&lt; endl; cout &lt;&lt; &quot;格式：结点u 结点v 距离w&quot; &lt;&lt; endl; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u][v] = g[v][u] = w; } } //回溯法核心 void backTrack(int t) { if (t &gt; n) //到达叶子结点 //最后一个结点与第一个结点有边相连且路径长度比当前最优值最小 //说明找到了一条更优路径，记录相关信息 { if (g[n][1] != INF &amp;&amp; (cl + g[x[n]][1] &lt; bestl)) { for (int j = 1; j &lt;= n; j++) bestx[j] = x[j]; bestl = cl + g[x[n]][1]; } } else { //没有到达叶子结点 for (int j = t; j &lt;= n; j++) { //搜索扩展结点的所有分支 //如果第t-1个结点与第t个结点有边相连且可以得到更短路径 if (g[x[t - 1]][x[j]] != INF &amp;&amp; (cl + g[x[t - 1]][x[j]] &lt; bestl)) { //保存第t个结点到x[t]中，进入第t+1个 swap(x[t], x[j]);//交换两个元素的值 cl = cl + g[x[t - 1]][x[t]]; backTrack(t + 1); cl = cl - g[x[t - 1]][x[t]]; swap(x[t], x[j]); } } } } //打印路径 void print() { cout &lt;&lt; &quot;最短路径：&quot; &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; bestx[i] &lt;&lt; &quot;---&gt;&quot;; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; cout &lt;&lt; &quot;最短路径长度：&quot; &lt;&lt; bestl &lt;&lt; endl; } 算法复杂度分析 时间复杂度：除了最后一层外，有1+(n-1)+…+(n-1)(n-2)…2&lt;=n(n-1)!个结点需要判断约束函数和限界函数，判断两个函数需要O(1)的时间，因此耗时O(n!)。在叶子节点处记录当前最优解需要耗时O(n)，在最坏情况下回搜索到每一个叶子结点，叶子数为(n-1)!，所以时间复杂度为O（n!）。 空间复杂度：O(n)。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://tech.yushuai.xyz/tags/算法/"},{"name":"回溯法","slug":"回溯法","permalink":"http://tech.yushuai.xyz/tags/回溯法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://tech.yushuai.xyz/categories/algorithm/"}]},{"title":"《剑指Offer》题目解析（12）","slug":"e3-80-8a-e5-89-91-e6bc-8812-ef-bc-89","date":"2019-03-10T15:10:05.000Z","updated":"2019-03-20T14:41:15.523Z","comments":false,"path":"2019/03/10/e3-80-8a-e5-89-91-e6bc-8812-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/10/e3-80-8a-e5-89-91-e6bc-8812-ef-bc-89/","excerpt":"","text":"题目1 序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 题目解析序列化二叉树可以使用前序遍历来进行，这样的话响应的反序列化在根节点的数值读出来的时候就可以开始了。如果二叉树读的时候遇到NULL，就输出一个“\\\\$ ”。我们以字符串“1,,2,4,$,\\\\$,\\\\$,3,5,\\\\$,\\\\$,6,\\\\$,\\\\$”为例来分析如何反序列化。第一个读出来的数字是1，所以这肯定是根节点的值，接下来读出来的肯定是根节点左子结点上的值，然后接下来再读到的肯定是其左子结点上的值。接着我们读出了两个“$”，这表明4的左右子结点都是空，因此它是一个叶结点，然后返回到上面的结点，也就是2，建立它的右节点，由于下一个字符是“$”，所以肯定右节点也是空，然后继续返回上一层结点，如此而来。 代码void Serialize(BinaryTreeNode* pRoot, ostream&amp; stream) { if(pRoot==NULL) { stream&lt;&lt;&quot;$&quot;; return; } stream&lt;&lt;pRoot-&gt;val&lt;&lt;&apos;,&apos;; Serialize(pRoot-&gt;left,stream); Serialize(pRoot-&gt;right,stream); } void Deserialize(BinaryTreeNode* pRoot, istream&amp; stream) { int number; if(ReadStream(stream,&amp;number)) { *pRoot=new BinaryTreeNode(); (*pRoot)-&gt;val=number; (*pRoot)-&gt;left=NULL; (*pRoot)-&gt;right=NULL; Deserialize(&amp;((*pRoot)-&gt;left),stream); Deserialize(&amp;((*pRoot)-&gt;right),stream); } } 题目2 平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 题目解析一个最容易想到的办法就是在每一层结点都分别判断这个子树是不是平衡二叉树，若都是那么就返回true，如果看到一个不是平衡二叉树，立马返回false。如代码1，其核心就是计算树的深度，这可以借鉴前面“二叉树的高度”的代码来执行。 但是这个方法每一次都有往下遍历到叶结点，纯粹浪费时间和空间。如果我们用后序遍历的方式遍历二叉树的每个结点，那么在遍历到一个结点之前我们就已经遍历了它的左、右子树。只要在遍历每个结点的时候记录它的深度，我们就可以一遍遍历一边判断每个结点是不是平衡的了。如代码2。 代码1class Solution { public: bool IsBalanced_Solution(TreeNode* pRoot) { if(pRoot == NULL) return true; int leftDepth = getDepth(pRoot -&gt; left); int rightDepth = getDepth(pRoot -&gt; right); if(leftDepth &gt; rightDepth + 1 || leftDepth + 1 &lt; rightDepth) return false; else return IsBalanced_Solution(pRoot -&gt; left) &amp;&amp; IsBalanced_Solution(pRoot -&gt; right); } int getDepth(TreeNode* pRoot){ if(pRoot == NULL) return 0; int leftDepth = getDepth(pRoot -&gt; left); int rightDepth = getDepth(pRoot -&gt; right); return leftDepth &gt; rightDepth ? leftDepth + 1 : rightDepth + 1; } }; 代码2bool IsBalanced(BinaryTreeNode* pRoot, int *pDepth) { if(pRoot==NULL) { *pDepth=0; return true; } int left,right; if(IsBalanced(pRoot-&gt;left,&amp;left &amp;&amp; IsBalanced(pRoot-&gt;right,&amp;right)) { int diff=left-right; if(diff&lt;=1 &amp;&amp;diff&gt;=-1) { *pDepth=1+(left&gt;right?left:right); return true; } } return false; } 题目3 和为S的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 题目解析这个题其实可以这样思考：由于这个序列肯定至少是从1开始（0的话没什么用处），所以先把l和r（也就是left和right）都设置为1。然后就判断在l&lt;=r条件下，对r不断右移位置，看他们这个时候的和是多少，如果这个时候这个和等于给定值并且l不等于r的话，那就把这个序列直接push进二维vector里面去。如果这个时候和大于给定值了，那就尝试把序列最左端（也就是最小的值）逐一减去试试，看何时到达给定值。这个时候如果到达了，又push进去。最后直到l&gt;r，也就是找不到了为止。 代码vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) { int l = 1,r = 1,sumx = 1; vector&lt;vector&lt;int&gt; &gt; ans; while(l &lt;= r){ r ++; sumx += r; while(sumx &gt; sum){ sumx -= l; l ++; } if(sumx == sum &amp;&amp; l != r){ vector&lt;int&gt; tmp; for(int i = l;i &lt;= r;i ++) tmp.push_back(i); ans.push_back(tmp); } } return ans; } 题目4 孩子们的游戏（约瑟夫环问题）题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 题目解析这实际上是一个约瑟夫环的问题。首先定义最初的n个数字（0,1,…,n-1）中最后剩下的数字是关于n和m的方程为f(n,m)。 在这n个数字中，第一个被删除的数字是(m-1)%n，为简单起见记为k。那么删除k之后的剩下n-1的数字为0,1,…,k-1,k+1,…,n-1，并且下一个开始计数的数字是k+1。相当于在剩下的序列中，k+1排到最前面，从而形成序列k+1,…,n-1,0,…k-1。该序列最后剩下的数字也应该是关于n和m的函数。由于这个序列的规律和前面最初的序列不一样（最初的序列是从0开始的连续序列），因此该函数不同于前面函数，记为f’(n-1,m)。最初序列最后剩下的数字f(n,m)一定是剩下序列的最后剩下数字f’(n-1,m)，所以f(n,m)=f’(n-1,m)。 接下来我们把剩下的的这n-1个数字的序列k+1,…,n-1,0,…k-1作一个映射，映射的结果是形成一个从0到n-2的序列： k+1 -&gt; 0k+2 -&gt; 1…n-1 -&gt; n-k-20 -&gt; n-k-1…k-1 -&gt; n-2 把映射定义为p，则p(x)= (x-k-1)%n，即如果映射前的数字是x，则映射后的数字是(x-k-1)%n。对应的逆映射是p-1(x)=(x+k+1)%n。 由于映射之后的序列和最初的序列有同样的形式，都是从0开始的连续序列，因此仍然可以用函数f来表示，记为f(n-1,m)。根据我们的映射规则，映射之前的序列最后剩下的数字f’(n-1,m)= p-1 [f(n-1,m)]=[f(n-1,m)+k+1]%n。把k=(m-1)%n代入得到f(n,m)=f’(n-1,m)=[f(n-1,m)+m]%n。 经过上面复杂的分析，我们终于找到一个递归的公式。要得到n个数字的序列的最后剩下的数字，只需要得到n-1个数字的序列的最后剩下的数字，并可以依此类推。当n=1时，也就是序列中开始只有一个数字0，那么很显然最后剩下的数字就是0。我们把这种关系表示为： 0 n=1f(n,m)={[f(n-1,m)+m]%n n&gt;1 尽管得到这个公式的分析过程非常复杂，但它用递归或者循环都很容易实现。最重要的是，这是一种时间复杂度为O(n)，空间复杂度为O(1)的方法， 代码int LastRemaining_Solution(int n, int m) { if(n==0) return -1; int s = 0; for(int i = 2;i &lt;= n; i++) { s = (s+m) % i; } return s; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《剑指Offer》题目解析（11）","slug":"e3-80-8a-e5-89-91-e6-8c--ef-bc-8811-ef-bc-89","date":"2019-03-08T02:50:26.000Z","updated":"2019-03-20T14:41:19.322Z","comments":false,"path":"2019/03/08/e3-80-8a-e5-89-91-e6-8c--ef-bc-8811-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/08/e3-80-8a-e5-89-91-e6-8c--ef-bc-8811-ef-bc-89/","excerpt":"","text":"题目4 和为S的两个数字题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 题目解析我们知道，两个数字，距离越远，乘积越小，距离越近乘积越大。所以我们可以设置两个指针，一个指向开头，一个指向末尾，然后他们不断移动，同时相加看是不是等于所制定的值。移动的条件是： 若和大于指定值，则将右指针左移； 若和小于指定值，则将左指针右移； 若到最后左指针和有指针位于一个位置，那么直接返回。 代码vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) { int length = array.size(); int start=0; int end=length-1; vector&lt;int&gt; result; while(start&lt;end) { if(array[start]+array[end]==sum) { result.push_back(array[start]); result.push_back(array[end]); break; } else if(array[start]+array[end]&lt;sum) ++start; else --end; } return result; } 题目5 左旋转字符串题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 题目解析这里我们可以使用一个C++里面的函数： string substr (size_t pos = 0, size_t len = npos) const; 解释如下： - pos：要复制的第一个字符作为子字符串的位置。 如果这等于字符串长度，则该函数返回一个空字符串；如果这大于字符串长度，则抛出out_of_range。 - len：要包含在子字符串中的字符数。若为npos，代表所有的字符。 该函数返回一个string类型的对象。 string&amp; erase (size_t pos = 0, size_t len = npos); 这个函数的意思是：删除从字符位置pos开始并跨越len个字符的字符串值的部分。 所以我们可以考虑利用substr将所要移动的字符复制出来，放到一个临时的字符串中，然后用erase将这几个字母从原字符串中删除，再将临时字符串加到原来字符串的后面即可。 当然一定不要忘记考虑n若为0或者小于零怎么办。 代码string LeftRotateString(string str, int n) { if(n&lt;0) return NULL; if(n==0) return str; string temp=str.substr(0,n); str.erase(0,n); str+=temp; return str; } 题目6 不用加减乘除做加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 题目解析这个题目就是让我们思考加法的原理。 首先看十进制是如何做的： 5+7=12，三步走第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 代码public int Add(int num1,int num2) { while(num2!=0){ int temp = num1^num2; num2 = (num1&amp;num2)&lt;&lt;1; num1 = temp; } return num1; } 题目7 二叉树的下一个结点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 题目解析三种情况： 是该点若有右子树，则继续往右子树中序遍历； 是该点无右子树，且是父节点的左孩子，则下一节点就是其父节点； 是该点无右子树，且是父节点的右孩子，则寻找其父节点的父节点的父节点的……，直到当前节点是寻找到的那个点的左孩子为止。 所以总体来说是四种情况（除以上三种，还有二叉树为空的情况） 代码TreeLinkNode* GetNext(TreeLinkNode* pNode) { //空二叉树 if (pNode == NULL) return NULL; //第一种情况 if(pNode-&gt;right!=NULL) { pNode=pNode-&gt;right; while(pNode-&gt;left!=NULL) pNode=pNode-&gt;left; return pNode; } //第二三种情况本质上是可以合并的，就是寻找当前节点是寻找到的那个点的左孩子 while(pNode-&gt;next!=NULL) { TreeLinkNode *paren = pNode-&gt;next; if(paren-&gt;left==pNode) return paren; pNode=pNode-&gt;next; } //最后一个节点的情况 return NULL; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《剑指Offer》题目解析（10）","slug":"e3-80-8a-e5-89-9190-ef-bc-8810-ef-bc-89","date":"2019-03-08T02:49:49.000Z","updated":"2019-03-20T14:41:23.324Z","comments":false,"path":"2019/03/08/e3-80-8a-e5-89-9190-ef-bc-8810-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/08/e3-80-8a-e5-89-9190-ef-bc-8810-ef-bc-89/","excerpt":"","text":"题目1 二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 题目解析如果一棵树只有一个结点，那么深度为1.如果根节点只有左子树而没有右子树，那么深度就是左子树深度+1；同理，对于右子树也是如此。如果既有左子树，也有右子树，那么该树的深度就是左右子树深度的最大值+1。所以可以利用递归的方式实现该题目。 代码int TreeDepth(TreeNode* pRoot) { int Hl, Hr, MaxH; if(pRoot) { Hl=TreeDepth(pRoot-&gt;left); Hr=TreeDepth(pRoot-&gt;right); MaxH=(Hl&gt;Hr)?Hl:Hr; return MaxH + 1; } else return 0; } 题目2 数组中只出现一次的数字题目描述一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 题目解析这一题我们来对这个数组进行分析。我的想法是首先对其排序，这样这部分复杂度是O(nlogn)，然后我们再来考虑排好序的数组中，这两个特殊的数字会有什么特点呢？ 假如有一个单独的数字在开头，那么它一定与第二个数字不相等。例如（1/2/2/3/3/4） 假如有一个单独的数字在末尾，那么它一定与倒数第二个数字不相等。例如(1/2/2/3/3/4) 假如有一个数字在中间（从第2位到最后一位），那么它一定与左边和右边的两个数字不相等。例如(1/2/3/3/4/4)或者(1/2/2/3/4/4)。 剩余一个数字肯定也符合上面3种情况中两种情况之一（第一个数字占据了之外的那种情况）。 所以这样，我们就可以把代码写出来了。 代码void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) { sort(data.begin(),data.end()); int len=data.size(); vector&lt;int&gt; temp; if(data[0]!=data[1])//第一种情况 temp.push_back(data[0]); for(int i=1;i&lt;len-1;++i)//第二种情况 if(data[i]!=data[i-1] &amp;&amp; data[i]!=data[i+1]) temp.push_back(data[i]); if(data[len-1]!=data[len-2])//第三种情况 temp.push_back(data[len-1]); *num1=temp[0]; *num2=temp[1]; } 题目3 数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 题目解析借鉴前面数组中只出现一次的数字的思想，同样使用数组，利用hash的思想来做。 代码bool duplicate(int numbers[], int length, int* duplication) { if(numbers==NULL||length==0) return 0; int isused[255]={0}; for(int i=0;i&lt;length;i++) { isused[numbers[i]]++; } int count=0; for(int i=0;i&lt;length;i++) { if(isused[numbers[i]]&gt;1) { duplication[count++]=numbers[i]; return true; } } return false; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《剑指Offer》题目解析（9）","slug":"e3-80-8a-e5-89-91-e6-8c-e-90-ef-bc-889-ef-bc-89","date":"2019-03-07T03:56:38.000Z","updated":"2019-03-20T14:41:26.782Z","comments":false,"path":"2019/03/07/e3-80-8a-e5-89-91-e6-8c-e-90-ef-bc-889-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/07/e3-80-8a-e5-89-91-e6-8c-e-90-ef-bc-889-ef-bc-89/","excerpt":"","text":"题目6 第一次只出现一次的字符题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。 题目解析只要这种问题，就可以想到HashTable，但是由于这个问题很简单，而且字符串全部由字母组成，那么每个字母的ASCII码肯定不一样，我们就可以用一个长度为52的数组来记录他们出现的次数，对于字母每出现一次，就对它加1。 当然我们这里为了通用性，可以使用对任意字符进行判断，那么我们就可以考虑实现一个简单的哈希表。字符是一个长度为8的数据类型，所以有256种可能，于是可以创建一个长度为256的数组，每个字符根据其ASCII码值作为数组的下表对应数组的一个数字，而数组中存储的是每个字符出现的次数。 第一次扫描时，在河西表中更新一个字符出现的次数的时间是O(1)。如果字符串长度为n，那么第一次扫描的时间复杂度是O(n)。第二次扫描时，同样在O(1)时间内能独处一个字符出现的次数，所以时间复杂度仍然是O(n)。这样算起来，总的时间复杂度是O(n)。同时，我们需要一个包含256个字符的辅助数组，它的代销为1kb。由于这个数组的大小是一个常数，因此可以认为空间复杂度为O(1)。 代码int FirstNotRepeatingChar(string str) { int asc[256]={0}; int len=str.size(); if(len==0) return -1; for(int i=0;i&lt;len;i++) asc[str[i]]++; for(int i=0;i&lt;len;i++) { if(asc[str[i]]==1) return i; } return -1; } 题目7 丑数题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 题目解析代码1中所述是最简单的判断方法，很直观，但是效率不够高。 代码1bool isUgly(int number) { while(number%2==0) number/=2; while(number%3==0) number/=3; while(number%/5==0) number/=5; return (number==1)?true:false; } int GetUglyNumber(int index) { if(index&lt;=0) return 0; int number=0; int uglyFound=0; while(uglyFound&lt;index) { ++number; if(isUgly(number)) { uglyFound++; } } return number; } 题目8 数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。 题目解析最简单的方法就是直接for循环，这个复杂度是O(n)。 代码int GetNumberOfK(vector&lt;int&gt; data ,int k) { int len = data.size(); int count=0; for(int i=0;i&lt;len;i++) { if(data[i]==k) ++count; } return count; } 题目9 两个链表的第一个公共节点题目描述输入两个链表，找出它们的第一个公共结点。 代码ListNode* FindFirstCommonNode( ListNode *pHead1, ListNode *pHead2) { int len1 = findListLenth(pHead1); int len2 = findListLenth(pHead2); //如果两个长度不相等，就把长的那个链表上的指针从开头往后移动|len1-len2|个位置，这样就相当于两个链表同一起跑线开始。 if(len1 &gt; len2){ pHead1 = walkStep(pHead1,len1 - len2); }else{ pHead2 = walkStep(pHead2,len2 - len1); } //由于这个时候两个链表从指针所在位置往后长度肯定一致，所以这里指定pHead1和pHead2判断是否到尾部都可以 while(pHead1 != NULL){ //如果两个结点相等，自然就是第一个公共节点了，否则往后继续找 if(pHead1 == pHead2) return pHead1; pHead1 = pHead1-&gt;next; pHead2 = pHead2-&gt;next; } return NULL; } int findListLenth(ListNode *pHead1){ if(pHead1 == NULL) return 0; int sum = 1; while(pHead1 = pHead1-&gt;next) sum++; return sum; } ListNode* walkStep(ListNode *pHead1, int step){ while(step--){ pHead1 = pHead1-&gt;next; } return pHead1; } 题目10 数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 题目解析我们以数组{7,5,6,4}为例来分析统计逆序对的过程。每次扫描到一个数字的时候，我们不拿ta和后面的每一个数字作比较，否则时间复杂度就是O(n^2)，因此我们可以考虑先比较两个相邻的数字。 (a) 把长度为4的数组分解成两个长度为2的子数组； (b) 把长度为2的数组分解成两个成都为1的子数组； (c) 把长度为1的子数组 合并、排序并统计逆序对 ； (d) 把长度为2的子数组合并、排序，并统计逆序对； 在上图（a）和（b）中，我们先把数组分解成两个长度为2的子数组，再把这两个子数组分别拆成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 排序 如上图（c）所示， 以免在以后的统计过程中再重复统计。 接下来我们统计两个长度为2的子数组子数组之间的逆序对。合并子数组并统计逆序对的过程如下图如下图所示。 我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数，如下图（a）和（c）所示。如果第一个数组的数字小于或等于第二个数组中的数字，则不构成逆序对，如图b所示。每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保 辅助数组（记为copy） 中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。 过程：先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。 代码int InversePairs(int* data, int length) { if(data==nullptr||length&lt;0) return 0; int* copy=new int[length]; for(int i=0;i&lt;length;++i) copy[i]=data[i]; int count=InversePairsCore(data,copy,0,length-1); delete[] copy; return count; } int InversePairsCore(int*data,int*copy,int start,int end) { if(start==end) { copy[start]=data[start]; return 0; } int length=(end-start)/2; int left=InversePairsCore(copy,data,start,start+length); int right=InversePairsCore(copy,data,start+length+1,end); //i初始化为前半段最后一个数字的下标 int i=start+length; //j初始化为后半段最后一个数字的下标 int j=end; int indexCopy=end; int count=0; while(i&gt;=start&amp;&amp;j&gt;=start+length+1) { if(data[i]&gt;data[j]) { copy[indexCopy--]=data[i--]; count+=j-start-length; } else { copy[indexCopy--]=data[j--]; } } for(;i&gt;=start;--i) copy[indexCopy--]=data[i]; for(;j&gt;=start+length+1;--j) copy[indexCopy--]=data[j]; return left+right+count; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《剑指Offer》题目解析（8）","slug":"e3-80-8a-e5-89-9a3-e6-9e-90-ef-bc-888-ef-bc-89","date":"2019-03-07T03:52:12.000Z","updated":"2019-03-20T14:41:29.916Z","comments":false,"path":"2019/03/07/e3-80-8a-e5-89-9a3-e6-9e-90-ef-bc-888-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/07/e3-80-8a-e5-89-9a3-e6-9e-90-ef-bc-888-ef-bc-89/","excerpt":"","text":"题目1 数组中出现次数超过一半的数字题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 题目解析最简单的想法就是我们这个数组进行排序，由于数字超过了一半，那么中间的数字（中位数）肯定是我们所需要找的数字。代码实现如代码1所示，但是排序使用快速排序，时间复杂度为O(nlogn)，并没有达到最好的速度。因此参考《剑指offer》一书，我们还可以有两种时间复杂度为O(n)的算法。 基于Partition函数的方法 这种算法受快速排序算法启发。在快速排序中，我们现在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的数字都排在它的左边，大的都在有边。如果这个选中的数字的下表刚好是n/2，那么这个数字就是数组的中位数；如果它的下表大于n/2，那么中位数应该位于它左边，我们可以直接在它左边部分的数组中查找；如果它的下表小于n/2，那么中位数应该位于它的有边，我们可以在它右边部分的数组查找。 此外，我们还要考虑一些无效输入。如果函数的输入参数是一个指针（数组在参数传递的时候退化为指针），就要考虑这个指针可能为nullptr。CheckInvalidArray()函数可以判断输入的数组是不是无效的。 如果输入的数组中出现频率最高的数字没有超过一半怎么办？定义一个CheckMoreThanHalf()函数来进行处理。 根据数组特点找出时间复杂度为O(n)的算法 数组中有一个数字出现次数超过长度一半，也就是说它出现的次数比其他所有数字出现的次数的和还要多。因此我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字；另一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1.如果次数为0，那么我们需要保存下一个数字，并把次数设为1.由于我们要找的数字出现次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设置为1时对应的数字。见代码3。 代码1int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) { int len = numbers.size(); int count=0; if(len==0) return 0; if(len==1) return numbers[0]; sort(numbers.begin(), numbers.end()); int mid = numbers[len/2]; for(int i=0;i&lt;len;i++) { if(numbers[i]==mid) ++count; } return (count&gt;(len/2))?mid:0; } 代码2bool g_bInputInvaild = false; bool CheckInvalidArray(int* numbers, int length) { g_bInputInvalid = false; if (numbers == nullptr &amp;&amp; length &lt;= 0) g_bInputInvalid = true; return g_bInputInvalid; } bool CheckMoreThanHalf(int* numbers, int length, int number) { int times = 0; for (int i = 0; i &lt; length; ++i) { if (numbers[i] == number) times++; } bool isMoreThanHalf = true; if (times * 2 &lt;= length) { g_bInputInvalid = true; isMoreThanHalf = false; } return isMoreThanHalf; } int Partition(int data[],int length,int start,int end) { if(data==NULL || length&lt;=0||start&lt;0 || end&gt;=length) { cout&lt;&lt;&quot;error1!&quot;&lt;&lt;endl; exit(0); } int index=RandomInRange(start,end); swap_element(&amp;data[index],&amp;data[end]); int small=start-1; for(index=start;index&lt;end;index++) { if(data[index]&lt;data[end]) { ++small; if(small != index) { swap_element(&amp;data[index],&amp;data[small]); } } } ++small; swap_element(&amp;data[small],&amp;data[end]); return small; } int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) { if(CheckInvalidArray(numbers,length) return 0; int middle=length&gt;&gt;1; int start=0; int end=length-1; int index=Partition(numbers,length,start,end); while(index!=middle) { if(index&gt;middle) { end=index-1; index=Partition(numbers,length,start,end); } else{ start=index+1; index=Partition(numbers,length,start,end); } } int result=numbers[middle]; if(!CheckMoreThanHalf(numbers,length,result)) result=0; return result; } 代码3int MoreThanHalfNum_Solution2(int* numbers, int length) { if (CheckInvalidArray(numbers, length)) return 0; int result = numbers[0]; int times = 1; for (int i = 1; i &lt; length; ++i) { if (times == 0) { result = numbers[i]; times = 1; } else if (numbers[i] == result) times++; else times--; } if (!CheckMoreThanHalf(numbers, length, result)) result = 0; return result; } 题目2 最小的k个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 题目解析最简单的方法莫过于对这个数组进行排序，然后输出前k个数，但是这样复杂度是O(nlogn)，当数字很大的时候，还是复杂度高了些。 但是我们可以考虑借鉴题目1中的方法，也就是借鉴快速排序进行处理，复杂度有O(n)，当然这种方法只有当我们可以修改输入的数组的时候才可以用。如果基于数组的第k个数字来调整，那么比第k个数字小的所有数字位于数组的左边，比第k个数字大的数字都位于数字有边。这样调整以后，位于数组中左边的k个数字就是最小的k个数字（这k个数字不一定有序）。代码如代码1所示。 代码void GetLeastNumbers(int* input, int n, int* output, int k) { if(input==nullptr||output==nullptr||k&gt;n||n&lt;=0||k&lt;=0) return; int start=0; int end=n-1; int index=Partition(intput,n,start,end); while(index!=k-1) { if(index&gt;k-1) { end=index-1; index=Partition(input,n,start,end); } else { start=index+1; index=Partition(intput,n,start,end); } } for(int i=0;i&lt;k;++i) output[i]=input[i]; } 题目3 连续子数组的最大和题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 题目解析使用在线规划，复杂度为O(n)。在线规划的思想就是定义一个当前和（ThisSum）和一个最大和（MaxSum）。就是从第一个数开始加，赋值给ThisSum，然后如果ThisSum比MaxSum大的话，那就把ThisSum给MaxSum，否则的话不给。如果ThisSum加着加着都小于0了，那么这几个数字的和就没必要保留，直接舍弃就好了。由于题目说了长度至少是1，所以无需判断长度为0的情况，但是脑子里应该要想着这件事。 代码int FindGreatestSumOfSubArray(vector&lt;int&gt; array) { int ThisSum =0; int MaxSum = array[0]; int N = array.size(); int i; for(i=0;i&lt;N;i++) { ThisSum += array[i]; if(ThisSum&gt;MaxSum) MaxSum=ThisSum; else if(ThisSum&lt;0) ThisSum=0; } return MaxSum; } 题目4 整数中出现1的次数题目描述求出1-13的整数中1出现的次数,并算出100-1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 题目解析可以直接判断，用数字%10的出来的余数看是不是等于1即可。复杂度为O(n)。 代码int NumberOf1Between1AndN_Solution(int n) { int count = 0; if(n==0) return count; for(int i=1;i&lt;=n;i++) { int tmp=i; while(tmp) { if(tmp%10==1) ++count; tmp /=10; } } return count; } 题目5 把数组排成最小的数字题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 题目解析我们应该考虑怎么去拼接数字。要注意，m和n在int型能表达范围之内，但是mn或者nm可就不一定了。所以我们可以把数字转换成字符串进行处理。 根据题目要求，若mn&lt;nm，则输出mn；若nm&lt;mn，则输出nm。然后我们可以通过证明得到以下结论（证明省略）： 若ab &gt; ba 则 a &gt; b，即排序为ba； 若ab &lt; ba 则 a &lt; b，即排序为ab； 若ab = ba 则 a = b，即排序为ab。 代码 static bool cmp(int a, int b) { //意思是若ab&lt;ba，则返回(a,b)；若ab&gt;ba，则返回(b,a)。 string A = to_string(a) + to_string(b); string B = to_string(b) + to_string(a); return A &lt; B; } string PrintMinNumber(vector&lt;int&gt; numbers) { int len =numbers.size(); if(len==0) return &quot;&quot;; string result; sort(numbers.begin(),numbers.end(),cmp); for(int i=0;i&lt;len;i++) result += to_string(numbers[i]); return result; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"腾讯C++后台一面面经（基本凉凉~）","slug":"e8-85-be-e8-aeac-e5-87-89-e5-87-89-ef-bc-89","date":"2019-03-05T14:26:07.000Z","updated":"2019-03-20T14:38:26.212Z","comments":false,"path":"2019/03/05/e8-85-be-e8-aeac-e5-87-89-e5-87-89-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/05/e8-85-be-e8-aeac-e5-87-89-e5-87-89-ef-bc-89/","excerpt":"","text":"今天在健身的时候，正跑着步，气喘吁吁的，突然接到了来自腾讯的电话，就知道是面试。腾讯已经在实习生招聘捞了我两个星期了，这次终于捞起了我。 不过终于体会到跑步大脑缺氧的感觉了，真的是问题都很熟悉，但是都没答上来，所以肯定就挂了。 因为我不是计算机专业的，所以问我都学了什么课程，哪些课程是自学的。 STL中Map的查找复杂度。 答：红黑树是AVL树（二叉平衡树）： - 插入处理在整体上耗费O(log n) 时间 - 删除处理在整体上耗费O(log n) 时间。 - 查找可以像普通二叉查找树一样的进行，所以耗费O(log n)时间。 3. Map的底层数据结构（因为我回答的并不好，所以引申问了我这个问题让我思考复杂度）。 答：map的特性是，所有的元素都会根据元素的键值自动排序，map所有元素都是key-value对。其底层机制是红黑树。拓展一下：set、map的底层都是红黑树。 有没有用过SortedMap？（貌似这个是Java里面的？） TCP/IP三次握手过程，为什么不是两次呢？ 答：TCP三次握手过程如下： （1）客户端向服务器端发出SYN，指明自己想要连接的端口和自己ISN； （2）服务器端向客户端发送自己的SYN作为呼应，并包括了自己的ISN，同时还将客户端的ISN+1作为ACK返回给客户端。 （3）为了确认服务器的SYN，客户端将服务器的ISN+1作为ACK返回给服务器。 为什么不是两次的原因在于：客户端向服务器端发送的第一个报文有可能因为网络原因而较长时间才能到达服务器端，这个时候服务器端会回复一个SYN，但是由于等待时间过长，客户端将此报文认为已经失效，但是这个时候如果没有第三次握手，服务器端会认为双方连接已经建立，然后服务器就会一直等待客户端发送信息，这样就浪费资源。 类里面成员变量能不能用memset()来进行设置？会有什么问题呢？ 答：不能。这里说不可以，不是说真的不可以，而是说真的别这样！有些情况下是可以用的，因为类只是一个说明，对象也是这个类的一个具体化了的内存块，当你memset一个对象时，它把这块对象内存初始化了，在不影响内部结构的情况下是不会有问题的，这就是为什么有时候使用memset一个对象时不会出错的原因。如果类包含虚拟函数，则不能用 memset 来初始化类对象。 你了解多线程和多进程吗？ 你知道fork()吗？（我说我知道fork()跟多线程有关系，但是操作系统我还没有再看一遍所以记不太清了，就没有继续问。） 介绍一下你的项目（项目一） 介绍下你在你的项目二中都做了什么？ （我的项目二是一个机器人来识别障碍物然后躲避障碍物），你是怎么实现机器人来躲避障碍物的？ 你有没有在Linux下进行网络编程？有没有服务器、客户端之类的编程项目？ 你平时编程是在linux下还是在windows下？ 差不多就想起来了这么多，基本跪了。就算给自己长点经验吧。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://tech.yushuai.xyz/tags/面经/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《剑指Offer》题目解析（7）","slug":"e3-80-8a-a7-a3-e6-9e-90-ef-bc-887-ef-bc-89","date":"2019-03-05T01:45:22.000Z","updated":"2019-03-20T14:41:34.246Z","comments":false,"path":"2019/03/05/e3-80-8a-a7-a3-e6-9e-90-ef-bc-887-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/05/e3-80-8a-a7-a3-e6-9e-90-ef-bc-887-ef-bc-89/","excerpt":"","text":"题目6 二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两 个数字都互不相同。 题目解析我们以后序遍历序列{5,7,6,9,11,10,8}和{7,4,6,5}为例来发现规律。在后序遍历里面，最后一个数字（8,5）一定是序列的根结点值。二叉搜索树左子树都小于根结点的值，右子树都大于根结点的值。 我们先看第一个序列。发现{5,7,6}都小于8，{9,11,10}都大于8，所以前者是左子树，后者是右子树，符合二叉搜索树的定义；再看左子树{5,7,6}，同理6是这个子树的根结点，然后5小于6，是子树的左子树，7&gt;6，是子树的右子树，符合二叉搜索树定义；再看右子树{9,11,10}，根结点是10，9&lt;10，符合左子树定义，11&gt;10，符合右子树定义，符合二叉搜索树定义。所以这是一个二叉搜索树。 再看{7,4,6,5}，5是根结点，由于第一个元素7&gt;5，所以可以肯定该树没有左子树，{7,4,6}都是右子树。然后看右子树，6是根结点，安装后序遍历来说，第一个数字应是根结点的左子树，那么{7,4}是右子树。我们再看4不仅小于右子树的根结点6，还小于整个树的根结点5，所以这个树不是二叉搜索树。 然后我们就可以根据递归来写。如果序列长度为0，那肯定不是，return false。 其它的情况我们就按照上面来，首先来寻找左子树，我们只需要一个for循环，判断到哪一位为止数字大于最后一个数字了，那么我们就默认这个数字开始的后面就是右子树了。找到左子树和右子树的之后，我们就可以分别对左子树和右子树进行递归判断了。 我们可以想一层一层递归，最后递归到一个只有根结点、左结点和右结点的小二叉树。在这个二叉树里面，我们继续判断那一个点开始是右子树，然后查找这个点后面有没有小于该树根结点的结点，如果有这样一个点，那肯定不是二叉搜索树的后序遍历，return false。当然啦，因为每一次我们要一层一层判断下去，如果这一层不符合就不用往下递归了，所以这个判断过程要放在递归前面。 代码bool VerifySquenceOfBST(vector&lt;int&gt; sequence) { if(sequence.size()==0) return false; return IsTreeBST(sequence,0,sequence.size()-1); } bool IsTreeBST(vector&lt;int&gt; sequence, int start, int end) { if(end &lt; start) return true; int i=start; for(;i&lt;end;i++) { if(sequence[i]&gt;sequence[end]) break; } for(int j=i;j&lt;end;j++) { if(sequence[j]&lt;sequence[end]) return false; } return IsTreeBST(sequence,start,i-1)&amp;&amp;IsTreeBST(sequence, i,end-1); } 题目7 二叉树中和为某一值的路径题目描述输入一颗二叉树的跟结点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 题目解析我们举例来考虑，加入我们输入的二叉树层序遍历的结果为{8,5,14,3,9}，整数为22。 我们要来计算，肯定要先遍历根结点，获取根结点的值，所以必须使用前序遍历。这样如下表所示。同时应注意，为了增强系统的鲁棒性，要判断二叉树为空的时候的情况。 步骤 操作 是否叶结点 路径 路径结点值的和 1 访问结点8 否 结点8 8 2 访问结点5 否 结点8，结点5 13 3 访问结点3 是 结点8，结点5，结点3 16 4 回到结点5 结点8，结点5 13 5 访问结点9 是 结点8，结点5，结点9 22 6 返回结点5 结点8，结点5 13 7 回到结点8 结点8 8 8 访问结点14 是 结点8，结点14 22 所以我们要做的就是新建一个 vector&lt;vector&lt;int&gt; &gt; buffer 用来存放结果。然后新建一个 vector&lt;int&gt; tmp; 用来存放中间值。 然后将根结点的值送入tmp，然后对左子树和右子树分别判断，即对左子树和右子树分别进行递归。 在到达一个结点的时候，我们要做两个判断： 加上当前结点的值，是否等于预设值了呢？（即(expectNumber-root-&gt;val)==0）； 该结点是否是叶结点了呢？（root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL） 若符合要求了，则代表找到了一条路径，直接push_back到buffer里面即可。 因为要先计算结点的值，所以就要把上面的步骤放在递归之前。 在完成一层层递归之后，需要向上返回，这个时候利用递归的特性即可，此时一定要记得删除tmp里面最上面的值。 代码vector&lt;vector&lt;int&gt; &gt; buffer; vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) { if(root==NULL)//鲁棒性 return buffer; tmp.push_back(root-&gt;val); if((expectNumber-root-&gt;val)==0 &amp;&amp; root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) { buffer.push_back(tmp); } FindPath(root-&gt;left,expectNumber-root-&gt;val); FindPath(root-&gt;right,expectNumber-root-&gt;val); if(tmp.size()!=0) tmp.pop_back(); return buffer; } 题目8 复杂链表的复制题目描述输入一个复杂链表（每个结点中有结点值，以及两个指针，一个指向下一个结点，另一个特殊指针指向任意一个结点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的结点引用，否则判题程序会直接返回空） 题目解析第一步，仍然是根据原始链表的每个结点N创建对应的N’。这一次，我们把N’链接在N的后面。 void nodeClone(RandomListNode *head) { RandomListNode *pNode = head; while (pNode != NULL) { RandomListNode *pClone = new RandomListNode(pNode-&gt;label); pClone-&gt;next = pNode-&gt;next; pNode-&gt;next = pClone; pNode = pClone-&gt;next; } } 第二步，设置复制出来的结点的random。假设原来上的N的random指向结点S，那么对应复制出来的N’是N的next指向的结点，同样S’也是S的next指向的结点。 void connectRandom(RandomListNode *head) { RandomListNode *pNode = head; while (pNode != NULL) { RandomListNode *pClone = pNode-&gt;next; if (pNode-&gt;random) { pClone-&gt;random = pNode-&gt;random-&gt;next; } pNode = pClone-&gt;next; } } 第三步把这个厂链拆分成两个链表，把技术位置的结点用next链接起来的就是原始链表，把偶数位置的结点用next链接起来的就是复制出来的链表。 RandomListNode *reconnect(RandomListNode *head) { RandomListNode *pNode = head; RandomListNode *result = head-&gt;next; while (pNode != NULL) { RandomListNode *pClone = pNode-&gt;next; pNode-&gt;next = pClone-&gt;next; pNode = pNode-&gt;next; if (pNode != NULL) pClone-&gt;next = pNode-&gt;next; } return result; } 题目9 二叉搜索树与双向链表题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 题目解析 由于要求转换之后的链表是排好序的，所以我们可以用一个中序遍历，这样就可以从小到大遍历二叉树的每个结点。当遍历到根节点的时候，我们把树看成3部分：值为10的结点；根结点为6的左子树；根结点为14的右子树。根据排序链表的定义，值为10的结点将和它左子树的最大一个结点链接起来，同时还将和右子树最小结点连接起来。 按照中序遍历顺序，我们遍历到根结点的时候，左子树已经变成一个排序的链表了，并且处在链表中的最后一个结点就是当前最大的结点，我们把值为8的结点和根结点链接起来，此时链表中最后一个结点就是10。然后我们去遍历转换右子树，然后把根节点和右子树最小结点链接起来。以此递归下去。 代码TreeNode* Convert(TreeNode* pRootOfTree) { if (pRootOfTree == NULL)return NULL; TreeNode *pointer = NULL; convert2List(pRootOfTree, pointer); while (pointer-&gt;left!=NULL) { pointer = pointer-&gt;left; } return pointer; } void convert2List(TreeNode* pRoot,TreeNode *&amp;pointer) { if (pRoot == NULL) { return; } { if (pRoot-&gt;left != NULL) { convert2List(pRoot-&gt;left,pointer); } pRoot-&gt;left = pointer; if (pointer != NULL) { pointer-&gt;right = pRoot; } pointer = pRoot; if (pRoot-&gt;right!=NULL) { convert2List(pRoot-&gt;right, pointer); } } } 题目10 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 题目解析我们求整个字符串的排列，可以分成两步。第一步，把字符串分为第一个字符和后面若干个字符，那么第一个位置上有哪些可能呢？就把第一个位置上原来的字符和后面的字符进行交换，加上原来的情况。第二步，就是固定第一个字符，求剩下的，对于剩下的字符来说，又可以分解为第一个字符和后面字符串的关系，然后把这个子字符串按照第一步来求解即可。这样很明显是一个递归。 当然啦，字符串为空的情况也要考虑到。 代码vector&lt;string&gt; result; vector&lt;string&gt; Permutation(string str) { if(str.length()==0){ return result; } Permutation1(str,0); sort(result.begin(),result.end()); return result; } void Permutation1(string str,int begin){ if(begin == str.length()){ result.push_back(str); return ; } for(int i = begin; str[i]!=&apos;\\0&apos;;i++){ if(i!=begin&amp;&amp;str[begin]==str[i]) continue; swap(str[begin],str[i]); Permutation1(str,begin+1); swap(str[begin],str[i]); } }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《剑指Offer》题目解析（6）","slug":"e3-80-8a-e5-89-91-e6e-90-ef-bc-886-ef-bc-89","date":"2019-03-05T01:44:42.000Z","updated":"2019-03-20T14:41:38.260Z","comments":false,"path":"2019/03/05/e3-80-8a-e5-89-91-e6e-90-ef-bc-886-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/05/e3-80-8a-e5-89-91-e6e-90-ef-bc-886-ef-bc-89/","excerpt":"","text":"题目1 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 题目解析一定要考虑到两种特殊情况： 二叉树为空 二叉树的左子树为空且二叉树的右子树为空 设计代码的时候一定要考虑代码的鲁棒性。所以需要设计到两个if语句，如果不在这两种特殊情况里面，再去新建一个TreeNode，然后交换进行做镜像。 代码void Mirror(TreeNode *pRoot) { if(pRoot == NULL)//特殊情况1 return; //特殊情况2 if((pRoot-&gt;left == NULL)&amp;&amp;(pRoot-&gt;right == NULL)) return ; TreeNode *tmp; tmp=pRoot-&gt;left; pRoot-&gt;left=pRoot-&gt;right; pRoot-&gt;right=tmp; if(pRoot-&gt;left) Mirror(pRoot-&gt;left); if(pRoot-&gt;right) Mirror(pRoot-&gt;right); } 题目2 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 题目解析用左上和右下的坐标定位出一次要旋转打印的数据，一次旋转打印结束后，往对角分别前进和后退一个单位。 代码vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) { vector&lt;int&gt; result; int row=matrix.size(); int col=matrix[0].size(); if(row==0||col==0) return result; int left = 0,right = col-1,top=0,end =row-1; while(left&lt;=right &amp;&amp; top&lt;= end) { //第一行从左往右 for(int i=left;i&lt;=right;i++) result.push_back(matrix[top][i]); //最右侧从上往下 if(top&lt;end) { for(int i=top+1;i&lt;=end;i++) result.push_back(matrix[i][right]); } //最下侧从右往左 if(top&lt;end &amp;&amp; left&lt;right) { for(int i=right-1;i&gt;=left;i--) result.push_back(matrix[end][i]); } //最左侧从下往上 if(top+1&lt;end &amp;&amp; left&lt;right) { for(int i=end-1;i&gt;=top+1;i--) result.push_back(matrix[i][left]); } left++; right--; top++; end--; } return result; } 题目3 包含min函数的栈题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 题目解析我们需要一个辅助堆栈来得到我们所需要数据，因为只有一个堆栈的话，我们没办法比较得出最小值。加入我们的数据压入顺序是3,4,2,1。那么可以这样： 步骤 操作 数据栈 辅助栈 最小值 1 压入3 3 3 3 2 压入4 3,4 3,3 3 3 压入2 3,4,2 3,3,2 2 4 压入1 3,4,2,1 3,3,2,1 1 5 弹出 3,4,2 3,3,2 2 6 弹出 3,4 3,3 3 7 压入0 3,4,0 3,3,0 0 代码stack&lt;int&gt; stack1,stack2; void push(int value) { stack1.push(value); if(stack2.empty()||value&lt;stack2.top()) stack2.push(value); else { stack2.push(stack2.top()); } } void pop() { stack2.pop(); stack1.pop(); } int top() { return stack1.top(); } int min() { return stack2.top(); } 题目4 栈的压入、弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 题目解析这个程序的代码思路跟我们手工做题的思路一样，所以也许不是复杂度最低的算法，它的思路是这样的： 1. 新建一个vector数组temp； 2. 然后将pushV的最头上的元素压入temp； 3. 判断该元素是否和popV中最上面的元素（即要被弹出的元素）是否相等，若不相等正则去执行第2步，直到找到相等的，然后temp里面的元素弹出； 4. 然后开始第2个元素的比较，步骤重复2和3，直到所有的完成。 代码bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) { bool result =false; stack&lt;int&gt;temp; int Index = 0; for(int i=0;i&lt;pushV.size();i++) { temp.push(pushV[i]); while(!temp.empty() &amp;&amp; temp.top()==popV[Index]) { temp.pop(); ++Index; } } result=temp.empty(); return result; } 题目5 从上往下打印二叉树题目描述从上往下打印出二叉树的每个结点，同层结点从左至右打印。 题目解析这就是层序遍历。用层序遍历的法子，借助队列来实现。其实广度优先搜索也借鉴了层序遍历的思想。 代码vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) { vector&lt;int&gt; result; queue&lt;TreeNode*&gt; q; q.push(root);//把根结点push进去 if(root == NULL)//稳健性 return result; while(!q.empty()) { root=q.front();//获取到队列q的头元素 q.pop(); result.push_back(root-&gt;val);//把头元素的值送入result if(root-&gt;left)//向左遍历 q.push(root-&gt;left); if(root-&gt;right)//向右遍历 q.push(root-&gt;right); } return result; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"常用排序算法复杂度和稳定性情况总结","slug":"changyongpaixuzongjie","date":"2019-03-04T06:19:05.000Z","updated":"2019-03-21T14:51:42.027Z","comments":false,"path":"2019/03/04/changyongpaixuzongjie/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/04/changyongpaixuzongjie/","excerpt":"","text":"排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 稳定性 冒泡排序 O(n2) O(n) O(n2) O(1) 稳定 选择排序 O(n2) O(n2) O(n2) O(1) 不稳定 插入排序 O(n2) O(n) O(n2) O(1) 稳定 希尔排序 O(nlogn)~O(n2) O(n2) O(n2) O(1) 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 快速排序 O(nlogn) O(nlogn) O(n2) O(logn)~O(n) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 计数排序 O(n+k) O(n+k) O(n+k) O(k) 稳定 桶排序 O(n+k) O(n+k) O(n2) O(n+k) 稳定 基数排序 O(n×k) O(n×k) O(n×k) O(n+k) 稳定 堆选归集与初始序列无关","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"《剑指Offer》题目解析（5）","slug":"e3-80-8a-e5-87-a3-e6-9e-90-ef-bc-885-ef-bc-89","date":"2019-03-04T01:16:40.000Z","updated":"2019-03-20T14:41:41.534Z","comments":false,"path":"2019/03/04/e3-80-8a-e5-87-a3-e6-9e-90-ef-bc-885-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/04/e3-80-8a-e5-87-a3-e6-9e-90-ef-bc-885-ef-bc-89/","excerpt":"","text":"题目7 链表倒数第k个结点题目描述输入一个链表，输出该链表中倒数第k个结点。 题目解析我们很容易可以想到，由于这是一个单向链表，所以我们可以第一遍先遍历这个链表，看有多少个结点（假设为n），然后计算出pos=n-k+1，然后我们只需要再遍历一遍这个链表，输出第n-k+1个结点的值即可。 但是要注意鲁棒性。我们要考虑，如果这个链表为空呢？如果这个链表的结点数不到k个呢？那就需要对代码进行补充和完善。 代码ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { if (pListHead == NULL) return NULL; ListNode* list1 = pListHead; int count=1; int pos = 0; while (list1) { ++count; list1 = list1-&gt;next; } if (count&lt;=k) return list1; pos = count - k + 1; int n = 1; ListNode* list2 = pListHead; while (list2 &amp;&amp; n &lt; pos - 1) { list2 = list2-&gt;next; ++n; } return list2; } 题目8 翻转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 题目解析首先我们应该考虑两个问题（鲁棒性）： 1. 链表为空呢？返回空。 2. 链表就只有一个结点呢？返回这个结点。 其它一般情况就是多个结点了。为了正确翻转一个链表，需要调整链表中指针的方向。我们假设有下面三个结点：a-&gt;b-&gt;c，假设我们要翻转b的next指向a，那么指向a之后，b和c之间的联系就断了，因此我们需要把结点c的地址保存下来。也就是说，我们在调整结点b的next指针的时候，除了需要知道结点b本身，还需要知道结点b的前一个结点a，因为我们要把结点b的next指针指向a。同时，我们还需要实现保存b的一个结点c，以防止链表断开。 我们新建一个next指针，让它来保存b指针的next所指向的地址，然后把a的next指向NULL，然后令node=a，然后把lnode=b；这个时候，进入下一个循环，next指向了c，然后把b的next指向了a，然后令node=b，然后将lnode往下指向c；下一个循环，next=空了，然后把c的next指向了b，然后node=c，然后lnode=空。这个时候判断了lnode为空，结束循环，形成了a&lt;-b&lt;-c。 代码ListNode* ReverseList(ListNode* pHead) { if (pHead == NULL) return NULL; ListNode *node = NULL; ListNode *lnode = pHead; while(lnode!= NULL){ ListNode *next = lnode-&gt;next; lnode-&gt;next = node; node = lnode; lnode = next; } return node; } 题目9 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 题目解析一定要考虑鲁棒性： 1. 若第一个链表为空，则直接返回第2个； 2. 若第二个链表为空，则直接返回第1个； 3. 其实若两个链表都为空的话，在第一个if语句判断的时候返回了第二个链表，而第2个链表为空，所以正好也是返回了NULL。 4. 这个时候我们新建一个result的链表存储结果，并为空，对于头结点来说，判断第一个链表和第二个链表的值，若第一个小于第二个，则把第一个链表的头结点给result，然后继续往下进行递归调用Merge函数（Merge(pHead1-&gt;next,pHead2)）；否则，把第二个链表的头结点给result，继续往下进行递归调用Merge函数（Merge(pHead1,pHead2-&gt;next）。 代码ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { if(pHead1==NULL) return pHead2; if(pHead2==NULL) return pHead1; ListNode* result=NULL; if(pHead1-&gt;val&lt;pHead2-&gt;val) { result=pHead1; result-&gt;next=Merge(pHead1-&gt;next,pHead2); } else { result=pHead2; result-&gt;next=Merge(pHead1,pHead2-&gt;next); } return result; } 题目10 树的子结构题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 题目解析第一步在树A中查找与根节点的值一样的结点，这实际上就是树的遍历。如HasSubtree()函数中所述。如果根值相同，则去继续比较，否则有A的左子树和B比较，如果还不行就用A的右子树和B比较。 我们一定要注意边界条件的检查，即检查空指针。当树A或B为空的时候，定义相应的输出。本代码里面就是if不符合之后直接返回result。 第二步是判断树A中以R为根节点的子树是不是和B具有相同的结构，这里也是用递归来实现的，如果A为空了B还不是空的，那么B肯定不是A的子树；如果B空了A还没空，那么肯定也不是；如果两个结点值不一样，那就返回false；如果值相同，则继续对左子树和右子树进行比较。 一个可以提现专业的细节：double和float表示小数的时候都有误差，所以判断两个小数的时候不能直接判断相等，而是要判断他们的误差是不是在一个很小的范围内，如果很小，就认为相等。所以可以定义下面的函数： bool Equal(double a,double b) { if((num1-num2&gt;-0.0000001)&amp;&amp;(num1-num2&lt;0.0000001) return true; else return false; } 代码bool HasSub(TreeNode* root1, TreeNode* root2) { if(root1 ==NULL &amp;&amp; root2 !=NULL) return false; if(root2==NULL) return true; if(root1-&gt;val != root2-&gt;val) return false; return HasSub(root1-&gt;left,root2-&gt;left)&amp;&amp;HasSub(root1-&gt;right,root2-&gt;right); } bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { bool result = false; if(pRoot1!=NULL &amp;&amp; pRoot2!=NULL) { if(pRoot1-&gt;val == pRoot2-&gt;val) result=HasSub(pRoot1,pRoot2); if(!result) result=HasSubtree(pRoot1-&gt;left,pRoot2); if(!result) result=HasSubtree(pRoot1-&gt;right,pRoot2); } return result; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《剑指Offer》题目解析（4）","slug":"e3-80-8a-e5a7-a3-e6-9e-90-ef-bc-884-ef-bc-89","date":"2019-03-04T01:16:07.000Z","updated":"2019-03-20T14:41:44.820Z","comments":false,"path":"2019/03/04/e3-80-8a-e5a7-a3-e6-9e-90-ef-bc-884-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/04/e3-80-8a-e5a7-a3-e6-9e-90-ef-bc-884-ef-bc-89/","excerpt":"","text":"题目1 斐波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 代码递归方法： int Fibonacci(int n) { if(n==0) return 0; if(n==1||n==2) return 1; return Fibonacci(n-1)+Fibonacci(n-2); } 非递归方法： int Fibonacci(int n) { int first = 0; int second = 1; int result = n; for(int i = 2; i&lt;=n; i++){ result = first + second; first = second; second = result; } return result; } 题目2 青蛙跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 题目解析对于这种问题我们可以这样分析。在第一次跳台阶的时候，它可以选择跳1个台阶，也可以选择跳两个台阶。对于它要跳n个台阶来说（设为f(n)），假如第一次跳了1个台阶，那么第二次跳就是f(n-1)的问题；假如第一次跳了2个台阶，那么第二次就是f(n-2)的问题。对于第二次跳也是如此，就是分别是f(n-2)和f(n-3)（对于第一次跳了1阶的情况下）、f(n-3)和f(n-4)（对于第一次跳了2阶的情况下），依次类推下去，成为一个递归。特别的，当n=1的时候，只有一种跳法（只跳一阶），当n=2的时候，有两种跳法（跳1阶跳两次，跳2阶跳一次）。实际上这就是一个斐波那契数列。 代码int jumpFloor(int number) { if(number==1) return 1; else if(number==2) return 2; else return jumpFloor(number-1)+jumpFloor(number-2); } 题目3 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 题目解析当一个青蛙跳上n级台阶有以下的情况： n 情况数 情况 1 1 (1) 2 2 (1,1),(2) 3 4 (1,1,1),(1,2),(2,1),(3) 4 8 (1,1,1,1),(1,2,1),(1,1,2),(2,1,1),(2,2),(1,3),(3,1),(4) …… …… …… n 2*f(n-1) (1) 通过尝试，可以发现规律，当n&gt;1的时候，f(n)=2*f(n-1)。 代码int jumpFloorII(int number) { if(number&lt;1) return -1; else if(number==1) return 1; else return 2*jumpFloorII(n-1); } 题目4 矩形覆盖题目描述我们可以用2 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 题目解析对于这种问题，我们还是需要进行分析。 n 情况数 情况（括号中1为竖着，2为横着） 1 1 (1) 2 2 (1,1),(2,2) 当n=3的时候，我们发现，若固定了第三块砖的放置方式，那么前两块砖有两种放置方式（f(2)）；若固定了第二块和第三块的放置方式，则前一块砖有一种放置方式（f(1)）。以此类推，可以得出f(n)=f(n-1)+f(n-2)，当n&gt;2的时候。 代码int rectCover(int number) { if(number&lt;=0) return 0; else if(number==1) return 1; else if(number==2) return 2; else return rectCover(number-1)+rectCover(number-2); } 题目5 二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 题目解析思路很简单，利用与的特性：1&amp;1=1，0&amp;1=0就可以进行判断。 代码int NumberOf1(int n) { int count=0; for(int i=0;i&lt;32;i++) //32位是由int决定 { if((n&gt;&gt;i)&amp;1) count++; } return count; } 题目6 调整数组，使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 题目解析其实这个可以借助于类似于冒泡法的思想，不过这样的复杂度有O(n2)，并且空间复杂度也较高。因此可以使用下面的方法。借鉴了插入排序。 代码void reOrderArray(vector&lt;int&gt; &amp;array) { for(int i = 0;i &lt; array.size();i++){ for(int j = array.size()-1; j&gt;i;j--){ if(array[j]%2==1&amp;&amp;array[j-1]%2==0) swap(array[j],array[j-1]); } } }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《剑指Offer》题目解析（3）","slug":"e3-80-8a-e5-89-91-e6-8c-8e-90-ef-bc-883-ef-bc-89","date":"2019-03-04T01:14:25.000Z","updated":"2019-03-20T14:41:48.712Z","comments":false,"path":"2019/03/04/e3-80-8a-e5-89-91-e6-8c-8e-90-ef-bc-883-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/04/e3-80-8a-e5-89-91-e6-8c-8e-90-ef-bc-883-ef-bc-89/","excerpt":"","text":"题目1：机器人的运动范围题目描述 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 题目解析 这个题可以看做是广度搜索优先（BFS）的一个拓展或者说是改编。如果说没有“不能进入行坐标和列坐标的数位之和大于****k****的格子”这个条件，那么它就是一个纯粹的BFS问题，设置上这个，就基本上就相当于只是多了一个条件。所以我们需要做的就是以下几个工作： 1.设置标志位。bool _flags=new bool[rows_cols]。 2.将移动一步单独设置为一个子函数，在这个函数里面，原始的判断条件只是： if(i&gt;=0 &amp;&amp; i&lt; rows &amp;&amp; j &gt;=0 &amp;&amp; j=0 &amp;&amp; i&lt; rows &amp;&amp; j &gt;=0 &amp;&amp; j&lt;cols &amp;&amp; (gssum(i) + gssum(j) &lt;= threshold) &amp;&amp; flags[icols+j]==false) *代码 int movingCount(int threshold, int rows, int cols) { bool *flags=new bool[rows*cols];//所有格子的标志位默认设置为false for(int i=0;i&lt;rows*cols;i++) flags[i]=false; int count = movingstep(threshold, rows, cols, 0, 0, flags);;//记录可访问格子数量 return count; } int movingstep(int threshold, int rows, int cols, int i, int j, bool *flags) { int count = 0; if(i&gt;=0 &amp;&amp; i&lt; rows &amp;&amp; j &gt;=0 &amp;&amp; j&lt;cols &amp;&amp; (gssum(i) + gssum(j) &lt;= threshold) &amp;&amp; flags[i*cols+j]==false) { flags[i*cols+j]=true; count = 1 + movingstep(threshold, rows, cols, i+1, j, flags)+movingstep(threshold, rows, cols, i-1, j, flags)+movingstep(threshold, rows, cols, i, j+1, flags)+movingstep(threshold, rows, cols, i, j-1, flags); } return count; } int gssum(int i) { int sum = 0; while(i) { sum += i % 10;; i /= 10; } return sum; } 题目2：把字符串转换成整数题目描述 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 题目解析 本题目其实是一个很简单的题目，只需要很细心判断以下几处问题即可： 1.不考虑最前面的空格； 2.若除去空格后的第一位为“+”或“-”，则分别将标志位做不同的设置，若为数字，直接将标志位设置为同“+”，若为其它则直接返回0； 3.后续几位直接判断是否为0~9之间的数字，由于是字符串格式，所以为ascii码，这样，我们在转换成int格式的时候，直接用该字符减去’0’即可。 代码 int StrToInt(string str) { int len=str.length(); if(len==0) return 0; int i = 0; int res = 0; int fla = 1; //滤掉前面的空格 while(str[i]==&apos; &apos;){ i++; } //进行符号判断 if(str[i]==&apos;+&apos;){ i++; }else if(str[i]==&apos;-&apos;){ i++; fla=-1; } while(str[i]!=&apos;\\0&apos;){ //对字符进行是否为数字的判断 if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;){ res=res*10+fla*(str[i]-&apos;0&apos;); i++; }else{ res=0; break; } } return res; } 题目3：表示数值的字符串题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 题目解析 表示数值的字符串遵循的规则； 1.在数值之前可能有一个“+”或“-”，接下来是0到9的数位表示数值的整数部分，如果数值是一个小数，那么小数点后面可能会有若干个0到9的数字。 2表示数值的小数部分，如果用科学计数法表示，接下来是一个‘e’或者‘E’，以及紧跟着一个整数（可以有正负号）表示指数。 代码 bool isNumeric(char* string) { if(string == NULL) return false; if(*string == &apos;+&apos; || *string ==&apos;-&apos;) string++; if(*string ==&apos;\\0&apos;) return false; int dot = 0;//小数点的个数 int num = 0;//数字的个数 int ex = 0;//e指数的个数 while(*string !=&apos;\\0&apos;) { if((*string &gt;= &apos;0&apos;) &amp;&amp; (*string &lt;=&apos;9&apos;)) { num++; string++; } //小数点开始 else if(*string ==&apos;.&apos;) { if(dot&gt; 0 || ex &gt; 0) return false; dot++; string++; } //指数e else if((*string ==&apos;e&apos;) ||(*string == &apos;E&apos;)) { if(num ==0 || ex &gt; 0) return false; string++; ex++; if(*string == &apos;+&apos; || *string ==&apos;-&apos;) string ++; if(*string==&apos;\\0&apos;) return false; } else return false; } return true; } 题目4：链表中环的入口节点题目描述 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 题目解析 其实我的思路是把每个访问过的结点做标记，然后不断往下走后，遇到的第一个标记过的点，就是还的入口结点，如果没有遇到，则就不存在环，返回null。但是这种方法比较复杂，而且很难找到标志每个结点的特点在哪里。 所以可以这样考虑。如图4.1所示。 图4.1 示意图 我们假设x为AB之间的距离，a为从b到c的距离（顺时针移动），c为环的长度。我们可以设置两个指针，一个快一个慢，然后快的是慢的速度的两倍。设快指针为f，慢指针为s，则当快指针和慢指针相遇的时候，s=x+m_c+a，f=x+n_c+a，m和n为某不同的常数，s=f。所以x=(n-2m)c-a=(n-2m-1)c+c-a。n-2m-1可为0。这里为了处理方便，省略前面这个类似于周期的东西，只留下c-a。c-a是什么？c-a就是图4.1中灰色的这条线。也就是说，AB之间的距离=灰色的线。这样，我们可以再重新将f这个指针（也可以是s）指向A，那么当f和s相遇的时候，所在的结点就是入口结点。 代码 ListNode* EntryNodeOfLoop(ListNode* pHead) { if((pHead==NULL)||(pHead-&gt;next==NULL)||(pHead-&gt;next-&gt;next==NULL)) return NULL; ListNode* fast = pHead-&gt;next-&gt;next; ListNode* slow = pHead-&gt;next; //先判断有没有环 while(fast!=slow) { if((fast-&gt;next !=NULL) &amp;&amp;(fast-&gt;next-&gt;next!=NULL)){ fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; } else{ return NULL; } } //如果能执行到这一步，说明有环，且此时fast==slow。 //然后把fast调整到头部，此时fast和slow第一次相遇的位置就是入口地址 fast=pHead; while(fast!=slow) { fast=fast-&gt;next; slow=slow-&gt;next; } return slow; } 题目5：把二叉树打印成多行题目描述 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 题目解析 如果不加上“打印成多行”，那么这就是一个层序遍历，利用队列实现即可。而加上这个要求之后，只需要增加两个参数设置，当参数达到阈值后，输出第一行。 代码 vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) { vector&lt;vector&lt;int&gt; &gt; vect;//最后输出的结果 if(pRoot==NULL) return vect;//若pRoot为空，直接返回空 //接下来总体上就是一个层序遍历的变体，所以可以使用层序遍历进行修改完成此题目 //层序遍历可以利用队列来实现。 //首先新建一个队列，然后将链表的头push进去，然后弹出，获得头的值，然后再分别push进去其左右两个结点。然后弹出头上的 //然后判断其左右结点是否有，有就push进去。这样层序遍历其实就是用队列来输入输出。 queue&lt;TreeNode*&gt; tmp; tmp.push(pRoot); while(!tmp.empty()) { int l=0; int h=tmp.size(); vector&lt;int&gt; t; while(l++&lt;h)//按行输出 { TreeNode* k = tmp.front(); tmp.pop(); t.push_back(k-&gt;val); if(k-&gt;left) tmp.push(k-&gt;left); if(k-&gt;right) tmp.push(k-&gt;right); } vect.push_back(t); } return vect; } 题目6：按之字形顺序打印二叉树题目描述 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 题目解析 这个题目是对于题目5的拓展，我们依旧可以借鉴层序遍历，但是这里我们要使用的是两个堆栈。总体上是一样的。 假设我们输出第一行，那么按照顺序输出以后，push进堆栈的顺序要和之前的相反，这样push进入第二个堆栈。当用第二个堆栈输出的时候，就要先左后右push进入第一个堆栈。 代码 vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) { vector&lt;vector&lt;int&gt; &gt; res;//结果存放 stack&lt;TreeNode*&gt; stackl,stackr;//从右往左和从左往右输出结果的堆栈 if(pRoot!=NULL) { stackl.push(pRoot);//跟层序遍历类似，先把根节点push进去 } struct TreeNode* node;//中介的结点，类似于层序遍历 while(!stackl.empty() || !stackr.empty()) { vector&lt;int&gt; tmp; if(!stackl.empty()){ while(!stackl.empty()) { node=stackl.top(); stackl.pop(); tmp.push_back(node-&gt;val); if(node-&gt;left!=NULL) stackr.push(node-&gt;left); if(node-&gt;right!=NULL) stackr.push(node-&gt;right); } res.push_back(tmp); } else if(!stackr.empty()){ while(!stackr.empty()){ node=stackr.top(); stackr.pop(); tmp.push_back(node-&gt;val); if(node-&gt;right!=NULL) stackl.push(node-&gt;right); if(node-&gt;left!=NULL) stackl.push(node-&gt;left); } res.push_back(tmp); } } return res; } 题目7：二叉搜索树的第k个节点题目描述 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 题目解析 这个题看着挺唬人，实际非常简单。由于二叉搜索树本身就是具有顺序特点的二叉树，因此这个题实际上是中序遍历二叉搜索树，然后输出中序遍历的第k个值。 代码 class Solution { private: int count; public: void inorder(TreeNode* root, TreeNode* &amp;ans) { if(root) { inorder(root-&gt;left,ans); count--;//记录是第几个值 if(!count) ans=root; inorder(root-&gt;right,ans); } } TreeNode* KthNode(TreeNode* pRoot, int k) { if(pRoot==NULL || k&lt;1) return NULL; TreeNode* ans = NULL; count = k; inorder(pRoot, ans); return ans; } }; 题目8：翻转单词顺序题目描述 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 题目解析 这个题目其实最容易想到的就是，我们可以整个句子翻转过来，这样做的结果是，每个单词正好也都是反序的，我们只需要再调用一次翻转，将单词翻转就变成了正序。 代码 void ReversedWord(string &amp;str, int st, int en) { while(st &lt; en) { swap(str[st++],str[en--]); } } string ReverseSentence(string str) { int len = str.size(); int st = 0; int en = 0; ReversedWord(str,0,len-1);//先整体翻转 int i=0; while(i &lt; len) { while(i &lt; len &amp;&amp; str[i] == &apos; &apos;) //空格跳过 i++; en = st = i; //记录单词的第一个字符的位置 while(i &lt; len &amp;&amp; str[i] != &apos; &apos;) //不是空格 找单词最后一个字符的位置 { i++; en++; } ReversedWord(str, st, en - 1); //局部翻转 } return str; } 题目9：扑克牌顺子题目描述 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\\\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 题目解析 顺子要求： 1.牌面不重复； 2.牌面是连续的。 为了满足以上条件，所以做了以下两个步骤： 1.设置flag。只要不重复，很多都会用到flag，由于扑克牌里面有14种牌，所以flag数组长度为14，默认为0，有重复就加1。 2.寻找最大最小值，计算它们的差值，判断结果。由于牌面不重复，又由于只有五张，所以max-min&lt;5的时候（其实就是为4的时候），肯定是连续的，若大了，肯定不连续。 代码 bool IsContinuous( vector&lt;int&gt; numbers ) { if(numbers.empty()) return false; int count[14]={0}; int max = -1; int min = 14; for(int i=0;i&lt;numbers.size();i++) { count[numbers[i]]++; if(numbers[i]==0) continue; if(count[numbers[i]]&gt;1) return false; if(numbers[i] &gt; max) max = numbers[i]; if(numbers[i] &lt; min) min = numbers[i]; } if(max - min &lt;5) return true; return false; } 题目10：矩阵中的路径题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 题目解析 类似于题目3，在此就不具体说了。 代码 private: bool isPath(char *matrix, vector&lt;char&gt; flags, char* str, int i, int j, int rows, int cols) { if(i&lt;0|| i&gt;=rows || j&lt;0 || j&gt;=cols) return false; if(matrix[i*cols+j] == *str &amp;&amp; flags[i*cols+j]==0) { flags[i*cols+j]=1; if(*(str+1)==0) return true; bool cond = isPath(matrix,flags,(str+1),i,j-1,rows,cols) || isPath(matrix,flags,(str+1),i-1,j,rows,cols)|| isPath(matrix,flags,(str+1),i,j+1,rows,cols)|| isPath(matrix,flags,(str+1),i+1,j,rows,cols); if(cond==false) flags[i*cols+j]=0; return cond; } else return false; } public: bool hasPath(char* matrix, int rows, int cols, char* str) { vector&lt;char&gt; flags(rows*cols,0); bool con = false; for(int i=0;i&lt;rows;i++) for(int j =0;j&lt;cols;j++) { con = (con|| isPath(matrix,flags,str,i,j,rows,cols) ); } return con; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"测试文件","slug":"e6-b5-8b-e8-af-95-e6-96-87-e4-bb-b6-trashed","date":"2019-03-01T07:01:46.000Z","updated":"2019-03-20T14:39:12.324Z","comments":false,"path":"2019/03/01/e6-b5-8b-e8-af-95-e6-96-87-e4-bb-b6-trashed/","link":"","permalink":"http://tech.yushuai.xyz/2019/03/01/e6-b5-8b-e8-af-95-e6-96-87-e4-bb-b6-trashed/","excerpt":"","text":"最优工程布线问题问题描述在3×3的方格阵列，灰色表示封锁，不能通过。将每个方格抽象为一个结点，方格和相邻4个方向（上下左右）中能通过的方格用一条线连接起来，不能通过的方格不连线。这样，可以把问题的解空间定义为一个图，如下图所示。 该问题是特殊的最短路径问题，特殊之处在于用布线走过的方格数代表布线的长度，布线时每一个方格，布线长度累加1.我们可以看出，从a到b有多种布线方案，最短的布线长度即从a到b的最短路径长度为4。 既然只能朝四个方向布线，也就是说如果从树型搜索的角度来看，我们可以把它看做为m叉树，那么问题的解空间就变成了一颗m叉树。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《剑指Offer》题目解析（1）","slug":"e3-80-8a-e5-89-91-e-90-ef-bc-881-ef-bc-89","date":"2019-02-26T14:19:33.000Z","updated":"2019-03-20T14:41:56.600Z","comments":false,"path":"2019/02/26/e3-80-8a-e5-89-91-e-90-ef-bc-881-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/02/26/e3-80-8a-e5-89-91-e-90-ef-bc-881-ef-bc-89/","excerpt":"","text":"题目1 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目解析其实这个题目是非常有规律的，所以才可以用复杂度更小的方法来实现。由于其每行自左向右递增，每列自上而下递增，所我们可以设置一个初始位置，让他不在(0,0)的位置，而是第一列最后一个位置，如果实际数比它大了，那就向右查找，否则向上查找。 代码bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) { if(array.size()!=0) { int rows=array.size(); int cols=array[0].size(); int i=rows-1;//最后一行 int j=0; while(i&gt;=0&amp;&amp;j&lt;cols) {//如果target小于这个数，自然往上找 if(target&lt;array[i][j]) --i; //如果target大于这个数，自然往后找 else if(target&gt;array[i][j]) ++j; else return true; } } return false; } 题目2 替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 题目解析代码void replaceSpace(char *str,int length) { int count=0; int realen=0; int i=0; while(str[i]!=&apos;\\0&apos;) { ++realen; if(str[i]== &apos; &apos;) ++count; ++i; } int newlen=realen+count*2; if(length&lt;newlen) return ; for(int j=realen-1;j&gt;=0;j--) { if(str[j]!=&apos; &apos;) str[j+2*count]=str[j]; else{ count--; str[j+2*count]=&apos;%&apos;; str[j+2*count+1]=&apos;2&apos;; str[j+2*count+2]=&apos;0&apos;; } } str[newlen]=&apos;\\0&apos;; } 题目3 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 题目解析其实很容易想到，可以使用FILO的堆栈来进行处理。 代码vector&lt;int&gt; printListFromTailToHead(ListNode* head) { vector&lt;int&gt; result; stack&lt;int&gt; arr; ListNode * p=head; //首先把链表从头到尾输入到一个堆栈 //利用堆栈先入后出特性，从尾到头输出到一个vector里面 while(p!=NULL) { arr.push(p-&gt;val); p=p-&gt;next; } int len= arr.size(); for(int i=0;i&lt;len;i++) { result.push_back(arr.top()); arr.pop(); } return result; } 题目4 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 题目解析我们根据前序遍历的特点可以发现，前序遍历的第一个数字一定是这个二叉树的根节点；然后根据中序遍历的特点可发现，根节点左侧的数字一定是左子树，右侧一定是右子树。然后将中序遍历以根节点为中心划分成两个部分，这又是两个子树，然后这个子树又可以根据前序遍历找到各个子树的根节点……以此类推，这非常适合有递推来实现。 就拿这个例子来说。 前序遍历： 序号 0 1 2 3 4 5 6 7 内容 1 2 4 7 3 5 6 8 中序遍历： 序号 0 1 2 3 4 5 6 7 内容 4 7 2 1 5 3 8 6 这又就把中序遍历分为了4/7/2和5/3/8/6两个部分。然后考虑4/7/2这个部分，前序遍历的第2个数字是划分4/7/2的数字，这样，2是这个子树的根节点，4/7都位于左子树。 然后再看右子树，也就是3/5/6/8这四个数字。同理可以得出，3是右子树的根节点，然后5在左子树，8/6在右子树。再去8/6这个子树看，根据前序遍历可以看到6为子树的根节点，根据中序遍历可以看到，8为子树的左结点。 接下来考虑代码实现问题。首先肯定要判断所给的两个数组是不是空，若是空肯定是个空树，否则继续进行。我们可以使用类里面的一个私有函数来进行具体的重建功能，而这个函数的参数自然是前序遍历结果、起始位置、结束位置、中序遍历结果、起始位置、结束位置。 当然作为刚开始的时候，起始位置肯定是0，结束位置肯定是length-1。 使用这个私有函数进行递归，肯定有停止递归的条件，那就是开始位置大于结束位置的时候，自然就代表迭代结束了。 然后新建一个TreeNode，第一个节点自然是前序遍历的第一个节点，所以可以： TreeNode root=new TreeNode(pre[startPre]); 接下来自然要开始进行判断，寻找前序遍历和中序遍历相等值的位置，由于前序遍历里面的点都可以作为中序遍历里面的根节点，所以我们只需要在中序遍历里面找到与前序遍历中值相等的位置，就是该子树的根节点的位置，就可以根据这个点划分左子树和右子树了。而中序遍历中到的根节点的位置i左侧有几个数字就是左子树有几个元素，右边有几个数字就是右子树有几个元素 对于左子树来说，左子树的起始位置自然是startPre的下一个位置，而结束是startPre+i-startIn（startPre是位置，i-startIn是从中序遍历中看左子树有几个元素），而中序遍历的开始位置自然是startIn，结束位置是i-1。 对于右子树来说，中序遍历的起始位置自然是i+1，结束位置是endIn；而对于前序遍历来说，自然是startPre+左子树的元素数+1，而左子树我们知道是i-startIn了，所以起始位置是startPre+i-startIn+1，结束位置自然是endPre。 于是，完成了这个程序的编写。 代码public TreeNode reConstructBinaryTree(int [] pre,int [] in) { TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root; } //前序遍历{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6} private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre, int [] in,int startIn,int endIn) { if(startPre&gt;endPre||startIn&gt;endIn) return null; TreeNode root=new TreeNode(pre[startPre]); for(int i=startIn;i&lt;=endIn;i++) if(in[i]==pre[startPre]){ root.left=reConstructBinaryTree(pre,startPre+1, startPre+i-startIn,in,startIn,i-1); root.right=reConstructBinaryTree(pre,i-startIn+startPre+1, endPre,in,i+1,endIn); break; } return root; } 题目5 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 题目解析思路很简单，就是用两个堆栈，push直接push进去就可以。由于队列是FIFO，而堆栈是FILO，所以只要使用push后的堆栈再push到另一个堆栈里面，这个时候pop出来的顺序总体上来说就是FIFO了。 代码public: void push(int node) { stack1.push(node); } int pop() { int tmp; if(stack2.empty()) while(!stack1.empty()) { tmp=stack1.top(); stack2.push(tmp); stack1.pop(); } int res=stack2.top(); stack2.pop(); return res; } private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2; 题目6 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 题目解析最傻瓜的方式就是直接进行比较了，但是这样的时间复杂度为O(n)，我们可以考虑降低复杂度。考虑到这个旋转数组本质上是一个基本有序的数组，所以我们可以考虑借鉴二分查找的思想。 令low=0，high=len-1，即两个指针分别指向数组的开头和结尾。我们令mid=(low+high)/2。 - 若a[mid]&gt;a[high]，则代表最小的元素一定在后面(因为这两块都是递增的），所以low=mid+1 - 若a[mid]==a[high]，这种情况比较复杂，需要一个一个的试，所以high=high-1，一点点缩小范围。 - a[mid]&lt;a[high]，则代表最小数字一定就是array[mid]或者在mid的左边。因为右边必然都是递增的，所以直接high=mid（一定不能为mid-1）。 代码int minNumberInRotateArray(vector&lt;int&gt; rotateArray) { int low=0;int high=rotateArray.size()-1; while(low&lt;high){ int mid = low+(high-low)/2; if(rotateArray[mid]&gt;rotateArray[high]) low= mid+1; else if(rotateArray[mid]==rotateArray[high]) high=high-1; else high=mid; } return rotateArray[low]; } 题目7 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 题目解析假如我们要计算313，我们既可以直接乘（复杂度为O(n)），也可以用快速算法降低复杂度。方法是怎样的呢？ 我们关注指数部分，13=(1101)2所以313=3(1000)2 * 3(0100)2 * 3(0001)2。 这样的话，我们可以将exponent&amp;1操作，如最低位为1，那么就是做ans=ans_base，否则不做。然后对exponent进行右移，每右移1位，base=base_base，这样若为1，则ans=base；若为101，则为ans=base_(base_base)。然后就可以得到结果了，代码如下。 代码double Power(double base, int exponent) { long long exp=abs((long long)exponent); double ans =1.0; while(exp) { if(exp&amp;1) ans*=base; base*=base; exp&gt;&gt;=1; } return exponent&lt;0?(1/ans):ans; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《剑指Offer》题目解析（2）","slug":"e3-80-8a-e5-89-91-882-ef-bc-89","date":"2019-02-21T06:09:59.000Z","updated":"2019-03-20T14:41:52.317Z","comments":false,"path":"2019/02/21/e3-80-8a-e5-89-91-882-ef-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2019/02/21/e3-80-8a-e5-89-91-882-ef-bc-89/","excerpt":"","text":"题目1 滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 题目解析我在做这个题的时候思路非常简单，我是用的暴力破解，所以复杂度也不理想，为O(n2)，所以仅供参考。下一步在进行第二遍做题的时候我会考虑采用复杂度更低的方法。 我的方法就是新建一个vector&lt; int &gt;，然后对原始数组直接进行加窗，然后对加窗的size个数进行排序，然后将最大值push进结果里面。 代码class Solution { public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) { vector&lt;int&gt; result;//结果存放 vector&lt;int&gt; temp;//加窗的数据存放 int len = num.size(); if(num.empty()||size&gt;len||size&lt;1) return result; for(int i=0;i&lt;len-size+1;i++) { for(int j=0;j&lt;size;j++) temp.push_back(num[i+j]);//窗口里面的数据 sort(temp.begin(),temp.end());//排序 result.push_back(temp[size-1]); //直接把排序好的结果中最大的push进入到result中 temp.clear(); } return result; } }; 题目2 对称二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 题目解析既然它是镜像的话，那么就是左右对称，这个我们可以使用一个递归来解决。我们令A等于这个树，B也等于这个树，假设A树和B树都只有一个结点（空结点也看做是一个结点）其实也就是两个树中至少一个树为NULL的时候，结果只会存在三种情况： 1.A的该结点为NULL，B的该结点也为NULL，即都是空结点，那么这两个树相等，自然是镜像，返回true； 2.A的该结点为NULL，B的该结点不为NULL（或者A的该结点不是NULL，B的该结点为NULL），那么不是镜像，返回false； 3.A和B均有值，但不相等，自然不是镜像，返回false。 我们把这个结点看做是其父结点的一个子树，然后逐层向上去扩展。 判断的时候是由上向下，只要两个结点值相等就继续递归。 代码 bool isSymmetrical(TreeNode* pRoot) { return isSym(pRoot, pRoot); } bool isSym(TreeNode* root1, TreeNode* root2) { if(root1==NULL &amp;&amp; root2==NULL) return true; if(root1 == NULL || root2 == NULL) //两个均为空的情况下前面就已经返回了 //所以既然要判断这个语句，那肯定至少其中一个不为空了 return false; if(root1-&gt;val!=root2-&gt;val) //既然到了这一步，说明两个节点都不是空的了 //说明是在树的中间节点。在这里就需要判断两个值是不是相等 return false; return isSym(root1-&gt;left, root2-&gt;right) &amp;&amp; isSym(root1-&gt;right, root2-&gt;left); } 题目3 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。 题目解析其实就是我新建一个结点，然后令这个结点为两个重复结点（A、B）中的第二个结点（B），然后判断这个结点和A是否相等，若相等，则让这个新结点等于B的下一个结点，然后依次判断这样返回的时候就把重复的结点给删除了。 代码ListNode* deleteDuplication(ListNode* pHead) { if(pHead == NULL) return NULL; if(pHead-&gt;next== NULL) return pHead; if(pHead-&gt;val==pHead-&gt;next-&gt;val) { ListNode* pNode = pHead-&gt;next; while(pNode!=NULL &amp;&amp; pNode-&gt;val==pHead-&gt;val) pNode=pNode-&gt;next; //跳过与当前结点值相同的所有结点， //直到找到一个值与当前不同的为止。 return deleteDuplication(pNode); } else { pHead-&gt;next=deleteDuplication(pHead-&gt;next); //保留当前结点，从下一个结点开始递归 return pHead; } } 题目4 字符流中第一个不重复的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 题目解析只要这种题，就想到用一个数组，然后字符减去’\\\\0’（或者其他的起始位）作为数组中元素的序号，每一个元素的大小代表这个字符流中的字符出现的次数，然后判断就可以了。 Insert()函数的就是每插入一个字符，就对该字符对应的数组元素进行加1，然后看这个时候这个字符是否是第一次插入呢，如果是就送入到character这个队列里面。 那自然，随着字符流不断输入，肯定有字符个数超过一个。这个时候就要使用char FirstAppearingOnce()来进行判断了。这个函数就是判断若character没空，并且数组元素大于1，即字符出现多次，那么久把字符从队列里面删除，直到剩下的最后一个返回；如果character空了，就代表没有只出现一次的字符，返回一个“#”。 代码class Solution { public: void Insert(char ch) { ++myArray[ch - &apos;\\0&apos;]; if(myArray[ch - &apos;\\0&apos;] == 1 ) character.push(ch); } //return the first appearence once char in current stringstream char FirstAppearingOnce() { while(character.size()!= 0 &amp;&amp; myArray[character.front()]&gt;1) character.pop(); if(character.empty()) return &apos;#&apos;; return character.front(); } private: unsigned char myArray[200]; queue&lt;char&gt; character; }; 题目5 数据流中的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 题目解析待弄明白更高效算法的时候再来解析。 代码class Solution { vector&lt;int&gt; numbers; public: void Insert(int num) { numbers.push_back(num); } double GetMedian() { sort(numbers.begin(),numbers.end()); //O(nlogn)，一般是快速排序 int len=numbers.size(); if(len%2==1) return (double)(numbers[len/2]); else { double a=(double)(numbers[len/2]); double b=(double)(numbers[len/2-1]); double c = (a+b)/2; return c; } } }; 题目6 构建乘积数组题目描述给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]_A[1]_…_A[i-1]_A[i+1]_…_A[n-1]。不能使用除法。 题目解析将B分为两个部分，B0和B1，B0计算A[0]_A[1]_…_A[i-1]；B1计算A[i+1]_…_A[n-1]。然后将B0_B1得到结果。 代码 vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) { int n = A.size(); vector&lt;int&gt; B0(n, 1); vector&lt;int&gt; B1(n, 1); for (int i = 1; i &lt; n;++i) { B0[i] = B0[i - 1] * A[i - 1]; } for (int i = n - 2; i &gt;= 0;--i) { B1[i] = B1[i + 1] * A[i + 1]; } vector&lt;int&gt; B(n, 1); for (int i = 0; i &lt; n;++i) { B[i] = B0[i] * B1[i]; } return B; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"编程知识点学习（1）：字符串知识点","slug":"e7-bc-96-e7-a8-8a6-e4-b8-b2-e7-9f-a5-e8-af-86-e7-82-b9","date":"2018-11-29T02:17:29.000Z","updated":"2019-03-20T14:38:49.167Z","comments":false,"path":"2018/11/29/e7-bc-96-e7-a8-8a6-e4-b8-b2-e7-9f-a5-e8-af-86-e7-82-b9/","link":"","permalink":"http://tech.yushuai.xyz/2018/11/29/e7-bc-96-e7-a8-8a6-e4-b8-b2-e7-9f-a5-e8-af-86-e7-82-b9/","excerpt":"","text":"1.若一个字符串长度为n，那么它的子串数目有n(n+1)/2+1个。 2.设S为一个长度为n的字符串,其中的字符各不相同,则S中的互异的非平凡子串(非空且不同于S本身)的个数为(n²/2)+(n/2)-1 3.关于puts和putchar （1）puts()函数用来向标准输出设备（屏幕）输出字符串并换行，具体为：把字符串输出到标准输出设备，将’\\\\0’转换为回车换行。其调用方式为，puts(s)；其中s为字符串字符（字符串数组名或字符串指针）。 （2）.putchar()函数作用是向终端输出一个字符。其格式为putchar(c)，其中c可以是被单引号（英文状态下）引起来的一个字符，可以是介于0~127之间的一个十进制整型数（包含0和127），也可以是事先用char定义好的一个字符型变量。 4.广义表L=(A,B,C),表头是A，表尾是（B,C)，这是定义。tail()表示取字符串的尾部，head()表示取字符串的头，concat()表示字符串拼接。 5.简单匹配算法的时间复杂度为O(m*n)，KMP匹配算法时间复杂度为O(m+n).。 6.串就是字符串,是一种特殊的线性表,它的每个结点仅由一个字符组成。 串值也可用链表来存储,由于串的数据元素是一个字符,它只有8位二进制数, 因此用链表存储时,通常一个结点中存放的不是一个字符,而是一个子串,例如: 在编辑系统中,整个文本编辑区可以看成是一个串,每一行是一个子串,构成一个结点。 7.将字符串赋值给字符数组： （1）定义时直接用字符串赋值。 char a[10]＝”hello”;但是不能先定义再赋值， （2）利用strcpy。 char a[10]; strcpy(a,”hello”) （3）利用指针。 char *p; p＝”hello”; （4）数组中的字符逐个赋值。 后续会不断补充。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"KMP算法的简单理解","slug":"comprehensionofkmp","date":"2018-11-27T12:40:12.000Z","updated":"2019-03-21T14:51:51.538Z","comments":false,"path":"2018/11/27/comprehensionofkmp/","link":"","permalink":"http://tech.yushuai.xyz/2018/11/27/comprehensionofkmp/","excerpt":"","text":"总结一些在网上看到的关于KMP算法的简单理解，目前我的理解还很初步，很多东西还似懂非懂，目前先贴下来，期待以后慢慢懂。 KMP算法的基本原理假设字符串S=BBC ABCDAB ABCDABCDABDE，搜索词P=ABCDABD。那么我们在执行搜索的时候进行下面的操作： 首先，字符串“BBC ABCDAB ABCDABCDABDE”的第一个字符与“ABCDABD”的第一个字符比较，因为不匹配，所以搜索词后移一位，直到移动到匹配的地方，即 B B C A B C D A B A B C D A B C D A B D E A 然后我们就发现匹配了，于是开始使用搜索词P的第二个字符与字符串S下一个字符进行比较发现相匹配，然后继续比较……直到P的最后一个字符D与S中相应位置进行比较，发现S中为空格，即 B B C A B C D A B A B C D A B C D A B D E A B C D A B D 如果是传统的方法，则是将字符串P的指针回到第一个字符，然后后移继续进行比较。这样的方法是暴力方法，复杂度太高。KMP算法是利用了已经知道的匹配信息，然后不再把“搜索位置”移回已经比较的位置再进行比较，而是继续往后移。这里利用的就是部分匹配值（Partial Match Value）。 部分匹配值的介绍 首先要了解“前缀”和“后缀”的概念。前缀是指除了最后一个字符以外，一个字符串的全部头部的集合，后缀是指除了第一个字符以外，一个字符串的全部尾部的集合。所谓部分匹配值就是前缀和后缀的最长的共有元素的长度。以ABCDABD为例，有以下情况： 字符 前缀 后缀 共有元素长度 A - - 0 AB A B 0 ABC A/AB BC/C 0 ABCD A/AB/ABC BCD/CD/D 0 ABCDA A/AB/ABC/ABCD BCDA/CDA/DA/A 1 ABCDAB A/AB/ABC/ABCD/ABCDA BCDAB/CDAB/DAB/AB/B 2 ABCDABD A/AB/ABC/ABCD/ABCDA/ABCDB BCDABD/CDABD/DABD/ABD/BD/D 0 所谓部分匹配，实质上指的是有时字符串头部和尾部会有重复。例如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 我们进行“继续往后移”的移动位数的标准是用如下公式计算： 移动位数=已匹配的字符数-对应的部分匹配值 基于上面这个公式，我们可以看到，已匹配的字符数为6（ABCDAB），对应的部分匹配值为2，那么就将搜索词向后移动4位。如下所示： B B C A B C D A B A B C D A B C D A B D E A B C D A B D 依旧是如此，可以看到空格与C不匹配，搜索词还要继续往后移。此时已匹配的字符数为2（AB），对应的部分匹配值为0，所以往后移动2位。 B B C A B C D A B A B C D A B C D A B D E A B C D A B D 此时空格与A不匹配，往后继续移动1位，得到如下所示。 B B C A B C D A B A B C D A B C D A B D E A B C D A B D 这个时候发现D又不匹配，此时已匹配的字符数为6位，对应的部分匹配值为2，所以向右移动4位，得到如下所示。 B B C A B C D A B A B C D A B C D A B D E A B C D A B D 此时，发现匹配，搜索完成。当然，如果想继续寻找后面是否还会有继续匹配的，可以继续移动7位（已匹配的字符数为7，对应的部分匹配值为0）。 我们换个角度来理解，假设P为主字串，而T为子串。当匹配失败时，j要移动的下一个位置k。存在着这样的性质：最前面的k个字符和j之前的最后k个字符是一样的。即 P[0 ~ k-1] == P[j-k ~ j-1] 因为: 当T[i] != P[j]时，有T[i-j ~ i-1] == P[0 ~ j-1]，由P[0 ~ k-1] == P[j-k ~ j-1]，必然：T[i-k ~ i-1] == P[0 ~ k-1]。 next数组的求解思路讲完上面的原理，下面就是编程的实现，这里面最重要的就是根据待匹配的模版字符串求出对应每一位的最大相同前后缀的长度。 实际上，next[j]**的值（也就是k）表示，当P[j] != T[i]时，j指针的下一步移动位置**。 我们在做题的时候来求next数组，可以通过手算，按照计算部分匹配值即可。要注意的是，next[1]=0，next[1]=1，next[n]是计算前面n-1个字符的部分匹配值，如果找到，那么next值是该长度加1，否则next值是1（其实就是0+1）。 但是，编写程序我们需要原理。如图2所示。此时j=0，如果这个时候不匹配，那么j已经在最左边，不可能移动了，所以这个时候应该是i来移动，所next[0]=-1。 图1 当j=1的时候，按照前面说的，我们应该将j移动到为T[0]的位置，所以实际上这里next[1]=0。 图2 对比图3中的两个图，我们发现当P[k] == P[j]时，有next[j+1] == next[j] + 1。其实这个是可以证明的：因为在P[j]之前已经有P[0 ~ k-1] == p[j-k ~ j-1]。（next[j] == k）这时候现有P[k] == P[j]，我们是不是可以得到P[0 ~ k-1] + P[k] == p[j-k ~ j-1] + P[j]。即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1。（这里还需要多去理解理解） 图3 如果P[k] != P[j]，那么k=next[k]，如图4所示。 图4 nextval数组的求解思路nextval[i]的求解需要比较s中next[i]所在位置的字符是否与s[i]的字符一致，如果一致则用s[next[i]]的nextval的值作为nextval[i]，如果不一致，则用next[i]做为nextval[i]。 即以下格式： nextval[i] = s[next[i]]==s[i]?nextval[s[next[i]]]:next[i] KMP算法的代码KMP**算法：可以实现复杂度为**O(m+n) #include&lt;stdio.h&gt; #include&lt;string.h&gt;void getNext(const char P[], int next[]){ int q, k; int m = strlen(P); next[0] = 0; for (q = 1, k = 0; q &lt; m; ++q) { while (k &gt; 0 &amp;&amp; P[q] != P[k]) k = next[k - 1]; if (P[q] == P[k]) { k++; } next[q] = k; }}int kmp(const char T[], const char P[], int next[]){ int n, m; int i, q; n = strlen(T); m = strlen(P); getNext(P, next); for (i = 0, q = 0; i &lt; n; ++i) { while (q &gt; 0 &amp;&amp; P[q] != T[i]) q = next[q - 1]; if (P[q] == T[i]) { q++; } if (q == m) // 输出找到的位置 还可以判断i == n - 1 未找到 { printf(“Pattern occurs with shift:%d\\\\n”, (i - m + 1)); } }} int main(){ int i; int next[100] = { 0 }; char T[20], P[20]; scanf(“%s%s”, T, P); printf(&quot;%s\\\\n&quot;, T); printf(&quot;%s\\\\n&quot;, P); kmp(T, P, next); for (i = 0; i &lt; strlen(P); ++i) { printf(&quot;%d &quot;, next\\[i\\]); } printf(&quot;\\\\n&quot;); return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"C++ Primer Plus（第五版）第11章编程题答案","slug":"c-primer-plus-ef-bc-88-e7-ac-ac-ed-94-e6-a1-88","date":"2018-11-18T12:07:13.000Z","updated":"2019-03-20T14:39:30.132Z","comments":false,"path":"2018/11/18/c-primer-plus-ef-bc-88-e7-ac-ac-ed-94-e6-a1-88/","link":"","permalink":"http://tech.yushuai.xyz/2018/11/18/c-primer-plus-ef-bc-88-e7-ac-ac-ed-94-e6-a1-88/","excerpt":"","text":"1.修改程序清单11.15，使之将一系列连续的随机漫步者位置写入到文件中。对于每个位置，用步号进行标示。另外，让该程序将初始条件（目标距离和步长）以及结果小结写入到该文件中。 #include #include #include #include #include “vector.h”using namespace std;using VECTOR::Vector;int main() { ofstream outFile; outFile.open(“exercise1.txt”); srand(time(0)); double direction; Vector step; Vector result(0.0, 0.0); unsigned long steps = 0; double target; double dstep; cout &lt;&lt; “Enter target distance(q to quit): “; while (cin &gt;&gt; target) { cout &lt;&lt; “Enter step length: “; if (!(cin &gt;&gt; dstep)) break; outFile &lt;&lt; “Target Distance: “ &lt;&lt; target &lt;&lt; “, Step Size: “ &lt;&lt; dstep &lt;&lt; endl; while (result.magval() &lt; target) { direction = rand() % 360; step.set(dstep, direction, ‘p’); result = result + step; outFile &lt;&lt; steps &lt;&lt; “: (x,y) = “ &lt;&lt; “(“ &lt;&lt; step.xval() &lt;&lt; “, “ &lt;&lt; step.yval() &lt;&lt; “)” &lt;&lt; endl; steps++; } outFile &lt;&lt; “After “ &lt;&lt; steps &lt;&lt; “ steps, the subject “ “has the following location:\\\\n”; outFile &lt;&lt; “(x,y)=” &lt;&lt; result &lt;&lt; endl; result.polar_mode(); outFile &lt;&lt; “ or\\\\n” &lt;&lt; result &lt;&lt; endl; outFile &lt;&lt; “Average outward distance per step = “ &lt;&lt; result.magval() / steps &lt;&lt; endl; outFile &lt;&lt; “====================================================”&lt;&lt;endl; outFile &lt;&lt; “COPYRIGHT 2018 WWW.YUSHUAI.XYZ” &lt;&lt; endl; steps = 0; result.set(0.0, 0.0); cout &lt;&lt; “Enter target distance (q to quit): “; } outFile.close(); cout &lt;&lt; “Bye~” &lt;&lt; endl; system(“pause”); return 0;} 2.对Vector类的头文件（程序清单11.13）和实现文件（程序清单11.14）进行修改，使其不再存储矢量的长度和角度，而是在magval()和angval()被调用时计算它们。 应保留公有接口不变（公有方法及其参数不变），但对私有部分（包括一些私有方法）和方法实现进行修改。然后，使用程序清单11.15对修改后的版本进行测试，结果应该与以前相同，因为Vector类的公有接口与原来相同。 vector.h // vect.h – Vector class with &lt;&lt;, mode state #ifndef VECTOR_H_ #define VECTOR_H_ #include namespace VECTOR{ class Vector { private: double x; // horizontal value double y; // vertical value char mode; // ‘r’ = rectangular, ‘p’ = polar // private methods for setting values void set_x(double mag, double ang); void set_y(double mag, double ang); public: Vector(); Vector(double n1, double n2, char form = ‘r’); void set(double n1, double n2, char form = ‘r’); ~Vector(); double xval() const { return x; } // report x value double yval() const { return y; } // report y value double magval() const { return sqrt(x x + y y); } // report magnitude double angval() const// report angle { if (x == 0.0 &amp;&amp; y == 0.0) return 0.0; else return atan2(y, x); } void polar_mode(); // set mode to &apos;p&apos; void rect_mode(); // set mode to &apos;r&apos; // operator overloading Vector operator+(const Vector &amp; b) const; Vector operator-(const Vector &amp; b) const; Vector operator-() const; Vector operator*(double n) const; // friends friend Vector operator*(double n, const Vector &amp; a); friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector &amp; v); }; } // end namespace VECTOR #endif #pragma once vector.cpp #include #include “vector.h” // includes using std::sqrt;using std::sin;using std::cos;using std::atan2;using std::cout; namespace VECTOR{ const double Rad\\_to\\_deg = 57.2957795130823; // private methods // calculates magnitude from x and y // set x from polar coordinate void Vector::set_x(double mag, double ang) { x = mag * cos(ang); } // set y from polar coordinate void Vector::set_y(double mag, double ang) { y = mag * sin(ang); } // public methods Vector::Vector() // default constructor { x = y = 0.0; mode = &apos;r&apos;; } // construct vector from rectangular coordinates if form is r // (the default) or else from polar coordinates if form is p Vector::Vector(double n1, double n2, char form) { mode = form; if (form == &apos;r&apos;) { x = n1; y = n2; } else if (form == &apos;p&apos;) { set_x(n1, n2); set_y(n1, n2); } else { cout &lt;&lt; &quot;Incorrect 3rd argument to Vector() -- &quot;; cout &lt;&lt; &quot;vector set to 0\\\\n&quot;; x = y = 0.0; mode = &apos;r&apos;; } } // set vector from rectangular coordinates if form is r (the // default) or else from polar coordinates if form is p void Vector::set(double n1, double n2, char form) { mode = form; if (form == &apos;r&apos;) { x = n1; y = n2; } else if (form == &apos;p&apos;) { set_x(n1, n2); set_y(n1, n2); } else { cout &lt;&lt; &quot;Incorrect 3rd argument to Vector() -- &quot;; cout &lt;&lt; &quot;vector set to 0\\\\n&quot;; x = y = 0.0; mode = &apos;r&apos;; } } Vector::~Vector() // destructor { } void Vector::polar_mode() // set to polar mode { mode = &apos;p&apos;; } void Vector::rect_mode() // set to rectangular mode { mode = &apos;r&apos;; } // operator overloading // add two Vectors Vector Vector::operator+(const Vector &amp; b) const { return Vector(x + b.x, y + b.y); } // subtract Vector b from a Vector Vector::operator-(const Vector &amp; b) const { return Vector(x - b.x, y - b.y); } // reverse sign of Vector Vector Vector::operator-() const { return Vector(-x, -y); } // multiple vector by n Vector Vector::operator*(double n) const { return Vector(n * x, n * y); } // friend methods // multiply n by Vector a Vector operator*(double n, const Vector &amp; a) { return a * n; } // display rectangular coordinates if mode is r, // else display polar coordinates if mode is p std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector &amp; v) { if (v.mode == &apos;r&apos;) os &lt;&lt; &quot;(x,y) = (&quot; &lt;&lt; v.x &lt;&lt; &quot;, &quot; &lt;&lt; v.y &lt;&lt; &quot;)&quot;; else if (v.mode == &apos;p&apos;) { os &lt;&lt; &quot;(m,a) = (&quot; &lt;&lt; v.magval() &lt;&lt; &quot;, &quot; &lt;&lt; v.angval() * Rad\\_to\\_deg &lt;&lt; &quot;)&quot;; } else os &lt;&lt; &quot;Vector object mode is invalid&quot;; return os; } } // end namespace VECTOR 3.修改程序清单11.15，使之报告N次测试中的最高、最低和平均步数（其中N是用户输入的整数），而不是报告每次测试的结果。 #include #include #include #include “vector.h”using namespace std;using VECTOR::Vector;int main() { srand(time(0)); double direction; Vector step; Vector result(0.0, 0.0); unsigned long steps = 0; double target; double dstep; unsigned long max = 0; unsigned long min = 999; double avg = 0; int N; cout &lt;&lt; “请输入测试的次数：N=”; cin &gt;&gt; N; cout &lt;&lt; “第一次：” &lt;&lt; endl; int i; for (i = 0; i &lt; N; i++) { cout &lt;&lt; “Enter target distance(ONLY ENTER NUMBER): “; cin &gt;&gt; target; cout &lt;&lt; “Enter step length: “; if (!(cin &gt;&gt; dstep)) break; while (result.magval() &lt; target) { direction = rand() % 360; step.set(dstep, direction, ‘p’); result = result + step; steps++; } if (max &lt; steps) max = steps; if (min &gt; steps) min = steps; avg += steps; result.polar_mode(); steps = 0; result.set(0.0, 0.0); } avg /= N; cout &lt;&lt; “max: “ &lt;&lt; max &lt;&lt; endl &lt;&lt; “min: “ &lt;&lt; min &lt;&lt; endl &lt;&lt; “average: “ &lt;&lt; avg &lt;&lt; endl; cout &lt;&lt; “Bye~”; system(“pause”); return 0;} 4.重新编写最后的Time类示例（程序清单11.10、程序清单11.11和程序清单11.12），使用友元函数来实现所有的重载运算符。 mytime3.h #pragma once #ifndef MYTIME3_H_ #define MYTIME3_H_ #includeusing namespace std;class Time {private: int hours; int minutes;public: Time(); Time(int h, int m = 0); void AddMin(int m); void AddHr(int h); void Reset(int h = 0, int m = 0); friend Time operator+(const Time &amp; t1, const Time &amp; t2); friend Time operator-(const Time &amp; t1, const Time &amp; t2); friend Time operator(const Time &amp;t, double n); friend Time operator(double m, const Time &amp; t) { return t*m; } friend ostream &amp; operator&lt;&lt;(ostream &amp; os, const Time &amp; t);}; #endif // !MYTIME_H_ mytime3.cpp #include #include “mytime3.h”using namespace std;Time::Time() { hours = minutes = 0; }Time::Time(int h, int m) { hours = h; minutes = m; }void Time::AddMin(int m) { minutes += m; hours += minutes / 0; minutes %= 60; }void Time::AddHr(int h) { hours += h; }void Time::Reset(int h, int m) { hours = h; minutes = m; }Time operator+(const Time &amp; t1, const Time &amp; t2) { Time sum; sum.minutes = t1.minutes + t2.minutes; sum.hours = t1.hours + t2.hours + sum.minutes / 60; sum.minutes %= 60; return sum;}Time operator-(const Time &amp; t1, const Time &amp; t2) { Time diff; int tot1, tot2; tot1 = t2.minutes + 60 t2.hours; tot2 = t1.minutes + 60 t1.hours; diff.minutes = (tot2 - tot1) % 60; diff.hours = (tot2 - tot1) / 60; return diff; } Time operator(const Time &amp;t, double n) { Time result; long totalminutes = t.hours\\n * 60 + t.minutes*n; result.hours = totalminutes / 60; result.minutes = totalminutes % 60; return result;} ostream &amp; operator&lt;&lt;(ostream &amp; os, const Time &amp; t) { os &lt;&lt; t.hours &lt;&lt; “ Hours, “ &lt;&lt; t.minutes &lt;&lt; “ minutes.”; return os;} usetime3.cpp #include #include”mytime3.h”using namespace std;int main() { Time aida(3, 35); Time tosca(2, 48); Time temp; cout &lt;&lt; “Aida and Tosca:\\\\n”; cout &lt;&lt; aida &lt;&lt; “;” &lt;&lt; tosca &lt;&lt; endl; temp = aida + tosca; temp = aida1.17; cout &lt;&lt; “Aida1.17: “ &lt;&lt; temp &lt;&lt; endl; cout &lt;&lt; “10*Tosca: “ &lt;&lt; 10 * tosca &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 5.重新编写Stonewt类（程序清单11.16和程序清单11.17），使它有一个状态成员，由该成员控制对象应转换为英石格式、整数磅格式还是浮点磅格式。重载&lt;&lt;运算符，使用它来替换show_stn()和show_lbs()方法。重载加法、减法和乘法运算符，以便可以对Stonewt值进行加、减、乘运算。编写一个使用所有类方法和友元的小程序，来测试这个类。 stonewt.h // stonewt.h – definition for the Stonewt class #ifndef STONEWT_H_ #define STONEWT_H_class Stonewt{private: enum {Lbs_per_stn = 14}; // pounds per stone int stone; // whole stones double pds_left; // fractional pounds double pounds; // entire weight in poundspublic: Stonewt(double lbs); // constructor for double pounds Stonewt(int stn, double lbs); // constructor for stone, lbs Stonewt(); // default constructor ~Stonewt(); void show_lbs() const; // show weight in pounds format void show_stn() const; // show weight in stone format}; #endif stonewt.cpp // stonewt.cpp – Stonewt methods #include using std::cout; #include “stonewt.h” // construct Stonewt object from double valueStonewt::Stonewt(double lbs){ stone = int (lbs) / Lbs_per_stn; // integer division pds_left = int (lbs) % Lbs_per_stn + lbs - int(lbs); pounds = lbs;} // construct Stonewt object from stone, double valuesStonewt::Stonewt(int stn, double lbs){ stone = stn; pds_left = lbs; pounds = stn * Lbs_per_stn +lbs;} Stonewt::Stonewt() // default constructor, wt = 0{ stone = pounds = pds_left = 0;} Stonewt::~Stonewt() // destructor{} // show weight in stonesvoid Stonewt::show_stn() const{ cout &lt;&lt; stone &lt;&lt; “ stone, “ &lt;&lt; pds_left &lt;&lt; “ pounds\\\\n”;} // show weight in poundsvoid Stonewt::show_lbs() const{ cout &lt;&lt; pounds &lt;&lt; “ pounds\\\\n”;} stone.cpp // stone.cpp – user-defined conversions// compile with stonewt.cpp #include using std::cout; #include “stonewt.h”void display(const Stonewt &amp; st, int n);int main(){ Stonewt pavarotti = 260; // uses constructor to initialize Stonewt wolfe(285.7); // same as Stonewt wolfe = 285.7; Stonewt taft(21, 8); cout &lt;&lt; &quot;The tenor weighed &quot;; pavarotti.show_stn(); cout &lt;&lt; &quot;The detective weighed &quot;; wolfe.show_stn(); cout &lt;&lt; &quot;The President weighed &quot;; taft.show_lbs(); pavarotti = 265.8; // uses constructor for conversion taft = 325; cout &lt;&lt; &quot;After dinner, the tenor weighed &quot;; pavarotti.show_stn(); cout &lt;&lt; &quot;After dinner, the President weighed &quot;; taft.show_lbs(); display(taft, 2); cout &lt;&lt; &quot;The wrestler weighed even more.\\\\n&quot;; display(422, 2); cout &lt;&lt; &quot;No stone left unearned\\\\n&quot;; system(&quot;pause&quot;); return 0; } void display(const Stonewt &amp; st, int n){ for (int i = 0; i &lt; n; i++) { cout &lt;&lt; “Wow! “; st.show_stn(); }} 7.复数有两个部分组成：实数部分和虚数部分。复数的一种书写方式是：（3.0,4.0）。请定义一个复数类，以便下面的程序可以使用它来获得正确的结果。 （……代码省略……） 注意。必须重载运算符&lt;&lt;和&gt;&gt;。标准C++使用头文件complex提供了比这个示例更广泛的复数支持，因此应将自定义的头文件命名为complex0.h，以免发生冲突。应尽可能使用const。 请注意，经过重载后，cin&gt;&gt;c将提示用户输入实数和虚数部分。 complex0.h #pragma once #include #ifndef COM0_H_using namespace std;class complex { double a; double b;public: complex(); complex(double x, double y); ~complex(); complex operator+(const complex &amp; t) const; complex operator-(const complex &amp; t) const; friend complex operator(const complex &amp; t,double n);//Êý³Ë friend complex operator(const complex &amp; t1, const complex &amp; t2); friend complex operator~(const complex &amp; t); friend ostream &amp; operator&lt;&lt;(ostream &amp; os, const complex &amp; c); friend istream &amp; operator &gt;&gt; (istream &amp;in, complex &amp;c); }; #endif // !COM0_H_ complex0.cpp #include “complex0.h” #includecomplex::complex() { a = 0; b = 0;}complex::complex(double x, double y) { a = x; b = y; }complex::~complex() {}complex complex::operator+(const complex &amp; t) const{ complex sum; sum.a = a + t.a; sum.b = b + t.b; return sum; }complex complex::operator-(const complex &amp; t) const{ complex diff; diff.a = a - t.a; diff.b = b - t.b; return diff; }complex operator(const complex &amp; t, double n) //Êý³Ë{ return complex((t.a)\\n, (t.b)*n); } complex operator(const complex &amp; t1, const complex &amp; t2){ return complex((t1.a\\t2.a - t1.b*t2.b), (t1.a*t2.b + t1.b*t2.a)); }complex operator~(const complex &amp; t){ return complex(t.a, (-1.0)*t.b); }ostream &amp; operator&lt;&lt;(ostream &amp; os, const complex &amp; c){ os &lt;&lt; “(“ &lt;&lt; c.a &lt;&lt; “,” &lt;&lt; c.b &lt;&lt; “!” &lt;&lt; “)”; return os; }istream &amp; operator &gt;&gt; (istream &amp;in, complex &amp;c){ in &gt;&gt; c.a &gt;&gt; c.b; return in;} 备注： 操作系统：Windows 10 x64(1803) 编译器：Microsoft Visual Studio 2015","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++ Primer Plus（第五版）第10章编程题答案","slug":"c-primer-plus-ef-bc-88-e7-ac98-e7-ad-94-e6-a1-88","date":"2018-11-18T11:53:37.000Z","updated":"2019-03-20T14:39:34.254Z","comments":false,"path":"2018/11/18/c-primer-plus-ef-bc-88-e7-ac98-e7-ad-94-e6-a1-88/","link":"","permalink":"http://tech.yushuai.xyz/2018/11/18/c-primer-plus-ef-bc-88-e7-ac98-e7-ad-94-e6-a1-88/","excerpt":"","text":"1.为复习题5描述的类提供方法定义，并编写一个小程序来演示所有的特性。 bankacc.h #ifndef BANKACC_H_1 #define BANKACC_H_1class Bank { char name[30]; char account[7]; double debt;public: Bank(); Bank(const char *co, const char *ac, double db = 0.0); ~Bank(); void show() const; void deposit(const double money); void withdrawal(const double money);}; #endif // !BANKACC_H_1 bankacc.cpp #include #include #include #include”bankacc.h”using namespace std;Bank::Bank() { strcpy(name, “no name”); name[30] = ‘\\\\0’; strcpy(account, “100000”); account[6] = ‘\\\\0’; debt = 0.0;}Bank::Bank(const char *co, const char *ac, double db){ strncpy(name, co, 29); strncpy(account, ac,6); name[30] = ‘\\\\0’; account[6] = ‘\\\\0’; debt = db; }Bank::~Bank() { cout &lt;&lt; “Your account has been deleted.Thank your for using our service.\\\\n”;}void Bank::show() const{ cout &lt;&lt; “Account Name: “ &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; “Account ID: “ &lt;&lt; account &lt;&lt; endl; cout &lt;&lt; “Debt: $” &lt;&lt; debt &lt;&lt; endl;}void Bank::deposit(const double money){ debt += money; cout &lt;&lt; “Your Debt: $” &lt;&lt; debt &lt;&lt; endl; cout &lt;&lt; “Thank you for using deposit service.Bye~\\\\n”; }void Bank::withdrawal(const double money) { if (money &lt;= debt) { debt -= money; cout &lt;&lt; “Your Debt: $” &lt;&lt; debt &lt;&lt; endl; } else cout &lt;&lt; &quot;Error, you do not have enough money.\\\\n&quot;; cout &lt;&lt; &quot;Thank you for using withdrawal service.Bye~\\\\n&quot;; } banker.cpp #include #include #include #include”bankacc.h”using namespace std; int main() { cout &lt;&lt; “This is Bank example 1:” &lt;&lt; endl; Bank banks1; banks1.show(); cout &lt;&lt; “After depositing…”&lt;&lt;endl; double depos1 = 3692.21; banks1.deposit(depos1); cout &lt;&lt; “After withdrawal…” &lt;&lt; endl; banks1.withdrawal(1252.63); cout &lt;&lt; “#########################################” &lt;&lt; endl; double money2 = 8945.32; Bank banks2 = Bank(“Yushuai Zhang”, “H6365”, money2); banks2.show(); cout &lt;&lt; “After depositing…” &lt;&lt; endl; double depos2 = 235.21; banks2.deposit(depos2); cout &lt;&lt; “After withdrawal…” &lt;&lt; endl; banks2.withdrawal(625.63); system(&quot;pause&quot;); return 0; } 2.下面是一个非常简单的类定义： （……代码省略……） 通过提供未定义的方法来完成这个类的实现。然后，编写一个使用这个类的程序，它使用了几种可能的构造函数调用（没有参数、一个参数和两个参数）以及两种显示方法。 person.cpp #include #include #includeusing namespace std;const int LIMIT = 25;class Person {private: string lname; char fname[LIMIT];public: Person(); Person(const string &amp;ln, const char*fn = “Heyyou”); void Show() const; void FormalShow() const;};Person::Person(){ lname = “”; fname[0] = ‘\\\\0’; }Person::Person(const string &amp; ln, const char *fn) { lname = ln; strncpy(fname, fn, LIMIT-1); fname[LIMIT - 1] = ‘\\\\0’; }void Person::Show()const { cout &lt;&lt; fname &lt;&lt; “ “ &lt;&lt; lname &lt;&lt; endl; } void Person::FormalShow() const { cout &lt;&lt; lname &lt;&lt; “ “ &lt;&lt; fname &lt;&lt; endl; }int main() { Person one; Person two(“Smythecraft”); Person three(“Dimwiddy”, “Sam”); one.Show(); cout &lt;&lt; endl; one.FormalShow(); cout &lt;&lt; endl; two.FormalShow(); cout &lt;&lt; endl; three.Show(); system(“pause”); return 0;} 3.完成第9章的编程练习1，但要用正确的golf类声明替换那里的代码。用带合适参数的构造函数替换setgolf(golf &amp;, const char , int)， 以提供初始值。保留setgolf()的交互版本，但要用构造函数来实现它（例如，setgolf()的代码应该获得数据，将数据传递给构造函数来创建一个临时对象，并将其赋给调用对象，即this）。 golf.h #ifndef GOLF_H #define GOLF_Hclass Golf {private: static const int Len = 40; char fullname[Len]; int handicap;public: Golf(const char * name = “HHHHHH”, int hc = 10); ~Golf(); bool setGolf(); void sethandicap(int hc); void showGolf()const;}; #endif // GOLF_H golf.cpp #include #include #include “golf.h”using namespace std; Golf::Golf(const char * name, int hc){ strncpy(fullname, name, 40); fullname[39] = ‘\\\\0’; handicap = hc;} Golf::~Golf(){ cout &lt;&lt; “Bye!” &lt;&lt; endl;} bool Golf::setGolf(){ char fullname[Len]; int handicap; cout &lt;&lt; &quot;Please input the name of the golf player: &quot;; cin.get(fullname, Len); if (cin) { cout &lt;&lt; &quot;Please input the handicap of the golf player: &quot;; cin &gt;&gt; handicap; cin.get(); *this = Golf(fullname, handicap); return true; } else return false; } void Golf::sethandicap(int hc){ handicap = hc;} void Golf::showGolf()const{ std::cout &lt;&lt; “hullname: “ &lt;&lt; fullname &lt;&lt; “, \\\\thandicap: “ &lt;&lt; handicap &lt;&lt; std::endl;} main.cpp #include #include “golf.h”using namespace std;int main(){ Golf one; Golf two; Golf three; one.showGolf(); // 默认构造函数 two.setGolf(); // 交互版本 two.showGolf(); two.sethandicap(5000); //成员函数 two.showGolf(); //成员函数 three.sethandicap(20); three.showGolf(); system(&quot;pause&quot;); return 0; } 5.考虑下面的结构声明： struct customer { char fullname[35]; double payment;}; 编写一个程序，它从栈中添加和删除customer结构（栈用Stack类声明表示）。每次customer结构被删除时，其payment的值都被加入到总数中，并报告总数。注意：应该可以直接使用Stack类而不作修改；只需修改typedef声明，使Item的类型为customer，而不是unsigned long即可。 stack.h #pragma once #ifndef STACK_H_ #define STACK_H_typedef struct customer{ char fullname[35]; double payment;}CUSTOMER; typedef customer Item; class Stack{private: enum { MAX = 10 }; Item items[MAX]; int top; int total;public: Stack(); ~Stack(); bool isempty()const; bool isfull()const; bool push(const Item &amp; item); bool pop(Item &amp; item);}; #endif // STACK_H_ static.cpp #include #include “stack.h”using namespace std;Stack::Stack(){ top = 0; total = 0;} Stack::~Stack(){ cout &lt;&lt; “Bye!\\\\n”;} bool Stack::isempty()const{ return top == 0;} bool Stack::isfull()const{ return top == MAX;} bool Stack::push(const Item &amp; item){ if (top &lt; MAX) { items[top++] = item; return true; } else return false;} bool Stack::pop(Item &amp; item){ if (top &gt; 0) { item = items[–top]; total +=item.payment; cout &lt;&lt; “PO#” &lt;&lt; item.fullname &lt;&lt; endl; cout &lt;&lt; “Total = “ &lt;&lt; total &lt;&lt; endl; return true; } else return false;} main.cpp #include #include #include “stack.h” int main(){ using namespace std; Stack st; // create an empty stack char ch; CUSTOMER po; cout &lt;&lt; “Please enter A to add a purchase order.\\\\n” &lt;&lt; “P to process a PO,or Q to quit.\\\\n”; while (cin &gt;&gt; ch &amp;&amp; toupper(ch) != ‘Q’) { while (cin.get() != ‘\\\\n’) continue; if (!isalpha(ch)) { cout &lt;&lt; ‘\\\\a’; continue; } switch (ch) { case ‘A’: case ‘a’: cout &lt;&lt; “Enter a PO fullname to add:\\\\t”; cin.getline(po.fullname, 35); cout &lt;&lt; “Enter a PO payment to add:\\\\t”; cin &gt;&gt; po.payment; if (st.isfull()) cout &lt;&lt; “stack already full\\\\n”; else st.push(po); break; case ‘P’: case ‘p’:if (st.isempty()) cout &lt;&lt; “Stack already empty\\\\n”; else st.pop(po); break; } cout &lt;&lt; “Please enter A to add a purchase order,\\\\n” &lt;&lt; “P to process a PO, or Q to quit.\\\\n”; } cout &lt;&lt; “Bye\\\\n”; return 0;} 6. 根据类声明，提供成员函数的定义和测试这个类的程序。 #includeusing namespace std;class Move{private: double x; double y;public: Move(double a = 0, double b = 0); void showmove()const; Move add(const Move &amp;m)const; void reset(double a = 0, double b = 0);};Move::Move(double a, double b){ x = a; y = b;}void Move::showmove()const { cout &lt;&lt; “x= “ &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; “y= “ &lt;&lt; y &lt;&lt; endl;}Move Move::add(const Move &amp; m) const { return Move(x + m.x, y + m.y); }void Move::reset(double a, double b){ x = a; y = b;} int main() { Move move1; cout &lt;&lt; “Move1:\\\\n”; move1.showmove(); Move move2 = Move(2.3, 1.9); cout &lt;&lt; “Move2:\\\\n”; move2.showmove(); move1 = move1.add(move2); cout &lt;&lt; “Move1 after adding move2:\\\\n”; move1.showmove(); move1.reset(); move2.reset(); cout &lt;&lt; “Reset Move1:\\\\n”; move1.showmove(); cout &lt;&lt; “Reset Move2:\\\\n”; move2.showmove(); system(“pause”); return 0; } 备注： 操作系统：Windows 10 x64(1803) 编译器：Microsoft Visual Studio 2015","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++ Primer Plus（第五版）第9章编程题答案","slug":"c-primer-plus-ef-bc-96-e7-a8-8b-e9-a2-98-e7-ad-94-e6-a1-88","date":"2018-11-14T14:22:41.000Z","updated":"2019-03-20T14:39:38.302Z","comments":false,"path":"2018/11/14/c-primer-plus-ef-bc-96-e7-a8-8b-e9-a2-98-e7-ad-94-e6-a1-88/","link":"","permalink":"http://tech.yushuai.xyz/2018/11/14/c-primer-plus-ef-bc-96-e7-a8-8b-e9-a2-98-e7-ad-94-e6-a1-88/","excerpt":"","text":"1. 下面是一个头文件： （……省略……） 根据这个头文件，创建一个多文件程序。其中的一个文件名为golf.cpp，它提供了与头文件中的原型匹配的函数定义；另一个文件应包含main()，并演示原型化函数的所有特性。例如，包含一个让用户输入的循环，并使用输入的数据来填充一个由golf结构组成的数组，数组被填满或用户将高尔夫选手的姓名设置为空字符串时，循环将结束。main()函数只使用头文件中原型化的函数来访问golf结构。 golf.cpp #include #include #include #include”golf.h”using namespace std;void setgolf(golf &amp; g, const char *name, int hc){ strcpy(g.fullname, name); g.handicap = hc;}int setgolf(golf &amp; g){ cout &lt;&lt; “Please enter the full name of golf player: “; cin.getline(g.fullname, Len); if (strcmp(g.fullname, “”) == 0) { return 0; } cout &lt;&lt; &quot;Please enter the hanicap of golf player: &quot;; cin &gt;&gt; g.handicap; cin.get(); return 1; } void handicap(golf &amp; g, int hc){ g.handicap = hc;} void showgolf(const golf &amp; g){ cout &lt;&lt; “Here is the golf contents:\\\\n”; cout &lt;&lt; “Name: “ &lt;&lt; g.fullname &lt;&lt; endl; cout &lt;&lt; “Handicap: “ &lt;&lt; g.handicap &lt;&lt; endl;} 2. 修改程序清单9.8：用string对象代替字符数组。这样，该程序将不再需要检查输入的字符串是否过长，同时可以将输入字符串同字符串“”进行比较，以判断是否为空行。 #include #include #includeusing namespace std;const int ArSize = 10;void strcount(const string &amp; str); int main() { string str; cout &lt;&lt; &quot;Enter a line: \\\\n&quot;; getline(cin, str); while (str != &quot;&quot;) { strcount(str); cout &lt;&lt; &quot;Enter next line(empty line to quit): \\\\n&quot;; getline(cin, str); } cout &lt;&lt; &quot;Bye\\\\n&quot;; system(&quot;pause&quot;); return 0; } void strcount(const string &amp; str){ using namespace std; static int total = 0; int count = 0; cout &lt;&lt; &quot;\\\\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\\\&quot; contains &quot;; count = str.length(); total += count; cout &lt;&lt; count &lt;&lt; &quot; characters\\\\n&quot;; cout &lt;&lt; total &lt;&lt; &quot; characters total\\\\n&quot;; } 3. 下面是一个结构声明： struct chaff { char dross[20]; int slag; }; 编写一个程序，使用定位new运算符将一个包含两个这种结构的数组放在一个缓冲区中。然后，给结构的成员赋值（对于char数组，使用函数strcpy()），并使用一个循环来显示内容。一种方法是像程序清单9.10那样将一个静态数组用作缓冲区；另一种方法是使用常规new运算符来分配缓冲区。 #include #include #includeusing namespace std; struct chaff{ char dross[20]; int slag;};void show_struct(chaff &amp; p);char buffer2[500];int main(){ chaff *p = new(buffer2) chaff[2]; strcpy(p[0].dross, “Yushuai Zhang”); strcpy(p[1].dross, “Shandong Province”); p[0].slag = 23; p[1].slag = 100; for (int i = 0; i &lt; 2; i++) { show_struct(p[i]); } system(&quot;pause&quot;); return 0; } void show_struct(chaff &amp; p){ cout &lt;&lt; “Dross: “ &lt;&lt; p.dross &lt;&lt; endl; cout &lt;&lt; “SLAG: “ &lt;&lt; p.slag &lt;&lt; endl; cout &lt;&lt; endl;} 4. 请基于下面这个名称空间编写一个由3个文件组成的程序： （……省略……） 第一个文件是一个头文件，其中包含名称空间；第二个文件是一个源代码文件，它对这个名称空间进行扩展，以提供这三个函数的定义；第三个文件声明两个Sales对象，并使用setSales()的交互式版本为一个结构提供值，然后使用setSales()的非交互式版本为另一个结构提供值。另外它还使用showSales()来显示这两个结构的内容。 exercise4.h #pragma once #ifndef SALES_H_ #define SALES_H_namespace SALES { const int QUARTERS = 4; struct Sales { double sales[QUARTERS]; double average; double max; double min; }; void setSales(Sales &amp;s); void showSales(const Sales &amp;s);} #endif exercise4_fun.cpp #include #include “exercise4.h”namespace SALES{ void setSales(Sales &amp; s) { using std::cin; using std::cout; using std::endl; cout &lt;&lt; &quot;Enter sales:&quot; &lt;&lt; endl; for (int i = 0; i &lt; QUARTERS; ++i) { cout &lt;&lt; &quot;sales\\[&quot; &lt;&lt; i &lt;&lt; &quot;\\]: &quot;; cin &gt;&gt; s.sales\\[i\\]; } // get average, max, min double sum = 0.0; double max = s.sales\\[0\\], min = s.sales\\[0\\]; for (int i = 0; i &lt; QUARTERS; ++i) { double cur = s.sales\\[i\\]; if (cur &gt; max) max = cur; if (cur &lt; min) min = cur; sum += cur; } s.average = sum / (float)QUARTERS; s.max = max; s.min = min; } void showSales(const Sales &amp; s) { using std::cout; using std::endl; // show sales cout &lt;&lt; &quot;SALES: &quot;; for (int i = 0; i &lt; QUARTERS; ++i) cout &lt;&lt; s.sales\\[i\\] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; // show average cout &lt;&lt; &quot;AVERAGE: &quot; &lt;&lt; s.average &lt;&lt; endl; // show max and min cout &lt;&lt; &quot;MAX: &quot; &lt;&lt; s.max &lt;&lt; endl; cout &lt;&lt; &quot;MIN: &quot; &lt;&lt; s.min &lt;&lt; endl; } } exercise4_main.cpp #include #include “exercise4.h” int main(void){ using namespace SALES; Sales s1; setSales(s1); showSales(s1); system(“pause”); return 0;} 备注： 操作系统：Windows 10 x64(1803) 编译器：Microsoft Visual Studio 2015","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"《C++面向对象程序设计》2018年秋季期末考试答案（选择题）","slug":"e3-80-8ac-e9-9d-a2-e5-90-91-e5-af-b9-e-e9-80-89","date":"2018-11-13T01:57:06.000Z","updated":"2019-03-20T14:42:00.602Z","comments":false,"path":"2018/11/13/e3-80-8ac-e9-9d-a2-e5-90-91-e5-af-b9-e-e9-80-89/","link":"","permalink":"http://tech.yushuai.xyz/2018/11/13/e3-80-8ac-e9-9d-a2-e5-90-91-e5-af-b9-e-e9-80-89/","excerpt":"","text":"1.**关于复制构造函数，下列说法正确的是 A.系统不会生成缺省复制构造函数，因此必须自己实现 B.复制构造函数是形如X::X(X)的函数 C.Myclass c1, c2; c1.n = 1; c2 = c1;第三句将会调用复制构造函数 D.调用函数A Func() { A a(4); return a; }时，将会调用A**的复制构造函数 解析： 只要你不写构造函数，系统就会自动帮你生成缺省的构造函数，包括复制构造函数，故A错误。复制构造函数的格式是X::X(X&amp;)或X::X(const X &amp;)，故B错误。复制构造函数起作用主要有以下三种情况： 1)当用一个对象去初始化同类的另一个对象时； 2)如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用； 3) 如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用。 由此可得，C错误，D正确（第3种情况）。 2.**关于虚函数，下列说法不正确的是 A.不允许以虚函数作为构造函数 B.没有虚函数便无法实现多态 C.**一般来讲，如果一个类中定义了虚函数，则不可将析构函数也定义为虚函数 D.不能用抽象类定义对象 解析： 在学习虚函数的时候，明确说过构造函数和静态函数不能使用virtual，即不能成为虚函数，虚函数是实现多态的基础，在实现多态的时候，析构函数也经常会被定义为虚函数，抽象类是可以定义对象的。这是一个概念题。 3.**关于 this 指针，以下说法不正确的是 A.static成员函数内部不可以使用this指针 B.在构造函数内部可以使用this指针 C.在析构函数内部可以使用 this 指针 D.const成员函数内部不可以使用this 指针 解析： 一个对象的this指针并不是对象本身的一部分，不会影响sizeof（对象）的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。友元函数没有this指针，因为友元不是类的成员。只有成员函数才有this指针。静态成员函数是类的一部分，作用是为了处理静态数据成员，它没有this指针，静态成员函数可以直接访问该类的静态成员，但不能直接访问类中的非静态成员。构造函数、析构函数、const成员函数都是成员函数，故可以使用this指针，静态成员函数因为其设计的原因，不可以使用is指针。 4.以下关于多态的说法那个不正确? A.**在成员函数中调用虚函数，是多态 B.通过“基类对象名.函数名”的方式调用虚函数，不是多态 C.多态的函数调用语句中，函数一定是虚函数 D.通过“基类引用名.函数名”的方式调用虚函数，是多态 解析： 多态的表现形式有以下几种： 1）通过基类指针调用基类和派生类中的同名虚函数时： ①若该指针指向一个基类的对象，那么被调用的是基类的虚函数； ②若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。 2）通过基类引用调用基类和派生类中的同名虚函数时： ①若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数； ②若该引用引用的是一个派生类的对象，那么调用的是派生类的虚函数。 故B、D正确，A错误。要实现多态，函数一定是虚函数，这是定义，故C正确。 5.map**的每个元素包括KEY(first）和VALUE(second)。关于map容器，下列哪种说法错误 A.map支持下标运算符 B.map的不同元素可以有相同的VALUE C.map支持STL的sort**算法 D.map支持双向迭代器 解析： map的设计问题，不做解释，详情可以查看map的具体解析就会明白。 6.**下列说法错误的是 A.可以在一个类的友元函数中使用this**指针 B.每个类只有一个析构函数 C.抽象类至少包含一个纯虚函数 D.构造函数不可以是virtual函数 解析见第**3**题。 7.**关于继承和派生的描述中，下列说法错误的是**: A.派生类的成员函数中，不能访问基类的private成员 B.**在派生类的析构函数执行之前，会先调用基类的析构函数 C.派生类对象的地址可以赋值给基类指针 D.派生类可以有和基类同名同参数的成员函数 解析： 继承的权限如下： 若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限； 若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限； 若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。 故A正确。C正确，实践中已经实现。D可以通过多态来实现。B的正确过程应该是：构造函数先执行基类构造函数，再执行派生类的构造函数，析构函数先执行派生类的构造函数，再执行基类的构造函数。 8.以下哪种使用std::sort**算法的方式是不合法的： A. vector a; …; sort(a.begin(), a.end()); B. bool b[99]; …; sort(b, b + 99); C. string c = “2333”; …; sort(c.begin(), c.end()); D. list d; …; sort(d.begin(), d.end()); 解析： A/B/C均可以实现，list应该使用mylist.sort();这种格式来进行排序。 9.**类A重载的运算符声明是int operator&lt;(A &amp;other) const，那么以下说法中正确的是： A.小于号左侧的A对象不可以是const的 B.小于号右侧的A对象不可以是const**的 C.这个写法是错误的，因为小于号的返回类型必须是bool D.使用小于号的时候，other参数处，传进来的对象实际上会被复制一次 解析： 该运算符使用时类似于c.operator&lt;(other)。小于号左侧的A对象就是这个表达式中的c，是可以const，也可以不const的，但是小于号右侧的A对象是不能为const的，因为若左侧的A对象不是const，根据非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员，那么一旦右侧为const的，这个比较就无法进行了，故A错误，B正确。 返回值为bool类型可以为int，故C错误，声明中参数是引用，故不会被复制一次，D错误。 10.**以下STL中的函数模板哪个可以作用于**set A. sort B. random_shuffle C. find D. 都不行 解析： 见set的使用说明。 本答案解析为本人整理，查阅了有关课本和网上的相关资料，如有转载请注明转载来源。本文首发于本博客（http://www.yushuai.xyz/2018/11/13/4130.html），未来还将发表于我的个人公众号（小奥的学习笔记）和我的GitHub、Gitee主页。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++ Primer Plus（第五版）第8章编程题答案","slug":"c-primer-plus-ef-bc-88-e7-ac-ac-e4-ba-94-e7-89-a2-98-e7-ad-94-e6-a1-88","date":"2018-11-08T13:52:09.000Z","updated":"2019-03-20T14:39:42.486Z","comments":false,"path":"2018/11/08/c-primer-plus-ef-bc-88-e7-ac-ac-e4-ba-94-e7-89-a2-98-e7-ad-94-e6-a1-88/","link":"","permalink":"http://tech.yushuai.xyz/2018/11/08/c-primer-plus-ef-bc-88-e7-ac-ac-e4-ba-94-e7-89-a2-98-e7-ad-94-e6-a1-88/","excerpt":"","text":"1. 编写通常接受一个参数（字符串的地址），并打印该字符串的函数。然而，如果提供了第二个参数（int类型），且该参数不为0，则该函数打印字符串的次数将为该函数被调用的次数（注意，字符串的打印次数不等于第二个参数的值，而等于函数被调用的次数）。是的，这是一个非常可笑的函数，但它让您能够使用本章介绍的一些技术。在一个简单的程序中使用该函数，以演示该函数是如何工作的。 //C++ Primer Plus Edition 5//Chapter 8 Homework 1 #includeusing namespace std;void show_ch(char str, int n = 0);int num = 0;int main(){ char name[10] = “zhang”; cout &lt;&lt; “如果第二个参数为0，那么输出（这是第一次调用）：” &lt;&lt; endl; show_ch(name); cout &lt;&lt; “输出结束” &lt;&lt; endl; cout &lt;&lt; “第二次调用输出结果：” &lt;&lt; endl; show_ch(name, 3); cout &lt;&lt; “第三次调用输出结果：” &lt;&lt; endl; show_ch(name, 9); cout &lt;&lt; “第四次调用输出结果：” &lt;&lt; endl; show_ch(name, 32); cout &lt;&lt; “完成!” &lt;&lt; endl; system(“pause”); return 0;}void show_ch(char str, int n){ ++num; if (n == 0) { cout &lt;&lt; str &lt;&lt; endl; } else for (int i = 0; i &lt; num; i++) cout &lt;&lt; str &lt;&lt; endl;} 2.CandyBar结构包含3个成员。第一个成员存储candy bar的品牌名称；第二个成员存储candy bar的重量（可能有小数）；第三个成员存储candy bar的热量（整数）。请编写一个程序，它使用一个这样的函数，即将CandyBar的引用、char指针、double和int作为参数并用最后3个值设置相应的结构成员。最后3个参数的默认值分别为“Millennium Munch”、2.85和350。另外，该程序还包含一个以CandyBar的引用为参数，并显示结构内容的函数，请尽可能的使用const。 //C++ Primer Plus Edition 5//Chapter 8 Homework 2 #include #includeusing namespace std;struct CandyBar { string name; double weight; int hot;};void set_CandyBar(CandyBar &amp;candy, char* n = “Millennium Munch”, double w = 2.85, int h = 360);void show_CandyBar(const CandyBar &amp;c);int main() { CandyBar candy; set_CandyBar(candy); show_CandyBar(candy); system(“pause”); return 0;} void set_CandyBar(CandyBar &amp;c, char* n, double w, int h){ c.name = n; c.weight = w; c.hot = h; }void show_CandyBar(const CandyBar &amp;c){ cout &lt;&lt; “Name: “ &lt;&lt; c.name &lt;&lt; endl; cout &lt;&lt; “Weight: “ &lt;&lt; c.weight &lt;&lt; endl; cout &lt;&lt; “Hot: “ &lt;&lt; c.hot &lt;&lt; endl;} 3.编写一个函数，它接受一个指向string对象的引用作为参数，并将该string对象的内容转换成大写，为此可使用表6.4描述的函数toupper()。然后编写一个程序，它通过使用一个循环让您能够用不同的输入来测试这个函数。 //C++ Primer Plus Edition 5//Chapter 8 Homework 3 #include #include #includeusing namespace std; string convert_Big(string &amp;str);int main() { string text,up; cout &lt;&lt; “Enter a string (q to quit):” &lt;&lt; endl; getline(cin, text); while (text != “q” &amp;&amp; text!=”Q”) { cout &lt;&lt; convert_Big(text) &lt;&lt; endl; cout &lt;&lt; “Next string (q to quit): “ &lt;&lt; endl; getline(cin, text); } system(&quot;pause&quot;); return 0; }//string可以被看做是字符数组string convert_Big(string &amp; str){ int limit = str.size(); for (int i = 0; i &lt; limit; i++) { if(isalpha(str[i])) str[i] = toupper(str[i]); } return str;} 4.下面是一个程序框架 //省略框架 请提供其中描述的函数和原型，从而完成该程序。注意，应有两个show()函数，每个都使用默认参数。请尽可能的使用const参数。set() 使用new分配足够的空间来存储制定的字符串。这里使用的技术与设计和实现类使用的相似。（可能害必须修改头文件的名称，删除using编译指令，这取决于所用的编译器。） //C++ Primer Plus Edition 5//Chapter 8 Homework 4 #includeusing namespace std; #include struct stringy { char str; int ct;};void show(const char st, int n = 1);void show(const stringy &amp;strc, int n = 1);void set(stringy&amp; st, const char *t); int main() { stringy beany; char testing[] = “Reality isn’t what it used to be.”; set(beany, testing); show(beany); show(beany, 2); testing[0] = ‘D’; testing[1] = ‘u’; show(testing); show(testing, 3); show(“Done!”); system(“pause”); return 0;} void set(stringy &amp;st, const char *n){ st.ct = strlen(n) + 1; st.str = new char[st.ct]; strcpy(st.str, n);}void show(const stringy &amp;strc, int n){ for (int i = 0; i &lt; n; i++) cout &lt;&lt; strc.str &lt;&lt; endl;} void show(const char *st, int n){ for (int i = 0; i &lt; n; i++) { if (strcmp(st, “Done!”) == 0) { cout &lt;&lt; “Done!” &lt;&lt; endl; break; } cout &lt;&lt; st &lt;&lt; endl; } } 5.编写模板函数max5()，它将一个包含5个T类型元素的数组作为参数，并返回数组中最大的元素（由于长度固定，因此可以在循环中使用硬编码，而不必通过参数来传递）。在一个程序中使用该函数，将T替换为一个包含5个int值的数组和一个包含5个double值的数组，以测试该函数。 //C++ Primer Plus Edition 5//Chapter 8 Homework 5 #includeusing namespace std;templateT max5(T *a);int main() { int inte[5] = { 23, 55, 65, 12, 34 }; int max_int = max5(inte); double dou[5] = { 12.3,14.3,11.9,89.6,1.8 }; double max_dou = max5(dou); cout &lt;&lt; “Integer MAX= “ &lt;&lt; max_int &lt;&lt; endl; cout &lt;&lt; “Double MAX= “ &lt;&lt; max_dou &lt;&lt; endl; system(“pause”); return 0;} templateT max5(T *a){ T temp = a[0]; for (int i = 1; i &lt; 5; i++) { if (a[i] &lt; temp) temp = a[i]; } return temp;} 6.编写模板函数maxn()，它将由一个T类型元素组成的数组和一个表示数组元素数目的整数作为参数，并返回数组中最大的元素。在程序对它进行测试，该程序使用一个包含6个int元素的数组和一个包含4个double元素的数组来调用该函数。程序还包含一个具体化，它将char指针数组和数组中的指针数量作为参数，并返回最长的字符串的地址。如果有多个这样的字符串，则返回其中第一个字符串的地址。使用由5个字符串指针组成的数组来测试该具体化。 //C++ Primer Plus Edition 5//Chapter 8 Homework 6 #includeusing namespace std;templateT maxn(T a, const int n);template&lt;&gt; const char maxn(const char **a, const int n); int main(){ int a[6] = {3,6,1,8,2,9 }; double b[4] = { 9.8,8.56,193.1,4.3 }; const char *c[5] = { “HAHAHA”, “BALABALA”, “XIAOMOXIAN”, “hengli”, “very good” }; cout &lt;&lt; maxn(a, 6) &lt;&lt; endl; cout &lt;&lt; maxn(b, 4) &lt;&lt; endl; cout &lt;&lt; maxn(c, 5) &lt;&lt; endl; system(“pause”); return 0;} templateT maxn(T *a, const int n){ for (int i = 0; i &lt; n; i++) if (a[i] &gt; a[0]) a[0] = a[i]; return a[0];} template&lt;&gt; const char maxn(const char *a, const int n){ int i, j = 0; for (i = 0; i&lt;n; i++) if (strlen(a[i])&gt;strlen(a[j])) j = i; return a[j]; } 7.修改程序清单8.14，使其使用两个名为SumArray()的模板函数来返回数组元素的总和，而不是显示数组的内容。程序应显示thing的总和以及所有debt的总和。 //C++ Primer Plus Edition 5//Chapter 8 Homework 7 #includeusing namespace std;templateT ShowArray(T arr[], int n); templateT ShowArray(T arr[], int n);struct debts { char name[50]; double amount;};int main(void) { int things[6] = { 13,31,103,301,310,130 }; struct debts mr_E[3] = { { “Ima Wolfe”,2400.0 }, { “Ura Foxe”,1300.0 }, { “Iby Stout”,1800.0 } }; double pd[3]; for (int i = 0; i &lt; 3; i++) pd[i] = &amp;mr_E[i].amount; cout &lt;&lt; “Listing Mr.E’s counts of things:”; int ans_int = ShowArray(things, 6); cout &lt;&lt; ans_int &lt;&lt; endl; cout &lt;&lt; “Listing Mr.E’s debts:”; double ans_dou= ShowArray(pd, 3); cout &lt;&lt; ans_dou &lt;&lt; endl; system(“pause”); return 0;} template T ShowArray(T arr[], int n) { T ans = arr[0]; cout &lt;&lt; “Template A\\\\n”; for (int i = 1; i &lt; n; i++) ans+=arr[i]; return ans;} templateT ShowArray(Tarr[], int n){ T ans=arr[0]; cout &lt;&lt; “Template B\\\\n”; for (int i = 1; i &lt; n; i++) ans += *arr[i]; return ans;}","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++中的cin, cin.getline, getline等混合使用时不能输入直接执行下一行的问题","slug":"c-cin-cin-getline-getline","date":"2018-11-06T03:06:41.000Z","updated":"2019-03-20T14:42:07.796Z","comments":false,"path":"2018/11/06/c-cin-cin-getline-getline/","link":"","permalink":"http://tech.yushuai.xyz/2018/11/06/c-cin-cin-getline-getline/","excerpt":"","text":"每次cin&gt;&gt;之后，缓冲区内会多出来一个回车符，这个回车符对cin&gt;&gt;不会有影响，但是对于cin.getline()函数和getline()函数就会产生影响，导致还不等你输入，就直接把输入语句执行语句运行结束了，直接去运行后面的程序了；解决方法就是养成习惯，每次cin&gt;&gt;之后，都加一句“cin.get();”或者“cin.ignore();”，而且这两句也不会影响连续多次cin&gt;&gt;的正常工作。 特别提示，在普通语句中可能很容易发现cin&gt;&gt;后面使用了cin.getline()或者getline()，但是在存在循环时就很容易忽略cin&gt;&gt;出现在cin.getline()函数和getline()函数的前面，因为一次循环执行结束之后，多出来的回车符还是会在缓冲区里，还是会对接下来的输入产生影响。 ——————— 作者：Leonardo Liu 来源：CSDN 原文：https://blog.csdn.net/leowinbow/article/details/82190631 版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++ Primer Plus（第五版）第7章编程题答案","slug":"c-primer-plus-ef-bc-88-e7-ac-ac-e-8b-e9-a2-98-e7-ad-94-e6-a1-88","date":"2018-11-06T03:03:29.000Z","updated":"2019-03-20T14:39:46.036Z","comments":false,"path":"2018/11/06/c-primer-plus-ef-bc-88-e7-ac-ac-e-8b-e9-a2-98-e7-ad-94-e6-a1-88/","link":"","permalink":"http://tech.yushuai.xyz/2018/11/06/c-primer-plus-ef-bc-88-e7-ac-ac-e-8b-e9-a2-98-e7-ad-94-e6-a1-88/","excerpt":"","text":"1. 编写一个程序，不断要求用户输入两个数，直到其中的一个为0。对于每两个数，程序将使用一个函数来计算它们的调和平均数，并将结果返回给main()，而后者将报告结果。调和平均数指的是倒数平均值的倒数，计算公式如下： 调和平均数=2.0*x*y/(x+y) //C++ Primer Plus Edition 5//Chapter 7 Homework 1 #includeusing namespace std;double heaver(int m, int n);int main() { double m, n, ans; cout &lt;&lt; “Please input two numbers: “; cin &gt;&gt; m &gt;&gt; n; while (m != 0 &amp;&amp; n != 0) { ans = heaver(m, n); cout &lt;&lt; “The answer is “ &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; “Please input two numbers: “; cin &gt;&gt; m &gt;&gt; n; } cout &lt;&lt; &quot;Done!&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } double heaver(int m, int n) { double res; res = 2.0*m*n / (m + n); return res;} 2. 编写一个程序，要求用户输入最多10个高尔夫成绩，并将其存储在一个数组中。程序允许用户提早结束输入，并在一行上显示所有成绩，然后报告平均成绩。请使用3个数组处理函数来分别进行输入、显示和计算平均成绩。 //C++ Primer Plus Edition 5//Chapter 7 Homework 2 #includeusing namespace std;const int MAXSIZE = 10;int fill_array(double scores[], int limit);void show_array(const double ar[], int n);double aver_array(double arc[], int n);int main() { double scores[MAXSIZE]; double average; cout &lt;&lt; “Please enter ten scores:” &lt;&lt; endl; int size = fill_array(scores, MAXSIZE); cout &lt;&lt; “The scores are:” &lt;&lt; endl; show_array(scores, size); average = aver_array(scores, size); cout &lt;&lt; “The average score is “ &lt;&lt; aver_array(scores, size) &lt;&lt; endl; system(“pause”); return 0;}int fill_array(double scores[], int limit) { double temp; int i; for (i = 0; i &lt; limit; i++) { cout &lt;&lt; “Enter Score #” &lt;&lt; i &lt;&lt; “: “; cin &gt;&gt; temp; if (!cin) { cin.clear(); while (cin.get() != ‘\\\\n’) continue; break; } else if (temp &lt; 0) break; scores[i] = temp; } return i; }void show_array(const double ar[], int n) { for (int i = 0; i &lt; n; i++) { cout &lt;&lt; “Score #” &lt;&lt; (i + 1) &lt;&lt; “: “ &lt;&lt; ar[i] &lt;&lt; endl; }}double aver_array(double arc[], int n) { double total = 0; double average; for (int i = 0; i &lt; n; i++) { total += arc[i]; } average = total / n; return average; } 3.下面是一个结构声明： //省略 a. 编写一个函数，按值传递box结构，并显示每个成员的值。 b. 编写一个函数，传递box结构的地址，并将volume成员设置为其他三维长度的乘积。 c. 编写一个使用这两个函数的简单程序。 //C++ Primer Plus Edition 5//Chapter 7 Homework 3 #includeusing namespace std;struct box { char maker[40]; float height; float width; float length; float volume;};void show_box(box member);void set_box(box *pmember);int main() { box b = { “Yu Shuai”,3,2,1,1 }; show_box(b); set_box(&amp;b); show_box(b); system(“pause”); return 0;}void show_box(box member) { cout &lt;&lt; “Box’s Maker: “ &lt;&lt; member.maker &lt;&lt; endl; cout &lt;&lt; “Box’s height: “ &lt;&lt; member.height &lt;&lt; endl; cout &lt;&lt; “Box’s width: “ &lt;&lt; member.width &lt;&lt; endl; cout &lt;&lt; “Box’s length: “ &lt;&lt; member.length &lt;&lt; endl; cout &lt;&lt; “Box’s volume: “ &lt;&lt; member.volume &lt;&lt; endl;} void set_box(box pmember) { (\\pmember).volume = (*pmember).height(\\pmember).length*(*pmember).width;} 4. 许多州的彩票发行结构都使用如程序清单7.4所示的简单彩票玩法的变体。在这些玩法中，玩家从一组被称为域号码（field number）的号码中选择几个。例如，可以从域号码1~47中选择5个号码；还可以从第二个区间（如1~27）选择一个号码（称为特选号码）。要赢得头奖，必须正确猜中所有的号码。中头奖的几率是选中所有域号码的几率与选中号码几率的乘积。例如，在这个例子中，中头奖的几率是从47个号码中正确选取5个号码的几率与从27个号码中正确选择1个号码的几率的乘积。请修改程序清单7.4，以计算中得这种彩票头奖的几率。 //C++ Primer Plus Edition 5//Chapter 7 Homework 4 #includeconst int n1 = 5;const int num1 = 47;const int n2 = 1;const int num2 = 27;long double odds(unsigned num, unsigned n);int main(){using namespace std;double odds1 = odds(num1, n1);double odds2 = odds(num2, n2);cout &lt;&lt; “中头奖的几率为: “ &lt;&lt; odds1odds2 &lt;&lt; endl;system(“pause”);return 0;}long double odds(unsigned num, unsigned n){using namespace std;long double res = 1.0;for (num, n; n &gt; 0; n–, num–)res = res n / num;return res;} 5. 定义一个递归函数，接受一个整数参数，并返回该参数的阶乘。前面讲过，3的阶乘写作3！，等于3*2！，依此类推；而0！被定义为1。通用的计算公式是，如果n大于零，则n!=n*(n-1)!。在程序中对该函数进行测试，程序使用循环让用户输入不同的值，程序将报告这些值的阶乘。 //C++ Primer Plus Edition 5//Chapter 7 Homework 5 #includeusing namespace std;int factorial(int n);int main() { int n, ans; cout &lt;&lt; “Please input an integer: “; cin &gt;&gt; n; ans = factorial(n); cout &lt;&lt; “The answer is “ &lt;&lt; ans &lt;&lt; endl; system(“pause”); return 0;}int factorial(int n) { int res = 1; if (n &gt; 1) res = n*factorial(n-1); return res;} 6.编写一个程序，它使用下列函数： Fill_array()将一个double数组的名称和长度作为参数。它提示用户输入double值，并将这些值存储到数组中。当数组被填满或用户输入了非数字时，输入将停止，并返回实际输入了多少个数字。 Show_array()将一个double数组的名称和长度作为参数，并显示该数组的内容。 Reverse_array()将一个double数组的名称和长度作为参数，并将存储在数组中的值的顺序反转。 程序将使用这些函数来填充数组，然后显示数组；反转数组，然后显示数组；反转数组中除第一个和最后一个元素之外的所有元素，然后显示数组。 //C++ Primer Plus Edition 5//Chapter 7 Homework 6 #includeint fill_array(double ar[], int limit);void show_array(double ar[], int size);void reverse_array(double ar[], int size);using namespace std;const int MAXSIZE = 20;int main(){ int n; double shuzu[MAXSIZE]; int size = fill_array(shuzu, MAXSIZE); show_array(shuzu, size); reverse_array(shuzu, size); cout &lt;&lt; “反转结果：” &lt;&lt; endl; show_array(shuzu, size); system(“pause”); return 0;}int fill_array(double ar[], int limit){ double temp; int i; for (i = 0; i&lt;limit; i++) { cout &lt;&lt; “Enter value#” &lt;&lt; (i + 1) &lt;&lt; “ \\\\n”; cin &gt;&gt; temp; if (!cin) { cin.clear(); cout &lt;&lt; “bad input:\\\\n”; break; } else ar[i] = temp; } return i;}void show_array(double ar[], int size){ for (int i = 0; i&lt;size; i++) cout &lt;&lt; “Value #” &lt;&lt; (i + 1) &lt;&lt; “: “ &lt;&lt; ar[i] &lt;&lt; endl;;}void reverse_array(double ar[], int size){ int i, j; for (i = 1, j = size - i - 1; i&lt;j; i++, j–) { double temp = ar[i]; ar[i] = ar[j]; ar[j] = temp; }} 7. 修改程序清单7.7中的3个数组处理函数，使之使用两个指针参数来表示区间。fill_array()函数不返回实际读取了多少个数字，而是返回一个指针，该指针指向最后被填充的位置；其他的函数可以将该指针作为第二个参数，以标识数据结尾。 //C++ Primer Plus Edition 5//Chapter 7 Homework 7 #includeusing namespace std;const int Max = 5;double fill_array(double \\ar, double *limit);void show_array(const double *ar, double *n);void revalue(double r, double *ar, double *n); int main() { double properties[Max]; double size = fill_array(properties, properties+Max); show_array(properties, size); cout &lt;&lt; “Enter revaluation factor: “; double factor; cin &gt;&gt; factor; revalue(factor, properties, size); show_array(properties, size); cout &lt;&lt; “Done.\\\\n”; system(“pause”); return 0;}double \\fill_array(double *ar, double limit) { double temp; double p; for (p=ar; p &lt; limit; p++) { cout &lt;&lt; “Enter value: “; cin &gt;&gt; temp; if (!cin) { cin.clear(); while (cin.get() != ‘\\\\n’) continue; cout &lt;&lt; “Bad input;input process terminated.\\\\n”; break; } else if (temp &lt; 0) break; *p = temp; } return p;} void show_array(const double *ar, double *n) { for (const double p = ar; p &lt; n; p++) { cout &lt;&lt; “Property: $”; cout &lt;&lt; p &lt;&lt; endl; }} void revalue(double r, double *ar, double *n) { for (ar; ar &lt; n; ar++) (*ar) *= r;} 第8~9题未做。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++ Primer Plus（第五版）第6章编程题答案","slug":"c-primer-plus-ef-bc-88-e7-a8-8b-e9-a2-98-e7-ad-94-e6-a1-88","date":"2018-10-26T09:14:52.000Z","updated":"2019-03-20T14:39:49.421Z","comments":false,"path":"2018/10/26/c-primer-plus-ef-bc-88-e7-a8-8b-e9-a2-98-e7-ad-94-e6-a1-88/","link":"","permalink":"http://tech.yushuai.xyz/2018/10/26/c-primer-plus-ef-bc-88-e7-a8-8b-e9-a2-98-e7-ad-94-e6-a1-88/","excerpt":"","text":"第1题： //C++ Primer Plus Edition 5//Chapter 6 Homework 1 #include #includeusing namespace std;int main() { cout &lt;&lt; “Enter text for analysis and type @” “to terminate input.\\\\n”; char ch; cin.get(ch); while (ch != ‘@’) { if (!isdigit(ch)) { if (islower(ch)) ch = toupper(ch); else if (isupper(ch)) ch = tolower(ch); cout &lt;&lt; ch; } cin.get(ch); } system(&quot;pause&quot;); return 0; }//错误代码，判断如果是数字执行continue的话就会循环判断字符是不是等于@，第一个字符就无限循环。//else同样。//while (ch != ‘@’) {// if (isdigit(ch))// continue;// else if (isalpha(ch))// {// cout &lt;&lt; ch &lt;&lt; endl;// if (islower(ch))// ch = toupper(ch);// else if (isupper(ch))// ch = tolower(ch);// cout &lt;&lt; ch;// }// else// continue;//} 第2题： //C++ Primer Plus Edition 5//Chapter 6 Homework 2 #include #includeconst int SIZE = 10;using namespace std;int main() { double donation[10]; double average; int countbig = 0; int count=0; double sum = 0.0; cout &lt;&lt; “Enter 10 numbers.If you want to quit, just input @:” &lt;&lt; endl; for (int i = 0; i &lt; SIZE; i++) { cin &gt;&gt; donation[i]; if (cin.fail()) break; else { sum += donation[i]; ++count; } } average = sum / count; cout &lt;&lt; “The average number is: “ &lt;&lt; average &lt;&lt; endl; for (int i = 0; i &lt; count; i++) { if (donation[i] &gt; average) ++countbig; } cout &lt;&lt; countbig &lt;&lt; “ numbers bigger than average.\\\\n”; system(&quot;pause&quot;); return 0; } 第3题： //C++ Primer Plus Edition 5//Chapter 6 Homework 3 #include #includeusing namespace std;void showmenu();int main() { showmenu(); char choice; cin.get(choice); while ((choice != ‘c’) &amp;&amp; (choice != ‘p’) &amp;&amp; (choice != ‘t’) &amp;&amp; (choice != ‘g’)) { cout &lt;&lt; “Please enter a c,p,t,g: “; //cin.get(choice); cin.ignore(); } switch (choice) { case ‘c’: cout &lt;&lt; “This is carnivore’s answer.\\\\n”; break; case ‘p’: cout &lt;&lt; “This is pianist’s answer.\\\\n”; break; case ‘t’: cout &lt;&lt; “A maple is a tree.\\\\n”; break; case ‘g’: cout &lt;&lt; “This is game’s answer.\\\\n”; break; default: break; } system(“pause”); return 0;} void showmenu() { cout &lt;&lt; “Please enter one of the following choices.\\\\n” “c)carnivore p)pianist\\\\n” “t)tree g)game\\\\n”;} 第4题： //C++ Primer Plus Edition 5//Chapter 6 Homework 4 #include #includeusing namespace std;//函数void showmenu();void dis_by_name();void dis_by_title();void dis_by_bop();void dis_by_pre();//定义常量const int strsize = 30;const int NUM = 5;//定义结构体struct bop { char fullname[strsize]; char title[strsize]; char bopname[strsize]; int preference;//0=fullname,1=title,2=bopname};bop people[5] = { { “Wimp Macho”, “BOSS”, “WM”, 0 }, { “Raki Rhodes”, “Manager”, “Junior Programmer”, 2 }, { “Celia Laiter”, “MIPS”, “CL”, 1 }, { “Hoppy Hipman”, “Analyst Trainee”, “AT”, 1 }, { “Pat Hand”, “Student”, “LOOPY”, 2 }};char ch;//开始主函数int main() { showmenu(); cin &gt;&gt; ch; while ((ch != ‘a’) &amp;&amp; (ch != ‘b’) &amp;&amp; (ch != ‘c’) &amp;&amp; (ch != ‘d’) &amp;&amp; (ch != ‘q’)) { showmenu(); //cin.get(choice); cin.ignore(); } while (ch != ‘q’) { switch (ch) { case ‘a’: dis_by_name(); break; case ‘b’: dis_by_title(); break; case ‘c’: dis_by_bop(); break; case ‘d’: dis_by_pre(); break; default: break; } cout &lt;&lt; “Next choice:” &lt;&lt; endl; cin &gt;&gt; ch; while ((ch != ‘a’) &amp;&amp; (ch != ‘b’) &amp;&amp; (ch != ‘c’) &amp;&amp; (ch != ‘d’) &amp;&amp; (ch != ‘q’)) { showmenu(); //cin.get(choice); cin.ignore(); } } cout &lt;&lt; &quot;Bye!&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } void showmenu() { cout &lt;&lt; “Please enter one of the following choices.\\\\n” “a)display by name b)display by title\\\\n” “c)display by bopname d)display by preference\\\\n” “q)game\\\\n”;}void dis_by_name() { for (int i = 0; i &lt; NUM; ++i) { cout &lt;&lt; people[i].fullname &lt;&lt; endl; }}void dis_by_title() { for (int i = 0; i &lt; NUM; ++i) { cout &lt;&lt; people[i].title &lt;&lt; endl; }}void dis_by_bop() { for (int i = 0; i &lt; NUM; ++i) { cout &lt;&lt; people[i].bopname &lt;&lt; endl; }}void dis_by_pre() { for (int i = 0; i &lt; NUM; ++i) { if(people[i].preference==0) cout &lt;&lt; people[i].fullname &lt;&lt; endl; else if(people[i].preference==1) cout&lt;&lt; people[i].title &lt;&lt; endl; else cout &lt;&lt; people[i].bopname &lt;&lt; endl; }} 第5题： //C++ Primer Plus Edition 5//Chapter 6 Homework 5 #includeconst double level1 = 0.1;const double level2 = 0.15;const double level3 = 0.2;using namespace std;int main() { double tvarp; double cus; cout &lt;&lt; “Please input your money: “; cin &gt;&gt; tvarp; while (cin.good() &amp;&amp; (tvarp &gt; 0)) { if (tvarp &lt;= 5000) cus = 0.0; else if (tvarp &gt; 5000 &amp;&amp; tvarp &lt;= 15000) cus = (tvarp - 5000)level1; else if (tvarp &gt; 15000 &amp;&amp; tvarp &lt;= 35000) cus = 10000 level1 + (tvarp - 15000)level2; else if (tvarp &gt; 35000) cus = 10000 level1 + 20000 level2 + (tvarp - 35000)level3; cout &lt;&lt; “您需要交税” &lt;&lt; cus &lt;&lt; “ tvarp.\\\\n”; cout &lt;&lt; “Please input your money: “; cin &gt;&gt; tvarp; } cout &lt;&lt; “Bye\\\\n”; system(&quot;pause&quot;); return 0; } 第6题： //C++ Primer Plus Edition 5//Chapter 6 Homework 6 #include #include #includeusing namespace std;struct donation{ string name; double money; };int main() { int num; int count = 0; cout &lt;&lt; “Please input the number of donationer: “; cin &gt;&gt; num; cin.get();//吃掉换行符 donation donaer = new donation[num]; for (int i = 0; i &lt; num; i++) { cout &lt;&lt; “Enter the name: “; getline(cin, donaer[i].name); cout &lt;&lt; “Enter money: “; cin &gt;&gt; donaer[i].money; cin.get();//吃掉换行符 } cout &lt;&lt; “**“ &lt;&lt; endl; cout &lt;&lt; “Grand Patrons” &lt;&lt; endl; cout &lt;&lt; “**“ &lt;&lt; endl; for (int i = 0; i &lt; num; i++) { if (donaer[i].money &gt; 10000) { ++count; cout &lt;&lt; “Name: “ &lt;&lt; donaer[i].name &lt;&lt; endl; cout &lt;&lt; “Donate Money: “ &lt;&lt; donaer[i].money &lt;&lt; endl; cout &lt;&lt; endl; } } if (count == 0) { cout &lt;&lt; “None” &lt;&lt; endl; } count = 0; cout &lt;&lt; “**“ &lt;&lt; endl; cout &lt;&lt; “Patrons” &lt;&lt; endl; cout &lt;&lt; “*“ &lt;&lt; endl; for (int i = 0; i &lt; num; i++) { if (donaer[i].money &lt;= 10000) { ++count; cout &lt;&lt; “Name: “ &lt;&lt; donaer[i].name &lt;&lt; endl; cout &lt;&lt; “Donate Money: “ &lt;&lt; donaer[i].money &lt;&lt; endl; cout &lt;&lt; endl; } } if (count == 0) { cout &lt;&lt; “None” &lt;&lt; endl; } delete[] donaer; system(“pause”); return 0;} 第7题： //C++ Primer Plus Edition 5//Chapter 6 Homework 7 #include #include #includeusing namespace std;int main() { string word; char ch; int yuan = 0; int fu = 0; int others = 0; cin &gt;&gt; word; while (word != “q”) { ch = word[0]; if (isalpha(ch)) { if (ch == ‘a’ || ch == ‘e’ || ch == ‘i’ || ch == ‘o’ || ch == ‘u’ || ch == ‘A’ || ch == ‘E’ || ch == ‘I’ || ch == ‘O’ || ch == ‘U’) ++yuan; else ++fu; } else ++others; cin &gt;&gt; word; } cout &lt;&lt; yuan &lt;&lt; “ words beginning with vowels.” &lt;&lt; endl; cout &lt;&lt; fu &lt;&lt; “ words beginning with consonants.” &lt;&lt; endl; cout &lt;&lt; others &lt;&lt; “ others.” &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 第8题： //C++ Primer Plus Edition 5//Chapter 6 Homework 8 #include #include #includeusing namespace std;const int MAXSIZE = 50;int main() { char filename[MAXSIZE]; ifstream inFile; cout &lt;&lt; “Please enter the file’s name: “; cin.getline(filename, MAXSIZE); inFile.open(filename); if (!inFile.is_open()) { cout &lt;&lt; “Open this file error.”&lt;&lt;endl; exit(EXIT_FAILURE); } char ch; int count = 0; inFile &gt;&gt; ch; while (inFile.good()) { ++count; inFile &gt;&gt; ch; } if (inFile.eof()) { cout &lt;&lt; “Have reached end of this file.\\\\n”; } else if (inFile.fail()) { cout &lt;&lt; “Input terminated by data mismatch.\\\\n”; } else cout &lt;&lt; “unknown reason to stop.\\\\n”; if (count == 0) { cout &lt;&lt; “No data in this file.\\\\n”; } else { cout &lt;&lt; “There are “ &lt;&lt; count &lt;&lt; “ characters in this file.\\\\n”; } inFile.close(); system(“pause”); return 0;} 第9题： //C++ Primer Plus Edition 5//Chapter 6 Homework 9 #include #include #include #includeusing namespace std;const int MAXSIZE = 50;struct donation{ string name; double money; };int main() { char filename[MAXSIZE]; ifstream inFile; cout &lt;&lt; “Please enter the file’s name: “; cin.getline(filename, MAXSIZE); inFile.open(filename); if (!inFile.is_open()) { cout &lt;&lt; “Open this file error.” &lt;&lt; endl; exit(EXIT_FAILURE); } int num; int count = 0; inFile &gt;&gt; num; inFile.get();//吃掉换行符 donation donaer = new donation[num]; for (int i = 0; i &lt; num; i++) { getline(inFile, donaer[i].name); inFile &gt;&gt; donaer[i].money; inFile.get();//吃掉换行符 } cout &lt;&lt; “**“ &lt;&lt; endl; cout &lt;&lt; “Grand Patrons” &lt;&lt; endl; cout &lt;&lt; “**“ &lt;&lt; endl; for (int i = 0; i &lt; num; i++) { if (donaer[i].money &gt; 10000) { ++count; cout &lt;&lt; “Name: “ &lt;&lt; donaer[i].name &lt;&lt; endl; cout &lt;&lt; “Donate Money: “ &lt;&lt; donaer[i].money &lt;&lt; endl; cout &lt;&lt; endl; } } if (count == 0) { cout &lt;&lt; “None” &lt;&lt; endl; } count = 0; cout &lt;&lt; “**“ &lt;&lt; endl; cout &lt;&lt; “Patrons” &lt;&lt; endl; cout &lt;&lt; “*“ &lt;&lt; endl; for (int i = 0; i &lt; num; i++) { if (donaer[i].money &lt;= 10000) { ++count; cout &lt;&lt; “Name: “ &lt;&lt; donaer[i].name &lt;&lt; endl; cout &lt;&lt; “Donate Money: “ &lt;&lt; donaer[i].money &lt;&lt; endl; cout &lt;&lt; endl; } } if (count == 0) { cout &lt;&lt; “None” &lt;&lt; endl; } delete[] donaer; inFile.close(); system(“pause”); return 0;}","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++ Primer Plus（第五版）第5章编程题答案","slug":"c-primer-plus-ef-bc-88-e7-ac-ac-e4-ba-94-e7-89-88-ef-bc-89chapter5-e7-bc-96-e","date":"2018-10-18T08:00:48.000Z","updated":"2019-03-20T14:39:53.354Z","comments":false,"path":"2018/10/18/c-primer-plus-ef-bc-88-e7-ac-ac-e4-ba-94-e7-89-88-ef-bc-89chapter5-e7-bc-96-e/","link":"","permalink":"http://tech.yushuai.xyz/2018/10/18/c-primer-plus-ef-bc-88-e7-ac-ac-e4-ba-94-e7-89-88-ef-bc-89chapter5-e7-bc-96-e/","excerpt":"","text":"第五章编程题因为时间原因我就只做了前两个题，从第6章开始全部都做。 5.1输入2个整数，输出这2个之间（包括这两个）所有整数和 代码如下： #include #include using namespace std; int main() { int a, b; int sum = 0; cout &lt;&lt; &quot;Enter two number:&quot; &lt;&lt; endl; cin &gt;&gt; a &gt;&gt; b; if (a &lt; b) { for (int i = a; i &lt;= b; i++) sum += i; } else if (a &gt; b) { for (int i = b; i &lt;= a; i++) sum += i; } cout &lt;&lt; sum &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 5.2 编写一个整数输入程序，每输入一个数，显示累计和，输入0停止 #include #include using namespace std; int main() { int i; int count=0; cout &lt;&lt; &quot;Enter number:&quot; &lt;&lt; endl; cin &gt;&gt; i; while (i != 0) { count += i; cout &lt;&lt;&quot;到目前的和为&quot; &lt;&lt; count &lt;&lt; endl; cin &gt;&gt; i; } system(&quot;pause&quot;); return 0; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++必读书籍推荐","slug":"c-e5-bf-85-e8-af-bb-e4-b9-a6-e7-b1-8d-e6-8e-a8-e8-8d-90","date":"2018-09-28T01:02:58.000Z","updated":"2019-03-20T14:40:58.140Z","comments":false,"path":"2018/09/28/c-e5-bf-85-e8-af-bb-e4-b9-a6-e7-b1-8d-e6-8e-a8-e8-8d-90/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/28/c-e5-bf-85-e8-af-bb-e4-b9-a6-e7-b1-8d-e6-8e-a8-e8-8d-90/","excerpt":"","text":"本文内容来自国外著名编程问答网站Stackoverflow评选的C++推荐书单！推荐大家看原版英文，但这些书大部分也都有中文版！ 本文全文转载自http://bestcbooks.com/recommended-cpp-books/，感谢原作者对于本篇文章的整理~ 手册类 – 所有级别 C++程序设计语言(The C++ Programming Language) 作者：Bjarne Stroustrup(更新到C++11)C++之父写的经典C++书籍。内容覆盖C++的所有东西，从语言内核到标准库、编程范式和语言哲学(这使得最新版突破1千页)。2013年5月出版的第四版涵盖了C++11的内容。 电子书：第三版（中文）、第四版（英文） C++标准程序库(C++ Standard Library Tutorial and Reference) 作者：Nicolai Josuttis (更新到C++11) 这本书是C++标准库（STL）的引导和手册。 2012年4月发行的第二版涵盖了C++11。 电子书：第一版（中文）、第一版（英文）、第二版（英文） The C++ IO Streams and Locales 作者：Angelika Langer and Klaus Kreft 除了这本书，市面上基本没有讲解streams and locales的书。 电子书：96年版（英文） C++ 11手册: The C++ Standard (INCITS/ISO/IEC 14882-2011) 作者：C++标准委员会 这当然是C++最权威的标准。要注意的是，C++标准是提供给有足够精力和时间的专家级用户研究用的。国内估计很少有人看，在国外一般它的第一个发行版也非常贵($300+ US)，国外有人会买现在价值$30US的电子发行版。 电子书：N3225（英文） Overview of the New C++ (C++11/14) 作者：Scott Meyers(更新到C++11/C++14) 这是Scott Meyers开设的一个为期3天的C++课程的教材。Scott Meyers是C++社区最受尊敬的作者之一。虽然内容比较简短，但质量极高。 电子书：2011年版（英文） 初级入门如果你是一个无编程经验的C++初学者，或者有其它语言经验的C++初学者，那强烈推荐下面的书籍。 C++ Primer 1 作者：Stanley Lippman, Josée Lajoie, and Barbara E. Moo (更新到C++11) 近1千页，本书透彻的介绍了C++，以浅显和详细的方式讲到C++语言差不多所有内容。2012年8月发行的第五版包含C++11的内容。 电子书：第三版（中文）、第四版（中文）、第五版（英文版） Accelerated C++ 作者：Andrew Koenig and Barbara Moo 这本书覆盖了和C++ Primer一样的内容，但厚度只有C++ Primer的四分之一。这主要是因为本书面向的不是编程的初学者，而是有其它语言经验的C++初学者。对于初学者，本书学习曲线稍显陡峭，但对于能克服这一点的学习者而言，它确实非常紧凑的介绍了C++这门语言。 电子书：中文版，英文版 C++编程思想（Thinking in C++) 作者：Bruce Eckel 共两卷，第二卷主要将标准库，但还是不错的。 电子书：第二版V1（英文版）、第二版V2（英文版）、第二版V1（中文版）、第二版V2（中文版） C++程序设计原理与实践 （Programming: Principles and Practice Using C++ ）作者：Bjarne Stroustrup C++之父写的C++入门书籍。本书面向没有编程经验的初学者，但相信有编程经验的人也能从本书中学到不少东西。 电子书：中文版 最实用 Effective C++ 作者：Scott Meyers 本书以瞄准成为C++程序员必读的第二本书籍而写，Scott Meyers成功了。早期的版本面向从C语言转过来的程序员。第三版修改为面向从类似Jave等语言转来的程序员。内容覆盖了50多个很容易记住的条款，每个条款深入浅出（并且有趣）讲到了你可能没有考虑过的C++规则。 电子书：第二版（英文）、第三版（英文）、第三版（中文) Effective STL 作者：Scott Meyers 讲解方式和Effective类似，但内容主要面向于STL。 电子书：中文版，英文版 中级 More Effective C++ 作者：Scott Meyers 更多（深入）关于C++的规则。没有前一本Effective C++重要。但同样值得一读。 电子书：中文版 Exceptional C++ 作者：Herb Sutter 讲解方式为提出并解决一系列的C++难题。本书极其透彻的讲解了C++资源管理、异常安全和RAII。同时覆盖了一些较为深入的技术，比如：编译防火墙（pimpl idiom)、名字查找规则,、好的类设计和C++内存模型。 电子书：中文版，英文版 More Exceptional C++ 作者：Herb Sutter 讲到了Exceptional C++没有涉及到的更高级的异常安全技术, 同时讨论了高效的C++ OOP方式和如何正确的使用STL。 电子书：中文版，英文版 Exceptional C++ Style 作者：Herb Sutter 讨论了泛型编程、最优化和资源管理。本书出彩之处在于谈到了如何用非成员函数和单职责原则编写模块化的C++代码。 电子书：中文版 C++编程规范(C++ Coding Standards) 作者：Herb Sutter and Andrei Alexandrescu “编程规范”这里并不是”代码缩进要用几个空格”。这本书包含了101个例子、惯用法、缺陷，通过这些可以帮助你编写正确、清晰高效的C++代码。 电子书：中文版 C++ 模板完全指南(C++ Templates: The Complete Guide)作者：David Vandevoorde and Nicolai M. Josuttis 本书是关于C++11之前的模板的。它覆盖了从非常基础到最高级的元编程知识，解释了模板工作原理的细节(概念和实现方式）。并且讨论了大量的缺陷。附录中包含关于ODR和重载的精彩总结。 电子书：中文版、英文版 高级 C++设计新思维-泛型编程与设计模式之应用(Modern C++ Design ) 作者：Andrei Alexandrescu 泛型编程鼻祖级书籍。本书先介绍了基于策略（policy-based)的设计、type lists 和泛型编程基础， 然后讲到了许多有用的设计模式(包括small object allocators, functors, factories, visitors, and multimethods) 如何被高效、模块化、清晰的泛型代码实现。 电子书：中文版、英文版(en)(271s).pdf) C++模板元编程(C++ Template Metaprogramming)作者：David Abrahams and Aleksey Gurtovoy 更多的是讲解boost::mpl，想要深入理解mpl的可以看一下。 电子书：中文版 C++ Concurrency In Action 作者：Anthony Williams 这本书主要内容是C++11的并发支持，包括线程库、原子(atomics)库、内存模型、锁和互斥量。同时也讲解了开发和调试多线程程序的一些难题。 电子书：英文版 Advanced C++ Metaprogramming 作者：Davide Di Gennaro 前C++11时代TMP技术的手册级书籍。本书更侧重于工程实践。里面有大量的可能几乎无人知道但很实用的技术写成的代码。本书可能比Alexandrescu的书更值得读。对于资深的开发者来说，这是一个学习C++暗角技术的绝佳机会，通常这些技术要通过资深的编程经历才能获取。 电子书：没找到 经典 / 古老注意: 下列书中的部分内容可能有些过时 C++的设计与演化(The Design and Evolution of C++ )作者：Bjarne Stroustrup 如果你想知道为什么C++是今天这个样子，那么这本书将给你答案。本书覆盖C++标准化之前的一切东西。 电子书：中文版 C++沉思录(Ruminations on C++) 作者：Andrew Koenig and Barbara Moo 本书不是为了讲解具体的C++技术细节，而是如何通过C++编写出色的OO代码。 电子书：中文版 Advanced C++ Programming Styles and Idioms 作者：James Coplien 讲解了一些C++特有的惯用法. 它确实是一本不错的书籍，如果时间闲暇也可一读。不过它确实很老了，可能有些不符合现代的C++。 电子书：中文版 大规模C++程序设计（Large Scale C++ Software Design） 作者：John Lakos 本书介绍了如何管理大规模C++软件项目的技术。很值得一读，除了有些过时以外。它是在C++98以前写的，缺少了好多对大规模项目重要的特性（比如名字空间）。假如你工作在一个大规模的C++项目中，你可能想要读它, 不过你需要注意那些不适用甚至错误的技术点。 电子书：中文版 深度探索C++对象模型 (Inside the C++ Object Model ) 作者：Stanley Lippman 如果你想知道虚函数是如何实现、多继承时基类是如何在内存中排布的和所有影响性能的东西，那么这本书会给你答案。不过这本书有好多低级的拼写排版错误，英文原版错误更多，侯捷翻译的版本中注明和纠正了很多，但本书绝对值得一读，你将明白编译器如何实现C++的对象模型。 电子书：中文版、英文版 不要和 C++ Primer Plus (Stephen Prata)搞混了。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++面向对象程序设计课程笔记（第十周）","slug":"c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b18-ae-a1-e8","date":"2018-09-23T10:34:02.000Z","updated":"2019-03-20T14:40:21.022Z","comments":false,"path":"2018/09/23/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b18-ae-a1-e8/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/23/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b18-ae-a1-e8/","excerpt":"","text":"第十周 C++11新特性和C++高级主题 第一节 C++新特性（1）1.**统一的初始化方法 （1）int arr[3]{1, 2, 3}; （2）vector iv{1, 2, 3}; （3）map&lt;int, string&gt; mp{ {1,”a”},{2,”b”}}; （4）string str{“Hello World”}; （5）int p = new int[20]{1,2,3}; （6）struct A{ int i,j; A(int m,int n):i(m),j(n){} }; A func(int m,int n ) { return {m,n}; } int main() { A pa = new A {3,7}; } 2.**成员变量默认初始值 class B { public: int m = 1234; int n; }; int main(){ B b; cout&lt;&lt;b.m&lt;&lt;endl; return 0; } 3.auto**关键字 用于定义变量，编译器可以自动判断变量的类型。 auto i =100;//i是int auto p = new A();//p是*A map&lt;string,int,greater &gt; mp; for(auto i =mp.begin(); i!=mp.end(); ++i) cout&lt;first&lt;&lt;”,”&lt;&lt;second; //i的类型是： map&lt;string,int,greater &gt;::iterator class A { }; A operator + ( int n,const A &amp; a) { return a; } template auto add(T1 x, T2 y) -&gt; decltype(x + y){return x+y;} auto d = add(100,1.5); // d是double d=101.5 auto k = add(100,A()); // d是A类型 4.decltype 关键字 int i; double t; struct A { double x; }; const A a = new A(); decltype(a) x1;//x1 is A decltype(i) x2;//x2 is int decltype(a-&gt;x) x3;//x3 is double decltype((a-&gt;x)) x4 =t;//x4 is double&amp; 5.智能指针share_ptr 头文件： 。通过shared_ptr的构造函数，可以让shared_ptr对象托管一个new运算符返回的指针，写法如下： shared_ptr ptr(new T); // T 可以是 int ,char, 类名等各种类型 此后ptr就可以像 T 类型的指针一样来使用，即 ptr 就是用new动态分配的那个对象，而且不必操心释放内存的事。 多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当无shared_ptr托管该指针时，delete该指针。 shared_ptr**对象不能托管指向动态分配的数组的指针，否则程序运行会出错。 例程1： #include #include using namespace std; struct A { int n; A(int v = 0):n(v){ } ~A() { cout &lt;&lt; n &lt;&lt; “ destructor” &lt;&lt; endl; } }; int main(){ shared_ptr sp1(new A(2)); //sp1托管A(2) share_ptr sp2(sp1);//sp2也托管A(2) cout&lt;&lt;”1)”&lt;n&lt;&lt;”,”&lt;n&lt;&lt;endl; //output: 1)2,2可以像一个指针一样使用 shared_ptr sp3; A*p=sp1.get();///p指向A(2)，把所托管的对象提取出来 cout&lt;&lt;”2)”&lt;n&lt;&lt;endl; sp3 = sp1; //sp3也托管 A(2) cout &lt;&lt; “3)” &lt;&lt; (*sp3).n &lt;&lt; endl; //输出 2 sp1.reset(); //sp1放弃托管 A(2) if( !sp1 ) cout &lt;&lt; “4)sp1 is null” &lt;&lt; endl; //会输出 A q = new A(3); sp1.reset(q); // sp1托管q cout &lt;&lt; “5)” &lt;&lt; sp1-&gt;n &lt;&lt; endl;//输出3 shared_ptr sp4(sp1); //sp4托管A(3) shared_ptr sp5; sp1.reset(); //sp1放弃托管 A(3) cout &lt;&lt; “before end main” &lt;&lt;endl; sp4.reset(); //sp1放弃托管 A(3) cout &lt;&lt; “end main” &lt;&lt; endl; return 0; //程序结束，会delete 掉A(2) } 输出结果： 1)2,2 2)2 3)2 4)sp1 is null 5)3 before end main 3 destruct11or 例程2： #include #include using namespace std; struct A { ~A() { cout &lt;&lt; “~A” &lt;&lt; endl; } }; int main() { A p = new A(); shared_ptr ptr(p); shared_ptr ptr2; ptr2.reset(p);//并不增加 ptr中对p的托管计数 cout &lt;&lt; “end” &lt;&lt; endl; return 0; } 在ptr中托管了p，但是我在ptr2中也托管p的时候，并不增加ptr中对p的托管计数。因为ptr和ptr2认为他们所托管的p不是一个p（虽然实际上是一个p）。在输出end之后主程序结束，ptr和ptr2都要进行执行析构函数，p被执行了两次析构函数，系统会崩溃。所以输出结果如下： end ~A ~A （之后程序崩溃） 6.**空指针**nullptr nullptr在有些地方类似于空指针NULL。例程如下： #include #include using namespace std; int main() { int p1 = NULL; int p2 = nullptr; shared_ptr p3 = nullptr; if(p1 == p2){ cout &lt;&lt; “equal 1” &lt;&lt;endl; } if(p3 == nullptr) cout&lt;&lt;”equal 2” &lt;&lt; endl; if(p3 == p2);//error，p3和p2类型不同 if(p3 == NULL) cout&lt;&lt;”equal4”&lt;&lt;endl; bool b = nullptr;//b=false int i = nullptr;//error，nullptr无法自动转换成整型 return 0; } 7.**基于范围的for循环 #include #include using namespace std; struct A{ int n; A(int i):n(i){}}; int main(){ int ary[] = {1,2,3,4,5}; for(int &amp; e:ary) e= 10; for(int e: ary) cout&lt;&lt;e&lt;&lt;”,”; cout&lt;&lt;endl; vector str(ary,ary+5); for(auto &amp;it:st) it.n=10; for(A it: st) cout&lt;&lt;it.n&lt;&lt;”,”; return 0; } 类似于Java中的使用。 8.右值引用和move语义 右值：一般来说，不能取地址的表达式，就是右值，能取地址的，就是左值。例如： class A { }; A &amp; r = A(); // error , A()是无名变量，是右值 A &amp;&amp; r = A(); //ok, r 是右值引用 主要目的是提高程序运行的效率，减少需要进行深拷贝的对象进行深拷贝的次数。我们前面学习的都是左值引用**！ 第二节 C++新特性（2）1.**可移动但不可复制的对象 struct A{ A(const A &amp; a) = delete; A(const A &amp;&amp; a) { cout &lt;&lt; “move” &lt;&lt; endl; } A() { }; }; A b; A func(){ A a; return a; } void func2(A a){} int main(){ A a1; A a2(a1);//compile error func2(a1);//compile error func(); return 0; } 2.**无序容器（哈希表） #include #include #include &lt;unordered_map&gt; using namespace std; int main() { unordered_map&lt;string, int&gt; turingWinner;//图灵奖获奖名单 turingWinner.insert(make_pair(“Dijkstra”,1972)); turingWinner.insert(make_pair(“Scott”,1976)); turingWinner.insert(make_pair(“Wilkes”,1967)); turingWinner.insert(make_pair(“Hamming”,1968)); turingWinner[“Ritchie”] = 1983; string name; cin &gt;&gt; name; //输入姓名 unordered_map&lt;string,int&gt;::iterator p = turingWinner.find(name); //据姓名查获奖时间 if( p != turingWinner.end()) cout &lt;&lt; p-&gt;second; else cout&lt;&lt;&lt; “Not Found” &lt;&lt;endl; return 0; } 哈希表插入和查询的时间复杂度几乎是常数。 3.**正则表达式 #include #include //使用正则表达式须包含此文件 using namespace std; int main() { regex reg(“b.?p.*k”); cout &lt;&lt; regex_match(“bopggk”,reg) &lt;&lt;endl;//输出 1, 表示匹配成功 cout &lt;&lt; regex_match(“boopgggk”,reg) &lt;&lt;endl;//输出 0, 匹配失败 cout &lt;&lt; regex_match(“b pk”,reg) &lt;&lt;endl;//输出1，表示匹配成功 regex reg2(“\\\\\\d{3}([a-zA-Z]+).(\\\\\\d{2}|N/A)\\\\\\s\\\\\\1”); string correct=”123Hello N/A Hello”; string incorrect=”123Hello 12 hello”; cout &lt;&lt; regex_match(correct,reg2) &lt;&lt;endl; //输出 1,匹配成功 cout &lt;&lt; regex_match(incorrect,reg2) &lt;&lt; endl; //输出 0, 失败 return 0; } 4.Lambda**表达式 形式： [外部变量访问方式说明符](参数表) -&gt;返回值类型{ 语句组 } []：不使用任何外部变量； [=]：以传值的形式使用所有外部变量； [&amp;]：以引用形式使用所有外部变量； [x, &amp;y]：x以传值形式使用，y以引用形式使用； [=,&amp;x,&amp;y]：x和y以引用形式使用，其余变量以传值形式使用； [&amp;,x,y]：x和y以传值的形式使用，其余变量以引用形式使用。 如果以传值方式进行传递对象，就不能修改该对象的值。“**-&gt;返回值类型”**也可以没有， 没有则编译器自动判断返回值类型。 例程： int main() { int x = 100,y=200,z=300; cout &lt;&lt; [ ](double a,double b) { return a + b; }(1.2,2.5) &lt;&lt;endl; auto ff = [=,&amp;y,&amp;z](int n){ cout&lt;&lt;x&lt;&lt;endl; y++,z++; return nn; }; cout &lt;&lt; ff(15)&lt;&lt;endl; cout&lt;y&lt;&lt;”,”&lt;&lt;z&lt;&lt;endl; int a[4] = {4,2,11,33}; sort(a,a+4,[](int x,int y)-&gt;bool{return x%10&lt;y%10;});//按照个位数进行排序，按照原来的方法需要新建一个函数，浪费时间和空间 for_each(a,a+4,[](int x){cout&lt;&lt;x&lt;&lt;” “;});//输出11 2 33 4 return 0； } 要注意，[ ](double a,double b) { return a + b; }(1.2,2.5)中的(1.2,2.5)并不是lambda表达式一部分，而只是调用lambda表达式函数的赋值语句。 例程：实现递归求菲波那切数列第**n**项： function&lt;int(int)&gt; fib = [&amp;fib](int n) {return n&lt;=2?1:fib(n-1)+fib(n-2);}; function&lt;int(int)&gt;**表示返回值为int，有一个int参数的函数。* 第三节 强制类型转换共有四种类型：static_cast、reinterpret_cast、const_cast和dynamic_cast。 1.static_cast static_cast用来进用行比较“**自然**”和低风险的转换，比如整型和实数型、字符型之间互相转换。 static_cast不能来在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，也不能用于不同类型的引用之间的转换。 2.reinterpret_cast reinterpret_cast用来进行各种不同类型的指针之间的转换、不同类型的引用之间转换、以及指针和能容纳得下指针的整数类型之间的转换。转换的时候，执行的是逐个比特拷贝的操作。 例程： #include using namespace std; class A { public: int i ,j; A(int n):i(n),j(n){} }; int main(){ A a(100); int &amp; r = reinterpret_cast&lt;int&amp;&gt;(a);//强行让r引用a r = 200;//把a.i = 200，因为r是4个字节，所以上面的引用只引用了a的前面4个字节，也就是a.i cout&lt;&lt;a.i&lt;&lt;”,”a.j&lt;&lt;endl; int n = 300; A pa = reinterpret_cast&lt;A&gt; ( &amp; n); //强行让 pa 指向 n pa-&gt;i = 400;//n编程400 pa-&gt;j =500;//不安全，因为不知道后面这部分内存地址是干什么的，所以可能导致程序崩溃 cout&lt;&lt;n&lt;&lt;endl;//输出400 long long la = 0x12345678abcdLL; pa = reinterpret_cast&lt;A&gt;(la); // la太长，只取低32位0x5678abcd拷贝给pa unsigned int u = reinterpret_cast(pa);//pa逐个比特拷贝给u cout &lt;&lt; hex &lt;&lt; u&lt;&lt;endl;//输出5678abcd typedef void (\\PF1)(int); typedef int (*PF2)(int,char ); PF1 pf1; PF2 PF2; pf2 = reinterpret_cast(pf1); //两个不同类型的函数指针之间可以互相转换 return 0; } 输出结果：200,100 400 5678abcd 3.const_cast 用来进行去除const属性的转换。将const引用转换成同类型的非const引用，将const指针转换为同类型的非const指针时用它。例如 const string s = “Inception”; string &amp; p = const_cast&lt;string&amp;&gt;(s); string ps = const_cast&lt;string&gt;(&amp;s); // &amp;s的类型是const string 4.dynamic_cast dynamic_cast专门用于将多态基类的指针或引用，强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回NULL指针。 dynamic_cast不能用于将非多态基类的指针或引用，强制转换为派生类的指针或引用。 例程如下： #include #include using namespace std; class Base { //有虚函数，因此是多态基类 public: virtual ~Base(){} }; class Derived:public Base{}; int main(){ Base b; Derived d; Derived pd; pd = reinterpret_cast&lt;Derived&gt;(&amp;b); if( pd ==NULL) //此处pd不会为NULL。reinterpret_cast不检查安全性，总是进行转换 cout&lt;&lt;&lt;&lt; “unsafe reinterpret_cast” &lt;&lt; endl; //不会执行 pd = dynamic_cast&lt;Derived&gt;(&amp;b); if( pd ==NULL)//结果会是NULL，因为 &amp;b不是指向派生类对象，此转换不安全 cout&lt;&lt; “unsafe dynamic_cast1” &lt;&lt; endl; //会执行 pd = dynamic_cast&lt;Derived&gt; ( &amp;d); //安全的转换 if( pd ==NULL) cout&lt;&lt; “unsafe dynamic_cast2” &lt;&lt; endl; //不会执行 return 0; } 如下所示：Derived &amp; r = dynamic_cast&lt;Derived&amp;&gt;(b); 那该如何判断该转换是否安全呢？ 答案：不安全则抛出异常。 第四节 异常处理程序运行中总难免发生错误，我们希望不只是简单地终止程序运行，还能够反馈异常情况的信息：哪一段代码发生的、什么异常，还能够对程序运行中已发生的事情做些处理：取消对输入文件的改动、释放已经申请的系统资源。 1.**异常处理 一个函数运行期间可能产生异常。在函数内部对异常进行处理未必合适。因为函数设计者无法知道函数调用者希望如何处理异常。我们需要告知函数调用者发生了异常，让函数调用者处理比较好，但是用函数返回值告知异常不方便。 （1）用try,catch进行异常处理** 例程： #include using namespace std; int main() { double m ,n; cin &gt;&gt; m &gt;&gt; n; try { cout &lt;&lt; “before dividing.” &lt;&lt; endl; if( n == 0) throw -1; //抛出int类型异常 else if(m==0) throw -1.0;//抛出double型异常 else cout &lt;&lt; m / n &lt;&lt; endl; cout &lt;&lt; “after dividing.” &lt;&lt; endl; } catch(double d){ cout&lt;&lt;”catch(double)” &lt;&lt;d &lt;&lt;endl; } catch(…){ cout&lt;&lt;”catch(…)” &lt;&lt;endl; } cout&lt;&lt;”finished””&lt;&lt;endl; return 0; } 表4.1 trycatch例程输入输出结果 程序输入 9 0 0 6 输出结果 before dividing catch(…) finished before dividing catch(double) -1 finished 注意：**try**块中定义的局部对象，发生异常时会析构！ （**2**）异常的再抛出 如果一个函数在执行的过程中，抛出的异常在本函数内就被catch块捕获并处理了，那么该异常就不会抛给这个函数的调用者(也称“上一层的函数”)；如果异常在本函数中没被处理，就会被抛给上一层的函数。 例程： #include #include using namespace std; class CException { public : string msg; CException(string s):msg(s) { } }; double Devide(double x, double y){ if(y == 0) throw CException(“devided by zero”);//抛出异常 cout &lt;&lt; “in Devide” &lt;&lt; endl; return x / y; } int CountTax(int salary){//异常自己处理掉了 try{ if( salary &lt; 0 ) throw -1; cout &lt;&lt; “counting tax” &lt;&lt; endl;} catch (int ) { cout &lt;&lt; “salary &lt; 0” &lt;&lt; endl; } cout &lt;&lt; “tax counted” &lt;&lt; endl; return salary 0.15; } int main(){ double f = 1.2; try { CountTax(-1);//在这个函数自己处理完了，try里面就感知不到这个错误了 f = Devide(3,0);//Devide本身没有处理异常，所以抛给了这个try里面了 cout &lt;&lt; “end of try block” &lt;&lt; endl; } catch(CException e) { cout &lt;&lt; e.msg &lt;&lt; endl; } cout &lt;&lt; “f=” &lt;&lt; f &lt;&lt; endl; cout &lt;&lt; “finished” &lt;&lt; endl; return 0; } 2.C++**标准异常类* C++标准库中有一些类代表异常，这些类都是从exception类派生而来的。 图4.1 exception派生出的异常类 （1）bad_cast 在用 dynamic_cast进行从多态基类对象（或引用）,到派生类的引用的强制类型转换时，如果转换是不安全的，则会抛出此异常。 （2）bad_alloc 在用new运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常。 （3）out_of_range 用vector或string的at成员函数根据下标访问元素时，如果下标越界，就会抛出此异常。 3.**运行时类型检查* C++运算符typeid是单目运算符，可以在程序运行过程中获取一个表达式的值的类型。typeid运算的返回值是一个type_info类的对象，里面包含了类型的信息。 例程如下： #include #include //要使用typeinfo，需要此头文件 using namespace std; struct Base { }; //非多态基类 struct Derived : Base { }; struct Poly_Base {virtual void Func(){ } }; //多态基类struct Poly_Derived: Poly_Base { }; int main() { //基本类型 long i; int p = NULL; cout &lt;&lt; “1) int is: “ &lt;&lt; typeid(int).name() &lt;&lt; endl; //输出 1) int is: int cout &lt;&lt; “2) i is: “ &lt;&lt; typeid(i).name() &lt;&lt; endl; //输出 2) i is: long cout &lt;&lt; “3) p is: “ &lt;&lt; typeid(p).name() &lt;&lt; endl; //输出 3) p is: int cout &lt;&lt; “4) \\p is: “ &lt;&lt; typeid(*p).name() &lt;&lt; endl ; //输出 4) *p is: int //非多态类型 Derived derived; Base* pbase = &derived; cout &lt;&lt; “5) derived is: “ &lt;&lt; typeid(derived).name() &lt;&lt; endl; //输出 5) derived is: struct Derived cout &lt;&lt; “6) *pbase is: “ &lt;&lt; typeid(*pbase).name() &lt;&lt; endl; //输出 6) *pbase is: struct Base cout &lt;&lt; “7) “ &lt;&lt; (typeid(derived)==typeid(*pbase) ) &lt;&lt; endl; //输出 7) 0 //多态类型 Poly_Derived polyderived; Poly_Base ppolybase = &polyderived; cout &lt;&lt; “8) polyderived is: “ &lt;&lt; typeid(polyderived).name() &lt;&lt; endl; //输出 8) polyderived is: struct Poly_Derived cout &lt;&lt; “9) \\ppolybase is: “ &lt;&lt; typeid(*ppolybase).name() &lt;&lt; endl; //输出 9) *ppolybase is: struct Poly_Derived cout &lt;&lt; “10) “ &lt;&lt; (typeid(polyderived)!=typeid(*ppolybase) ) &lt;&lt; endl; //输出 10) 0 return 0; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++面向对象程序设计课程笔记（第九周）（下）","slug":"c-e9-9d-a2-e5-90-91-e5-af-e8-ae-be-e8-ae-a1-e-bc-89","date":"2018-09-21T03:14:08.000Z","updated":"2019-03-20T14:40:31.916Z","comments":false,"path":"2018/09/21/c-e9-9d-a2-e5-90-91-e5-af-e8-ae-be-e8-ae-a1-e-bc-89/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/21/c-e9-9d-a2-e5-90-91-e5-af-e8-ae-be-e8-ae-a1-e-bc-89/","excerpt":"","text":"第四节 容器适配器容器适配器没有迭代器！ 1.stack stack是后进先出的数据结构，只能插入、删除和访问栈顶的元素。可以用vector、list和deque来实现，缺省使用deque实现。用vector和deque实现，比用list实现性能好。 template&lt;class T, class Cont = deque &gt; class stack{ }; stack可以进行下面的操作： （1）push：插入元素； （2）pop：弹出元素； （3）top：返回栈顶元素的引用。 2.Queue 和stack基本类似，可以用list和deque实现，缺省情况下使用deque实现。 template&lt;class T, class Cont = deque &gt; class queue{ }; 同样有push，pop和top函数。但是push在队尾，pop和top在队头。因为是先进先出。有back成员函数可以返回队尾元素的引用。 3.priority_queue template &lt;class T, class Container = vector. class Compare = less &gt; class priority_queue; 和queue类似，可以用vector和deque实现。缺省情况下用vector实现。 priority_queue通常用堆排序技术实现，保证最大的元素总是在最前面，即执行pop操作时，删除的是最大的元素；执行top操作时，返回的是最大元素的常引用。默认元素比较器是less。 push/pop的时间复杂度是O(logn)，top()的时间复杂度是O(1)。 #include #include using namespace std; int main() { priority_queue p1; p1.push(3.2);p1.push(9.8);p1.push(9.8);p1.push(5.4); while(!p1.empty()){ cout&lt;&lt;p1.top()&lt;&lt;” “; p1.pop(); }//输出9.8 9.8 5.4 3.2 cout&lt;&lt;endl; priority_queue&lt;double,vector,greater p2; p2.push(3.2);p2.push(9.8);p2.push(9.8);p2.push(5.4); while(!p1.empty()){ cout&lt;&lt;p1.top()&lt;&lt;” “; p2.pop(); }//输出3.2 5.4 9.8 9.8 return 0; } stack/queue/priority_queue都有：empty()（用于判断适配器是否为空）和size()（返回适配器中元素个数。） 第五节 算法STL中的算法大致可以分为以下七类： （1）不变序列算法 （2）变值算法 （3）删除算法 （4）变序算法 （5）排序算法 （6）有序区间算法 （7）数值算法 大多数重载的算法都是有两个版本：一个版本是用“==”判断元素是否相等，或用“&lt;”来比较大小；还有一个版本是多出一个类型参数Pred和函数形参Pred op，通过表达式op(x,y)的返回值true/false来判断x是否等于y或者x是否小于y或者x是否大于y。 1.**不变序列算法 此类算法不会修改算法所作用的容器或对象，适用于所有容器（特别是顺序容器和关联容器）。它的时间复杂度是O(n)**的。它包括以下算法： 表5.1 不变序列算法中的算法 算法名称 功能 min 求两个对象中较小的（可自定义比较器） max 求两个对象中较大的（可自定义比较器） min_element 求区间中的最小值（可自定义比较器） max_element 求区间中的最大值（可自定义比较器） for_each 对区间中的每个元素都做这种操作（不能改变数值） count 计算区间中等于某值的元素个数 count_if 计算区间中符合某种条件的元素个数 find 在区间中查找等于某值的元素 find_if 在区间中查找符合某条件的元素 find_end 在区间中查找另一个区间最后一次出现的位置（可自定义比较器） find_first_of 在区间中查找第一个出现在另一个区间中的元素（可自定义比较器） adjacent_find 在区间中寻找第一次出现连续两个相等元素的位置（可自定义比较器） search 在区间中查找另一个区间第一次出现的位置（可自定义比较器） search_n 在区间中查找第一次出现等于某值的连续n个元素（可自定义比较器） equal 判断两区间是否相等（可自定义比较器） mismatch 逐个比较两个区间元素，返回第一次发生不相等的两个元素的位置（可自定义比较器） lexicographical_compare 按字典序比较两个区间的大小（可自定义比较器） 我们具体来看： （1）find： template InIt find(InIt first, InIt last, const T&amp; val); 返回区间[first,last)中的迭代器i，使得*i==val。 （2）find_if： template InIt find_if(InIt first, InIt last,Pred pr); 返回区间[first,last)中的迭代器i，使得pr(*i)==true。 （3）for_each： template Fun for)each(InIt first, InIt last, Fun f); 对区间[first,last)中的每个元素e，执行f(e)，要求f(e)不能改变e。 （4）count： template size_t count(InIt first, InIt last, const T&amp; val); 计算[first,last) 中等于val的元素个数。 （5）count_if template size_t count_if(InIt first, InIt last, Pred pr); 计算[first,last) 中符合pr(e) == true 的元素 e的个数。 （6）min_element： template FwdIt min_element(FwdIt first, FwdIt last); 返回[first,last) 中最小元素的迭代器,以 “&lt; ”作比较器。最小指没有元素比它小，而不是它比别的不同元素都小。因为即便a!= b, a&lt;b 和b&lt;a有可能都不成立 （7）max_element： template FwdIt max_element(FwdIt first, FwdIt last); 返回[first,last) 中最大元素(它不小于任何其他元素，但不见得其他不同元素都小于它）的迭代器,以 “&lt; ”作比较器。 2.**变值算法 此类算法会修改源区间或目标区间元素的值。值被修改的那个区间，不可以是属于关联容器的（因为关联容器是排好序的算法，如果直接值被修改，容器中顺序被打破，再去执行别的操作可能结果就不是预期结果）。** 表5.2 变值算法的算法 算法名称 算法功能 for_each 对区间中的每个元素都做某种操作（可以改变数值） copy 复制一个区间到别处 copy_backward 复制一个区间到别处，但目标区前是从后往前被修改的 transform 将一个区间的元素变形后拷贝到另一个区间 swap_ranges 交换两个区间内容 fill 用某个值填充区间 fill_n 用某个值替换区间中的n个元素 generate 用某个操作的结果填充区间 generate_n 用某个操作的结果替换区间中的n个元素 replace 将区间中的某个值替换为另一个值 replace_if 将区间中符合某种条件的值替换成另一个值 replace_copy 将一个区间拷贝到另一个区间，拷贝时某个值要换成新值拷过去 replace_copy_if 将一个区间拷贝到另一个区间，拷贝时符合某条件的值要换成新值拷过去 我们来具体看一下： （1）transform template OutIt transform(InIt first, InIt last, OutIt x, Unop uop); 对[first,last)中的每个迭代器 I，执行 uop( I ) ; 并将结果依次放入从x开始的地方。要求uop( I )不得改变 I 的值。本模板返回值是个迭代器，即 x + (last-first)，x 可以和 first相等。 （2）copy template OutIt copy(InIt first, InIt last, OutIt x); 本函数对每个在区间[0,last-first)中的N执行一次(x+N)=(first+N)，返回x+N。copy的源代码如下： template inline _OI copy(_II_F, _II_L, __OI_X) { for(;_F!=_L;++_X,++_F) \\_X = *_F; return(_X); } 它有两个类型，一个是II一个是OI，暗示分别是输入和输出。函数的三个参数的前两个是区间的开始和结束，后面则可以是某个位置。这个函数做的就是在从_F走到_L的过程中，把*_F的值赋给*_X，然后_F和_X不断后移。 对于copy(v.begin(), v.end(), output);first和last的类型是vecotr::const_iterator，output的类型是osream_iterator。 3.**删除算法 删除算法会删除一个容器里的某些元素。这里所说的 “删除”，并不会使容器里的元素减少，其工作过程是：将所有应该被删除的元素看做空位子，然后用留下的元素从后往前移，依次去填空位子。元素往前移后，它原来的位置也就算是空位子，也应由后面的留下的元素来填上。最后，没有被填上的空位子，维持其原来的值不变。删除算法不应作用于关联容器**。 表5.3 删除算法的算法 算法名称 算法功能 remove 删除区间中等于某个值的元素 remove_if 删除区间中满足某种条件的元素 remove_copy 拷贝区间到另一个区间。等于某个值的元素不拷贝 remove_copy_if 拷贝区间到另一个区间。符合某种条件的元素不拷贝 uqique 删除区间中连续相等的元素，只留下一个(可自定义比较器) unique_copy 拷贝区间到另一个区间。连续相等的元素，只拷贝第一个到目标区间 (可自定义比较器) 算法复杂度均为O(n)。 我们具体来看： （1）unique template FwdIt unique(FwdIt first, FwdIt last); 用 == 比较是否等 template FwdIt unique(FwdIt first, FwdIt last, Pred pr);用 pr 比较是否等 返回值是迭代器，指向元素删除后的区间的最后一个元素的后面。 int main() { int a[5] = {1,2,3,2,5}; int b[6] = {1,2,3,2,5,6}; ostream_iterator oit(cout,”,”); int p = remove(a,a+5,2); //输出语句，输出1,3,2,5 cout&lt;&lt;”2)”&lt;&lt;p-a&lt;&lt;endl;//输出2)3。是指的元素中剩余的有效元素还有3个，删除了首地址的元素。 vector v(b,b+6); remove(v.begin().v.end(),2); //输出语句，结果为1,3,5,6,5,6 return 0; } 之所以第一次输出的结果为1,3,2,5是因为，当我们删除第一个2的时候，后面的3移过来，然后后面的2页被删了，再后面的5移过来，这样最后面空了2个位置，则这两个位置的原来的值保持不变。 4.**变序算法 变序算法改变容器中元素的顺序，但是不改变元素的值。变序算法不适用于关联容器*。此类算法复杂度都是O(n)的。 表5.4 变序算法的算法 算法名称 算法功能 reverse 颠倒区间的前后次序 reverse_copy 把一个区间颠倒后的结果拷贝到另一个区间，源区间不变 rotate 将区间进行循环左移 rotate_copy 将区间以首尾相接的形式进行旋转后的结果拷贝到另一个区间，源区间不变 next_permutation 将区间改为下一个排列(可自定义比较器) prev_permutation 将区间改为上一个排列(可自定义比较器) random_shuffle 随机打乱区间内元素的顺序 partition 把区间内满足某个条件的元素移到前面，不满足该条件的移到后面 stable_patition 把区间内满足某个条件的元素移到前面，不满足该条件的移到后面。而且对这两部分元素，分别保持它们原来的先后次序不变 我们来具体看一下： （1）random_shuffle template void random_shuffle(RanIt first, RanIt last); 随机打乱[first,last) 中的元素，适用于能随机访问的容器。用之前要初始化伪随机数种子： srand(unsigned(time(NULL)));//**需要**#include （2）reverse template void reverse(BidIt first, BidIt last); 颠倒区间[first,last)顺序。 （3）next_permutation template bool next_permutaion (Init first,Init last); 求下一个排列。 例程： #include #include #include using namespace std; int main() { string str = “231”; char szStr[] = “324”; while (next_permutation(str.begin(), str.end())){ cout &lt;&lt; str &lt;&lt; endl;//输出312 321 } cout &lt;&lt; ““ &lt;&lt; endl; while (next_permutation(szStr,szStr + 3)) { cout &lt;&lt; szStr &lt;&lt; endl; } sort(str.begin(),str.end()); cout &lt;&lt; ““ &lt;&lt; endl; while (next_permutation(str.begin(), str.end())){ cout &lt;&lt; str &lt;&lt; endl; } return 0; } 5.**排序算法 排序算法比前面的变序算法复杂度更高，一般是O(n×log(n))。排序算法需要随机访问迭代器的支持，因而不适用于关联容器和**list。 表5.5 排序算法的算法 算法名称 算法功能 sort 将区间从小到大排序(可自定义比较器)。 stable_sort 将区间从小到大排序，并保持相等元素间的相对次序(可自定义比较器)。 partial_sort 对区间部分排序，直到最小的n个元素就位(可自定义比较器)。 partial_sort_copy 将区间前n个元素的排序结果拷贝到别处。源区间不变(可自定义比较器)。 nth_element 对区间部分排序，使得第n小的元素（n从0开始算）就位，而且比它小的都在它前面，比它大的都在它后面(可自定义比较器)。 make_heap 使区间成为一个“堆”(可自定义比较器)。 push_heap 将元素加入一个是“堆”区间(可自定义比较器)。 pop_heap 从 “堆”区间删除堆顶元素(可自定义比较器)。 sort_heap 将一个“堆”区间进行排序，排序结束后，该区间就是普通的有序区间，不再是 “**堆”了**(可自定义比较器)。 我们来具体看一下： （1）sort 快速排序 template void sort(RanIt first, RanIt last); 按升序排序。判断x是否应比y靠前，就看 x &lt; y 是否为true。 template void sort(RanIt first, RanIt last, Pred pr); 按升序排序。判断x是否应比y靠前，就看 pr(x,y) 是否为true sort 实际上是快速排序，时间复杂度 O(nlog(n))；平均性能最优。但是最坏的情况下，性能可能非常差。如果要保证“最坏情况下”的性能，那么可以使用**stable_sort**。stable_sort 实际上是归并排序，特点是能保持相等元素之间的先后次序。在有足够存储空间的情况下，复杂度为 n log(n)，否则复杂度为 n log(n) log(n)。stable_sort 用法和 sort相同。排序算法要求随机存取迭代器的支持，所以list 不能使用排序算法，要使用list::sort。 此外，其它排序算法： partial_sort：部分排序，直到前n个元素就位即可。 nth_element：排序，直到第 n个元素就位，并保证比第n个元素小的元素都在第n个元素之前即可。 partition：改变元素次序，使符合某准则的元素放在前面。 6.**有序区间算法** 有序区间算法要求所操作的区间是已经从小到大排好序的，而且需要随机访问迭代器的支持。所以有序区间算法不能用于关联容器和list。 表5.6 有序区间算法的算法 算法名称 功能 binary_search 判断区间中是否包含某个元素。 includes 判断是否一个区间中的每个元素，都在另一个区间中。 lower_bound 查找最后一个不小于某值的元素的位置。 upper_bound 查找第一个大于某值的元素的位置。 equal_range 同时获取lower_bound和upper_bound。 merge 合并两个有序区间到第三个区间。 set_union 将两个有序区间的并拷贝到第三个区间。 set_intersection 将两个有序区间的交拷贝到第三个区间。 set_difference 将两个有序区间的差拷贝到第三个区间。 set_symmetric_difference 将两个有序区间的对称差拷贝到第三个区间。 inplace_merge 将两个连续的有序区间原地合并为一个有序区间。 我们来具体看一下： （1）binary_search 二分查找 template bool binary_search(FwdIt first, FwdIt last, const T&amp; val); 上面这个版本，比较两个元素x,y大小时,看 x &lt; y。 template bool binary_search(FwdIt first, FwdIt last, const T&amp; val, Pred pr); 上面这个版本，比较两个元素x,y大小时,若pr(x,y) 为true，则认为x小于y。 （2）merge template OutIt merge(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, OutIt x);用&lt;作比较器 template OutIt merge(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, OutIt x, Pred pr);用pr做比较器 把[first1,last1),[first2,last2)两个升序序列合并，形成第3个升序序列，第3个升序序列以x开头。（空间必须得充足） （3）includes template bool includes(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2); template bool includes(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, Pred pr); 判断[first2,last2)中的每个元素，是否都在[first1,last1)中第一个用&lt;作比较器，第二个用pr作比较器,pr(x,y)==true说明x,y相等。 （4）set_difference template OutIt set_difference(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, OutIt x); template OutIt set_difference(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, OutIt x, Pred pr); 求出[first1,last1)中，不在[first2,last2)中的元素，放到从x开始的地方。如果[first1,last1)里有多个相等元素不在[first2,last2)中，则这多个元素也都会被放入x代表的目标区间里。 （5）set_intersection template OutIt set_intersection(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, OutIt x); template OutIt set_intersection(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, OutIt x, Pred pr); 求出[first1,last1)和[first2,last2)中共有的元素，放到从x开始的地方。若某个元素e在[first1,last1)里出现n1次，在[first2,last2)里出现n2次，则该元素在目标区间里出现min(n1,n2)次。 （6）set_symmetric_difference template OutIt set_symmetric_difference(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, OutIt x); template OutIt set_symmetric_difference(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, OutIt x, Pred pr); 把两个区间里相互不在另一区间里的元素放入x开始的地方。 （7）set_union 图5.1 set_union 7.bitset**（非数值算法，是类模板）** template&lt;size_t N&gt; class bitset {}; 是实现标志位。实际使用的时候，N是个整型常数如： bitset bst; bst是一个由40位组成的对象，用bitset的函数可以方便地访问任何一位。 bitset的成员函数如下： bitset&amp; operator&amp;=(const bitset&amp; rhs); bitset&amp; operator|=(const bitset&amp; rhs); bitset&amp; operator^=(const bitset&amp; rhs); bitset&amp; operator&lt;&lt;=(size_t num); bitset&amp; operator&gt;&gt;=(size_t num); bitset&amp; set(); //全部设成1 bitset&amp; set(size_t pos, bool val = true); //设置某位 bitset&amp; reset(); //全部设成0 bitset&amp; reset(size_t pos); //某位设成0 bitset&amp; flip(); //全部翻转 bitset&amp; flip(size_t pos); //翻转某位 reference operator[](size_t pos); //返回对某位的引用 bool operator[](size_t pos) const; //判断某位是否为1 reference at(size_t pos); bool at(size_t pos) const; unsigned long to_ulong() const; //转换成整数 string to_string() const; //转换成字符串 size_t count() const; //计算1的个数 size_t size() const; bool operator==(const bitset&amp; rhs) const; bool operator!=(const bitset&amp; rhs) const; bool test(size_t pos) const; //测试某位是否为1 bool any() const; //是否有某位为1 bool none() const; //是否全部为0 bitset operator&lt;&lt;(size_t pos) const; bitset operator&gt;&gt;(size_t pos) const; bitset operator~(); static const size_t bitset_size = N; 注意：第0位在最右边。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++面向对象程序设计课程笔记（第九周）（上）","slug":"c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a","date":"2018-09-21T03:12:09.000Z","updated":"2019-03-20T14:40:36.582Z","comments":false,"path":"2018/09/21/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/21/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a/","excerpt":"","text":"第一节 关联容器set/multiset/map/multimap 内部元素有序排列，新元素插入的位置决定于它的值，查找速度快。 除了各容器都有的函数外，还支持以下成员函数： find: 查找等于某个值 的元素(x小于y和y小于x同时不成立即为相等) lower_bound : 查找某个下界 upper_bound : 查找某个上界 equal_range : 同时查找上界和下界 count :计算等于某个值的元素个数(x小于y和y小于x同时不成立即为相等) insert: 用以插入一个元素或一个区间 第二节 set和multiset预备知识：**pair**模板 template struct pair{ typedef _T1 first_type; typedef _T2 second_type; _T1 first; _T2 second; pair():first(),second(){}//如果first和second是对象的话，就用无参构造函数来初始化 pair(const _T1&amp;__a,const _T2&amp;__b):first(__a),second(__b){} //构造函数有两个静态变量__a和__b，分别用来初始化first和second template pair(const pair&lt;_U1,_U2&gt;&amp;__p):first(__p.first),second(__p.second){} }; 第三个构造函数是一个函数模板，用以下例子来示例一下： pair&lt;int, int&gt; p(pair&lt;double, double&gt;(5.5,4.6)); //p.first = 5, p.second = 4 1.multiset template&lt;class Key, class Pred = less, class A = allocator &gt; class multiset { …… }; 在这里面，Pred类型的变量决定了multiset中的元素“一个比另一个小”是怎么定义的。multiset运行过程中，比较两个元素x，y的大小的做法，就是生成一个Pred类型的变量，假定为op，若表达式op&lt;x,y&gt;返回值为true，则x比y小。Pred**的缺省值类型是**less。 less模板： template struct less : public binary_function&lt;T, T, bool&gt; { bool operator()(const T&amp; x, const T&amp; y) { return x &lt; y ; } const; }; //less模板是靠 &lt; 来比较大小的 表2.1 multiset的成员函数 函数名 作用 iterator find(const T &amp;val) 在容器中查找值为val的元素，返回其迭代器。如果找不到，返回end()。 iterator insert(const T &amp; val); 将val插入到容器中并返回其迭代器。 void insert( iterator first,iterator last); 将区间[first,last)插入容器。 int count(const T &amp; val); 统计有多少个元素的值和val相等。 iterator lower_bound(const T &amp; val); 查找一个最大的位置it,使得[begin(),it)中所有的元素都比val小。（返回大于等于val的第一个数字的地址） iterator upper_bound(const T &amp; val); 查找一个最小的位置it,使得[it,end())中所有的元素都比val大。（返回比val大的第一个数字的地址） pair&lt;iterator,iterator&gt; equal_range(const T &amp; val); 同时求得lower_bound和upper_bound。 iterator erase(iterator it); 删除it指向的元素，返回其后面的元素的迭代器(Visual studio 2010上如此，但是在C++标准和Dev C++中，返回值不是这样)。 （**1）multiset**的用法 #include using namespace std; class A { }; int main() { multiset a; a.insert(A());//error } 主函数中第一句话没有什么问题，但是第二句话存在问题。因为multiset a等价于multiset&lt;A, less&gt; a，这样插入元素的时候，multiset会将插入元素同已有元素进行比较。由于a中的元素都是A类型的，插入的也是一个A类型的，所以需要对A类型的对象进行比较，这要求A的对象能用&lt;比较，即需要对**&lt;**进行重载。 例程： #include #include using namespace std; template void Print(T first, T last) { for(;first!=last;++first) cout&lt;&lt;*first&lt;&lt;” “; cout&lt;&lt; endl; } class A{ private: int n; public: A(int _n){n = _n;} friend bool operator&lt;(const A &amp;a1, const A &amp;a2){return a1.n&lt;a2.n;} friend ostream &amp; operator&lt;&lt;(ostream &amp; o, const A &amp;a2){o&lt;&lt;a2.n;return o;} friend class MyLess; }; struct MyLess{ bool operator ()(const A &amp; a1, const A &amp; a2)//按个位数比较 {return (a1.n%10)&lt;(a2.n%10);} }; typedef multiset MSET1; typedef multiset&lt;A,MyLess&gt; MSET2;//MSET用MyLess::operator()比较大小 int main(){ const int SIZE = 6; A a[SIZE]={4,22,19,8,33,40}; MSET1 m1; m1.insert(a,a+SIZE); m1.insert(22); cout&lt;&lt;”1)”&lt;&lt;m1.count(22)&lt;&lt;endl;//output:1)2 cout&lt;&lt;”2)”&lt;&lt;Print(m1.begin(),m1.end());//output: 2)4 8 19 22 22 33 40 MSET1::iterator pp = m1.find(19); if(pp!=m1.end()) cout&lt;&lt;”found”&lt;&lt;endl; cout&lt;&lt;”3}”;cout&lt;&lt;*m1.lower_bound(22)&lt;&lt;”,”&lt;&lt;*m1.upper_bound(22)&lt;&lt;endl;//output:22 23 pp = m1.erase(m1.lower_bound(22),m1.upper_bound(22));//pp指向被删除元素的下一个元素 cout&lt;&lt;”4)”;Print(m1.begin(),m1.end());//输出4 8 19 33 40 cout&lt;&lt;”5)”;cout&lt;&lt;*p&gt;&gt;endl;//输出33 MSET2 m2; m2.insert(a,a+SIZE); cout&lt;&lt;”6)”;Print(m2.begin(),m2.end());//输出6)40 22 33 4 8 19 return 0; } 以上程序已弄明白，但是要多看看，理解下。 2.set template&lt;class Key, class Pred = less, class A = allocator&gt; class set{} 插入set中已有元素时，忽略插入。例程如下： #include #include using namespace std; int main() { typedef set::iterator IT; int a[5] = { 3,4,6,1,2 }; set st(a, a + 5); pair&lt;IT,bool&gt; result; result = st.insert(5); if (result.second) cout &lt;&lt; *result.first &lt;&lt; “inserted” &lt;&lt; endl; if (st.insert(5).second) cout &lt;&lt; *result.first &lt;&lt; endl; else cout &lt;&lt; *result.first &lt;&lt; “already exists” &lt;&lt; endl; pair&lt;IT, IT&gt;bounds = st.equal_range(4); cout &lt;&lt; *bounds.first &lt;&lt; “.” &lt;&lt; *bounds.second; system(“pause”); return 0; } 定义的result是一个pair类型的对象，其里面的first是IT类型，second是bool类型（pair类定义见本节的预备知识）。下面得到的result对象里面的IT就是迭代器指向5所在位置，而second的值为true（因为插入成功）。 if (st.insert(5).second)这句话实际上是先执行了st.insert(5)之后，判断其second值是false还是true。由于前面已经插入了5，所以这里肯定插入不成功，所以second肯定是false。 第三节 map和multimap1.multimap template&lt;class Key, class T, class Pred = less, class A = allocator&gt; class multimap{ typedef pairvalue_type; };//Key代表关键字的类型 multimap中的元素由 &lt;关键字,值&gt;组成，每个元素是一个pair对象，关键字就是first成员变量,其类型是Key。 multimap 中允许多个元素的关键字相同。元素按照first成员变量从小到大排列，缺省情况下用 less 定义关键字的“小于”关系。 例程： #include #include using namespace std; int main() { typedef multimap&lt;int, double, less&gt; mmid; mmid pairs; cout &lt;&lt; “1)” &lt;&lt; pairs.count(15) &lt;&lt; endl; pairs.insert(mmid::value_type(15, 2.7));//typedef pairvalue_type pairs.insert(mmid::value_type(15, 99.3)); cout &lt;&lt; “2)” &lt;&lt; pairs.count(15) &lt;&lt; endl;//求关键字等于15的个数，应该输出 pairs.insert(mmid::value_type(30, 111.11)); pairs.insert(mmid::value_type(10, 22.22)); pairs.insert(mmid::value_type(25, 33.333)); pairs.insert(mmid::value_type(20, 9.3)); for (mmid::const_iterator i = pairs.begin(); i != pairs.end(); ++i) cout &lt;&lt; “(“ &lt;&lt; i-&gt;first &lt;&lt; “,” &lt;&lt; i-&gt;second &lt;&lt; “)” &lt;&lt; “,”; cout &lt;&lt; endl; system(“pause”); return 0; } multimap**例题：一个学生成绩录入和查询系统。接受以下两种输入： Add name id score Query score name是个字符串，中间没有空格，代表学生姓名。id是个整数，代表学号 。score是个整数，表示分数。学号不会重复，分数和姓名都可能重复。 两种输入交替出现。第一种输入表示要添加一个学生的信息，碰到这种输入，就记下学生的姓名、id和分数。第二种输入表示要查询，碰到这种输入 ，就输出已有记录中分数比score低的最高分获得者的姓名、学号和分数。如果有多个学生都满足条件，就输出学号最大的那个学生的信息。如果找不到满足条件的学生，则输出“Nobody”。 输入样例： Add Jack 12 78 Query 78 Query 81 Add Percy 9 81 Add Marry 8 81 Query 82 Add Tom 11 79 Query 80 Query 81 输出果样例： Nobody Jack 12 78 Percy 9 81 Tom 11 79 Tom 11 79 程序如下： #include #include #include using namespace std; class CStudent { public: struct CInfo { int id; string name; }; int score; CInfo info; }; typedef multimap&lt;int, CStudent::CInfo&gt; MAP_STD;//pair模板只允许first和second两个参数 int main() { MAP_STD mp; CStudent st; string cmd; while(cin&gt;&gt;cmd){ if (cmd == “Add”) { cin &gt;&gt; st.info.name &gt;&gt; st.info.id &gt;&gt; st.score; mp.insert(MAP_STD::value_type(st.score, st.info)); //mp.insert(make_pair(st.scorest.info));也可以 } else if (cmd == “Query”) { int score; cin &gt;&gt; score; MAP_STD::iterator p = mp.lower_bound(score); if (p != mp.begin()) { –p; score = p-&gt;first;//比要查询分数低的最高分 MAP_STD::iterator maxp = p;//已经是比分数低的最高分的位置 int maxId = p-&gt;second.id; for (; p != mp.begin() &amp;&amp; p-&gt;first == score; –p) { if (p-&gt;second.id &gt; maxId) { maxp = p; maxId = p-&gt;second.id; } } if (p-&gt;first == score) { if (p-&gt;second.id &gt; maxId) { maxp = p; maxId = p-&gt;second.id; } } cout &lt;&lt; maxp-&gt;second.name &lt;&lt; “ “ &lt;&lt; maxp-&gt;second.id &lt;&lt; “ “ &lt;&lt; maxp-&gt;first &lt;&lt; endl; } else cout &lt;&lt; “Nobody” &lt;&lt; endl; } } system(“pause”); return 0; } 2.map** template&lt;class Key, class T, class Pred = less, class A = allocator &gt; class map { typedef pair value_type; }; map中的元素都是pair模板类对象。关键字（first成员变量）各不相同。元素按照关键字从小到大排列，缺省情况下用less，即“&lt;”定义“小于”。 3.map的[]成员函数 若pairs为map模版类的对象， pairs[key] 返回对关键字等于key的元素的值(second成员变量）的引用。若没有关键字为key的元素，则会往pairs里插入一个关键字为key的元素，其值用无参构造函数初始化，并返回其值的引用。 如： map&lt;int, double&gt; pairs; 则 pairs[50]=5;会修改paris中关键字为50的元素，使其值变为5。若不存在关键字等于50的元素，则插入此元素，并使其值变为5。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++面向对象程序设计课程笔记（第八周）","slug":"c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8 (2)","date":"2018-09-18T14:31:35.000Z","updated":"2019-03-20T14:40:14.324Z","comments":false,"path":"2018/09/18/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8 (2)/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/18/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8 (2)/","excerpt":"","text":"第八周 标准模板库STL（一） 第一节 string类1.**关于string类 string类是模板类：typedef basic_stringstring;实例出来的类。使用string类要包含头文件。 string对象的初始化有以下几种类型： string s1(“Hello); string month = “March”; string s2(8,’x’); 以下的初始方法错误： string error1 = ‘c’;//error string error2(‘u’);//error string error3 = 22//error string error4(22);//error 但是可以将字符赋值给string对象，如下： string s; s = ‘n’;//OK string对象的长度用成员函数length()读取，如下： string s(“hello”); cout&lt;&lt;s.length()&lt;&lt;endl; string支持流读取运算符，如下： string stringObject; cin&gt;&gt; stringObject; string支持getline函数： string s; getline(cin,s); 2.string**的赋值和连接 （1）用=赋值： string s1(“cat”),s2; s2 = s1; （2）用assign成员函数复制 string s1(“cat”),s3; s3.assign(s1); （3）用assign成员函数部分复制 string s1(“catpig”),s3; s3.assign(s1,1,3);//从s1中下标为1的字符开始复制3个字符给s3 （4）单个字符复制 s2[5]=s1[3]=’a’; （5）逐个访问string对象中的字符 string s1(“Hello”); for(int i = 0;i&lt;s1.length();i++) cout&lt;&lt;s1.at(i)&lt;&lt;endl; 成员函数at会做范围检查，如果超出范围，会抛出out_of_range异常，而下标运算符[]不做范围检查。 （6）用+运算符连接字符串 string s1(“good”),s2(“morning”); s1+=s2; cout&lt;&lt;s1;//输出goodmorning （7）用成员函数append s2.append(s1,3,s1.size());//s1.size()为s1的字符数 下标为3开始，s1.size()个字符数，如果字符串内没有足够字符，则复制到字符串最后一个字符。 3.**比较**string （1）用关系运算符比较string的大小：==/&gt;/&gt;=/&lt;/&lt;=/!= 返回值都是bool类型，按照字典序。 （2）用成员函数compare比较string的大小 string s1(“hello”),s2(“hello”),s3(“hell”); int f1 = s1.compare(s2);//0 int f2 = s1.compare(s3);//1 int f3 = s3.compare(s1);//-1 int f4 = s1.compare(1,2,s3,0,3);//-1,比较s1的1-2与s3的0到3 int f5 = s1.compare(0,s1.size(),s3);//1，比较s1和s3的0-end 4.**成员函数 （1）成员函数substr string s1(“hello world”),s2; s2 = s1.substr(4,5);//下标4开始5个字符 cout &lt;&lt; s2 &lt;&lt;endl; 输出：o wor （2）成员函数swap string s1(“hello”),s2(“really”); s1.swap(s2); （3）成员函数find() string s1(“hello world”); s1.find(“lo”); 在s1中从前向后查找lo第一次出现的地方，如果找到则返回lo开始的位置（即l的下标）；如果找不到，返回string::npos（string定义的静态常量）。 （4）成员函数rfind() string s1(“hello world”); s1.rfind(“lo”); 在s1中从后向前查找lo第一次出现的地方，如果找到则返回lo开始的位置（即l的下标）；如果找不到，返回string::npos（string定义的静态常量）。 （5）成员函数find_first_of() string s1(“hello world”); s1.find_first_of(“abcd”); 在s1中从前向后找abcd中任何一个字符第一次出现的地方，如果找到返回字母的位置；如果找不到返回string::npos。 （6）成员函数find_last_of() string s1(“hello world”); s1.find_last_of(“abcd”); 在s1中查找abcd中任何一个字符最后一次出现的地方，如果找到，返回找到字母的位置；如果找不到，返回string::npos。 （7）成员函数find_first_not_of() string s1(“hello world”); s1.find_first_not_of (“abcd”); 在s1中从前向后查找不在abcd中的字母第一次出现的地方，如果找到，返回找到字母的位置（在此例中为h，返回0）；如果找不到，返回string::npos。 （8）成员函数find_last_not_of() string s1(“hello world”); s1.find_last _not_of (“abcd”); 在s1中凑后往前查找不在abcd中的字母第一次出现的地方，如果找到，返回找到字母的位置（此处为l，返回地址为9）；如果找不到，返回string::npos。 （9）成员函数erase()。删除string中的字符。 （10）成员函数replace()。替换string中的字符。例如： string s1(“hello world”); s1.replace(2,3,”haha”); cout &lt;&lt; s1; //将s1下标2开始的三个字符替换为haha 如果被替换区间大小小于替换长度，那么直接在后面加，如本例输出为hehaha world （11）成员函数insert()。在string中插入字符。 例程： string s1(“hello world”); string s2(“show insert”); s1.insert(5,s2); // 将s2插入s1下标5的位置 cout &lt;&lt; s1 &lt;&lt; endl; s1.insert(2,s2,5,3); //将s2中下标5开始的3个字符插入s1下标2的位置 cout &lt;&lt; s1 &lt;&lt; endl; 输出结果为： helloshow insert world heinslloshow insert world （12）成员函数c_str。转换成C语言式char*字符串 string s1(“hello world”); printf(“%s\\\\n,s1.c_str());//为了兼容C语言 // s1.c_str() 返回传统的const char * 类型字符串，且该字符串以‘\\\\0’结尾。 （13）成员函数data() string s1(“hello world”); const char p1=s1.data(); for(int i=0;i&lt;s1.length();i++) printf(“%c”,(p1+i)); //s1.data() 返回一个char * 类型的字符串，对s1 的修改可能会使p1出错。 （14）成员函数copy()。字符串拷贝函数。 string s1(“hello world”); int len = s1.length(); char * p2 = new char[len+1]; s1.copy(p2,5,0); p2[5]=0; cout &lt;&lt; p2 &lt;&lt; endl; // s1.copy(p2,5,0) 从s1的下标0的字符开始制作一个最长5个字符长度的字符串副本并将其赋值给p2。返回值表明实际复制字符串的长度。 输出结果为：hello 5.**字符串流处理 除了标准流和文件流输入输出外，还可以从string进行输入输出； 类似 istream和osteram进行标准流输入输出，我们用istringstream 和 ostringstream进行字符串上的输入输出，也称为内存输入输出。 用到的头文件： #include #include #include 例程**1**：字符串输入流 istringstream string input(“Input test 123 4.7 A”); istringstream inputString(input); string string1, string2; int i; double d; char c; inputString &gt;&gt; string1 &gt;&gt; string2 &gt;&gt; i &gt;&gt; d &gt;&gt; c; cout &lt;&lt; string1 &lt;&lt; endl &lt;&lt; string2 &lt;&lt; endl; cout &lt;&lt; i &lt;&lt;endl &lt;&lt; d &lt;&lt; endl &lt;&lt; c &lt;&lt; endl; long L; if(inputString &gt;&gt; L) cout &lt;&lt; “long\\\\n”; else cout &lt;&lt; “empty\\\\n”; 输出结果为： Input test 123 4.7 A empty 例程**2**：字符串输出流 istringstream ostringstream outputString; int a = 10; outputString &lt;&lt; “This “ &lt;&lt; a &lt;&lt; “ ok” &lt;&lt; endl; cout &lt;&lt; outputString.str(); 输出：This 10 ok 第二节 标准模板库STL概述（一）1.**泛型程序设计 C++语言的核心优势之一就是便于软件的重用。C++中有两个方面体现重用： （1）面向对象的思想：继承和多态，标准类库。 （2）泛型程序设计的思想：模板机制，以及标准模板库STL。 将一些常用的数据结构（比如链表，数组，二叉树）和算法（比如排序，查找）写成模板，以后则不论数据结构里放的是什么对象，算法针对什么样的对象，则都不必重新实现数据结构，重新编写算法。 标准模板库 (Standard Template Library) 就是一些常用数据结构和算法的模板的集合。有了STL，不必再写大多的标准数据结构和算法，并且可获得非常高的性能。 2.STL**中的基本概念 容器：可容纳各种数据类型的通用数据结构,是类模板。 迭代器：可用于依次存取容器中元素，类似于指针。 算法：用来操作容器中的元素的函数模板。 算法本身与他们操作的数据的类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用。 举个例子，比如说int array[100];该数组就是容器，而int类型的指针变量就可以作为迭代器，sort算法可以作用于该容器上，对其进行排序： sort(array,array+70); 3.**容器概述 可以用于存放各种类型的数据（基本类型的变量、对象等）的数据结构，都是类模板，分为三种： ①顺序容器：vector，deque，list。 ②关联容器：set，multiset，map，multimap。 ③容器适配器：stack，queue，priority_queue。 对象被插入容器中时，被插入的是对象的一个复制品。许多算法，比如排序，查找，要求对容器中的元素进行比较，有的容器本身就是排序的，所以，放入容器的对象所属的类，往往还应该重载 == 和 &lt; 运算符。 （1）顺序容器 容器并非排序的，元素的插入位置同元素的值无关。有vector，deque，list三种。 ①vector 头文件 动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能(大部分情况下是常数时间）。 ②deque 头文件 双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（但次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。 ③list 头文件 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。 （2）关联容器 元素是排序的，插入任何元素，都按相应的排序规则来确定其位置。在查找时有非常好的性能，通常以平衡二叉树方式实现，插入和检索时间都是**O(log(N))。 ①set/multiset 头文件 set即集合。set中不允许相同元素，multiset中允许相同的元素。 ②map/multimap 头文件 map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first，另一个名为second，map根据first值对元素进行从小到大排序，并可快速根据first来检索元素。 map同multimap的不同在于是否允许相同first值的元素。 （3）容器适配器 ①stack：头文件 栈。是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项。后进先出。 ②queue 头文件 队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。 ③priority_queue 头文件 优先级队列。最高优先级元素总是第一个出列。 4.**顺序容器和关联容器中都有的成员函数* 成员函数 功能 begin 返回指向容器中第一个元素的迭代器。 end 返回指向容器中最后一个元素后面的位置的迭代器。 rbegin 返回指向容器中最后一个元素的迭代器。 rend 返回只想容器中第一个元素前面的位置迭代器。 erase 从容器中删除一个或几个元素。 clear 从容器中删除所有元素。 5.顺序容器的常用成员函数 成员函数 功能 front 返回容器中第一个元素的引用。 back 返回容器中最后一个元素的引用。 push_back 在容器末位增加新元素。 pop_back 删除容器模块的元素。 erase 删除迭代器指向的元素(可能会使该迭代器失效），或删除一个区间，返回被删除元素后面的那个元素的迭代器。 第三节 标准模板库STL概述（二）1.**迭代器** （1）基本概念 用于指向顺序容器和关联容器中的元素 迭代器用法和指针类似 有const 和非 const两种 通过迭代器可以读取它指向的元素 通过非const迭代器还能修改其指向的元素 （2）迭代器的定义 定义一个容器类的迭代器的方法可以是： 容器名称::iterator 变量名; 或 容器名称::const_iterator 变量名; 访问一个迭代器指向的元素： 迭代器变量名 迭代器上可以执行 ++ 操作, 以使其指向容器中的下一个元素。如果迭代器到达了容器中的最后一个元素的后面，此时再使用它，就会出错，类似于使用NULL或未初始化的指针一样。 例程： #include #include using namespace std; int main() { vector v; //一个存放int元素的数组，一开始里面没有元素 v.push_back(1);v.push_back(2);v.push_back(3);v.push_back(4); vector::const iterator i;//常量迭代器 for(int i = v.begin();i!=v.end;++i) cout&lt;&lt;\\i&lt;&lt;”,”; cout&lt;&lt;endl; //输出结果1,2,3,4, vector::reserve.iterator r;//反向迭代器 for(r = v.rbegin();r!=v.rend();r++) cout&lt;&lt;*r&lt;&lt;”,”; cout&lt;&lt;endl; //输出结果：4,3,2,1, vector::iterator j;//非常量迭代器 for(j = v.begin();j!=v.end();j++) *j = 100; for(i = v.begin();i!=v.end();i++) cout&lt;&lt;*i&lt;&lt;”,”; //输出结果：100,100,100,100, return 0; } （3）双向迭代器 若p和p1都是双向迭代器，则可对p、p1可进行以下操作： ++p,p++：使p指向容器中下一个元素； –p,p–：使p指向容器的上一个元素； *p：取p指向的元素； p = p1：赋值； p==p1,p!=p1：判断是否相等 （4）随机访问迭代器 若p和p1都是随机访问迭代器，则可对p、p1可进行以下操作： 双向迭代器的所有操作 p += i 将p向后移动i个元素 p -= i 将p向向前移动i个元素 p + i 值为: 指向 p 后面的第i个元素的迭代器 p - i 值为: 指向 p 前面的第i个元素的迭代器 p[i] 值为: p后面的第i个元素的引用 p &lt; p1, p &lt;= p1, p &gt; p1, p&gt;= p1 p – p1 : p1和p之间的元素个数 表3.1 容器和容器上面的迭代器 容器 容器上的迭代器类别 vector 随机访问 deque 随机访问 list 双向 set/multiset 双向 map/multimap 双向 stack 不支持 queue 不支持 priority_queue 不支持 例程**1：vector的遍历，deque**也是这样 vector v(100); int i; for(i = 0;i &lt; v.size() ; i ++) cout&lt;&lt;v[i];//根据下标随机访问 vector::const_iterator ii; for( ii = v.begin(); ii != v.end ();++ii) cout &lt;&lt; ii; for( ii = v.begin(); ii &lt; v.end ();++ii ) cout &lt;&lt; ii; 例程2：list的遍历（双向迭代器） list v; list::const_iterator ii; for(ii=v.begin();ii!=v.end();++ii) cout&lt;&lt;ii; 2.**算法 算法就是一个个函数模板, 大多数在 中定义。STL中提供能在各种容器中通用的算法，比如查找，排序等。算法通过迭代器来操纵容器中的元素。许多算法可以对容器中的一个局部区间进行操作，因此需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。比如，排序和查找。有的算法返回一个迭代器。比如 find() 算法，在容器中查找一个元素，并返回一个指向该元素的迭代器。算法可以处理容器，也可以处理普通数组 算法示例：find() template InIt find(InIt first, InIt last, const T&amp; val); first 和 last 这两个参数都是容器的迭代器，它们给出了容器中的查找区间起点和终点[first,last)。区间的起点是位于查找范围之中的，而终点不是。find在[first,last)**查找等于val的元素。用 == 运算符判断相等。函数返回值是一个迭代器。如果找到，则该迭代器指向被找到的元素。如果找不到，则该迭代器等于last。 例程： #include #include #include using namespace std; int main() { int array[10] = {10,20,30,40}; vector v; v.push_back(1);v.push_back(2);v.push_back(3);v.push_back(4); vector::iterator p; p = find(v.begin(),v.end(),3); if(p!=v.end()) cout&lt;&lt;\\p&lt;&lt;endl;//输出3 p = find(v.begin(),v.end(),9) if(p == v.end()) cout&lt;&lt;”not found”&lt;&lt;endl;//输出not found p = find(v.begin+1,v.end()-2,1); //查找区间为[2,3) if(p!=v.end()) cout&lt;&lt;*p&lt;endl;//输出结果为3，因为找不到就返回v.end()，在这里相当于v.end()的是3这个位置 int *pp = find(array,array+4,20);//数组名是迭代器 cout&lt;&lt;*pp&lt;&lt;endl;//输出20 } 3.STL**中的“大”、“小”和“相等” 关联容器内部的元素是从小到大排序的。有些算法要求其操作的区间是从小到大排序的，称为“有序区间算法”，例如binary_search（二分法查找）；有些算法会对区间进行从小到大（可以自己定义）排序，称为“排序算法”，例如sort；还有一些其它算法会用到“大”“小”的概念，使用STL时，在缺省**情况下，以下三个说法等价： （1）x比y小； （2）表达式“x&lt;y”为真； （3）y比x大。 有时，“x和y相等”等价于“x==y为真”，例如在未排序的区间上进行的算法，如顺序查找find；有时候“x和y相等”等价于“x小于y和y小于x同时为假”（这里小于也是可以自定义的），例如有序区间算法，如binary_search，关联容器自身的成员函数find。 第四节 vector，deque和list1.vector vector**示例程序1： #include #include using namespace std; template void PrintVector( T s, T e){ for(; s != e; ++s) cout &lt;&lt; * s &lt;&lt; “ “; cout &lt;&lt; endl; } int main(){ int a[5] = {1,2,3,4,5}; vector v(a,a+5);//将数组a的内容放入v cout&lt;&lt;”1)”&lt;&lt;v.end()-v.begin()&lt;&lt;endl; //两个随机迭代器可以相减，输出1)5 cout&lt;&lt;”2)”; PrintVector(v.begin(),v.end()); //2)1 2 3 4 5 v.insert(v.begin()+2,13); cout&lt;&lt;”3)”; PrintVector(v.begin(),v.end()); //3)1 2 13 3 4 5 v.erase(v.begin()+2); cout&lt;&lt;”4)”; PrintVector(v.begin(),v.end()); //4)1 2 3 4 5 vector v2(4,100);//v2有4个元素，都是100 v2.insert(v2.begin(),v.begin()+1,v.begin()+3); cout&lt;&lt;”5)”; PrintVector(v2.begin(),v2.end()); //5)2 3 100 100 100 100 v.erase(v.begin() + 1, v.begin() + 3); //删除 v 上的一个区间,即 2,3 cout &lt;&lt; “6) “; PrintVector(v.begin(),v.end()); //6) 1 4 5 return 0; } 例程2：用vector实现二维数组 #include #include using namespace std; int main() { vector&lt;vector &gt; v(3); //v有3个元素，每个元素都是vector容器 for(int i = 0;i&lt;v.size();++i) for(int j = 0;j&lt;4;++j) v[i].push_back(j); for(int i = 0;i&lt;v.size();++i){ for(int j = 0;j&lt;v[i].size();++j) cout&lt;&lt;v[i][j]&lt;&lt;” “; cout&lt;&lt;endl; } return 0; } 2.deque 所有适用于 vector的操作都适用于 deque。 deque还有 push_front（将元素插入到前面） 和pop_front(删除最前面的元素）操作，复杂度是O(1)。 3.**双向链表 在任何位置插入删除都是常数时间，不支持随机存取。除了具有所有顺序容器都有的成员函数以外，还支持8个成员函数： 函数名 作用 函数名 作用 push_front 在前面插入 unique 删除所有和前一个元素相同的元素（要做到元素不重复，则在unique之前还需要sort） pop_front 删除最前面的元素 merge 合并两个链表，并清空被合并的那个 sort 排序（但不支持**STL的算法sort**） reverse 颠倒链表 remove 删除和指定值相等的所有元素 splice 在指定位置前面插入另一链表中的一个或多个元素，并在另一链表中删除被插入的元素 例程：双向链表的例程 图4.1 程序1 图4.2 程序1续1 template void PrintList(const list &amp; lst) { //不推荐的写法，还是用两个迭代器作为参数更好 int tmp = lst.size(); if( tmp &gt; 0 ) { typename list::const_iterator i; i = lst.begin(); for( i = lst.begin();i != lst.end(); i ++) cout&lt;&lt;*i&lt;&lt;”,”; } }//typename用来说明 list::const_iterator是个类型 //在vs中不写也可以 int main(){ list lst1,lst2; lst1.push_back(1);lst1.push_back(3); lst1.push_back(2);lst1.push_back(4); lst1.push_back(2); lst2.push_back(10);lst2.push_front(20); lst2.push_back(30);lst2.push_back(30); lst2.push_back(30);lst2.push_front(40); lst2.push_back(40); cout&lt;&lt;”1)”;PrintList(lst1);cout&lt;&lt;endl; //1)1,3,2,4,2 cout&lt;&lt;”2)”;PrintList(lst2);cout&lt;&lt;endl; //2)40,20,10,30,30,30,40 lst2.sort(); 图4.3 程序1续2 图4.4 程序1 续3 图4.5 程序1 续4 第五节 函数对象1.**函数对象定义 函数对象是个对象，但是用起来看上去像函数调用，实际上也执行了函数调用。若一个类重载了运算符“()”，则该类的对象就成为了函数对象。 例如： class CMyAverage{ public: double operator()(int a1, int a2, int a3){ return (double)(a1+a2+a3)/3; } }; CMyAverage agerage; cout&lt;&lt;agerage(3,4,5);//输出为4 2.STL**里有模板举例 （1）template T accumulate(InIt first, InIt last, T val, Pred pr); pr就是一个函数对象，对[first,last)中的每个迭代器I，执行val = pr(val,*I),返回最终的val。 pr也可以是个函数。 Dev C++中的Accumulate源代码1： template _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init){ for(;__first!=__last;++__first) __init = __init + *__first; return __init; } //typename等价于class Dev C++中的Accumulate源代码2： template _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,_BinaryOperation __binary_op){ for(;__first!=__last;++__first) __init = __binary_op(__init + __first); return __init; } 调用accumulate时，和__binary_op对应的实参可以是个函数或函数对象。 （2）greater函数对象类模板 template struct greater : public binary_function&lt;T, T, bool&gt; { bool operator()(const T&amp; x, const T&amp; y) const { return x&gt;y; } }; 可以看出，在这里只有x&gt;y的时候才会返回true。 list有两个sort函数，第一个是前面所说的不带参数的sort函数，它将list中的元素按“规定的比较方法”升序排列。 list还有另一个sort函数： template void sort(T2 op); 可以用op来比较大小，即op(x,y)为true则认为x应该排在前面。 例程： #include #include #include using namespace std; class MyLess { public: bool operator()(const int &amp; c1, const int &amp; c2) { return (c1%10)&lt;(c2%10); } }; int main() { const int SIZE = 5; int a[SIZE] = {5,21,14,2,3}; list lst(a,a+SIZE); lst.sort(MyLess()); //调用的第二种sort排序，由MyLess()来确定，准确的说是()确定 Print(lst.begin(),lst.end()); cout&lt;&lt;endl; lst.sort(greater());//greater()是个对象 Print(lst.begin(),lst.end()); cout&lt;&lt;endl; return 0; } 输出结果：21,2,3,14,5,（按照个位数排序） 21,14,5,3,2,（倒序排列） 3.**在STL中使用自定义的“大”“小”关系 关联容器和STL中许多算法，都是可以用函数或函数对象自定义比较器的。在自定义了比较器op的情况下，以下三种说法是等价的： ①x小于y； ②op(x,y)返回值为true； ③y大于x。 例题：写出MyMax模板 #include #include using namespace std; class MyLess { public: bool operator()(const int &amp; c1, const int &amp; c2) { if((c1%10)&lt;(c2%10)) return true; elsereturn false; } bool MyCompare(int a1, int a2) { if((a1%10)&lt;(a2%10)) return false; else return true; } }; template T MyMax(T first, T last, Pred myless) { T tmpMax= first;//tmpMax是一个迭代器 for(;first!=last;++first) if(myless(\\tmpMax,*first)) tmpMax = first; return tmpMax; };* int main() { int a[] = {35,7,13,19,12}; cout&lt;&lt;\\MyMax(a,a+5,MyLess())&lt;&lt;endl;//个位数最大 cout&lt;&lt;*MyMax(a,a+5,MyCompare)&lt;&lt;endl;//个位数最小 return 0; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++面向对象程序设计课程笔记（第七周）","slug":"c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae","date":"2018-09-17T15:15:51.000Z","updated":"2019-03-20T14:40:43.340Z","comments":false,"path":"2018/09/17/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/17/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae/","excerpt":"","text":"第七周：输入输出和模板 第一节 输入输出流相关的类1.**与输入输出流操作相关的类** 图1.1 与输入输出流操作相关的类 istream是用于输入的流类，cin就是该类的对象；ostream是用于输出的流类，cout就是该类的对象；ifstream是用于从文件读取数据的类；ofstream是用于向文件写入数据的类；iostream是既能用于输入，又能用于输出的类；fstream 是既能从文件读取数据，又能向文件写入数据的类。 2.**标准流对象 （1）输入流对象：cin与标准输入设备相连。 （2）输出流对象：cout与标准输出设备相连；cerr，与标准错误输出设备相连；clog，与标准错误输出设备相连。缺省情况下，以下三者功能相同： cerr &lt;&lt; “Hello,world” &lt;&lt; endl; clog &lt;&lt; “Hello,world” &lt;&lt; endl; cout &lt;&lt; “Hello,world” &lt;&lt; endl; cin对应于标准输入流，用于从键盘读取数据，也可以被重定向为从文件中读取数据。  cout对应于标准输出流，用于向屏幕输出数据，也可以被重定向为向文件写入数据。  cerr对应于标准错误输出流，用于向屏幕输出出错信息，  clog对应于标准错误输出流，用于向屏幕输出出错信息，  cerr和clog的区别在于cerr不使用缓冲区,直接向显示器输出信息；而输出到clog中的信息先会被存放在缓冲区,缓冲区满或者刷新时才输出到屏幕。 3.**输入重定向和输出重定向 （**1**）输入重定向 #include using namespace std; int main(){ double f; int n; freopen(“t.txt”,”r”,stdin);//cin被改为从t.txt中读取数据 cin&gt;&gt;f&gt;&gt;n; cout&lt;&lt;f&lt;&lt;”,”&lt;&lt;n&lt;&lt;endl; return 0; } （**2**）输出重定向 #include using namespace std; int main(){ int x,y; freopen(“test.txt”,”w”,stdout);//将标准输出重定向到test.txt文件 if(y==0) cerr&lt;&lt;”error.”&lt;&lt;endl; elsecout&lt;&lt;x/y;//结果输出到test.txt return 0; } 在上面这个程序里面，我们把标准输出重定向为输出到test.txt文件中去。这个时候，只要执行cout就会向test.txt中写文件。而如果我们这个时候出现错误需要向屏幕显示错误信息而不是向文件写入该怎么办呢？那就利用cerr，因为cerr没有被重定向。 4.**判断输入流结束 可以用如下方法判断输入流结束： int x; while(cin&gt;&gt;x){ … } return 0; 如果是从文件输入，比如前面有freopen(“some.txt”,”r”,stdin);那么读到文件尾部，输入流就算结束。如果从键盘输入，则在单独一行输入Ctrl+Z代表输入流结束。 5.istream**类的成员函数 （1）istream &amp; getline(char buf, int bufSize); 从输入流中读取bufSize-1个字符到缓冲区buf，或读到碰到‘\\\\n’ 为止（哪个先到算哪个）。 （2）istream &amp; getline(char buf, int bufSize,char delim); 从输入流中读取bufSize-1个字符到缓冲区buf，或读到碰到delim字符为止（哪个先到算哪个）。 两个函数都会自动在**buf中读入数据的结尾添加\\\\0’。,‘\\\\n’或delim都不会被读入buf**，但会被从输入流中取走。 如果输入流中 ‘\\\\n’或delim之前的字符个数达到或超过了bufSize个，就导致读入出错，其结果就是：虽然本次读入已经完成，但是之后的读入就都会失败了。 可以用 if(!cin.getline(…)) 判断输入是否结束。 bool eof(); 判断输入流是否结束 int peek(); 返回下一个字符,但不从流中去掉. istream &amp; putback(char c); 将字符ch放回输入流 istream &amp; ignore( int nCount = 1, int delim = EOF ); 从流中删掉最多nCount个字符，遇到EOF时结束。 例程： #include using namespace std; int main(){ int x; char buf[100]; cin &gt;&gt; x; cin.getline(buf,90); cout&lt;&lt;buf&lt;&lt;endl; return 0; } 输入12 abcd（回车），输出abcd（即：空格+abcd）这是正常的。 但是输入12（回车），程序立即结束，输出为空。这是为什么呢？因为getline读到留在流中的’\\\\n’就会立即结束，然后返回。 第二节 用流操纵算子控制输出格式1.**流操纵算子 使用流操纵算子需要#include 。 （1）整数流的基数：流操纵算子dec，oct，hex，setbase（任何一个进制） int n =10; cout&lt;&lt;oct&lt;&lt;n&lt;&lt;endl; 设置了之后一直起作用，直到你设置了另一个流操纵算子。 （2）浮点数的精度（precision，setprecision）——对整型无影响 precision是成员函数，其调用方式为cout.precision(5); setprecision是流操作算子，其调用方式为cout&lt;&lt;setprecision(5);//可以连续输出。 它们的功能相同。 指定输出浮点数的有效位数（非定点方式输出时） 指定输出浮点数的小数点后的有效位数（定点方式输出时）定点方式：小数点必须出现在个位数后面。 例程： ①非定点方式 #include #include using namespace std; int main() { double x = 1234567.89,y = 12.34567; int n = 1234567; int m = 12; cout &lt;&lt; setprecision(6) &lt;&lt; x &lt;&lt; endl&lt;&lt; y &lt;&lt; endl &lt;&lt; n &lt;&lt; endl &lt;&lt; m; }//默认为非定点 输出：1.23457e+006 12.3457 1234567 12 ②设置定点方式如下： #include #include using namespace std; int main() { double x = 1234567.89,y = 12.34567; int n = 1234567; int m = 12; cout &lt;&lt;setiosflags(ios::fixed)&lt;&lt; setprecision(6) &lt;&lt; x &lt;&lt; endl&lt;&lt; y &lt;&lt; endl &lt;&lt; n &lt;&lt; endl &lt;&lt; m; } 输出：1234567.890000 12.345670 1234567 12 ③取消定点 #include #include using namespace std; int main() { double x = 1234567.89; int m = 12; cout &lt;&lt;setiosflags(ios::fixed)&lt;&lt; setprecision(6) &lt;&lt; x &lt;&lt; endl&lt;&lt; resetiosflags(ios:fixed) &lt;&lt; x; } 输出：1234567.890000 1.23457e+006 （3）设置域宽(setw，width) 两者功能相同，一个是成员函数（width），另一个是流操作算子（setw），调用方式不同： cin &gt;&gt; setw(4); 或者 cin.width(5); cout &lt;&lt; setw(4); 或者 cout.width(5); 宽度设置有效性是一次性的，在每次读入和输出之前都要设置宽度。 例程： #include #include using namespace std; int main() { int n = 141; //1) 分别以十六进制、十进制、八进制先后输出 n cout &lt;&lt; “1) “ &lt;&lt; hex &lt;&lt; n &lt;&lt; “ “ &lt;&lt; dec &lt;&lt; n &lt;&lt; “ “ &lt;&lt; oct &lt;&lt; n &lt;&lt; endl; double x = 1234567.89,y = 12.34567; //2) 保留5位有效数字 cout &lt;&lt; “2) “ &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; “ “ &lt;&lt; y &lt;&lt; “ “ &lt;&lt; endl; //3) 保留小数点后面5位 cout &lt;&lt; “3) “ &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; “ “ &lt;&lt; y &lt;&lt; endl ; //4) 科学计数法输出，且保留小数点后面5位 cout &lt;&lt; “4) “ &lt;&lt; scientific &lt;&lt; setprecision(5) &lt;&lt;x &lt;&lt; “ “ &lt;&lt; y &lt;&lt; endl ; //5) 非负数要显示正号，输出宽度为12字符，showpos表示非负数要写出正号来。宽度不足则用’‘填补 cout &lt;&lt; “5) “ &lt;&lt; showpos &lt;&lt; fixed &lt;&lt; setw(12) &lt;&lt; setfill(‘‘) &lt;&lt; 12.1 //6) 非负数不显示正号，输出宽度为12字符，宽度不足则右边用填充字符填充 cout &lt;&lt; “6) “ &lt;&lt; noshowpos &lt;&lt; setw(12) &lt;&lt; left &lt;&lt; 12.1 &lt;&lt; endl; //7) 输出宽度为12字符，宽度不足则左边用填充字符填充 cout &lt;&lt; “7) “ &lt;&lt; setw(12) &lt;&lt; right &lt;&lt; 12.1 &lt;&lt; endl; //8) 宽度不足时，负号和数值分列左右，中间用填充字符填充 cout &lt;&lt; “8) “ &lt;&lt; setw(12) &lt;&lt; internal &lt;&lt; -12.1 &lt;&lt; endl; cout &lt;&lt; “9) “ &lt;&lt; 12.1 &lt;&lt; endl; return 0; } 输出结果如下： 1) 8d 141 215 2) 1.2346e+006 12.346 3) 1234567.89000 12.34567 4) 1.23457e+006 1.23457e+001 5) *+12.10000 6) 12.10000** 7) ****12.10000 8) -***12.10000 9) 12.10000 （4）用户自定义的流操纵算子等。 例程： ostream &amp;tab(ostream &amp;output){ return output&lt;&lt;’\\\\t’; } cout&lt;&lt;”aa”&lt;&lt;tab&lt;&lt;”bb”&lt;&lt;endl; 输出：aa bb 为什么能进行这样的操作呢？因为iostream里面对&lt;&lt;进行了重载（成员函数）： ostream &amp;operator&lt;&lt;(ostream&amp;(*p)(osream&amp;)); 该函数内部会调用p所指向的函数，且以*this作为参数。 第三节 文件读写（一）1.**创建文件 可以将顺序文件看作一个有限字符构成的顺序字符流，然后像对cin，cout一样的读写。 #include //包含头文件 ofstream outFile(“cliends.dat”,ios::out|ios::binary); 在这其中，clients.dat是要创建的文件的名字。ios::out是文件打开方式，ios:out输出到文件，删除原有内容。ios::app输出到文件，保留原有内容，总是在尾部添加。ios::binary以二进制文件格式打开文件。 也可以先创建ofstream对象，再用open函数打开： ofstream fout; fout.open(“test.out”,ios::out|ios:binary); 判断打开是否成功： if(!fout){cout&lt;&lt;”File open error!”&lt;&lt;endl;} 文件名可以给出绝对路径，也可以给相对路径。没有交代路径信息，就是在当前文件夹下找文件。 2.**文件名的绝对路径和相对路径 如图所示。 图3.1 文件路径 3.**文件的读写指针 对于输入文件，有一个读指针；对于输出文件，有一个写指针；对于输入输出文件，有一个读写指针；标识文件操作的当前位置，该指针在哪里，读写操作就在哪里进行。 例程1： ofstream fout(“a1.out”,ios::app)//以添加方式打开 long location = fout.tellp(); //获取写指针的位置 location = 10; fout.seekp(location);//将写指针移动到第10个字节处 fout.seekp(location,ios::beg); //从头数location location fout.seekp(location,ios::cur); //从当前位置数location location fout.seekp(location,ios::end); //从尾部数location 例程2： ifstream fout(“a1.in”,ios::ate) //打开文件，定位文件指针到文件尾 long location = fin.tellg(); //取得读指针的位置，获得文件的长度。 location = 10L; fin.seekg(location); // 将读指针移动到第10个字节处 fin.seekg(location,ios::beg); //从头数location location fin.seekg(location,ios::cur); //从当前位置数location location fin.seekg(location,ios::end); //从尾部数location location**可以为负数！ 4.**显式关闭文件 读文件： ifstream fin(“test.dat”,ios::in); fin.close(); 写文件： ofstream fout(“test.dat”,ios::out); fout.close(); 5.**字符文件读写 因为文件流也是流，所以流的成员函数和流操作算子也同样适用于文件流。写一个程序，将文件 in.txt 里面的整数排序后，输出到out.txt。 程序如下： #include #include #include #include using namespace std; int main() { vector v; ifstream srcFile(“in.txt”,ios::in); ofstream destFile(“out.txt”,ios::out); int x; while( srcFile &gt;&gt; x ) v.push_back(x); sort(v.begin(),v.end()); for( int i = 0;i &lt; v.size();i ++ ) destFile &lt;&lt; v[i] &lt;&lt; “ “; destFile.close(); srcFile.close(); return 0; } 第四节 文件读写（二）1.**二进制文件读写 （1）二进制读文件 ifstream和fstream的成员函数： istream&amp; read (char s, long n); 将文件读指针指向的地方的n个字节内容，读入到内存地址s，然后将文件读指针向后移动n字节 (以ios::in方式打开文件时，文件读指针开始指向文件开头)。 （2）二进制写文件 ofstream和fstream的成员函数： istream&amp; write(const char s,long n); 将内存地址s处的n个字节内容，写入到文件中写指针指向的位置，然后将文件写指针向后移动n字节(以ios::out方式打开文件时，文件写指针开始指向文件开头, 以ios::app方式打开文件时，文件写指针开始指向文件尾部)。 例程：在文件中写入和读取一个整数 #include #include using namespace std; int main() { ofstream fout(“some.dat”, ios::out | ios::binary); int x=120; fout.write( (const char )(&amp;x), sizeof(int) ); fout.close(); ifstream fin(“some.dat”,ios::in | ios::binary); int y; fin.read((char ) &amp; y,sizeof(int)); fin.close(); cout &lt;&lt; y &lt;&lt;endl; return 0; } 例程2：从键盘输入几个学生的姓名的成绩，并以二进制文件形式保存 #include #include using namespace std; struct Student { char name[20]; int score; }; int main(){ Student s; ofstream OutFile(“c:\\\\\\tmp\\\\\\students.dat”,ios::out|ios::binary); while(cin&gt;&gt;s.name&gt;&gt;s.core) OutFile.write((char)&amp;s,sizeof(s)); OutFile.close(); return 0; } 例程3：将students.dat文件的内容独出并显示 #include #include using namespace std; struct Student { char name[20]; int score; }; int main(){ Student s; ifstream inFile(“students.dat”,ios::in | ios::binary ); if(!inFile) { cout &lt;&lt; “error” &lt;&lt;endl; return 0; } while( inFile.read( (char ) &amp; s, sizeof(s) ) ) { int readedBytes = inFile.gcount();//看读了多少字节 cout&lt;&lt;s.name&lt;&lt;” “&lt;&lt;s.score&lt;&lt;endl; } inFile.close(); return 0; } 例程4：将students.dat文件的Jane的名字替换成Mike #include #include using namespace std; struct Student { char name[20]; int score; }; int main(){ Student s; fstream iofile( “c:\\\\\\tmp\\\\\\students.dat”, ios::in|ios::out|ios::binary); if( !iofile) { cout &lt;&lt; “error” ; return 0; } iofile.seekp( 2 sizeof(s),ios::beg); //定位写指针到第三个记录 iofile.write(“Mike”,strlen(“Mike”)+1); iofile.seekg(0,ios::beg); //定位读指针到开头 while( iofile.read( (char ) &amp; s, sizeof(s)) ) cout &lt;&lt; s.name &lt;&lt; “ “ &lt;&lt; s.score &lt;&lt; endl; iofile.close(); return 0; } 例程5：文件拷贝程序mycopy示例 #include #include using namespace std; int main(int argc, char * argv[]){ if(argc!=3){ cout&lt;&lt;”File name missing!”&lt;&lt;endl; return 0; } ifstream inFile(argv[1],ios::binary|ios::in);//打开文件用于读 if(!inFile){ cout&lt;&lt;”Source file open error”&lt;&lt;endl; return 0; } ofstream outFile(argv[2],ios::binary|ios::out);//打开文件用于写 if(!inFile){ cout&lt;&lt;”New file open error”&lt;&lt;endl; inFile.close();//务必把要读的文件关闭 return 0; } char c; while(inFile.get(c))//每次读取一个字符，但是操作系统已经把硬盘上较大的空间读在内存了 outFile.put(c);//每次写入一个字符 outFile.close(); inFile.close(); return 0; } 2.**二进制文件和文本文件的区别 Linux,Unix下的换行符号：‘\\\\n’（ASCII码：0x0a）。 Windows 下的换行符号：‘\\\\r\\\\n’（ASCII码： 0x0d0a），endl 就是 ‘\\\\n’。 Mac OS下的换行符号：‘\\\\r’（ASCII码：0x0d）。 导致Linux，Mac OS文本文件在Windows记事本中打开时不换行。 Unix/Linux下打开文件，用不用 ios::binary 没区别。但是在Windows下，如果不用，则会出现以下情况： （1）读取文件时，所有的’\\\\r\\\\n’会被当做一个字符’\\\\n’处理，即少读了一个字符’\\\\r’。 （2）写入文件时，写入单独的’\\\\n’时，系统自动在前面加一个’\\\\r’，即多写了一个’\\\\r’ 第五节 函数模板（泛型程序设计）1.**函数模板基础 格式如下： template 返回值类型 模板名(形参表) { 函数体 }; 举例如下： template void Swap(T &amp; x, T&amp; y) { T tmp = x; x = y; y = tmp; } int main() { int n =1, m =2; Swap(n,m);//编译器自动生成void Swap(int &amp; , int &amp;) double f = 1.2,g=2.3; Swap(f,g);//编译器自动生成void Swap(double &amp; , double &amp;) return 0; } 函数模板中可以不只有一个类型参数。例如： template T2 print(T1 arg1, T2 arg2) { cout&lt;&lt; arg1 &lt;&lt; “ “&lt;&lt; arg2&lt;&lt;endl; return arg2; } 例程1：求数组最大元素的MaxElement函数模板 template T MaxElement(T a[], int size){ T = tmpMax = a[0]; for(int i = 0;i&lt;size;i++) { if(tmpMax &lt; a[i]) tmpMax = a[i]; } return tmpMax; } 以上称为模板实例化，是通过参数实例化的。 例程2：不通过参数实例化函数模板 #include using namespace std; template T Inc(T n) { return 1 + n; } int main() { cout &lt;&lt; Inc(4)/2; //在Inc后面加一个就是一个实例化。实例化后是5，然后除以2是2.5 return 0; } 2.**函数模板的重载 函数模板可以重载，只要它们的形参表或类型参数表不同即可。 3.**函数模板和函数的次序 在有多个函数和函数模板名字相同的情况下，编译器如下处理一条函数调用语句： （1）先找参数完全匹配的普通函数(非由模板实例化而得的函数)。 （2）再找参数完全匹配的模板函数。（匹配模板函数时，不进行类型自动转换！！！*） （3）再找实参数经过自动类型转换后能够匹配的普通函数。 （4）上面的都找不到，则报错。 函数模板实例：Map #include using namespace std; template void Map(T s, T e, T x, Pred op){ //往往s和e都是指针，s是区间的开始位置，e是区间的结束位置，x也是指针，op是函数指针 for(;s!=e;++s,++x){ \\x = op(*s);//把s指向的东西（*s）通过op变换放到x指向的地方（*x） } } int Cube(int x){return x*x*x;} double Square(double x){return x*x;} int a[5] = {1,2,3,4,5}, b[5];//a为源区间，b为目标区间 double d[5] = { 1.1,2.1,3.1,4.1,5.1} , c[5]; //d为源区间，c为目标区间 int main() { Map(a,a+5,b,Square); for(int i =0;i&lt;5;++i) cout&lt;&lt;b[i]&lt;&lt;”,”; cout&lt;&lt;endl; Map(a,a+5,b,Cube); for(int i = 0;i&lt;5;++i) cout&lt;&lt;b[i]&lt;&lt;”,”; cout&lt;&lt;endl; Map(d,d+5,c,Square); for(int i=0;i&lt;5;++i) cout&lt;&lt;c[i]&lt;&lt;”,”; cout&lt;&lt;endl; return 0; } 输出： 1,4,9,16,25, 1,8,27,64,125, 1.21,4.41,9.61,16.81,26.01, 来分析以下，以第一个Map为例： 在调用的时候，Map模板实际上变成了这样： void Map(int * s, int e, int x, double ( *op)(double)) { for(;s!=e;++s,++x){ *x = op(*s); } } 第六节 类模板为了多快好省地定义出一批相似的类,可以定义类模板,然后由类模板生成不同的类。 考虑一个可变长数组类，需要提供的基本操作 –len()：查看数组的长度 –getElement(int index)：获取其中的一个元素 –setElement(int index)：对其中的一个元素进行赋值 这些数组类，除了元素的类型不同之外，其他的完全相同。 类模板：在定义类的时候，加上一个/多个类型参数。在使用类模板时，指定类型参数应该如何替换成具体类型，编译器据此生成相应的模板类。 1.**类模板的定义 template //类型参数表 class 类模板名{ //成员函数和成员变量 }; 或 template class 类模板名{ //成员函数和成员变量 }; 类模板例成员函数的写法： template //类型参数表 返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名（参数表）{ //函数体 } 用类模板定义对象的写法： 类模板名 &lt;真实类型参数表&gt; 对象名(构造函数实参表); 类模板示例：Pair类模板 template class Pair { public: T1 key; //关键字 T2 value; //值 Pair(T1 k,T2 v):key(k),value(v) { }; bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const; }； template bool Pair&lt;T1,T2&gt;::operator &lt;( const Pair&lt;T1,T2&gt; &amp; p) const //Pair的成员函数 operator { return key &lt; p.key; } int main(){ Pair&lt;string,int&gt; student(“Tom”,19); //实例化出一个类 Pair&lt;string,int&gt; cout &lt;&lt; student.key &lt;&lt; “ “ &lt;&lt; student.value; return 0; } 输出：Tom 19 2.**用类模板定义对象 编译器由类模板生成类的过程叫类模板的实例化。由类模板实例化得到的类，叫模板类。 同一个类模板的两个模板类是不兼容的 3.**函数模板作为类模板成员 #include using namespace std; template class A { public: template void Func(T2 t){cout&lt;&lt;t;}//成员函数模板 }; int main(){ A a; a.Func(‘K’);//成员函数模板Func被实例化 a.Func(“hello”);//成员函数模板再次被实例化 return 0; } 输出：Khello 4.**类模板与非类型参数 类模板的“&lt;类型参数表&gt;”中可以出现非类型参数： template class CArray{ T array[size]; public: void Print( ) { for( int i = 0;i &lt; size; ++i) cout&lt;&lt;array[i]&lt;&lt;endl; } }; CArray&lt;double,40&gt; a2; CArray&lt;int,50&gt; a3; //a2和a3属于不同的类 第七节 类模板与派生、友元和静态成员变量类模板的派生有以下四种情况： （1）类模板从类模板派生； （2）类模板从模板类派生； （3）类模板从普通类派生； （4）普通类从模板类派生。 1.**类模板从类模板派生 例如： template class A { T1 v1; T2 v2; }; template class B:public A&lt;T2,T1&gt;{ T1 V3;T2 v4; }; template class C:public B&lt;T,T&gt;{ T v5; }; int main(){ B&lt;int,double&gt; obj1; C obj2; return 0; } 通过B&lt;int, double&gt; obj1;实例化出： class B&lt;int, double&gt;: public A&lt;double, int&gt; { int v3;double v4; }; class A&lt;double,int&gt; { double v1;int v2; }; 2.**类模板从模板类派生 template class A { T1 v1; T2 v2; }; template class B:public A&lt;int,double&gt;{ T v; }; int main(){ B obj1;//自动生成两个模板类：A&lt;int,double&gt;和B return 0; } 3.**类模板从普通类派生 class A{ int v1; }; template class B:public A{//所有从B实例化得到的类，都以A为基类 T v; }; int main(){ B obj1; return 0; } 4.**普通类从模板类派生 template class A { T v1; int n; }; class B:public A{ double v; }; int main(){ B obj1; return 0; } 5.**类模板与友元 有以下类型： ①函数、类、类的成员函数作为类模板的友元； ②函数模板作为类模板的友元； ③函数模板作为类的友元； ④类模板作为类模板的友元。 （1）.函数、类、类的成员函数作为类模板的友元 void Func1() { } class A { }; class B { public: void Func(){} }; template class Tmpl { friend void Func1(); friend class A; friend void B::Func(); }; //任何从Tmp1实例化出来的类，都有以上三个友元 （2）.函数模板作为类模板的友元 #include #include using namespace std; template class Pair { private: T1 key; //关键字 T2 value; //值 public: Pair(T1 k,T2 v):key(k),value(v) { }; bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const; template friend ostream &amp; operator&lt;&lt; ( ostream &amp; o, const Pair&lt;T3,T4&gt; &amp; p); }; template bool Pair&lt;T1,T2&gt;::operator &lt;( const Pair&lt;T1,T2&gt; &amp; p) const {//小的意思就是关键字小 return key &lt; p.key; } template ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p) { o&lt;&lt; “(“ &lt;&lt; p.key &lt;&lt; “,” &lt;&lt; p.value &lt;&lt; “)” ; return o; } int main() { Pair&lt;string,int&gt; student(“Tom”,29); Pair&lt;int,double&gt; obj(12,3.14); cout &lt;&lt; student &lt;&lt; “ “ &lt;&lt; obj; return 0; } 输出： (Tom,29)(12,3.14) 任意从 template ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)生成的函数，都是任意Pair摸板类的友元 （3）.函数模板作为类的友元** 图7.1 函数模板作为类的友元 （**4）.**类模板作为类模板的友元 图7.2 类模板作为类模板的友元 6.**类模板与静态成员变量** （1）类模板与static成员 类模板中可以定义静态成员，那么从该类模板实例化所得到的所有类，都包含同样的静态成员。 #include using namespace std; template class A { private: static int count; public: A(){count++;} ~A(){count–;} A(A&amp;){count++;} static void PrintCount(){cout&lt;&lt;count&lt;&lt;endl;} }; template&lt;&gt; int A::count = 0; template&lt;&gt; int A::count = 0; int main() { A ia; A da; ia.PrintCount(); da.PrintCount(); return 0; } 输出： 1 1","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++面向对象程序设计课程笔记（第六周）","slug":"c-e9-9d-a2-e5-90-91-89","date":"2018-09-17T15:09:27.000Z","updated":"2019-03-20T14:40:10.317Z","comments":false,"path":"2018/09/17/c-e9-9d-a2-e5-90-91-89/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/17/c-e9-9d-a2-e5-90-91-89/","excerpt":"","text":"第六周：多态 第一节 虚函数和多态的基本概念1.**虚函数 在类的定义中，前面有virtual关键字的成员函数就是虚函数。 class base{ virtual int get(); } int base::get(){} virtual关键字只在类定义里的函数声明中，写函数体的时候不用。构造函数和静态函数不能使用virtual，即不能成为虚函数。 2.**多态 （1）表现形式一 派生类的指针可以赋给基类指针。 通过基类指针调用基类和派生类中的同名虚函数时： ①若该指针指向一个基类的对象，那么背调用的是基类的虚函数； ②若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。 这种机制称为多态。例如： class CBase{ public: virtual void SomeVirtualFunction(){} }; class CDerived:public CBase{ public: virtual void SomVirtualFunction(){} }; int main(){ CDerived ODerived; CBase p = &ODerived; p-&gt;SomeVirtualFunction();//p指向派生类对象，所以调用派生类里面的 return 0; } （2）表现形式二 派生类的对象可以赋给基类引用 通过基类引用调用基类和派生类中的同名虚函数时： ①若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数； ②若该引用引用的是一个派生类的对象，那么调用的是派生类的虚函数。 class CBase{ public: virtual void SomeVirtualFunction(){} }; class CDerived:public CBase{ public: virtual void SomVirtualFunction(){} }; int main(){ CDerived ODerived; CBase &amp;r = ODerived; r-&gt;SomeVirtualFunction();//在这里调用的是派生类中的 return 0; } 3.**多态的作用* 在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。 第二节 多态实例：魔法门之英雄无敌在游戏中有很多怪物，没种怪物都有一个类与之对应，每个怪物就是一个对象。怪物能够互相攻击，攻击敌人和被攻击时都有相应的动作，动作是通过对象的成员函数实现的。游戏版本升级时，要增加新的怪物——雷鸟（CThunderBird）。如何编程使代码改动和增加量较小？ 基本思路： 为每个怪物类编写 Attack、FightBack和 Hurted成员函数。 Attact函数表现攻击动作，攻击某个怪物，并调用被攻击怪物的Hurted函数，以减少被攻击怪物的生命值，同时也调用被攻击怪物的 FightBack成员函数，遭受被攻击怪物反击。 Hurted函数减少自身生命值，并表现受伤动作。 FightBack成员函数表现反击动作，并调用被反击对象的Hurted成员函数，使被反击对象受伤。 设置基类CCreature，并且使CDragon、CWolf等其他类都从该基类派生而来，如图2.1所示。 图2.1 基本思路图 1.**非多态实现方法： class class CCreature { protected: int nPower ; //代表攻击力 int nLifeValue ; //代表生命值 }; class CDragon:public CCreature { public: void Attack(CWolf pWolf) { //．．．表现攻击动作的代码 pWolf-&gt;Hurted( nPower); pWolf-&gt;FightBack( this); } void Attack(CGhost pGhost){ //表现攻击动作代码 pGhost-&gt;Hurted( nPower); pGhost-&gt;FightBack( this); } void Hurted(int nPower){ //表现受伤动作代码 nLifeValue -=nPower; } void FightBack(CWolf *pWolf){ //表现反击动作的代码 pWolf-&gt;Hurted(nPower/2); } void FightBack(CGhost *pGhost){ //表现反击动作代码 pGhost-&gt;Hurted(nPower/2); } } //……还有很多 有n种怪物，CDrogon就要有n个Attack成员函数和n个FightBack成员函数，对于其他类也是如此。 如果游戏版本升级，增加了新的怪物雷鸟CthunderBird，则程序改动非常大，所有的类都需要增加两个成员函数（攻击和反击）。 2.**多态实现方法： 代码如下： class class CCreature { protected: int nPower ; //代表攻击力 int nLifeValue ; //代表生命值 public: virtual void Attack(CCreature *pCreature){} virtual void Hurted(int nPower){} virtual void FightBack(CCreature *pCreature){} }; class CDragon:public CCreature { public: virtual void Attack(CCreature *pCreature); virtual void Hurted(int nPower); virtual void FightBack(CCreature *pCreature); }; void CDragon::Attack(CCreature p) { //．．．表现攻击动作的代码 p-&gt;Hurted(m_nPower); pWolf-&gt;FightBack(this); } void CDragon::Hurted(int nPower){ //表现受伤动作代码 m_nLifeValue -=nPower; } void CDragon::FightBack(CCreature \\p){ //表现反击动作的代码 pWolf-&gt;Hurted(m_nPower/2); } 基类只有一个Attack、FightBack成员函数，所有CCreature的派生类也一样。 如果游戏版本升级，增加了新的怪物雷鸟CThunderBird，只需要编写心累CThunderBird，不需要在已有的类例专门为新怪物增加： void Attack( CThunderBird * pThunderBird) ; void FightBack( CThunderBird * pThunderBird) ; 第三节 多态实例：几何形体程序几何形体处理程序：输入若干个几何形体的参数，要求按面积排序输出，输出时要指明形状。 输入： 第一行是几何体数目n（不超过100行），下面有n行，每行以一个字母开头： （1）若字母为“R”，则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高； （2）若字母为“C”，则代表一个圆，本行后面跟着一个整数代表其半径； （3）若字母为“T”，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度。 输出： 按面积从小到大依次输出每个几何形体的种类及面积。每行一个几何形体，输出格式为： 形体名称：面积 代码如下： #include #include &lt;stdlib.h&gt; #include &lt;math.h&gt; using namespace std; class CShape { public: virtual double Area() = 0;//纯虚函数 virtual void PrintInfo() = 0; }; class CRectangle :public CShape { public: int w, h; virtual double Area(); virtual void PrintInfo(); }; class CCircle :public CShape { public: int r; virtual double Area(); virtual void PrintInfo(); }; class CTriangle :public CShape { public: int a, b, c; virtual double Area(); virtual void PrintInfo(); }; double CRectangle::Area() { return w*h; } void CRectangle::PrintInfo() { cout &lt;&lt; “Rectangle:” &lt;&lt; Area() &lt;&lt; endl; } double CCircle::Area() { return 3.14*r*r; } void CCircle::PrintInfo() { cout &lt;&lt; “Circle:” &lt;&lt; Area() &lt;&lt; endl; } double CTriangle::Area() { double p = (a + b + c) / 2.0; return sqrt(p*(p - a)(p - b)(p - c)); } void CTriangle::PrintInfo() { cout &lt;&lt; “Triangle:” &lt;&lt; Area() &lt;&lt; endl; } CShape pShapes[100];//基类指针，可以指向不同派生类 int MyCompare(const void \\s1, const void*s2); int main() { int i, n; CRectangle *pr; CCircle *pc; CTriangle *pt; cin &gt;&gt; n; for (i = 0; i &lt; n; i++) { char c; cin &gt;&gt; c; switch (c) { case ‘R’: pr = new CRectangle(); cin &gt;&gt; pr-&gt;w &gt;&gt; pr-&gt;h; pShapes[i] = pr; break; case ‘C’: pc = new CCircle(); cin &gt;&gt; pc-&gt;r; pShapes[i] = pc; break; case ‘T’: pt = new CTriangle(); cin &gt;&gt; pt-&gt;a &gt;&gt; pt-&gt;b &gt;&gt; pt-&gt;c; pShapes[i] = pt; break; } } qsort(pShapes, n, sizeof(CShape*), MyCompare); for (int i = 0; i &lt; n; i++) pShapes[i]-&gt;PrintInfo();//利用多态操作不同类的输出函数 system(“pause”); return 0; } int MyCompare(const void s1, const void \\s2) { double a1, a2; CShape **p1;//s1,s2是void,不可写\\s1来取得s1指向的内容 CShape **p2; p1 = (CShape )s1;//s1,s2指向pShapes数组中的元素，数组元素的类型是CShape * p2 = (CShape )s2; a1 = (*p1)-&gt;Area(); a2 = (*p2)-&gt;Area(); if (a1 &lt; a2) return -1; else if (a2 &lt; a1) return 1; else return 0; } 因为s1和s2都是void，所以没办法直接获取到指向的内容。所以设置了两个CShape的变量p1和p2，把s1和s2强制转换成CShape类型。s1和s2是指向pShapes数组中的元素，数组元素类型为CShape。p1，p2是指向指针的指针，所以要用两个。 *用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组，就能对各个派生类对象做各种操作。 又一个例子，还是比较好理解的： 图3.1 多态又一例子 在非构造函数、非析构函数的成员函数中调用虚函数，是多态。 构造函数和析构函数中调用虚函数，不是多态。编译时即可确定，调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。 派生类中和基类中虚函数同名同参数表的函数，不加**virtual**也自动成为虚函数。 图3.2 虚函数访问权限介绍 在这里会出现编译出错。因为语法检查是不考虑运行结果，所以在fun2()是Base的私有成员的时候，语法检查直接给判错，即便运行到此时实际上按照规定是调用的Derived的公有成员fun2()。 但是如果基类中是public，派生类中即使是private，编译依然能通过，因为语法检查还是只看能不能访问基类的，运行的时候再看实际情况。这里面因为基类指针指向了派生类，所以派生类中成员函数是private也是可以运行出来的。 第四节 多态的实现原理“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定——这叫“动态联编”。当然多态就是在运行的时候才确定调用谁的函数，而不是在编译的时候确定。 例程如下： class Base{ public: int i; virtual void Print(){cout &lt;&lt; “Base Print”&lt;&lt;endl;} }; class Derived:public Base{ public: int n; virtual void Print){cout&lt;&lt;”Derived Print”&lt;&lt;endl;} }; int main(){ Derived d; cout&lt;&lt;sizeof(Base)&lt;&lt;sizeof(Derived); return 0; } 输出结果本来我们认为是4和8，但实际上却是8和12，这是为什么呢？ 1.**多态实现的关键——虚函数表** 每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。多出来的4个字节就是用来放虚函数表的地址的。 图4.1 Base类的虚函数表 图4.2 Deriverd类的虚函数表 多态程序会有额外的时间（查询函数表）和空间开销（虚函数表）。 又一个例程： #include &lt;iostream&gt; using namespace std; class A{ public:virtual void Func(){cout &lt;&lt;&quot;A::Func&quot;&quot;&lt;&lt;endl;} }; class B: public A{ public:virtual void Func(){cout&lt;&lt;&quot;B::Func&quot;&lt;&lt;endl;} }; int main(){ A a; A* pa = new B(); pa-&gt;Func();//显然，输出结果为B::Func //在64位电脑执行，64位程序指针为8字节 long long \\*p1 = (long long \\*)&amp;a;//把a的地址转换成一个longlong型的地址指针赋值给p1 long long \\*p2 = (long long \\*)pa;//把new出来的B的地址转换成longlong型的地址指针赋给p2 \\*p2 = \\*p1;//=是赋值号。把p1指向地方的内容放在p2指向的地方去。 //由于p1是longlong型，所以*p1是8字节的内容。8个地址正好也是一个地址，这个地址放在a对象的开头，是classA的虚函数表的地址。 //p2指向New出来的B对象，所以p2的开头也应该放着classB的虚函数表的地址，也是8个字节。 //把p1指向的8个字节赋值给了p2指向的8个字节，所以下面语句输出值为A::Func pa-&gt;Func(); return 0; } 第五节 虚析构函数、纯虚函数和抽象类1.**虚析构函数（不是多态） 通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数。但是，删除一个派生类的对象时，应该先调用派生类的析构函数，然后调用基类的析构函数。 解决方法：把基类的析构函数声明为virtual。 派生类的析构函数可以不进行声明也是虚函数。通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数。 一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成虚函数。或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。 注意：不允许以虚函数作为构造函数。 例子： class son{ public: virtual ~son() {cout&lt;&lt;”bye from son”&lt;&lt;endl;}; }; class grandson:public son{ public: ~grandson(){cout&lt;&lt;”bye from grandson”&lt;&lt;endl;}; }; int main() { son *pson; pson= new grandson(); delete pson; return 0; } 输出结果：bye from grandson bye from son 2.**纯虚函数和抽象类 纯虚函数：没有函数体的虚函数，不等同于函数体无语句！！！。 格式如下： virtual void Print( )=0;//纯虚函数 包含纯虚函数的类叫抽象类。抽象类只能作为基类来派生新类使用，不能创建抽象类的对象；抽象类的指针和引用可以指向由抽象类派生出来的类的对象。 如下例： A a ; // 错，A 是抽象类，不能创建对象 A * pa ; // ok,可以定义抽象类的指针和引用 pa = new A ; //错误, A 是抽象类，不能创建对象 在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。 例程： class A{ public: virtual void f() =0;//纯虚函数 void g(){this-&gt;f();//ok } A(){//f();//错误 } }; class B:public A{ public: void f(){cout&lt;&lt;”B:f()”&lt;&lt;endl;} }; int main(){ B b; b.g(); return 0; } 输出：B.f()","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++面向对象程序设计课程笔记（第五周）","slug":"c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7e8-ae-a1-e8-af-be-e7","date":"2018-09-14T03:31:00.000Z","updated":"2019-03-20T14:40:24.388Z","comments":false,"path":"2018/09/14/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7e8-ae-a1-e8-af-be-e7/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/14/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7e8-ae-a1-e8-af-be-e7/","excerpt":"","text":"第五周 继承 第一节 继承和派生1.**继承 继承是在定义一个新类B时，如果该类与某个已有类A相似（指B至少拥有A的全部特点），那么就把A作为一个基类，B作为基类的一个派生类。 派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。派生类一经定义后，可以独立使用，不依赖于基类。 派生类拥有基类的全部成员函数和成员变量，不论是private、protected、public。但是在派生类的各个成员函数中，不能访问基类中的private成员。 派生类的写法： class 派生类名: public 基类名 { }; 例程： class CStudent{ private: string sName; int nAge; public: bool IsThreeGood(){}; void SetName(const string &amp; name) {sName = name;} }; class CUndergraduateStudent: public CStudent{ private: int nDepartment; public: bool IsThreeGood(){}//覆盖 bool CanBaoYan(){}; }; class CGraduatedStudent: public CStudent{ private: int nDepartment; char szMentorName[20]; public: int CountSalary(){}; }; 2.**派生类对象的内存空间 派生类对象的体积，等于基类对象的体积再加上派生类对象自己的成员变量的体积。在派生类对象中，包含着基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。 完整程序如下： #include #include #include using namespace std; class CStudent { private: string name; string id; char gender; int age; public: void PrintInfo(); void SetInfo(const string &amp; name_, const string &amp; id_, int age_, char gender_); string GetName() { return name; } }; class CUndergraduateStudent : public CStudent { private: string department; public: void QualifiedForBaoyan() { cout &lt;&lt; “qualified for baoyan” &lt;&lt; endl; } void PrintInfo() { CStudent::PrintInfo();//因为我也要输出基类的信息，覆盖就没办法直接输出了，所以先调用下基类的该函数，如果是构造函数就可以直接省略，进行隐式方式调用 cout &lt;&lt; “Department:” &lt;&lt; department &lt;&lt; endl; } void SetInfo(const string &amp; name_, const string &amp; id_, int age_, char gender_, const string &amp; department_) { CStudent::SetInfo(name_, id_, age_, gender_); department = department_; } }; void CStudent::PrintInfo() { cout &lt;&lt; “Name:” &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; “ID:” &lt;&lt; id &lt;&lt; endl; cout &lt;&lt; “Age:” &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; “Gender:” &lt;&lt; gender &lt;&lt; endl; } void CStudent::SetInfo(const string &amp; name_, const string &amp; id_, int age_, char gender_) { name = name_; id = id_; age = age_; gender = gender_; } int main() { CUndergraduateStudent s2; s2.SetInfo(“Zhang Yushuai”, “011210149”, 23, ‘M’, “comunication”); s2.QualifiedForBaoyan(); s2.PrintInfo(); system(“pause”); return 0; } 第二节 继承关系和复合关系类与类的关系有三种：①没有关系；②继承关系；③符合关系。 继承：“是”的关系。基类A，B是基类A的派生类。逻辑上的要求：“一个B对象也是一个A对象”。 复合：“有”关系。 类C中“有”成员变量k，k是类D的对象，则C和D是符合关系。一般逻辑上的要求：D对象是C对象的固有属性或组成部分。 1.**复合关系的使用* 几何形体程序中，需要写“点”类，也需要写“圆类”，两者的关系就是复合关系——每一个圆对象里都包含一个点对象，即圆心。代码如下： class CPoint{ double x,y; friend class CCircle; } class CCicle{ double r; CPoint center;//圆心 } 举例：写一个小区养狗管理程序，需要些一个业主类，还需要些一个狗来。而狗是由猪肉的，主人当然有业主。假定狗只有一个主人，但一个业主可以有最多10条狗。 写法：为“狗”类设一个“业主”类的对象指针；为“业主”类设一个“狗”类的对象指针数组。 class CMaster; class CDog{ CMaster \\pm; }; class CMaster{ CDog *dogs[10]; }; 图2.1 复合关系示意 第三节 覆盖和保护成员1.**覆盖 派生类可以定义一个和基类成员同名的成员，这叫覆盖。在派生类中访问这类成员时，缺省的情况是访问派生类定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用域符号::。 例如： class base{ int j; public: int i; void func(); }; class derived:public base{ public: int i; void access(); void func(); }; void derived::access(){ j = 5;//error i = 5;//引用的是派生类的i base::i = 6;//引用的是基类的i func();//派生类的 base::func();//基类的 } int main() { derived obj; obj.i = 1; base::obj.i = 2; return 0; } 一般来说，基类和派生类不定义同名成员变量，但同名成员函数很常见。 2.**类的保护成员 （1）protected 基类的private成员，可以被下列函数访问： ①基类的成员函数； ②基类的友元函数 基类的public成员可以被下列函数访问： ①基类的成员函数； ②基类的友元函数； ③派生类的成员函数； ④派生类的友元函数； ⑤其它的函数。 基类的protected成员可以被下列函数访问： ①基类的成员函数； ②基类的友元函数； ③派生类的成员函数可以访问当前对象的基类的保护成员。 例子： class Father{ private: int nPrivate;//私有成员 public: int nPublic;//公有成员 protected: int nProtected;//保护成员 }; class Son:public Father{ void AccessFather(){ nPublic = 1;//ok nPrivate = 1;//wrong nProtected = 1;//OK，访问从基类基础的Protected成员可以 Son f; f.nProtected = 1;//wrong，f不是当前对象 } }; int main(){ Father f; Son s; f.nPublic = 1;//ok s.nPublic = 2;//ok f.nProtected = 3;//error只能在本类的成员函数，派生类的成员函数，友元的成员函数访问 f.nPrivate = 4;//error基类的对象没办法访问基类的私有对象 s.nProtected = 5;//error派生类的对象无法访问基类的保护成员 s.nPrivate = 6;//error派生类的对象无法访问派生类从基类得到的私有成员 return 0; } 第四节 派生类的构造函数1.**派生类的构造函数 class Bug{ private: int nLegs; int nColor; public: int nType; Bug(int legs, int color); void PrintBug(){}; }; class FlyBug:public Bug{ int nWings; public: FlyBug(int legs, int color, int wings); }; Bug::Bug(int legs, int color) { nLegs = legs; nColor = color; } FlyBug::FlyBug(int legs, int color, int wings):Bug(legs,color){ nWings = wings; } int main(){ FlyBug fb(2,3,4); fb.PrintBug(); fb.nType = 1; fb.nLegs = 2;//error无法直接访问私有成员 return 0; } 其实派生类的构造函数大部分都很简单，和普通的构造函数一样，但是派生类的构造函数如何继承来自基类的私有成员呢？其实在第一节2的代码给了我们一个答案，就是如下，利用了初始化列表调用Bug类中的构造函数来实现，第一节2的代码是直接写在了代码块里面。 FlyBug::FlyBug(int legs, int color, int wings):Bug(legs,color){ nWings = wings; } 这两种方式总结如下： （1）显式方式：在派生类的构造函数中，为基类的构造函数提供参数。格式如下： derived::derived(arg_derived-list):base(arg_base-list) （2）隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的默认构造函数（无参构造函数，若不存在则报错）。 在创建派生类的对象时，需要调用基类的构造函数：初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。 派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。 2.**包含成员对象的派生类（封闭类）的构造函数写法 代码如下： class Bug{ private: int nLegs; int nColor; public: int nType; Bug(int legs, int color); void PrintBug(){}; }; class Skill{ public: Skill(int n){} }; class FlyBug:public Bug{ int nWings; Skill sk1,sk2; public: FlyBug(int legs, int color, int wings); }; FlyBug::FlyBug(int legs, int color, int wings):Bug(legs,color),sk1(5),sk2(color),nWings(wings){} （吐槽：都这么喜欢初始化列表，回头查查初始化列表仔细了解下） 3.**封闭派生类对象的构造函数执行顺序** 在创建派生类的对象时: （1）先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员； （2）再执行成员对象类的构造函数，用以初始化派生类对象中成员对象； （3）最后执行派生类自己的构造函数。 在派生类对象消亡时： （1）先执行派生类自己的析构函数 （2）再依次执行各成员对象类的析构函数 （3）最后执行基类的析构函数 第五节 公有（public）继承的赋值兼容规则1.public**继承的赋值兼容规则 class base{}; class derived:public base{};//公有派生 base b; derived d; 如上情况下，可以写出以下兼容规则： （1）派生类的对象可以赋值给基类对象 b =d;//OK （2）派生类对象可以初始化基类引用 base &amp; br = d; （3）派生类对象的地址可以赋值给基类指针，但是不能通过pb访问d对象中属于Derived类而不属于Base类的成员： base *pb = &d; 这一切都是基于派生类对象就是一个基类对象的原因。 但是，如果派生方式是private或protected，则上述三条不可行。 2.protected继承和private**继承 class base{}; class derived:protected base{};//公有派生 base b; derived d; protected继承时，基类的public成员和protected成员成为派生类的protected成员。 private继承时，基类的public成员成为派生类的private成员，基类的protected成员成为派生类的不可访问成员。 protected**和private的继承不是“是”的关系。 3.**基类与派生类的指针强制转换 通过强制指针类型转换，可以把ptrBase转换成Derived类的指针： Base ptrBase = &objDerived; Derived \\ptrDerived = (Derived * ) ptrBase; 4.**直接基类和间接基类** A派生类B，类B派生类C，类C派生类D，…… – 类A是类B的直接基类 – 类B是类C的直接基类，类A是类C的间接基类 – 类C是类D的直接基类，类A、B是类D的间接基类 在声明派生类时，只需要列出它的直接基类： （1）派生类沿着类的层次自动向上继承它的间接基类。 （2）派生类的成员包括： ①派生类自己定义的成员； ②直接基类中的所有成员； ③所有间接基类的全部成员。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++面向对象程序设计课程笔记（第四周）","slug":"c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8-a","date":"2018-09-11T13:59:43.000Z","updated":"2019-03-20T14:40:17.700Z","comments":false,"path":"2018/09/11/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8-a/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/11/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8-a/","excerpt":"","text":"第一节 运算符重载的基本概念C++预定义的运算符，只能用于基本数据类型的运算。基本数据类型包括：整型、实型、字符型、逻辑型等。 在数学上，两个复数可以直接进行+、-运算，但是在C++中，直接将+、-用在复数对象是不允许的。 有时候也会希望让对象也能通过运算符进行运算，这样代码更简洁、更容易理解，这个时候就需要运算符的重载了。 运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之能作用于对象。 它的实质是函数重载。可以重载为普通函数，也可以成员函数。 把含运算符的表达式转换成对运算符函数的调用，把运算符的操作数转换成运算符函数的参数。 运算符被多次重载时，根据实参的类型决定调用哪个运算符函数。 运算符重载的形式： 返回值类型 operator 运算符(形参表) { //函数体 } 如下例： class Complex{ public: double real,imag; Complex(double r = 0.0, double i = 0.0):real(r),imag(i){ } Complex operator-(const Complex &amp; c); }; Complex operator+(const Complex &amp;a, const Complex &amp;b){ return Complex(a.real + b.real,a.imag + b.imag);//返回一个临时对象 } Complex Complex::operator-(const Complex &amp;c) { return Complex(real - c.real, imag - c.imag);//返回一个临时对象 } int main(){ Complex a(4,4),b(1,1),c; c = a + b;//等价于c = operator+(a,b); cout &lt;&lt; c.real &lt;&lt;”,” &lt;&lt;c.imag &lt;&lt; endl; cout&lt;&lt;(a-b).real &lt;&lt; “,” &lt;&lt; (a-b).imag &lt;&lt; endl; //a-b等价于a.operator-(b) return 0; }注意：重载为成员函数时，参数个数为运算符目数减一（另一个就是我调用这个成员函数的对象）；重载为普通函数时，参数个数为运算符目数。 第二节 赋值运算符的重载1.**赋值运算符“=”的重载 有时候希望赋值运算符两边的类型可以不匹配，此时就需要重载赋值运算符“=”。赋值运算符“=”只能重载为成员函数。 例程如下： class String{ private: char str;//指向动态分配的数组 public: String():str(new char[1]){str[0] = 0;} const char c_str(){return str;}; String &amp; operator = (const char*s); String::~String(){delete [] str;} }; String &amp;String::operator = (const char *s) { //重载=以使obj=”hello”能够成立 delete[] str; str = new char[strlen(s)+1]; strcpy(str,s); return * this; } int main() { String s; s = “Good luck,”;//等价于s.operator=(“Good Luck,”); cout&lt;&lt;s.c_str()&lt;&lt;endl; //String s2 = “hello!”;//这条语句不注释掉就会出错 s = “Shenzhou 8!”;//等价于s.operator=(“Shenzhou 8!”); cout &lt;&lt;s.c_str()&lt;&lt;endl; return 0; } 对重载函数进行解释。首先把str给delete掉，然后给str重新分配一个空间，大小为s字符串的大小+1，然后把s的值复制给str，返回一个本身的引用。要注意，“=”已经被重载，再编写String s2 = “hello!”后，=已经不是赋值语句，所以必然会出错。 2.**相关其它内容 如下代码： class String{ private: char str;//指向动态分配的数组 public: String():str(new char[1]){str[0] = 0;} const char c_str(){return str;}; String &amp; operator = (const char*s){ delete [] str; str = new char[strlen(s)+1]; strcpy(str,s); return * this; }; String::~String(){delete [] str;} }; 我们在主函数里面要实现下面功能： String S1,S2; S1=”this”; S2=”that”; S1=S2; 在没有重载“=”的时候，S1=S2也可以编译通过，因为它们类型完全相同的。但是，这个“=”会使S1每一点都和S2一样。那么，这会有什么问题呢？让我们一步一步分解来看。 首先执行String S1,S2；S1=”this”;S2=”that”;那么就会实现这样的效果： 图2.1 S1=”this”;S2=”that”; 再执行S1=S2，我们发现成了这个样子： 图2.2 S1=S2的结果 即S1实际上是指向了S2，两者实际上只指向的一个，原来S1的空间失去了指向，与我们想让S1中的内容（所指向的空间的内容）和S2一样的想法完全不一样。 如果S1对象消亡，析构函数将释放 S1.str 指向的空间，则S2消亡时还要释放一次，相当于delete S2了两次。 如果执行S1=&quot;other&quot;，会导致S2.str指向的地方被delete掉。所以重载之后，可以避免这样的问题。 考虑下面的语句： String s; s = &quot;Hello&quot;; s = s; 会有什么问题呢？我们重新看重载“=”的成员函数，发现函数第一句和就是把等号左侧对象的空间给delete掉了，这在普通的语句下没有什么问题，但是在这里，赋给等号左边对象值的那个对象也是它本身，这样delete掉之后，后面的strcpy函数就无法复制正确的值给左侧的对象了。为了解决这个问题，需要在这个重载成员函数的函数体开头添加以下语句： if(this == &amp;s) return *this; 接下来对operator=的返回值类型进行讨论。**当对运算符进行重载的时候，好的风格是应该尽量保留运算符原来的特性**。 我们考虑a=b=c，若是void，那么b=c返回值类型就是void，就没办法再执行a=操作了，所以可以用String类型。 再考虑(a=b)=c。先执行a=b，在C++里面，执行=的返回值是**左侧元素的引用**，所以(a=b)的结果是一个a的引用，对a的引用赋值为c，那么这个b毫无用处。因此不能用String，而是用String &amp;这样一个引用格式。this是当前对象的地址，那么\\*this就是当前对象，这解释了为什么要用\\*this的原因。 为String类编写复制构造函数的时候，会面临和“=”同样的问题（两个对象指向同一个空间），用他同样的方法处理： String(String &amp;s) { str = new char\\[strlen(s.str)+1\\]; strcpy(str,s.str); } 关于浅拷贝和深拷贝待补充 第三节 运算符重载为友元一般情况下，将运算符重载为类的成员函数是较好的选择。但有时，重载为成员函数并不能满足使用要求，重载为普通函数，又不能访问类的私有成员，所以需要将运算符重载为友元。 如下代码： class Complex { double real,imag; public: Complex(double r, double i):real(r),imag(i){}; Complex operator+(double r); }; Complex Complex::operator+(double r) { return Complex(real+r,imag); } 经过重载以后，c=c+5有意义，相当于c=c.operator+(5) 但是，c=5+c就会出错。所以，为了使得上述表达式成立，需要将+重载为普通函数，这样c=5+c就可以通过了。但是普通函数又不能访问私有成员，即不能计算c=c+5。这样，我们只能用重载为友元函数了。如下： class Complex { double real,imag; public: Complex(double r, double i):real(r),imag(i){}; friend Complex operator + (double r, const Complex &amp; c); }; Complex Complex::operator+(double r) { return Complex(real+r,imag); } 第四节 运算符重载实例：可变长整型数组如下代码： int main(){//要编写可变长整型数组类，使之能如下使用 CArray a;//开始数组是空的 for(int i = 0; i &lt; 5;++i) a.push_back(i);//要用动态分配的内存来存放数组元素需要一个指针成员变量 CArray a2,a3 a2 = a;//要重载”=”，把a中的值复制给a2 for(int i = 0; i&lt;a.length;++i) cout&lt;&lt;a2[i]&lt;&lt;””;//要重载[]，因为a2原来是一个对象 a2 = a3;//a2是空的，因为原来的空间被释放了 for(int i = 0;i&lt;a2.length;++i)//a2.length()返回0 cout&lt;&lt;a2[i]&lt;&lt;””; cout&lt;&lt;endl; a[3]=100; CArray a4(a); CArray A4(A);//要自己写复制构造函数 for(int i = 0; i&lt;a4.length;++i) cout&lt;&lt;a4[i]&lt;&lt;””; return 0; } class CArray{ int size;//数组元素的个数 int *ptr;//指向动态分配的数组 public: CArray(int s = 0);//s代表数组元素的个数 CArray(CArray &amp;a); ~CArray(); void push_back(int v);//用于在数组尾部添加一个元素v CArray &amp; operator=(const CArray &amp;a); //用于数组对象间的赋值 int length(){return size;}//返回数组元素个数 int &amp; CArray::operator[](int i) //返回值不能为int，不支持a[i]=4，双目运算符，但是在类内，只有一个运算符 {//用以支持根据下标访问数组元素，如n=a[i]和a[i]=4这样的语句 return ptr[i]; } }; CArray::CArray(int s):size(s) {//构造函数 if(s ==0) ptr = NULL; else ptr = new int[s]; } CArray::CArray(CArray &amp;a){//复制构造函数，要实现深复制 if(!a.ptr){ ptr = NULL; size = 0; return; } ptr = new int [a.size]; memcpy(ptr,a.ptr,sizeof(int)*a.size); size = a.size; } CArray：：~CArray() { if(ptr) delete [] ptr; } CArray &amp; CArray::operator=(const CArray &amp;a)//深拷贝，而不是浅拷贝 {//赋值号的作用是使“=”左边对象里存放的数组，大小和内容都和右边的对象一致。 if(ptr == a.ptr) return *this;//防止前文所述的出错 if(a.ptr == NULL){//如果a里面的数组是空的 if(ptr) delete[] ptr; ptr = NULL; size =0; return *this; } if(size &lt;a.size){//如果原有空间不够，则新建一个足够大的空间 //如果足够大，就不分配新的空间直接执行if后面的语句 if(ptr) delete [] ptr; ptr = new int[a.size]; } memcpy(ptr,a.ptr,sizeof(int)*a.size);//空间大小为数目*一个int的字节数 size = a.size; return *this; } void CArray::push_back(int v) {//在数组尾部添加一个元素。先判断原来是否有元素，如果有元素，就新建一个临时空间， //然后把原来的元素复制过来，然后删除原来的空间，然后把ptr指针指向了tmpPtr这个临时空间 //这个元素非常浪费资源 if(ptr){ int *tmpPtr = new int[size+1];//重新分配空间 memcpy(tmpPtr,ptr,sizeof(int)*size);//拷贝原数组内容 delete[] ptr; ptr = tmpPtr; } else ptr = new int[1];//数组原来是空的 ptr[size++] = v;//加入新的数组元素 } 第五节 流插入运算符和流提取运算符的重载问题1：cout&lt;&lt;5&lt;&lt;”this”为什么能够成立？ 问题2：cout是什么？&lt;&lt;为什么能用在cout上？ 1.**流插入运算符的重载 cout是在iostream中定义的ostream**类的对象。之所以&lt;&lt;能用在cout上是因为，在iostream中对&lt;&lt;进行了重载。 考虑到我们要执行对5的操作也要执行对this的操作，如果我们定义的重载函数返回值为void或者int类型，都无法保证后面的两次甚至更多输出能够成立。但是如果我们将其定义为ostream类型的话，那么对5操作后，还是ostream类型，那么就可以继续对this操作了，因此要把返回值类型定义为ostream。即下面的格式： ostream &amp; ostream::operator&lt;&lt;(int n) { //代码 return *this; } ostream &amp; ostream::operator&lt;&lt;(const char *s) { //代码 return this; } cout&lt;&lt;5&lt;&lt;”this”本质上的函数调用形式是： cout.operator&lt;&lt;(5).operator&lt;&lt;(“this”); 例**1：假定下面程序输出为5hello**，该补写些什么？ class CStudent{ public: int nAge; }; int main(){ CStudent s; s.nAge = 5; cout &lt;&lt; s &lt;&lt;”hello”; return 0; } 需要重载左移运算符，如下： 由于&lt;&lt;已经在ostream中成员函数重载，因此在这里我们只能定义为全局函数进行重载，所以需要两个参数。如下面代码所示，o其实就是对象cout。 ostream &amp; operator&lt;&lt;(ostream &amp; o, const CStudent &amp; s){ o&lt;&lt;s.nAge; return o; } 例题**2**：假定c是Complex复数类对象，现在希望写”cout &lt;&lt; c;”，就能以”a+bi”的形式输出c的值；写“cin&gt;&gt;c”就能从键盘接受“a+bi”形式的输入，并且使得c.real = a，c.imag = b。 int main(){ Complex c; int n; cin &gt;&gt; c &gt;&gt; n; cout &lt;&lt; c &lt;&lt; “,” &lt;&lt;n; return 0; } 程序运行结果可以如下： 输入：13.2+133i 87 输出：13.2+133i,87 代码如下： #include #include #include using namespace std; class Complex{ double real,imag; public: Complex(double r=0,double i =0):real(r),imag(i){}; friend ostream &amp; operator&lt;&lt;(ostream &amp; os, const Complex &amp;c); friend istream &amp; operator &gt;&gt;(istream &amp; is, Compex &amp; c); }; ostream &amp; operator &lt;&lt;(ostream &amp; os, const Complex &amp; c) { os&lt;&lt;c.real&lt;&lt;”+”&lt;&lt;c.imag&lt;&lt;”i”; return os; } istream &amp; operator &gt;&gt;(istream &amp; is, Complex &amp; c) { string s; is &gt;&gt; s;//将”a+bi”作为字符串读入，中间不能有空格 int pos = s.find(“+”,9); string sTmp = s.substr(0,pos);//分离出代表实部的字符串 c.real = atof(sTmp.c_str());//atof库函数能讲const char指针指向的内容转换成float sTmp = s.substr(pos+1,s.length()-pos-2);//分离出代表虚部的字符串 c.imag = atof(sTmp.c_str()); return is; } int main(){ Complex c; int n; cin &gt;&gt; c &gt;&gt; n; cout &lt;&lt; c &lt;&lt; “,” &lt;&lt;n; return 0; } 选择题：重载“&lt;&lt;”用于将自定义的对象通过cout输出时，以下说法正确的是： C 可以将“**&lt;&lt;”重载为全局函数，第一个参数以及返回值，类型都是ostream &amp;**。 第六节 类型转换运算符的重载代码如下： #include using namespace std; class Complex{ double real,imag; public: Complex(double r=0,double i =0):real(r),imag(i){}; operator double(){return real;}//类型转换运算符重载时不写返回值类型，因为返回值类型就是它本身 }; int main() { Complex c(1.2,3.4); cout &lt;&lt; (double)c &lt;endl;//输出1.2 double n = 2 + c;//c被自动用类型转换运算符，等价与double n = 2+c.operator double() cout &lt;&lt; n;//输出3.2 } 第七节 自增自减运算符的重载自增运算符++、自减运算符–有前置/后置之分，为了区别所重载的是前置运算符还是后置运算符，C++规定： （1）前置运算符作为一元运算符重载： 重载为成员函数时： T &amp; operator++() T &amp; operator—() 重载为全局函数时： T1 &amp; operator++(T2) T1 &amp; operator—(T2) （2）后置运算符作为二元运算符重载，多写一个没用的参数int： 重载为成员函数时： T operator++(int) T operator–(int) 重载为全局函数时： T1 operator++(T2, int) T1 operator–(T2, int) 但是在没有后置运算符重载而有前置运算符重载的情况下，在vs中，obj++也调用前置重载，而dev则令obj++编译出错。 例题**1**： int main() { CDemo d(5); cout&lt;(d++) &lt;&lt;”,”;//等价于d.operator++(0); cout &lt;&lt; d &lt;&lt; “,”; cout &lt;&lt; (++d) &lt;&lt; “,”;//等价于d.operator++(); cout &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; (d–) &lt;&lt; “,”;//等价于d.operator–(0); cout &lt;&lt; d &lt;&lt; “,”; cout &lt;&lt; (–d) &lt;&lt; “,”;//等价于d.operator–(); cout &lt;&lt; d &lt;&lt; endl; return 0; } 输出结果： 5,6,7,7 7,6,5,5 如何编写CDemo？ class CDemo{ int n; public: CDemo(int i=0):n(i){} CDemo &amp; operator++();//前置形式++n返回值就是n的引用，所以这里要用引用 CDemo operator++(int);//后置形式，n++返回的是一个临时变量，所以这里不能用引用 operator int(){return n;} friend CDemo &amp; operator–(CDemo &amp;); friend CDemo operator–(CDemo &amp;, int); }; CDemo &amp; CDemo::operator++(): {//前置 n ++; return *this; } CDemo CDemo::operator++(int k): {//后置 CDemo tmp(*this);//记录修改前的对象 n++; return tmp;//返回修改前的对象 }//s++即为s.operator++(0); CDemo &amp; operator–(CDemo &amp; d){//前置 d.n–; return d; } CDemo operator–(CDemo &amp;d, int){//后置 CDemo tmp(d); d.n–; return tmp; }//s–即为operator–(s,0) 可以看出，前置操作因为少一个步骤，所以运算速度快于后置操作。所以提倡写**++i。 运算符重载的注意事项：* 1.C++不允许定义新的运算符； 2.重载后运算符的含义应该符合日常习惯； 3.运算符重载不改变运算符的优先级； 4.以下运算符不能被重载：“.”、“.”、“::”、“?:”、sizeof； 5.重载运算符()、[]、-&gt;或者赋值运算符=时，运算符重载函数必须生命为成员函数。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++面向对象程序设计课程笔记（第三周）","slug":"c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8-ae","date":"2018-09-08T02:31:29.000Z","updated":"2019-03-20T14:40:39.852Z","comments":false,"path":"2018/09/08/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8-ae/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/08/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8-ae/","excerpt":"","text":"第一节 this指针1.C++**程序到C程序的翻译** 图1 从C++到C C++中的class在C语言中并不存在，因此可以用struct（结构体）来代替，成员变量也可以直接用域来代替，但是类中的成员函数却无法在C语言中直接表示，所以只能把SetPrice设置为全局函数。由于是全局函数，为了能让其使用结构体内的数据，故在SetPrice中增加了一个参数struct CCar this，这样就可以在函数体中把p的值传递给结构体中的price，实现了跟成员函数一样的功能，同理，在main()中SetPrice函数执行也得把car的地址传递过去。 故，this的作用就是指向成员函数所作用的对象。 2.this**指针作用* （1）非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针。 图2 this指针作用 在main()函数中，首先对对象c1执行了AddOne()函数，然后开始执行AddOne()，对c1中的real加1，然后执行对c1的Print()函数，这之后，返回一个this指针所指向对Complex对象（即c1）给c2。 对this指针再加深一个理解，如下例： class A { int i; public: void Hello() {cout&lt;&lt;””Hello”&lt;&lt;endl;} }; int main() { A *p=NULL; p-&gt;Hello(); } 系统会报错吗？答案是否定的，并且输出Hello。原因在于，虽然我们看着这个*p指向的空，但是实际上，由于C++在转换成C语言的时候，成员函数会被转换成全局函数并增加一个this指针的参数，即变为了 void Hello(A this){cout &lt;&lt;”Hello”&lt;&lt;endl; 主函数中的p-&gt;Hello();也变成了Hello(p); 因此就算p为空指针，在这里传递给全局函数后并没有用到p做任何输出，所以直接输出了Hello。但如果我们在这个函数的输出时用到了成员变量**i，那么成员函数在变换到全局函数的时候再来执行就用到了这个this所指向的对象，而此时this指向的p**为空，所以报错。 静态成员函数不能使用**this**指针，因为静态成员函数并不具体作用于某个对象，因此静态成员函数的真是的参数的个数，就是程序中写出的参数个数！* 第二节 静态成员变量1.**静态成员基本概念 在定义前面加了static关键字的成员，称为静态成员。静态成员包括静态成员变量和静态成员函数两种。 普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。 sizeof运算符在计算类的大小的时候不会计算静态成员变量。 普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。 因此静态成员不需要通过对象就能访问。 静态成员变量本质上是全局变量！！！ 静态成员函数本质上是全局函数！！！ 设置静态成员的机制是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一根整体，容易维护和理解。 2.**如何访问静态成员 （1）类名::成员名 例如CRectangle::PrintTotal(); （2）对象名.成员名 例如CRectangle r; r.PrintTotal(); （3）指针-&gt;成员名 CRectangle p=&r;p-&gt;PrintTotal(); （4）引用.成员名 CRectangle &amp;ref =r; int n = ref.nTotalNumber; 必须在定义类的文件中对静态成员变量进行一次说明或初始化，否则编译能通过，链接不能通过。 在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。 如下所示的写法，存在缺陷。 CRectangle::CRectangle(int w_,h_) { w = w_; h = h_; nTotalNumber++; nTotalArea += w h; } CRectangle::~CRectangle(){ nTotalNumber–; nTotalArea -= w*h; } void CRectangle::PrintTotal(){ cout&lt;&lt;nTotalNumber&lt;&lt;”,”&lt;&lt;nTotalArea&lt;&lt;endl; } 在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象，比如：①我们调用了一个以CRectangle类对象作为参数的函数；②调用一个以CRectangle类对象作为返回值的函数。这个时候就如前面介绍复制构造函数时所说，会产生一个隐藏的临时对象（此函数没写复制构造函数，因此就算直接复制值过去，并没有执行Crectangle（int w_,int h_）），而这个临时对象在消亡的时候会调用析构函数，减少了nTotalNumber和nTotalArea的值，而它们这些对象在生成时却没有增加这两个值，由于这两个值是静态成员变量，所以实际上这两个值是减少了。 解决方案很显然就算写一个复制构造函数： CRectangle::CRectangle(CRectangle &amp;r) { w = r.w;h=r.h; nTotalNumber ++; nTotalArea += w*h; } 第三节 成员对象和封闭类1.**基本概念 有成员对象的类交封闭（enclosing）类。 有一个类的成员是其它类的对象，被称为成员对象。 如下例程： class CTyre { private: int radius; int width; public: CTyre(int r int w):radius(r),width(w){}//初始化列表，可以为每一个成员变量提供一个初始值。 }; class CEngine{}; class CCar{//封闭类 private: int price; Ctyre tyre;//成员对象 CEngine engine;//成员对象 public: CCar(int p, int tr,int tw); }; CCar::CCar(int p,int tr,int w):price(p),tyre(tr,w)//engine使用无参构造函数构造 {}; int main() { CCar car(20000,17,225); return 0; } 在这个例子，如果CCar类不定义构造函数，则CCar car;这个语句会报错，因为编译器不明白car.tyre该如何初始化。 任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象是如何初始化的。 具体做法是：通过封闭类的构造函数的初始化列表进行。 成员对象初始化列表中的参数可以是任意复杂的表达式，可以包括函数、变量，只要表达式中的函数或变量有定义就行。 2.**封闭类构造函数和析构函数的执行顺序 （1）封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数； （2）对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关； （3）当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反。 3.**封闭类的复制构造函数** 封闭类的对象，如果是用默认复制构造函数初始化的，那么它里面包含的成员对象，也会用复制构造函数初始化。 例如： Class A { public: A(){cout&lt;&lt;”default”&lt;&lt;endl;} A(A&amp;a){cout&lt;&lt;”copy”&lt;&lt;endl;} }; class B{A a;}; int main() { B b1,b2(b1); return 0; } 输出： default copy 说明b2.a是用类A的复制构造函数初始化的，而且调用复制构造函数的实参就是b1.a。 第四节 友元（friends）友元分为友元函数和友元类两种。 1.**友元函数 一个类的友元函数可以访问该类的私有成员（这说明友元函数不是这个类的成员函数） 可以将一个类的成员函数（包括构造、析构函数）说明为另一个类的友元。 Class B{ public: void function(); }; Class A{ friend void B::function(); }; 这就代表function()可以访问A里面的私有成员了。 2.**友元类 如果A是B的友元类，那么A的成员函数可以访问B的私有成员。 Class CCar { private: int price; friend class CDriver;//声明CDriver为友元类 }; class CDriver { public: CCar myCar; void ModifyCar(){ myCar.price += 1000; //因为CDriver是CCar的友元类，故可以访问其私有成员 } }; int main(){return 0;} 友元类之间的关系不能传递，不能继承！ 第五节 常量对象、常量成员函数和常引用1.**常量成员函数 如果不希望某个对象值被改变，则定义该对象的时候可以在前面加const关键词。例如： class Sample{ private: int value; public: Sample(){} void SetValue(){} }; const Sample Obj;//常量对象 Obj.SetValue();//错误。常量对象只能使用构造函数、析构函数和右const说明的函数（const方法） 在类的成员函数说明后面加const关键字，则该成员函数为常量成员函数。常量成员函数执行期间不应修改其作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。 如下： class Sample{ public: int value; void func(){}; Sample(){} void GetValue() const; }; void Sample::GetValue() const{ value = 0;//wrong func();//wrong } int main(){ const Sample o; o.value = 100;//err常量对象不可被修改 o.func();//常量对象上面不能执行非常量成员函数 o.GetValue();//OK常量对象可以执行常量成员函数 return 0; } 需要注意，在Dev C++中，要为Sameple类编写无参构造函数才可以，在VS中不需要。 2.**常量成员函数的重载 两个成员函数，名字和参数表都一样，但是一个是const，一个不是，算重载。 3.**常引用** 引用前面加const称为常引用。不能通过常引用修改其引用的变量。 可以用对象的引用作为参数，如： class Sample{ }; void PrintfObj(Sample &amp; o){ } 对象引用作为函数的参数有一定风险性，若函数中不小心修改了形参o，则实参也跟着变。为了避免这个问题，我们可以用对象的常引用作为参数，这样就能确保不会出现无意中更改o值的语句了。 class Sample{ }; void PrintfObj(const Sample &amp; o){ }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++面向对象程序设计课程笔记（第二周）","slug":"c-e9-9d-a2-e5-90-91-e5-af-b9-e8-e8-ae-a1-e8-af-b","date":"2018-09-03T14:56:41.000Z","updated":"2019-03-20T14:40:27.604Z","comments":false,"path":"2018/09/03/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-e8-ae-a1-e8-af-b/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/03/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-e8-ae-a1-e8-af-b/","excerpt":"","text":"第一节 类和对象的基本概念（2）1.**类的成员函数和类的定义分开写 例如我们在类里面定义了一个类别还有函数，那么类的定义可以写在类的外面，以例子给出格式（仍以上一节CRectangle类为例）： int CRectangle::Area(){ return w*h; } void CRectangle::Init(int w_, int h_) { w = w_; h = h_; } 一定要通过对象或对象的指针或对象的引用才能引用。 2.**类成员的可访问范围 （1）private：私有成员，只能在成员函数内访问； （2）public：公有成员，可以在任何地方访问； （3）protected：保护成员。 具体用法如下： class className{ private: 私有属性和函数 public: 公有属性和函数 protected: 保护属性和函数 } 注意：如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。 例如： class Man{ int nAge;//私有成员 int szName[20];//私有成员 public: void SetName(char szName){ strcpy(Man::szName,szName); } }; 3.**类成员的可访问范围 在类的成员函数内部，能够访问： （1）当前对象的全部属性、函数； （2）同类其它对象的全部属性、函数。 在类的成员函数以外的地方，只能访问该类的公有成员。 设置私有成员的机制，称为“隐藏”。其目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可，否则所有直接访问成员变量的语句都需要修改。 4.**成员函数的重载及参数缺省* 成员函数重载，成员函数也可以带缺省参数。 第二节 构造函数1.**基本概念 构造函数是成员函数的一种它的名字与类名相同，可以有参数，但不能有返回值（void也不行）。作用是对对象进行初始化，如给成员变量赋初值。如果定义类时没有写构造函数，则编译器生成一个默认的无参数的构造函数，默认的构造函数不做任何操作。如果我们定义了构造函数，那么系统就不生成构造函数。 对象生成时构造函数自动被调用，对象一旦生成，就再也不能在其上执行构造函数。一个类可以有多个构造函数。 打个比方，我们新建成员变量是建房子，那么构造函数只能做装修房子，不能做建房子的操作。 为什么需要构造函数呢？ （1）构造函数执行必要的初始化工作，有了构造函数，就不必专门再写初始化函数，也不用担心忘记调用初始化函数。 （2）有时对象没被初始化就使用，会导致程序出错。 例如： class Complex{ private: double real,imag; public: void Set(double r, double i); };//编译器自动生成默认构造函数 Complex c1;//默认构造函数被调用 Complex *pc = new Complex;//默认构造函数被调用，生成一个可变的 自己写出构造函数，例如： class Complex{ private: double real,imag; public: Complex(double r, double i =0); }; Complex::Complex(double r, double i){ real = r; imag = i; } Complex c1;//错误，缺少构造函数的参数 Complex *pc = new Complex;//错误，缺少构造函数的参数 Complex c1(2);//Ok，第二个参数使用缺省参数i=0 Complex c1(2,4),c2(3,5);//OK Complex *pc = new Complex(3,4);//OK 多个构造函数举例： class Complex{ private: double real,imag; public: void Set(double r, double i); Complex(double r, double i); Complex(double r); Complex(Complex c1, Complex c2); }; Complex::Complex(double r, double i){ real = r; imag = i; } Complex::Complex(double r){ real = r; imag = 0; } Complex::Complex(Complex c1, Complex c2){ real = c1.real + c2.real; imag = c1.imag + c2.imag; } Complex d1(3),d2(1,0),d3(d1,d2); //d1 = {3,0}, d2 = {1,0}, d3 = {4,0} 注意：构造函数最好是public的，private构造函数不能直接用来初始化对象。 2.**构造函数在数组中的使用 以例子来讲解。例1如下： class CSample { int x; public: CSample() { cout &lt;&lt; “Constructor 1 Called” &lt;&lt; endl; } CSample(int n) { x = n; cout &lt;&lt; “Constructor 2 Called” &lt;&lt; endl; } }; int main(){ CSample array1[2];//由于数组为空，当作一个无参来初始化。 //然后数组里面是两个空的元素，实际上相当于初始化然后数组里面是两个空的元素， //实际上相当于初始化了两边。输出结果是两遍Constructor 1 Called cout &lt;&lt;”step1”&lt;&lt;endl;//输出step1 CSample array2[2] = {4,5};//此时是有参构造，相当于创建两个对象，一个对象里面x为4，一个为5 //所以输出是两遍Constructor 2 Called cout &lt;&lt;”step2”&lt;&lt;endl; //输出step2 CSample array3[2] = {3};//此时是有参构造和无参构造结合，相当于创建另两个对象，一个里面x=3 //另一个无参数，输出一遍Constructor 2 Called，Constructor 1 Called cout &lt;&lt;”step3”&lt;&lt;endl;//step3 CSample *array4 = new CSample[2];//与array1[2]同理 delete []array4;//回收 return 0; 例2： class Test { public: Test(int n) { } //(1) Test( int n, int m) { } //(2) Test() { } //(3) }; Test array1[3] = { 1, Test(1,2) }; // 三个元素分别用(1),(2),(3)初始化 Test array2[3] = { Test(2,3), Test(1,2) , 1}; // 三个元素分别用(2),(2),(1)初始化 Test * pArray[3] = { new Test(4), new Test(1,2) }; //两个元素分别用(1),(2) 初始化 注意，指针不会被初始化。例如：假设 A 是一个类的名字，下面的语句生成了几个类A的对象？ A * arr[4] = { new A(), NULL,new A() }; 答案是2个。因为new A()会生成对象，NULL为空，所以它还是一个指针，没有指向一个对象的地址，故无法生成对象，第四个元素同理。因为只有两个new A()，故有2个对象。 第三节 复制构造函数1.**基本概念 只有一个参数，即对同类对象的引用。形如 X::X(X&amp;)或X::X(const X &amp;)，二者选一，参数地方必须为引用！。后者能以常量对象作为参数。 如果没有定义复制构造参数，那么编译器生成默认复制构造函数。默认的复制构造函数完成对象间的复制功能。例如： class Complex{ private: double real,imag; }; Complex c1;//调用缺省无参构造参数 Complex c2(c1);//调用缺省的复制构造函数，将c2初始化成和c1一样 如果自己写，例如： class Complex{ public: double real,imag; Complex(){} Complex(const Complex &amp;c){ real = c.real; imag = c.imag; cout&lt;&lt;”Copy Constructor called”; } }; Complex c1;//调用缺省无参构造参数 Complex c2(c1);//调用编写的复制构造函数，将c2初始化成和c1一样 2.**复制构造函数起作用的三种情况 1)当用一个对象去初始化同类的另一个对象时。例如： Complex c2(c1); Complex c2 = c1; //初始化语句，非赋值语句 2)如果某函数有一个参数是类 A 的对象， 那么该函数被调用时，类**A**的复制构造函数将被调用。 class A { public: A(){ }; A( A &amp; a) { cout &lt;&lt; “Copy constructor called” &lt;&lt;endl; } }; void Func(A a1){} int main(){ A a2; Func(a2);//参数为类A的对象 return 0; } 输出：Copy constructor called 3) 如果函数的返回值是类**A**的对象时，则函数返回时， A**的复制构造函数被调用: class A { public: int v; A(int n) { v = n; }; A( const A &amp; a) { v = a.v; cout &lt;&lt; “Copy constructor called” &lt;&lt;endl; } }; A Func() { A b(4); return b; } int main() { cout &lt;&lt; Func().v &lt;&lt; endl; return 0; } 输出结果： Copy constructor called 4 复制构造函数的参数是b。Func().v是b.v的一个复制品。 注意：对象间赋值并不导致复制构造函数被调用。 例如： class CMyclass { public: int n; CMyclass() {}; CMyclass( CMyclass &amp; c) { n = 2 c.n ; } }; int main() { CMyclass c1,c2; c1.n = 5; c2 = c1; CMyclass c3(c1); cout &lt;&lt;”c2.n=” &lt;&lt; c2.n &lt;&lt; “,”; cout &lt;&lt;”c3.n=” &lt;&lt; c3.n &lt;&lt; endl; return 0; } 在这里c2=c1不是一个初始化语句，而是一个赋值语句，所以并不导致复制构造函数被调用。因此输出的结果c2.n = 5，c3.n = 10（因为复制构造函数所计算值是2c.n）。 3.**常量引用参数的使用 void fun(CMyclass obj_) { cout &lt;&lt; “fun” &lt;&lt; endl; } 这样的函数，调用时生成形参会引发复制构造函数调用，开销比较大。所以可以考虑使用 CMyclass &amp; 引用类型作为参数，实际上形参成为了实参的应用，成为了一回事（原来的时候在调用函数时，形参实际上是复制了一份实参，这个太浪费时间）。如果希望确保实参的值在函数中不应被改变，那么可以加上const 关键字： void fun(const CMyclass &amp; obj) { //函数中任何试图改变 obj值的语句都将是变成非法 } 第四节 类型转换构造函数和析构函数1.**什么是类型转换构造函数 它定义转换构造函数的目的是实现类型的自动转换。如果只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数。当需要的时候，编译系统会自动调用转换构造函数，建立一个无名的临时对象(或临时变量)。 实例如下： class Complex { public: double real, imag; Complex( int i) {//类型转换构造函数 cout &lt;&lt; “IntConstructor called” &lt;&lt; endl; real = i; imag = 0; } Complex(double r,double i) { real = r; imag = i; } }; int main () { Complex c1(7,8); Complex c2 = 12; //它调用Complex( int i) c1 = 9; // 9被自动转换成一个临时Complex对象 cout &lt;&lt; c1.real &lt;&lt; “,” &lt;&lt; c1.imag &lt;&lt; endl; return 0; } 解析：**c1=9这里经历的这样一个过程：首先新建一个临时的Complex对象，我假定为m，那么这个m进行初始化（即相当于执行Complex a(9)，或者Complex a=9），然后调用Complex(int i)这个类型转换构造函数，构造一个m里面的real=9，imag=0，然后把m复制给c1。 习题：类A定义如下： class A { int v; public: A(int i) { v = i; } A() { } }; 下面段程序不会引发类型转换构造函数被调用？ A) A a1(4); B) A a2 = 4; C) A a3; a3 = 9; D) A a1,a2; a1 = a2; 答案：D。解析如下：A、B、C都显然调用了A(int i)，而D里面a1=a2是赋值语句。 2.**析构函数 名字与类名相同，在前面加‘~’， 没有参数和返回值，一个类最多只能有一个析构函数。析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等。 如果定义类时没写析构函数，则编译器生成缺省析构函数。缺省析构函数什么也不做。如果定义了析构函数，则编译器不生成缺省析构函数。 析构函数实例： class String{ private: char * p; public: String () { p = new char[10]; } ~ String (); }; String ::~ String() { delete [] p; } 对象数组声明期结束时，对象数组的每个元素的析构函数都会被调用。 class Ctest { public: ~Ctest() { cout&lt;&lt; “destructor called” &lt;&lt; endl; } }; int main () { Ctest array[2]; cout &lt;&lt; “End Main” &lt;&lt; endl; return 0; } 输出结果： End Min destructor called destructor called 数组的两个元素都用完了，所以构造了析构函数两遍。 3.析构函数和运算符delete （1）delete运算导致析构函数调用。 Ctest * pTest; pTest = new Ctest; //构造函数调用 delete pTest; //析构函数调用 ——————————————————— pTest = new Ctest[3]; //构造函数调用3次 delete [] pTest; //析构函数调用3次 前面说过：若new一个对象数组，那么用delete释放时应该写 []。否则只delete一个对象(调用一次析构函数)。 4.**析构函数在对象作为函数返回值返回后被调用 例如： class CMyclass { public: ~CMyclass() { cout &lt;&lt; “destructor” &lt;&lt; endl; } }; CMyclass obj; CMyclass fun(CMyclass sobj ) {//次数对象作为了形参，调用复制构造函数 //参数对象消亡也会导致析构函数被调用 return sobj; //函数调用返回时生成临时对象返回 } int main() { obj = fun(obj); //函数调用的返回值（临时对象）被 return 0; //用过后，该临时对象析构函数被调用 } 第五节 构造函数析构函数调用时机构造函数和析构函数什么时候被调用呢？见课本P190的这个例子： class Demo { int id; public: Demo(int i) {//这个也可以看做是类型转换构造函数 id = i; cout &lt;&lt; “id=” &lt;&lt; id &lt;&lt; “ constructed” &lt;&lt; endl; } ~Demo() { cout &lt;&lt; “id=” &lt;&lt; id &lt;&lt; “ destructed” &lt;&lt; endl; } }; Demo d1(1);//全局对象，在main运行前先运行构造函数，因此输出id=1 constructed void Func() { static Demo d2(2);//静态局部变量 Demo d3(3); cout &lt;&lt; “func” &lt;&lt; endl; } int main () { Demo d4(4);//先运行构造函数，输出id=4 constructed d4 = 6;//运行类型转换构造函数，输出id=6 constructed //临时对象调用完之后，就会消亡。输出id=6 destructed。但是消亡的是临时对象 cout &lt;&lt; “main” &lt;&lt; endl; { Demo d5(5); }//局部对象。输出id=5 constructed。因为是局部对象，花括号结束后就消亡。 //因此输出id=5 destructed Func();//调用Func函数，输出id=2 constructed和id=3 constructed，然后输出func //局部静态变量在函数结束的时候仍然存在，仅此只有d3(3)消亡，输出 id=3 destructed cout &lt;&lt; “main ends” &lt;&lt; endl; return 0;//整个程序结束后，局部变量消亡，输出id=6 destructed。main的变量d4和全局变量d1消亡，输出id=2 destructed和id=1 destructed } 输出结果为： id=1 constructed id=4 constructed id=6 constructed id=6 destructed main id=5 constructed id=5 destructed id=2 constructed id=3 constructed func id=3 destructed main ends id=6 destructed id=2 destructed id=1 destructed 形象举例，析构函数在拆房子过程中不是负责拆房子，而是在拆房子之前在房子里面做一些善后工作，比如说把东西都搬走。 习题：假设A是一个类的名字，下面的程序片段会类A的调用析构函数几次？ int main() { A p = new A[2]; A p2 = new A; A a; delete [] p; } 答案：3次。第一句话new出来2个，第二句话new出来1个。new**出来的东西，如果你不delete它，主程序结束它也不会消亡。所以调用西沟函数是A a在最后调用1次，delete调用2次，一共3次。 复制构造函数在不同编译器中的表现不一定相同！ 例如下： class A { public: int x; A(int x_):x(x_) { cout &lt;&lt; x &lt;&lt; “ constructor called” &lt;&lt; endl; } A(const A &amp; a ) { //本例中dev需要此const其他编译器不要 x = 2 + a.x; cout &lt;&lt; “copy called” &lt;&lt; endl; } ~A() { cout &lt;&lt; x &lt;&lt; “ destructor called” &lt;&lt; endl; } }; A f( ){ A b(10); return b; } int main( ){ A a(1); a = f(); return 0; } 正常情况下执行过程如下，以下为在Visula Studio中输出情况： 首先执行main函数里面的第一句话，输出1 constructor called。然后执行第二句话，调用函数f()，生成b，调用构造函数使m=10，因此输出10 constructor called，b返回后，任务结束，调用析构函数，输出10 destructor called。接着f的返回值是一个临时对象，需要进行初始化，所以调用A(const A &amp; a )，首先执行加法操作，临时对象的值变为12，然后输出copy called。将临时对象赋值给a后，临时对象消亡，调用析构函数，输出12 destructor called，然后主程序执行完毕，a也消亡，调用析构函数，输出12 destructor called**。 而在dev C++则输出： 1 constructor called 10 constructor called 10 destructor called 10 destructor called 说明dev出于优化目的并未生成返回值临时对象。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++面向对象程序设计课程笔记（第一周）","slug":"c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8","date":"2018-09-03T14:54:49.000Z","updated":"2019-03-20T14:40:47.430Z","comments":false,"path":"2018/09/03/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8/","link":"","permalink":"http://tech.yushuai.xyz/2018/09/03/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8/","excerpt":"","text":"一、动态内存分配 1.第一种用法，分配一个变量： P = new T; T是任意类型名，P是类型为T*的指针。动态分配出一片大小为sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P。比如： int *pn; pn = new int; *pn = 5; 2.第二种用法，分配一个数组： P= new T[N]; T：任意类型名； P：类型为T*的指针； N：要分配的数组元素的个数，可以是整型表达式。 动态分配出一片大小为N*sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋给P。 例如： int *pn; int i = 5; pn = new int[i20]; pn[0]=20; pn[100] =30;//编译没有问题，运行时导致数组越界，最大下标为99才对 new运算符返回值的类型都是T。 3.用delete运算符释放动态分配的内存 用new动态分配的内存空间，一定要用delete运算符进行释放。 格式如下： delete 指针;//该指针必须指向new出来的空间 例如： int *p = new int; *p = 5; delete p; delete p;//异常，一片空间不能被delete多次 用delete释放动态分配的数组，要加“[]”。，格式如下： delete[] 指针;//该指针必须指向new出来的数组。 如果不加[]，那么delete的空间就不会被释放完全。 二、内联函数和重载函数，函数参数缺省值 1.内联函数 函数调用是由时间开销的。如果函数本身只有几条语句，之行很快，而且执行次数较多，那么调用函数产生额外开销比较大，。为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。 内联函数的书写格式： inline 函数返回值类型 函数名称(参数) { 函数体; } 2.函数重载 同java类似，不再累述，根据调用语句中的实参的个数和类型判断应该调用哪个函数。但是若实参的个数和类型一致，只是返回值类型不同，就不是重载，会报错。 3.函数参数缺省值 定义函数的时候可以让最右边的连续若干个参数有缺省值。 三、类和对象的基本概念与用法 结构化程序设计中，函数和其操作的数据结构没有直观联系。 重用：在编写某个程序时，发现其需要的某项功能，在现有的某个程序里已经有了相同或类似的实现，那么自然希望能够将那部分代码抽取出来，在新程序中使用。 在结构化程序设计中，随着程序规模的增大，由于程序大量函数、变量之间的关系错综复杂，要抽取这部分代码，会变得十分困难。 面向对象的程序设计具有：抽象、封装、继承和多态四个基本特点。 例程： class CRectangle { public: int w,h; int Area(){ return w*h; } int Perimeter(){ return 2*(w+h); } void Init(intw_,inth_){ w = w_; h = h_; } };//必须要有分号 在主程序中使用： int main() { int w,h; CRectangle r;//新建一个类 cin&gt;&gt;w&gt;&gt;h; r.Init(w,j);;//初始化赋值 cout&lt;&lt;r.Area()&lt;&lt;endl&lt;&lt;r.Perimeter(); return 0; } 和结构变量一样，对象所占用的内存空间的大小，等于所有成员变量（不包括成员函数）的大小之和。 每个对象各有自己的存储空间，一个对象的某个成员变量被改变了不会影响另一个对象的成员变量。 和结构变量一样，对象之间可以用“=”进行赋值，但不可以运用别的运算符号，除非重载。 第二种使用类的成员变量和成员函数的方法： 指针-&gt;成员名。 第一种类似于Java，不说了。 用法3：引用名.成员名 CRectangle r2; CRectangle &amp; rr =r2; rr.w=5; rr.Init(5,4);//rr的值边了，r2的值也变","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"今天在github上更新了几个小程序","slug":"e4-bb-8a-e5-a4-a9-e5--aa-e5-b0-8f-e7-a8-8b-e5-ba-8f","date":"2018-08-29T14:39:05.000Z","updated":"2019-03-20T14:41:11.108Z","comments":false,"path":"2018/08/29/e4-bb-8a-e5-a4-a9-e5--aa-e5-b0-8f-e7-a8-8b-e5-ba-8f/","link":"","permalink":"http://tech.yushuai.xyz/2018/08/29/e4-bb-8a-e5-a4-a9-e5--aa-e5-b0-8f-e7-a8-8b-e5-ba-8f/","excerpt":"","text":"今天在GitHub上更新了大学的时候曾经写过的一些程序，可以在我的GitHub上查看。第一个是图书馆人员计数器，第二个是超声波测距仪，第三个是基于MATLAB的回波信号的产生与消除。其中前两个程序是我和同学一起制作，最后一个程序是我自己单独制作。欢迎查看。 图书馆人员出入计数器1.设计任务设计一个图书馆出入人员计数系统，要求利用2组红外发射接收对管组成模拟图书馆出入人员计数系统，使其能够模拟统计图书馆出入人员计数, 并使用数码管显示计数信息。 2.基本要求（1) 任何一对红外管能够检测到有人走过，并将计数显示出来； （2）当障碍物依次从红外发射管1到2走过的时候，人员数加1； （3）在实现(2)的基础上，实现则有分，如果不能保证两个同时实现，则不加分。当障碍物依次从红外发射管2到1走过的时候，人员数减1。 3.发挥部分（1）充分发挥两对红外对管的功能,实现当人员走到一半再返回,则计数不变功能； （2）为保证系统稳定性，当人员从第1对红外发射管经过之后，直接从中间取出，不计数；当人员从中间直接经过第2个管子之后， 不计数；待再次从第1、2对红外管经过时，正常计数。 4.下载地址[下载地址] 超声波测距仪关于程序本设计利用超声波具有指向性强，能量消耗慢，传播距离较远等优点，设计了一个基于51系列单片机的超声波测距系统，该系统使用ATMEL公司的51系列单片机，由单片机控制产生超声波脉冲并使用定时器计时，计算超声波自发射至接收的往返时间，从而得到实测距离，并用四位LED数码管显示出来，利用按键还可以实现距离的记录和乘积计算以及报警功能。整个硬件电路由单片机核心控制模块、超声波发送与接收模块、显示电路模块、蜂鸣器模块、按键模块和供电模块等组成。此系统具有易控制、工作可靠、测距准确度高、可读性强和流程清晰等优点。实现后的作品可用于需要测量距离参数的各种应用场合。 设计要求本系统的设计目的是，通过自己设计并画出电路原理图、PCB板，焊接电路，同时编写程序实现以下功能： S1：按下S1不放，则数码管显示数字定住，表示此时确定了一个距离L1，松开S1,则继续测距。 S2：按下S2不放，则数码管显示数字定住，表示此时确定了一个距离L2，松开S2,则继续测距。 S3：距离L1与距离L2相乘的结果。（注意：由于数码管显示有限，只能显示4位，所以L1和L2为两位数时，相乘结果才正确） S4：按下S4，约10秒后蜂鸣器响，按复位键后恢复正常。 硬件选择本设计的MCU采用的是DIP（Dual In-line Package塑料双列直插式）封装的STC89C52高性能8位单片机。AT89C51是一个低电压，高性能CMOS 8位单片机，片内含4k bytes的可反复擦写的Flash只读程序存储器和128 bytes的随机存取数据存储器（RAM），器件采用ATMEL公司的高密度、非易失性存储技术生产，兼容标准MCS-51指令系统，片内置通用8位中央处理器和Flash存储单元，内置功能强大的微型计算机的AT89C51提供了高性价比的解决方案。 系统框图 该系统由1个中心模块、5个功能模块组成。 单片机核心控制是整个系统的心脏。在本系统中，它将产生一个电平使超声波发送模块产生40kHZ的方波并发送出去；利用其中的定时器实现计时，并计算出距离，然后将其显示在数码管上；接收来自按键模块的信息；控制蜂鸣器模块的工作。 供电模块是系统的电源供给部分。来自电池的9V电压将通过该模块降为5V供给其它各个模块。 其它模块不在此再累述。 系统测试结果测试次数 1 2 3 4 5 系统测试值（单位：mm） 239 348 421 520 685 直尺测试值（单位：mm） 248 358 430 532 691 误差（单位：mm 9 10 9 12 6 下载地址[下载地址] 基于MATLAB的回波信号的产生与消除1.设计任务本课程设计要求用MATLAB语言编程实现回波信号的产生和消除。 2.理论依据根据设计要求分析系统功能，掌握设计中所需理论及原理（采样频率、采样位数的概念，采样定理；回声信号，卷积，相关分析；时域信号的FFT分析；数字滤波器设计原理和方法）。 3.信号的采集录制一段音频（如歌曲、说话声等），绘制其时域波形，对此音频信号用FFT作谱分析。 4.回声信号的产生在录制信号基础上产生带有回声的声音信号并绘制其时域波形，对其进行FFT频谱分析，绘制频谱图。 5.从带有回声的声音信号中恢复原信号设计合适的滤波器，对带有回声的声音信号进行滤波，恢复原信号。绘制所设计滤波器的幅频和相频特性，及滤波后的信号的时域波形和频谱图。 6.分析反射物距离从带有回声的声音信号中估计反射物的距离。采用相关分析法从带有回声的声音信号中估计反射物的距离。 7.下载地址[下载地址]","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"中国大学MOOC-陈越、何钦铭-数据结构-2018春期末考试","slug":"datastructure_finalexam","date":"2018-05-24T08:08:10.000Z","updated":"2019-03-21T14:51:47.812Z","comments":false,"path":"2018/05/24/datastructure_finalexam/","link":"","permalink":"http://tech.yushuai.xyz/2018/05/24/datastructure_finalexam/","excerpt":"","text":"一、判断题 1-1若用平方探测法解决冲突，则插入新元素时，若散列表容量为质数，插入就一定可以成功。(2分) F 1-2对N个不同的数据采用冒泡排序进行从大到小的排序，当元素基本有序时交换元素次数肯定最多。(2分) F 1-3_n_!是_O_(_n^n_)的。(2分) T 1-4对一棵平衡二叉树，所有非叶结点的平衡因子都是0，当且仅当该树是完全二叉树。(2分) F 1-5无向连通图至少有一个顶点的度为1。(2分) F 二、选择题 2-1 对一组数据{2，12，16，88，5，10}进行排序，若前三趟排序结果如下：第一趟排序结果：2，12，16，5，10，88第二趟排序结果：2，12，5，10，16，88第三趟排序结果：2，5，10，12，16，88则采用的排序方法可能是：(2分) 冒泡排序 2-2 给定有权无向图的邻接矩阵如下，其最小生成树的总权重是：(4分) 图1 14 2-3 数据结构中Dijkstra算法用来解决哪个问题？(2分) 最短路径 2-4 给定二叉树如下图所示。设N代表二叉树的根，L代表根结点的左子树，R代表根结点的右子树。若遍历后的结点序列为3、1、7、5、6、2、4，则其遍历方式是：(2分) 图2 RNL 2-5 设栈S和队列Q的初始状态均为空，元素{1,2,3,4,5,6,7}依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是{2,5,6,4,7,3,1}，则栈S的容量至少是：(2分) 4 2-6对于序列{49，38，65，97，76，13，27，50}，按由小到大进行排序，下面哪一个是初始步长为4的希尔排序法第一趟的结果？(4分) 49,13,27,50,76,38,65,97 2-7在一个有权无向图中，如果顶点b到顶点a的最短路径长度是10，顶点c与顶点b之间存在一条长度为3的边。那么下列说法中有几句是正确的？(4分) c与a的最短路径长度就是13 c与a的最短路径长度就是7 c与a的最短路径长度不超过13 c与a的最短路径不小于7 2句 2-8 在拓扑排序算法中用堆栈和用队列产生的结果会不同吗？(2分) 有可能会不同 2-9 设最小堆（小根堆）的层序遍历结果为{5,18,15,28,22,42,40}。用线性时间复杂度的算法将该堆调整为最大堆（大根堆），则该树的中序遍历结果为：(4分) A. 18,28,22,42,15,40,5 2-10 在图中自a点开始进行广度优先遍历算法可能得到的结果为：(2分) 图3 a,b,e,c,d,f 2-11 在一个链队列中，front和rear分别为头指针和尾指针，则插入一个结点s的操作为（）。(2分) rear-&gt;next=s;rear=s; 2-12 设散列表的地址区间为[0,16]，散列函数为_H_(_Key_)=_Key_%17。采用线性探测法处理冲突，并将关键字序列{26，25，72，38，8，18，59}依次存储到散列表中。元素59存放在散列表中的地址是：(4分) 11 2-13 令P代表入栈，O代表出栈。则将一个字符串3a+b/c变为3abc/+的堆栈操作序列是哪个？（例如将ABC变成BCA的操作序列是PPOPOO。）(4分) POPPOOPPOPPOOO 2-14要判断一个整数_N_（&gt;10）是否素数，我们需要检查3到√_N_之间是否存在奇数可以整除_N_。则这个算法的时间复杂度是：(2分) O(根号N) 2-15 将1~6这6个键值插到一棵初始为空的二叉搜索树中。如果插入完成后，搜索树结构如图所示，问：可能的插入序列是什么？(2分) 图4 413256 2-16 将9,8,7,2,3,5,6,4顺序插入一棵初始为空的AVL树。下列句子中哪句是错的？(4分) 5是根结点 2-17 对给定序列{110，119，7，911，114，120，122}采用次位优先（LSD）的基数排序，则两趟收集后的结果为：(2分) 7,110,911,114,119,120,122 2-18 给定输入序列{4371,1323,6173,4199,4344,9679,1989}以及散列函数_h_(_X_)=_X_%10。如果用大小为10的散列表，并且用分离链接法解决冲突，则输入各项经散列后在表中的下标为：（-1表示相应的插入无法成功）(4分) 1,3,3,9,4,9,9 2-19 在图中自d点开始进行深度优先遍历算法可能得到的结果为：(2分) 图5 d,e,a,c,f,b 2-20 哈夫曼树是n个带权叶子结点构成的所有二叉树中（带权路径长度）最小的二叉树。(2分) 2-21 在并查集问题中，已知集合元素0~8所以对应的父结点编号值分别是{1,-4,1,1,-3,4,4,8,-2}（注：−_n_表示树根且对应集合大小为_n_），那么将元素6和8所在的集合合并（要求必须将小集合并到大集合）后，该集合对应的树根和父结点编号值分别是多少？(4分) 4和-5 2-22 将10,12,1,14,6,5,8,15,3,9,7逐个按顺序插入到初始为空的最小堆中，然后连续执行两次删除最小元素操作（DeleteMin），再插入4，16，此后堆顶的元素是什么？(4分) 4 二、程序填空题 图6 三、编程题 7-1 还原二叉树（8 分） 给定一棵二叉树的先序遍历序列和中序遍历序列，要求计算该二叉树的高度。 输入格式： 输入首先给出正整数N（≤50），为树中结点总数。下面两行先后给出先序和中序遍历序列，均是长度为N的不包含重复英文字母（区别大小写）的字符串。 输出格式： 输出为一个整数，即该二叉树的高度。 输入样例： 9 ABDFGHIEC FDHGIBEAC 输出样例： 5 代码： 暂时不公布代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"数据结构【浙江大学】（第11节）整理","slug":"datastructure_chapter11","date":"2018-05-14T15:42:22.000Z","updated":"2019-03-21T14:51:55.393Z","comments":false,"path":"2018/05/14/datastructure_chapter11/","link":"","permalink":"http://tech.yushuai.xyz/2018/05/14/datastructure_chapter11/","excerpt":"","text":"第十一讲：散列查找11.1 散列表11.1.1 散列的基本思路编译处理时，设计变量及属性的管理： （1）插入：新变量定义。 （2）查找：变量的引用。 编译处理中对变量管理：动态查找问题。 利用查找树进行变量管理，由于两个变量名（字符串）比较效率不高。 我们已知的查找方法： （1）顺序查找，复杂度O(N)； （2）二分查找（静态查找），复杂度O(logN) （3）二叉搜索树，复杂度为O(h)，其中h为二叉查找树的高度； （4）平衡二叉树，复杂度为O(logN)。 如何快速搜索到需要的关键词呢？如果关键词不方便比较该怎么办呢？ 我们回顾下查找的本质：已知对象找到位置。有序安排对象：全序、半序。直接“算出”对象位置：散列。 散列查找法的两项基本工作： （1）计算位置：构造散列函数确定关键词存储位置； （2）解决冲突：应用某种策略解决多个关键词位置相同的问题。 时间复杂度几乎是常量：O(1)，即查找时间与问题规模无关！ 11.1.2 什么是散列表散列表（哈希表） 类型名称:符号表（SymbolTable） 数据对象集：符号表是“名字(Name)-属性(Attribute)”对的集合。 操作集：对于一个符号表Table∈SymbolTable，一个给定名字Name∈NameType，属性Attr∈AttributeType，以及正整数TableSize，符号表的基本操作主要有： 1、SymbolTable InitializeTable( int TableSize )：创建一个长度为TableSize的符号表； 2、Boolean IsIn( SymbolTable Table, NameType Name)： 查找特定的名字Name是否在符号表Table中； 3、AttributeType Find( SymbolTable Table, NameType Name)： 获取Table中指定名字Name对应的属性； 4、SymbolTable Modefy(SymbolTable Table, NameType Name, AttributeType Attr)： 将Table中指定名字Name的属性修改为Attr； 5、SymbolTable Insert(SymbolTable Table, NameType Name, AttributeType Attr)： 向Table中插入一个新名字Name及其属性Attr； 6、 SymbolTable Delete(SymbolTable Table, NameType Name)： 从Table中删除一个名字Name及其属性。 【例1：一位数组】有n = 11个数据对象的集合，关键词是正整数，分别为 18，23，11，20，2，7，27，30，42，15，34。 如果符号表的大小用TableSize = 17（通常用一个素数），选取散列函数h如下： h(key) = key mod TableSize （公式 5.1） 其中mod 是求余运算，相当于C语言中的%运算。 用这个散列函数对11个数据对象建立查找表（忽略各关键词对应的属性部分，该例的关键词没有冲突）如下： 地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 关键词 34 18 2 20 23 7 42 27 11 30 15 （1）存放： h(18)=1，h(23)=6，……。如果新插入35，h(35)=1，该位置有对象，冲突！ （2）查找（先考虑在没有冲突情况下） 查找时，对给定关键词keyi依然通过公式5.1计算出地址，再将keyi与该地址单元中关键词比较，若相等，则查找成功。例如： key=22，h(22)=5，该地址空，不在表中； key=30，h(30)=13，该地址存放是30，找到！ 【定义】设散列表空间大小为m，填入表中的元素个数是n，则称α＝n/m为散列表的“装填因子（Loading Factor）”。 装填因子α＝11 / 17 ≈ 0.65。 实用时，常将散列表大小设计使得 α＝0.5～0.8为宜。 [例2：二维数组]将给定的10个C语言中的关键词(保留字或标准函数名)顺次存入一张散列表。这10个关键词为：acos、define、float、exp、char、atan、ceil、floor、clock、ctime。散列表设计为一个二维数组Table[26][2]，2列分别代表 2个槽，如图1所示。 图1 利用一个二维数组，为例1中所提到的冲突提供了一个解决方案。可以将相同的两个元素放到多个槽中。 考虑到这些都是单词，我们在设计散列函数的时候可以以首字母为基准进行，比如设计为： _h(key) = key[0] – ‘a’_ 如图2所示，当放到clock和ctime的时候，发现产生了冲突，如图2所示。 图2 如果没有溢出，则 _T_**_查询_ _= T_**_插入_ _= T_**_删除_ _=_ O( 1 )** 总结一下： “散列（Hashing）” 的基本思想是：以数据对象的关键字key为自变量，通过一个确定的函数关系 h，计算出对应的函数值h(key)，把这个值解释为数据对象的存储地址，并按此存放，即“存储位置 = h（key）”。 散列方法中使用的计算函数称为“散列函数” （也称哈希函数），按这个思想构造的表称为“散列表”，所以它也是一种存储方法。 在查找某数据对象时，用同样的方法“存储位置 = h（key）”计算出地址，将key与该地址单元中数据对象关键字进行比较，确定查找是否成功。 可能将不同的关键字映射到同一个散列地址上，即h(keyi) = h(keyj)（当keyi ≠keyj），这种现象称为“冲突(Collision)”， keyi 和keyj称为“同义词（synonym）”。 通常关键词的值域（允许取值的范围）远远大于表空间的地址集，所以说，冲突不可能避免，只能尽可能减少。 11.2 散列函数的构造方法一个“好”的散列函数一般应考虑下列两个因素： 1\\. **计算简单**，以便提高转换速度； 2. 关键词对应的地址空间分布均匀，以尽量减少冲突。 11.2.1 数字关键词的散列函数构造1.直接定址法：取关键词的某个线性函数值为散列地址，即h(key)=a×key+b(a、b为常数)。 2.除留余数法：散列函数为：h(key) = key mod p。为了地址空间分布均匀，一般p取素数。 3.数字分析法：分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址。 比如：取11位手机号码key的后4位作为地址：散列函数为：h(key) = atoi(key+7) 4.折叠法：把关键词分割成位数相同的几个部分，然后叠加。 例如56793542，则做以下处理：（542）+（793）+（056）=1391，取391作为关键字。 5.平方取中法：例如56793542，则计算56793542×56793542=3225506412905764，那么就取中间的641作为关键字。 11.2.2 字符串关键词的散列函数构造1.一个简单的散列函数——ASCII码加和法 对字符型关键词key定义散列函数如下： h(key) = (Σkey[i]) mod TableSize 这种方法也会有比较严重的冲突！ 2.简单的改进——前3个字符位移法 h(key)=(key[0] + key[1]´27 + key[2]´272 )mod TableSize 缺点：仍然冲突：string、 street、strong、structure等等；空间浪费：3000/263 ≈ 30% 3.好的散列函数——移位法 设计关键词所有n个字符，并且分布得很好。如图3所示的公式。 图3 在实际应用这个公式的时候，我们可以考虑在第一节的时候计算多项式的那个简便方法。代码如下： Index Hash ( const char Key, int TableSize ){ unsigned int h = 0; / 散列函数值，初始化为0 / while ( \\Key != ‘\\\\0’) /* 位移映射 / h = ( h &lt;&lt; 5 ) + Key++; return h % TableSize;} 11.3 冲突处理方法常用处理冲突的思路： （1）换个位置：开放地址法； （2）同一位置的冲突对象组织在一起：链地址法。 11.3.1 开放定址法所谓开放定址法（Open Addressing）就是一旦产生了冲突（该地址已经有其它元素），就按某种规则去寻找另一空地址。 若发生了第i次冲突，试探的下一个地址将增加di，基本公式是： hi(key) = (h(key)+di) mod TableSize ( 1≤ i &lt; TableSize ) di决定了不同的解决冲突方案：线性探测（di=i）、平方探测（di=±i2）、双散列（di=i*h2(key)）。 11.3.2 线性探测即线性探测法以增量序列 1，2，……，（TableSize-1）循环试探下一个存储地址。 【例】设关键词序列为 {47，7，29，11，9，84，54，20，30}， 散列表表长TableSize=13， 装填因子α=9/13 ≈0.69； 散列函数为：h(key) =key mod 11。 用线性探测法处理冲突，列出依次插入后的散列表，并估算查找性能。（1分钟） 关键词 (key) 47 7 29 11 9 84 54 20 30 散列地址h(key) 3 7 7 0 9 7 10 9 8 冲突次数 0 0 1 0 0 3 1 3 6 地址 操作 0 1 2 3 4 5 6 7 8 9 10 11 12 说 明 插入47 47 无冲突 插入7 47 7 无冲突 插入29 47 7 29 d1 = 1 插入11 11 47 7 29 无冲突 插入9 11 47 7 29 9 无冲突 插入84 11 47 7 29 9 84 d3 = 3 插入54 11 47 7 29 9 84 54 d1 = 1 插入20 11 47 7 29 9 84 54 20 d3 = 3 插入30 11 30 47 7 29 9 84 54 20 d6 = 6 线性探测会产生聚集现象。 1.散列表查找性能分析 （1）成功平均查找长度（ASLs）。假设要查找的关键词一定在散列表中存在。只要对查找表中的每个关键词的比较次数加起来，除以关键词的个数，就得到平均每个关键词的查找长度。而每个关键词的比较次数是其冲突次数加1。 ASL s= （1+7+1+1+2+1+4+2+4）/ 9 = 23/9 ≈ 2.56 （2）不成功平均查找长度（ASLu），即不在散列表中的关键词的平均查找次数（不成功）。一般方法：将不在散列表中的关键词分若干类。如根据H(key)值分类。查找方式举个例子就明白了，假设我们查找22,22 mod 11=0，那么从H(key)=0开始查找，发现此时没有它，往后移一位还是不对，再后一位是空的，故判断其不在表中，故查找次数为3。然后所有这些找不到的元素的查找次数之和除以其个数就可以得出其ASLu。 11.3.3 线性探测——字符串的例子【例】将acos/define/float/exp/char/atan/ceil/floor顺次放入一张大小为26的散列表中。H(key)=key[0]-‘a’，采用线性探测di=i。 0 1 2 3 4 5 6 7 …… acos atan char define exp float ceil floor …… 分析： ASLs： （1+1+1+1+1+2+5+3）/8=15/8≈1.87 ASLu：根据H(key)值分为26种情况，H值为0,1,2…,25，则 ASLu=(9+8+7+6+5+4+3+2+118)/26=62/26≈*2.38 11.3.4 平方探测法（二次探测）即平方探测法以增量序列12，-12，22，-22，…，q2，-q2且q ≤ ëTableSize/2û 循环试探下一个存储地址。 【例】设关键词序列为 {47，7，29，11，9，84，54，20，30} （1）散列表表长TableSize = 11（即满足4×2+3形式的素数） （2）装填因子 α = 9/11 ≈ 0.82 （3）散列函数为：h(key) = key mod 11 （4）用平方探测法处理冲突，列出依次插入后的散列表并估算ASLs 关键词 key 47 7 29 11 9 84 54 20 30 散列地址h(key) 3 7 7 0 9 7 10 9 8 冲突次数 0 0 1 0 0 2 0 3 3 地址 操作 0 1 2 3 4 5 6 7 8 9 10 说 明 插入47 47 无冲突 插入7 47 7 无冲突 插入29 47 7 29 d1 = 1 插入11 11 47 7 29 无冲突 插入9 11 47 7 29 9 无冲突 插入84 11 47 84 7 29 9 d2 = -1 插入54 11 47 84 7 29 9 54 无冲突 插入20 11 20 47 84 7 29 9 54 d3 = 4 插入30 11 30 20 47 84 7 29 9 54 d3 = 4 ASLs=（1+1+2+1+1+3+1+4+4）/ 9 = 18/9 = 2 是否有空间，平方探测（二次探测）就能找得到？这不一定！ 但是有定理显示：如果散列表长度TableSize是某个4k+3（k是正整数）形式的素数时，平方探测法就可以探查到整个散列表空间。 11.3.5 平方探测法的实现typedef struct HashTbl HashTable;struct HashTbl{ int TableSize; Cell TheCells;}H ; HashTable InitializeTable( int TableSize ) { HashTable H; int i;/ 1/ if ( TableSize &lt; MinTableSize ){/ 2/ Error( “散列表太小” );/ 3/ return NULL; } / 分配散列表 // 4/ H = malloc( sizeof( struct HashTbl ) );/ 5/ if ( H == NULL )/ 6/ FatalError( “空间溢出!!!” );/ 7/ H-&gt;TableSize = NextPrime( TableSize ); / 分配散列表 Cells // 8/ H-&gt;TheCells = malloc( sizeof( Cell ) H-&gt;TableSize );/ 9/ if( H-&gt;TheCells == NULL )/*10*/ FatalError( “空间溢出!!!” );/*11*/ for( i = 0; i &lt; H-&gt;TableSize; i++ )/*12*/ H-&gt;TheCells[ i ].Info = Empty;/*13*/ return H; } Position Find( ElementType Key, HashTable H ) { Position CurrentPos, NewPos; int CNum; / 记录冲突次数 // 1/ CNum = 0;/ 2/ NewPos = CurrentPos = Hash( Key, H-&gt;TableSize );/ 3/ while( H-&gt;TheCells[ NewPos ].Info != Empty &amp;&amp; H-&gt;TheCells[ NewPos ].Element != Key ) { / 字符串类型的关键词需要 strcmp 函数!! // 4/ if(++CNum % 2){ / 判断冲突的奇偶次 // 5/ NewPos = CurrentPos + (CNum+1)/2(CNum+1)/2;/ 6/ while( NewPos &gt;= H-&gt;TableSize )/ 7/ NewPos -= H-&gt;TableSize; } else {/ 8/ NewPos = CurrentPos - CNum/2 CNum/2;/ 9/ while( NewPos &lt; 0 )/ 10/ NewPos += H-&gt;TableSize; } }/ 11/ return NewPos; }void Insert( ElementType Key, HashTable H ){ / 插入操作 / Position Pos;/ 1/ Pos = Find( Key, H );/ 2/ if( H-&gt;TheCells[ Pos ].Info != Legitimate ) { / 确认在此插入 // 3/ H-&gt;TheCells[ Pos ].Info = Legitimate;/ 4/ H-&gt;TheCells[ Pos ].Element = Key; /字符串类型的关键词需要 strcpy 函数!! / } } 在开放地址散列表中，删除操作要很小心。通常只能“懒惰删除”，即需要增加一个“删除标记(Deleted)”，而并不是真正删除它。以便查找时不会“断链”。其空间可以在下次插入时重用。 另外还有两种方法： 3.双散列探测法 di 选为i*h2(key)，其中h2(key)是另一个散列函数。我们把它叫做双散列探测法。由此，探测序列成了：h2(key)，2h2(key)，3h2(key)，… 对任意的key，h2(key) ≠0 探测序列还应该保证所有的散列存储单元都应该能够被探测到。选择以下形式有良好的效果： h2(key)=p-(key mod p) 其中：p &lt; TableSize，p、TableSize都是素数。 4.再散列 当散列表元素太多（即装填因子α太大）时，查找效率会下降；重新计算，再装入散列表。 11.3.6 分离链接法分离链接法是解决冲突的另一种方法，其做法是将所有关键词为同义词的数据对象通过结点链接存储在同一个单链表中。 【例】 设关键字序列为 47, 7, 29, 11, 16, 92, 22, 8, 3, 50, 37, 89, 94, 21…… 散列函数取为：h(key) = key mod 11，用分离链接法处理冲突。 如图4所示。 图4 该表中有9个结点只需1次查找 5个结点需要2次查找 因此查找成功的平均查找次数为： ASL s=（9+5*2）/ 14 ≈ 1.36。 代码如下： struct HashTbl{ int TableSize; List TheLists;}H;struct ListNode;typedef struct ListNode *Position, *List;struct HashTbl;typedef struct HashTbl HashTable;struct ListNode{ ElementType Element; Position Next;};Position Find( ElementType Key, HashTable H ){ Position P; List L;/ 1/ L = &amp;( H-&gt;TheLists[ Hash( Key, H-&gt;TableSize ) ] );/ 2/ P = L-&gt;Next;/ 3/ while( P != NULL &amp;&amp; strcmp(P-&gt;Element, Key) )/ 4/ P = P-&gt;Next;/ 5*/ return P;} 11.4 散列表的性能分析关键词的比较次数，取决于产生冲突的多少。 影响产生冲突多少有以下三个因素： （1）散列函数是否均匀； （2）处理冲突的方法； （3）散列表的装填因子α。 1.线性探测发的查找性能 可以证明，线性探测法的期望探测次数满足下列公式： 图5 当α=0.5时， 插入操作和不成功查找的期望ASLu=0.5*(1+1/(1-0.5)2)=2.5次， 成功查找的期望ASLs=0.5*(1+1/(1-0.5))=1.5次。 例子的α=0.69，于是 期望ASLu=0.5*(1+1/(1-0.69)2)=5.70次 期望ASLs=0.5*(1+1/(1-0.69))=2.11次（例中ASLs=2.56）。 2. 平方探测法和双散列探测法的查找性能 可以证明，平方探测法和双散列探测法探测次数 满足下列公式： 图6 当α=0.5时， 插入操作和不成功查找的期望ASLu=1/(1-0.5)=2次， 成功查找的期望ASLs=-1/0.5*ln(1-0.5)≈1.39次。 例子的α=0.82，于是 期望ASLu=1/(1-0.82)≈5.56次 期望ASLs=-1/0.5*ln(1-0.5)≈2.09次（例中ASLs=2）。 图7表示了期望探测次数与装填因子α的关系。 图7 当装填因子α&lt;0.5的时候，各种探测法的期望探测次数都不大，也比较接近。 随着α的增大，线性探测法的期望探测次数增加较快，不成功查找和插入操作的期望探测次数比成功查找的期望探测次数要大。 合理的的最大装入因子α应该不超过0.85。 3. 分离链接法的查找性能 所有地址链表的平均长度定义成装填因子α，α有可能超过1。 不难证明：其期望探测次数 p为： 图8 当α=1时， 插入操作和不成功查找的期望ASLu=1+e-1=1.37次， 成功查找的期望ASLs=1+1/2=1.5次。 我们发现：随着α增大，ASLu增加很慢；而ASLs线性增长。 总结一下散列查找： 1.选择合适的 h(key) ，散列法的查找效率期望是常数_O(1)，_它几乎与关键字的空间的大小n无关！ 2.它是以较小的α为前提。因此，散列方法是一个以空间换时间的成功范例。 3.散列方法的存储对关键字是随机的，不便于顺序查找关键字，也不适合于范围查找，或最大值最小值查找。 再来总结下开放地址法和分离链接法： 1.开放地址法： （1）散列表是一个数组，存储效率高，随机查找。 （2）散列表有“聚集”现象，再散列时有“停顿”现象。 （3）关键字的删除只能采用“懒惰删除”法，会导致存储“垃圾”。 2.分离链接法： （1）关键字删除不需要“懒惰删除”法，从而没有存储“垃圾”。 （2）散列表是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低。 （3）太小的α可能导致空间浪费，大的α又将付出更多的时间代价。不均匀的链表长度导致时间效率的严重下降。 11.5应用实例：文件中单词词频统计【问题】给定一个英文文本文件，统计文件中所有单词出现的频率，并输出词频最大的前10%的单词及其词频。 为简单起见，假设单词字符定义为大小写字母、数字和下划线，其他字符均认为是单词分隔符，不予考虑。 【分析】解决这个问题的最基本的工作、也是大量的工作是不断对新读入的单词在已有单词表中查找，如果已经存在，则将该单词的词频加1，如果不存在，则插入该单词并记词频为1。 使用散列表设计该单词表的数据结构可以进行快速地查找和插入 【解决方案】代码如下： int main() {/ 1 / int TableSize = 10000； / 散列表的估计大小 / int wordcount = 0, length; HashTable H; ElementType word; FILE fp;/ 2 / char document[30]= “HarryPotter.txt“; / 要被统计词频的文件名 // 3 / H = InitializeTable( TableSize ); / 建立散列表 // 4 / if(( fp = fopen(document, “r” ))==NULL) FatalError(“无法打开文件!\\\\n” ); while( !feof( fp ) ){/ 5 / length = GetAWord( fp, word ); / 从文件中读取一个单词 // 6 / if(length &gt; 3){ / 只考虑适当长度的单词 // 7 / wordcount++;/查找散列表，若存在，则将该单词的词频加1，若不存在，则插入。// 8 / InsertAndCount( word, H ); } } fclose( fp );/ 9 / printf(“该文档共出现 %d 个有效单词，”, wordcount);/根据散列表，输出最频繁出现的给定百分比（10%）的单词。// 10 / Show( H ，10.0/100 ); / 显示词频前10%的所有单词 // 11 / DestroyTable( H ); / 销毁散列表 */ return 0;}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"数据结构【浙江大学】（第10节）整理","slug":"datastructure_chapter10","date":"2018-05-13T13:29:44.000Z","updated":"2019-03-21T14:51:59.353Z","comments":false,"path":"2018/05/13/datastructure_chapter10/","link":"","permalink":"http://tech.yushuai.xyz/2018/05/13/datastructure_chapter10/","excerpt":"","text":"第十讲：排序（下）10.1 快速排序10.1.1 算法概述策略：分而治之。 下面举个例子，假如一组数为13/81/92/43/65/31/57/26/75/0，我们对其进行排序。那么首先选择出一个主元，这里我们选择为65，那么将这组数的其他成员分为了两组，一组是小于主元的13/43/31/57/26/0，一组是大于主元的81/92/75.然后将其递归处理，两边各选一个主元再进行分组……倒数第二步的时候，我们在第一步选择出来的主元左侧已经排好了顺序，右侧也排好了顺序，这样将它们放在同一个数组中，就完成了排序。 以下是上面这段话的伪码描述： void QuickSort(ElementType A[], int N){ if(N&lt;2) return; pivot = 从A[]中选一个主元; 将S={A[]\\\\PIVOT}分成2个独立子集： A1={a∈S|a≤piovt}和 A2={a∈S|a≥piovt} A[]=Quic_Sort(A1,N1)∪(pivot)∪QuickSort(A2,N2);} 这个方法的关键在于主元的选取（选取不好，快速算法会很慢）和子集划分（这个过程也是耗费时间的一个地方）。 快速排序算法的最好情况就是每次正好中分，T(N)=O(NlogN)。 10.1.2 选主元选取头、中、尾的中位数，也可以选取5个、7个等数字的中位数。例如8/12/3的中位数就是8。伪码描述如下： ElementType Median3(ElementType A[], int Left, int Right){ int Center=(Left+Right)/2; if(A[Left]&gt;A[Center]) Swap(&amp;A[Left],&amp;A[Center]); if(A[Left]&gt;A[Right]) Swap(&amp;A[Left],&amp;A[Right]); if(A[Center]&gt;A[Right]) Swap(&amp;A[Center],&amp;A[Right]); Swap(&amp;A[Center],&amp;A[Right-1]);/将pivot藏到右边/ /只需要考虑A[left+1]到A[Right-2]，这样来划分左右/ return A[Right-1];} 10.1.3 子集划分为了便于理解，还是举一个例子： 8 1 4 9 0 3 5 2 7 6（M） 定义两个指针i（指向第一个元素）和j（指向中位数左侧的元素）。（继续强调，这里的i和j不是实际的指针，而是存储所需要元素下标的整数。）先比较i代表的元素和主元的大小，发现8大于6，那么i这个指针不变；然后看j代表的元素和主元比较，发现7大于6，将j减一（即左移一位），然后再比较，发现2小于6，这样就不对了，j停止移动。在i和j都停止移动后，将其所指向的两个元素交换位置，变成了下面这个样子。 2 1 4 9 0 3 5 8 7 6（M） 然后i加1（右移一位），1小于6，正常，i继续加1（右移一位），4小于6，正常，i继续加1（右移一位），此时9大于6，不正常，i停止；再看j减1（左移一位），5小于6，不正常，j停止，然后交换此时i和j所代表的元素，变成下面这个样子。 2 1 4 5 0 3 9 8 7 6（M） 然后i加1（右移一位），发现正常，i继续加1，发现正常，i再加1，发现9小于6，不正常，i停止；然后j左移一位，发现3小于6，不正常，停止。 此时发现i-j&lt;0了，子集划分结束，同时将i代表的元素和主元交换，完成了子集的划分。最后结果如下： 2 1 4 5 0 3 6（M） 8 7 9 快速算法的“快速”在于，划分完成后其主元被一次性放到了正确的位置再也不会移动；例如插入算法等都需要一步一步往后移。 如果有元素正好等于pivot怎么办？停下来处理。 对于小规模数据还不如用插入排序。当递归的数据规模充分小，则停止递归，直接调用简单排序。在程序中定义一个Cutoff的阈值。 10.1.4 算法实现伪码描述： void Quicksort(ElementType A[], int Left, int Right){ if(Cutoff&lt;=Right-Left) { Pivot = Median3(A, Left, Right); i=Left; j= Right-1; for(;;) { while(A[++i]&lt;Pivot){} while(A[–j]&gt;Pivot){} if(i&lt;j) Swap(&amp;A[i],&amp;A[j]); else break; } Swap(&amp;A[i],&amp;A[Right-1]); Quicksort(A,Left,i-1); Quicksort(A,i+1,Right); } else Insertion_Sort(A+Left,Right-Left+1); } 为了统一接口，在上段程序后面再加一个： void Quick_Sort(ElementType A[], int N){ Quicksort(A, 0, N-1);} 快速排序算法是不稳定算法！ 以下给出另外的C语言编写的代码，它是直接调用函数库： / 快速排序 - 直接调用库函数 / #include &lt;stdlib.h&gt; /—————简单整数排序——————–/int compare(const void *a, const void *b){ / 比较两整数。非降序排列 / return ((int)a - (int)b);}/ 调用接口 /qsort(A, N, sizeof(int), compare);/—————简单整数排序——————–/ /————— 一般情况下，对结构体Node中的某键值key排序 —————/struct Node { int key1, key2;} A[MAXN]; int compare2keys(const void *a, const void *b){ / 比较两种键值：按key1非升序排列；如果key1相等，则按key2非降序排列 / int k; if ( ((const struct Node)a)-&gt;key1 &lt; ((const struct Node)b)-&gt;key1 ) k = 1; else if ( ((const struct Node)a)-&gt;key1 &gt; ((const struct Node)b)-&gt;key1 ) k = -1; else { / 如果key1相等 / if ( ((const struct Node)a)-&gt;key2 &lt; ((const struct Node)b)-&gt;key2 ) k = -1; else k = 1; } return k;}/ 调用接口 /qsort(A, N, sizeof(struct Node), compare2keys);/————— 一般情况下，对结构体Node中的某键值key排序 —————/ 10.2 表排序10.2.1 算法概述表排序用于：元素不是简简单单的排序，每一个元素都是一个庞大的结构，例如一个结构体等，此时如果我们想要交换两个元素，就不能忽略交换所需要的时间了。表排序就是在移动的时候，并不移动原始的数据，只是移动指向它的指针。 它是一种间接排序的方法，定义一个指针数组作为“表”（table）。 用下面一个例子来举例： A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 0 1 2 3 4 5 6 7 利用插入算法，可以得出： A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 3 5 2 1 7 0 4 6 如果仅要求按顺序输出，则输出： A[table[0]],A[table[1]],……,A[table[N-1]] 10.2.2 物理排序所谓物理排序就是说，我们不能像前文那样利用指针来移动，而是必须实际移动结构体，那该怎么办呢？ 利用这样一个原理：N个数字的排列由若干个独立的环组成。 为了解释这个原理，看10.2.1中最后的结果那个表，table[0]值（3）-&gt;table[3]值（1）-&gt;table[1]的值（5）-&gt;table[5](0)返回到了table[0]。一共有三种环，这三种环互不相交，称为独立。 在排序的时候，先对一个环内进行排序。那么如何判断一个环的结束呢？ 每访问一个空位i后，就令table[i]=i。当发现table[i]==i时，环就结束了。 下面分析一下复杂度的情况： （1）最好的情况：初始即有序。 （2）最坏的情况：有N/2个环，每个环包含两个元素，元素需要移动3N/2次。 但是无论如何，复杂度都可以写为T(N)=O(mN)，其中m是每个A元素复制需要的时间。 10.3 基数排序10.3.1 桶排序举例：假设我们有N个学生，他们的成绩是0到100之间的整数（于是有于是有M=101个不同的成绩值个不同的成绩值）。如何在线性时间内将学生按成绩排序？ 我们可以为每一个成绩值构造一个“桶”，于是就有了101个桶，如图1所示。如果我们有一个88分的学生，那么就把学生的信息查到88分的这个链表的表头里，伪码描述如下： void Bucket_Sort(ElementType A[], int N){ count[]初始化; while (读入读入11个学生成绩个学生成绩graded) 将该生插入count[grade]链表; for ( i=0; i&lt;M; i++ ) { if(count[i]) 输出整个count[i]链表; }} 时间复杂度：T(N,M)=O(M+N) 插入学生的成绩，因为是N个学生，所以复杂度为O(N)；输出成绩，for循环，M个成绩，自然复杂度为O(M)。故总的时间复杂度如上。 如果有N=40000个学生，由于M=101，故这就是一个线性的复杂度。 图1 但是，如果M&gt;&gt;N怎么办？ 10.3.2 基数排序举例：假设我们有N=10个整数，每个整数的值在0到999之间之间（于是有于是有M=1000个不同的值个不同的值）。还有可能在线性时间内排序吗？ 这里的基数就是跟进制有关，如果是二进制，基数就是2；如果是十进制，基数就是10。这里我们说的是十进制，所以基数就是10。 加入我们的输入序列为：64,8,216,512,27,729,0,1,343,125，用“次位优先”（Least Significant Digit，LSD）算法。主位是指的第一位，剩余的都叫次位。因此这里比较我们先从个位开始。 首先我们建立十个“桶”，然后将它们以个位数为标准放到这10个桶里面去，如表中Pass 1；然后按照十位数为标准放到10个桶里，如Pass 2；在完成之后，我们来做一个收集，收集的过程就是扫描每一个桶，然后把桶里的元素按照0,1,8,512,216……顺序用一个链表把它们串起来；串起来后，按照主位放到相应的桶里，如Pass3；最后，再对它们进行一次收集，用链表连起来，得出结果。 表3.1 基数排序算法流程表 Bucket 0 1 2 3 4 5 6 7 8 9 Pass 1 0 1 512 343 64 125 216 27 8 729 Pass2 0 512 125 343 64 1 216 27 8 729 Pass3 0 125 216 343 512 729 1 8 27 64 时间复杂度：T(N,B,P)=O(P(N+B))。其中P为基数排序次数（本例子例为3），N为输入序列中数字个数，B为整数进制。 10.3.3 多关键字排序例如，一副扑克牌是按2种关键字排序的，如图2所示，花色是它的主关键字，面值是它的次关键字。 图2 在这里，我们可以用“主位优先”（Most Significant Digit, MSD）排序，为花色建立4个桶，在每个桶里分别排序，最后合并结果。 也可以使用“次位优先”（LSD）算法排序，为面值建立13个桶，就可以直接将结果合并，然后为花色建4个桶，放进去就可以了。 在这里，LSD优点是不需要排序，时间复杂度小的多。 基数排序是稳定的算法。 补充（1）次位优先的C语言代码： / 基数排序 - 次位优先 / / 假设元素最多有MaxDigit个关键字，基数全是同样的Radix / #define MaxDigit 4 #define Radix 10 / 桶元素结点 /typedef struct Node *PtrToNode;struct Node { int key; PtrToNode next;}; / 桶头结点 /struct HeadNode { PtrToNode head, tail;};typedef struct HeadNode Bucket[Radix]; int GetDigit ( int X, int D ){ / 默认次位D=1, 主位D&lt;=MaxDigit / int d, i; for (i=1; i&lt;=D; i++) { d = X % Radix; X /= Radix; } return d; } void LSDRadixSort( ElementType A[], int N ){ / 基数排序 - 次位优先 / int D, Di, i; Bucket B; PtrToNode tmp, p, List = NULL; for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */ B\\[i\\].head = B\\[i\\].tail = NULL; for (i=0; i&lt;N; i++) { /* 将原始序列逆序存入初始链表List */ tmp = (PtrToNode)malloc(sizeof(struct Node)); tmp-&gt;key = A\\[i\\]; tmp-&gt;next = List; List = tmp; } /* 下面开始排序 */ for (D=1; D&lt;=MaxDigit; D++) { /* 对数据的每一位循环处理 */ /* 下面是分配的过程 */ p = List; while (p) { Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */ /* 从List中摘除 */ tmp = p; p = p-&gt;next; /* 插入B\\[Di\\]号桶尾 */ tmp-&gt;next = NULL; if (B\\[Di\\].head == NULL) B\\[Di\\].head = B\\[Di\\].tail = tmp; else { B\\[Di\\].tail-&gt;next = tmp; B\\[Di\\].tail = tmp; } } /* 下面是收集的过程 */ List = NULL; for (Di=Radix-1; Di&gt;=0; Di--) { /* 将每个桶的元素顺序收集入List */ if (B\\[Di\\].head) { /* 如果桶不为空 */ /* 整桶插入List表头 */ B\\[Di\\].tail-&gt;next = List; List = B\\[Di\\].head; B\\[Di\\].head = B\\[Di\\].tail = NULL; /* 清空桶 */ } } } /* 将List倒入A\\[\\]并释放空间 */ for (i=0; i&lt;N; i++) { tmp = List; List = List-&gt;next; A\\[i\\] = tmp-&gt;key; free(tmp); } } （2）主位优先C语言代码： / 基数排序 - 主位优先 // 假设元素最多有MaxDigit个关键字，基数全是同样的Radix / #define MaxDigit 4 #define Radix 10 / 桶元素结点 /typedef struct Node *PtrToNode;struct Node{ int key; PtrToNode next;}; / 桶头结点 /struct HeadNode { PtrToNode head, tail;};typedef struct HeadNode Bucket[Radix]; int GetDigit ( int X, int D ){ / 默认次位D=1, 主位D&lt;=MaxDigit / int d, i; for (i=1; i&lt;=D; i++) { d = X%Radix; X /= Radix; } return d; } void MSD( ElementType A[], int L, int R, int D ){ / 核心递归函数: 对A[L]…A[R]的第D位数进行排序 / int Di, i, j; Bucket B; PtrToNode tmp, p, List = NULL; if (D==0) return; / 递归终止条件 / for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */ B\\[i\\].head = B\\[i\\].tail = NULL; for (i=L; i&lt;=R; i++) { /* 将原始序列逆序存入初始链表List */ tmp = (PtrToNode)malloc(sizeof(struct Node)); tmp-&gt;key = A\\[i\\]; tmp-&gt;next = List; List = tmp; } /* 下面是分配的过程 */ p = List; while (p) { Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */ /* 从List中摘除 */ tmp = p; p = p-&gt;next; /* 插入B\\[Di\\]号桶 */ if (B\\[Di\\].head == NULL) B\\[Di\\].tail = tmp; tmp-&gt;next = B\\[Di\\].head; B\\[Di\\].head = tmp; } /* 下面是收集的过程 */ i = j = L; /* i, j记录当前要处理的A\\[\\]的左右端下标 */ for (Di=0; Di&lt;Radix; Di++) { /* 对于每个桶 */ if (B\\[Di\\].head) { /* 将非空的桶整桶倒入A\\[\\], 递归排序 */ p = B\\[Di\\].head; while (p) { tmp = p; p = p-&gt;next; A\\[j++\\] = tmp-&gt;key; free(tmp); } /* 递归对该桶数据排序, 位数减1 */ MSD(A, i, j-1, D-1); i = j; /* 为下一个桶对应的A\\[\\]左端 */ } } } void MSDRadixSort( ElementType A[], int N ){ / 统一接口 / MSD(A, 0, N-1, MaxDigit);} 10.4 排序算法的比较排序方法 平均时间复杂度 最坏情况下时间复杂度 额外空间复杂度 稳定性 简单选择排序 O(N2) O(N2) O(1) 不稳定 冒泡排序 O(N2) O(N2) O(1) 稳定 直接插入排序 O(N2) O(N2) O(1) 稳定 希尔排序 O(Nd) O(N2) O(1) 不稳定 堆排序 O(NlogN) O(NlogN) O(1) 不稳定 快速排序 O(NlogN) O(N2) O(logN) 不稳定 归并排序 O(NlogN) O(NlogN) O(N) 稳定 基数排序 O(P(N+B)) O(P(N+B)) O(N+B) 稳定 前三种排序算法的共同优点是算法编写简单。冒泡排序和直接插入排序每次都是交换两个元素，因此是慢的，但是它们稳定，简单选择排序是跳着交换，有可能不稳定。 希尔排序算法打破了N的平方的复杂度，它的好坏取决于d（增量序列），因为是跳着排的，所以它也是不稳定的。 堆排序和归并排序的时间复杂度是最好的，无论何时都是一样的。归并排序的缺点是它需要一个额外的空间，当数据量非常大的时候，只能排一半数据，但是它的优点是它是稳定的。堆排序理论上看很美，实际情况是虽然理论上是O(NlogN)，但是O这个常数会比较大，所以它到底跟快速排序哪个快，就难说了。堆排序和快速排序的共同缺点是不稳定，快速排序总可以构造一种最糟糕的情况是O(N2)，而且因为是递归的，所以额外空间是需要的，时间复杂度最好时，额外空间复杂度也是O(logN)。 基数排序在某种情况下，会打破NlogN的魔咒，会更快，近乎线性。它需要的额外空间是需要B个桶，每个桶设置B个数据的位置，所以到底什么情况下合算，看情况，它的好处是它是稳定的。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"数据结构【浙江大学】（第9节）整理","slug":"datastructure_chapter9","date":"2018-05-12T08:24:47.000Z","updated":"2019-03-21T14:52:02.928Z","comments":false,"path":"2018/05/12/datastructure_chapter9/","link":"","permalink":"http://tech.yushuai.xyz/2018/05/12/datastructure_chapter9/","excerpt":"","text":"第九节：排序（上）9.1 概述对于之后应用到的一些说明： （1）void X_Sort(ElementType A[], int N) X为排序名称。 ①大多数情况下，为了简单起见，讨论从小到大的整数排序。 ②默认N为正整数。 ③只讨论基于比较的排序（&gt;=&lt;都是有定义的）。 ④只讨论内部排序（一次性可以写入内存，然后只在内存里面的数据排序）。 ⑤稳定性：任意两个相等的数据，排序前后的相对位置不发生改变。 没有一种排序是任何情况下都表现最好的！！！ 9.2 简单排序算法9.2.1 冒泡排序在一次排序完成后，最后面的一定是最大的，第二次排序的时候只需要对前N-1个排序即可，然后N-2……一直到最后完成。 冒泡排序的伪码描述如下： void Bubble_Sort(ElementType A[], int N){ for(P=N-1;P&gt;=0;P–) { flag = 0; for(i=0;i&lt;P;i++) {/一趟冒泡/ if(A[i]&gt;A[i+1]) { Swap(A[i],A[i+1);] flag = 1;/标志发生了交换/ } } if(flag==0) break;/全程无交换，已经排好/ }} 最好情况：顺序T=O(N)；最差情况：逆序T=O(N2) 这个算法具有稳定性！ 9.2.2 插入排序类似于打扑克的时候拿到牌之后进行排序 。 源代码： void InsertionSort( ElementType A[], int N ){ / 插入排序 / int P, i; ElementType Tmp; for ( P=1; P&lt;N; P++ ) { Tmp = A\\[P\\]; /* 取出未排序序列中的第一个元素*/ for ( i=P; i&gt;0 &amp;&amp; A\\[i-1\\]&gt;Tmp; i-- ) A\\[i\\] = A\\[i-1\\]; /*依次与已排序序列中元素比较并右移*/ A\\[i\\] = Tmp; /* 放进合适的位置 */ } } 最好情况：顺序T=O(N) 最坏情况：逆序T=O (N2) 此方法也具有稳定性。 举例，问序列{34,8,64,51,32,21}中用插入排序和冒泡排序分别需要交换多少次？ 答：冒泡法：9次；插入法，9次。 它们的次数相等，是巧合还是必然？见下一节。 9.2.3 时间复杂度下界1.逆序对 对于下标i&lt;j，如果A[i]&gt;A[j]，则称(i,j)是一对逆序对（inversion）。 我们来看上一节中最后的序列{34,8,64,51,32,21}，它里面有多少逆序对呢？ (34,8)(34,42)(34,21)(64,51)(64,21)(64,21)(51,32)(51,21)(32,21) 一共9个逆序对。这说明，前面两种算法，交换2个相邻元素正好消去1个逆序对！ 插入排序时间复杂度：T(N,I)=O(N+I)。这里面N是元素个数，I是逆序对个数。这个可以这样理解，时间复杂度最低为元素个数N，即逆序对为0，也就是顺序排列情况下；然后随着多一个逆序对，复杂度加1。 如果序列基本有序，那么插入排序简单且高效。 2.定理1：任意N个不同元素组成的序列平均具有N(N-1)/4个逆序对。 3.定理2：任何仅以交换相邻两元素来排序的算法，其平均时间复杂度为Ω（N2）。（_注意：Ω是下界，O是上界）_ 这意味着，要提高算法效率，我们必须：每次消去不止1个逆序对！每次交换相隔较远的2个元素！ 9.3 希尔排序1.简单举例 它利用了插入排序的简单，同时克服了交换每次只交换相邻两个元素的缺点。 用下面这个序列来进行希尔排序的举例： 81 94 11 96 12 35 17 95 28 58 41 75 15 （1）首先以每5个元素取一个的规律进行排序：这里取了81、35、41。用插入排序对其进行排序： 35 94 11 96 12 41 17 95 28 58 81 75 15 然后取94、17、75进行插入排序，得到下面的结果： 35 17 11 96 12 41 75 95 28 58 81 94 15 然后考虑11、95、15，得到下面结果： 35 17 11 96 12 41 75 15 28 58 81 94 95 然后考虑96、28，得到下面结果： 35 17 11 28 12 41 75 15 96 58 81 94 95 然后考虑12和58： 35 17 11 28 12 41 75 15 96 58 81 94 95 （2）再用每3个元素取一个的规律进行排序：这里取35、28、75、58、95，结果如下： 28 12 11 35 15 41 58 17 94 75 81 96 95 （3）再做1间隔排序（即普通插入排序）。我们可以发现，此时整个序列已经基本有序，所以此时插入排序简单高效。 11 12 15 17 28 35 41 58 75 81 94 95 96 该算法的步骤： ①.定义增量序列DM&gt;DM-1&gt;…&gt;D1=1 ②对每个Dk进行“Dk-间隔”排序。 注意：“Dk-间隔”有序的序列，在执行“Dk-1-间隔”排序后，仍然是“Dk-间隔”有序的。 2.希尔增量序列 （1）原始希尔排序：DM=[N/2]，Dk=[Dk+1/2]。其中，[]代表取整。 伪代码如下： void Shell_Sort(ElementType A[], int N){ for(D=N/2;D&gt;0;D/=2) { for(P=D;P&lt;N;P++) { Tmp= A[P]; for(i=P;i&gt;=D&amp;&amp;A[i-D]&gt;Tmp;i-=D) A[i]=A[i-D]; A[i]=Tmp; } }} 最坏情况：T=θ(N2)（θ代表即使上界也是下界，即可以达到的值） 这种情况即，增量元素不互质，则小增量可能根本不起作用。 3.其它增量序列 （1）Hibbard增量序列：Dk=2k-1（相邻元素互质）。最坏情况：T=θ(N3/2)，猜想Tavg=O(N5/4)。 （2）Sedgewick增量序列：{1,5,19,41,109}（9×4i-9×2i+1或4i-3×2i+1），猜想Tavg=O(N7/6)，Tworst=O(N4/3)。 4.稳定性：不稳定。 9.4 堆排序9.4.1 选择排序void Selection_Sort(ElementType A[], int N){ for(i=0;i&lt;N;i++) { MinPosition = ScanForMin(A, i N-1); /从A[i]到A[N-1]中找最小元，并将其位置赋给MinPosition/ Swap(A[i], A[MinPosition]); /将未排序部分的最小元换到有序部份的最后位置/ }} 无论如何，T=θ(N2)。 如何快速寻找到最小元？见下一节。 9.4.2 堆排序（选择排序的改进）1.算法1： void Heap_Sort ( ElementType A[], int N ){ BuildHeap(A); /调整为最小堆，复杂度为O(N) / for ( i=0; i&lt;N; i++ ) TmpA[i] = DeleteMin(A); /以此把最小元弹出来放到这个临时数组中//复杂度为O(logN) / for ( i=0; i&lt;N; i++ )/ O(N) / A[i] = TmpA[i];/把临时数组的数组返回原来的数组/} 时间复杂度：T(N)=O(NlogN) 缺点：需要额外O(N)空间，并且复制元素需要时间。 2.算法2： 注意，在堆排序里面的这个堆，元素是从0的位置开始的；原来学堆的时候，0是用来放哨兵的。 因此，在堆排序中，元素下标从0开始。则对于下标为i的元素，其左、右孩子的下标分别为：**2i+1**, **2i+2**。 伪码描述如下： void Heap_Sort ( ElementType A[], int N ){ for ( i=N/2-1; i&gt;=0; i– )/ BuildHeap / PercDown( A, i, N ); for ( i=N-1; i&gt;0; i– ) { Swap( &amp;A[0], &amp;A[i] ); / DeleteMax / PercDown( A, 0, i ); }} 定理：堆排序处理N个不同元素的随机排列的平均比较次数是2NlogN-O(Nlog logN)。 注意：虽然堆排序给出最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。 整体C语言源代码： void Swap( ElementType *a, ElementType *b ){ ElementType t = *a; *a = *b; *b = t;} void PercDown( ElementType A[], int p, int N ){ / 改编代码4.24的PercDown( MaxHeap H, int p ) / / 将N个元素的数组中以A[p]为根的子堆调整为最大堆 / int Parent, Child; ElementType X; X = A\\[p\\]; /* 取出根结点存放的值 */ for( Parent=p; (Parent*2+1)&lt;N; Parent=Child ) { Child = Parent * 2 + 1; if( (Child!=N-1) &amp;&amp; (A\\[Child\\]&lt;A\\[Child+1\\]) ) Child++; /* Child指向左右子结点的较大者 */ if( X &gt;= A\\[Child\\] ) break; /* 找到了合适位置 */ else /* 下滤X */ A\\[Parent\\] = A\\[Child\\]; } A\\[Parent\\] = X; } void HeapSort( ElementType A[], int N ){ / 堆排序 / int i; for ( i=N/2-1; i&gt;=0; i-- )/* 建立最大堆 */ PercDown( A, i, N ); for ( i=N-1; i&gt;0; i-- ) { /* 删除最大堆顶 */ Swap( &amp;A\\[0\\], &amp;A\\[i\\] ); /* 见代码7.1 */ PercDown( A, 0, i ); } } 9.5 归并排序9.5 1有序子列的归并1.举例：假设我们有两个有序序列如下： 1 13 24 26 2 15 27 38 我们要将它们合并成一个序列并按照顺序排序。我们需要设置三个指针，如图1所示。Aptr指向A序列的第一个元素（1），Bptr指向B序列的第一个元素（2），Cptr指向合并后的第一个元素。这里的指针其实是三个整数，分别存储的三个元素的下标。首先比较Aptr和Bptr指向的元素那个比较小，选择比较小的放入Cptr所代表的下标的那个位置。然后将Aptr加1，Cptr加1，用Bptr所代表的的下标的元素和Aptr所代表的的下标的元素比较，发现Bptr下标的元素（2）小，将2存入Cptr代表下标的元素，即C[Cptr]。然后依次类推。 图1 时间复杂度T(N)=O(N)。 伪代码描述如下： / L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置 /void Merge( ElementType A[], ElementType TmpA[], int L, int R, int RightEnd ){ LeftEnd = R - 1; / 左边终点位置。假设左右两列挨着 / Tmp = L; / 存放结果的数组的初始位置 / NumElements = RightEnd - L + 1; while( L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd ) { if( A[L] &lt;= A[R] ) TmpA[Tmp++] = A[L++]; else TmpA[Tmp++] = A[R++]; } while( L &lt;= LeftEnd ) / 直接复制左边剩下的 / TmpA[Tmp++] = A[L++]; while( R &lt;= RightEnd ) /直接复制右边剩下的 / TmpA[Tmp++] = A[R++]; for(i=0;i&lt;NumElements;i++,RightEnd–) A[RightEnd] = TmpA[RightEnd];} 9.5.2递归算法1.分而治之 如图2所示，该算法是稳定的。 图2 伪码描述如下： void MSort( ElementType A[], ElementType TmpA[], int L, int RightEnd ){ int Center; if ( L &lt; RightEnd ) { Center = ( L + RightEnd ) / 2; MSort( A, TmpA, L, Center ); MSort( A, TmpA, Center+1, RightEnd ); Merge( A, TmpA, L, Center+1, RightEnd ); }} 时间复杂度为：**T(N)=T(N/2)+T(N/2)+O(N)，即T(N)=O(NlogN)。** 2.统一函数接口 为了与前面的函数接口统一，因此我们需要再写一个函数来统一函数接口。其伪码描述如下： void Merge_sort( ElementType A[], int N ){ ElementType TmpA; TmpA = malloc( N sizeof( ElementType ) ); if ( TmpA != NULL ) { MSort( A, TmpA, 0, N-1 ); free( TmpA ); } else Error( “空间不足” );} 如果只在Merge中声明临时数组，那么两个子函数声明如下： void Merge( ElementType A[], int L, int R, int RightEnd ) void MSort( ElementType A[], int L, int RightEnd ) 这样也不是不行，但是这样的话，**每一次在子函数里面用一次释放一次，增加了时间复杂度，还不如直接在最外层的代码里面定义好。** 整体的源代码实现如下： / 归并排序 - 递归实现 / / L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置/void Merge( ElementType A[], ElementType TmpA[], int L, int R, int RightEnd ){ / 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 / int LeftEnd, NumElements, Tmp; int i; LeftEnd = R - 1; /* 左边终点位置 */ Tmp = L; /* 有序序列的起始位置 */ NumElements = RightEnd - L + 1; while( L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd ) { if ( A\\[L\\] &lt;= A\\[R\\] ) TmpA\\[Tmp++\\] = A\\[L++\\]; /* 将左边元素复制到TmpA */ else TmpA\\[Tmp++\\] = A\\[R++\\]; /* 将右边元素复制到TmpA */ } while( L &lt;= LeftEnd ) TmpA\\[Tmp++\\] = A\\[L++\\]; /* 直接复制左边剩下的 */ while( R &lt;= RightEnd ) TmpA\\[Tmp++\\] = A\\[R++\\]; /* 直接复制右边剩下的 */ for( i = 0; i &lt; NumElements; i++, RightEnd -- ) A\\[RightEnd\\] = TmpA\\[RightEnd\\]; /* 将有序的TmpA\\[\\]复制回A\\[\\] */ } void Msort( ElementType A[], ElementType TmpA[], int L, int RightEnd ){ / 核心递归排序函数 / int Center; if ( L &lt; RightEnd ) { Center = (L+RightEnd) / 2; Msort( A, TmpA, L, Center ); /* 递归解决左边 */ Msort( A, TmpA, Center+1, RightEnd ); /* 递归解决右边 */ Merge( A, TmpA, L, Center+1, RightEnd ); /* 合并两段有序序列 */ } } void MergeSort( ElementType A[], int N ){ / 归并排序 / ElementType TmpA; TmpA = (ElementType )malloc(N*sizeof(ElementType)); if ( TmpA != NULL ) { Msort( A, TmpA, 0, N-1 ); free( TmpA ); } else printf( &quot;空间不足&quot; ); } 9.5.3 非递归算法非递归算法的图示如图3所示。 图3 额外空间复杂度是O(N)。我们只需要开一个临时数组就可以了，没必要每次都开一个。 其伪码描述如下： void Merge_pass( ElementType A[], ElementType TmpA[], int N,int length ) / length = 当前有序子列的长度/{ for ( i=0; i &lt;= N–2*length; i += 2*length ) Merge1( A, TmpA, i, i+length, i+2length–1 ); if ( i+length &lt; N ) / 归并最后2个子列/ Merge1( A, TmpA, i, i+length, N–1); else / 最后只剩1个子列*/ for ( j = i; j &lt; N; j++ ) TmpA[j] = A[j];} 统一接口如下： void Merge_sort( ElementType A[], int N ){ int length = 1; / 初始化子序列长度/ ElementType TmpA; TmpA = malloc( N sizeof( ElementType ) ); if ( TmpA != NULL ) { while( length &lt; N ) { Merge_pass( A, TmpA, N, length ); length = 2; Merge_pass( TmpA, A, N, length ); length = 2; } free( TmpA ); } else Error( “空间不足” );} 具有稳定性！ 缺点是需要额外空间之类的~此方法主要用在外排序。 C语言实现源代码： / 归并排序 - 循环实现 // 这里Merge函数在递归版本中给出 / / length = 当前有序子列的长度/void Merge_pass( ElementType A[], ElementType TmpA[], int N, int length ){ / 两两归并相邻有序子列 / int i, j; for ( i=0; i &lt;= N-2\\*length; i += 2\\*length ) Merge( A, TmpA, i, i+length, i+2*length-1 ); if ( i+length &lt; N ) /* 归并最后2个子列*/ Merge( A, TmpA, i, i+length, N-1); else /* 最后只剩1个子列*/ for ( j = i; j &lt; N; j++ ) TmpA\\[j\\] = A\\[j\\]; } void Merge_Sort( ElementType A[], int N ){ int length; ElementType *TmpA; length = 1; /* 初始化子序列长度*/ TmpA = malloc( N * sizeof( ElementType ) ); if ( TmpA != NULL ) { while( length &lt; N ) { Merge_pass( A, TmpA, N, length ); length *= 2; Merge_pass( TmpA, A, N, length ); length *= 2; } free( TmpA ); } else printf( &quot;空间不足&quot; ); }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"数据结构【浙江大学】（第8节）整理","slug":"datastructure_chapter8","date":"2018-05-12T08:21:31.000Z","updated":"2019-03-21T14:52:06.642Z","comments":false,"path":"2018/05/12/datastructure_chapter8/","link":"","permalink":"http://tech.yushuai.xyz/2018/05/12/datastructure_chapter8/","excerpt":"","text":"第八讲：图（下）8.1 最小生成树问题8.1.1 最小生成树（Minimum Spanning Tree） 如图1所示。 图1 它是一棵树：无回路；|V|个顶点一定有|V|-1条边； 它是生成树：包含全部顶点；|V|-1条边都在图里。在图1中，第2/3/4个图都是图1的生成树，可以看出，生成树中任加一条边都一定构成回路。 最小：边的权重和最小。 显然可以得出，最小生成树存在图连通。 8.1.2 贪心算法 贪：每一步都要最好的。好：权重最小的边。 需要约束：只能用图里有的边；只能正好用掉|V|-1条边；不能有回路。 8.1.3 Prim算法（密集图）—让一棵小树长大 如图2所示，我们选择v1作为源节点，选择权重最小的（为1），到v4；然后我们看这个图，权重最小的为2有两个边，分别到v2和v3，我们先选择连到v2，再用v4连接到v3；为了不构成回路，我们需要选择权重为4的由v4到v7的边；再选择权重为1的v6，再选择权重为6的v5。 图2 其伪码描述如下，其中dist[V]=E(s,v)或正无穷，parent[s]=-1： void Prim(){ MST={s}; while(1){ V=未收录顶点中dist最小者; if(V不存在) break; 将V收录进MST,dist[V]=0; for(V的每一个邻接点W) if(dist[W]!=0)/即这个点未被收入/ if(E[V,W]&lt;dist[W]){ dist[W]=E[V,W]; parent[W]=v; } } if(MST中收的顶点不到|V|个) Error(“生成树不存在”);} 完整代码： / 邻接矩阵存储 - Prim最小生成树算法 / Vertex FindMinDist( MGraph Graph, WeightType dist[] ){ / 返回未被收录顶点中dist最小者 / Vertex MinV, V; WeightType MinDist = INFINITY; for (V=0; V&lt;Graph-&gt;Nv; V++) { if ( dist\\[V\\]!=0 &amp;&amp; dist\\[V\\]&lt;MinDist) { /* 若V未被收录，且dist\\[V\\]更小 */ MinDist = dist\\[V\\]; /* 更新最小距离 */ MinV = V; /* 更新对应顶点 */ } } if (MinDist &lt; INFINITY) /* 若找到最小dist */ return MinV; /* 返回对应的顶点下标 */ else return ERROR; /* 若这样的顶点不存在，返回-1作为标记 */ } int Prim( MGraph Graph, LGraph MST ){ / 将最小生成树保存为邻接表存储的图MST，返回最小权重和 / WeightType dist[MaxVertexNum], TotalWeight; Vertex parent[MaxVertexNum], V, W; int VCount; Edge E; /* 初始化。默认初始点下标是0 */ for (V=0; V&lt;Graph-&gt;Nv; V++) { /* 这里假设若V到W没有直接的边，则Graph-&gt;G\\[V\\]\\[W\\]定义为INFINITY */ dist\\[V\\] = Graph-&gt;G\\[0\\]\\[V\\]; parent\\[V\\] = 0; /* 暂且定义所有顶点的父结点都是初始点0 */ } TotalWeight = 0; /* 初始化权重和 */ VCount = 0; /* 初始化收录的顶点数 */ /* 创建包含所有顶点但没有边的图。注意用邻接表版本 */ MST = CreateGraph(Graph-&gt;Nv); E = (Edge)malloc( sizeof(struct ENode) ); /* 建立空的边结点 */ /* 将初始点0收录进MST */ dist\\[0\\] = 0; VCount ++; parent\\[0\\] = -1; /* 当前树根是0 */ while (1) { V = FindMinDist( Graph, dist ); /* V = 未被收录顶点中dist最小者 */ if ( V==ERROR ) /* 若这样的V不存在 */ break; /* 算法结束 */ /* 将V及相应的边&lt;parent\\[V\\], V&gt;收录进MST */ E-&gt;V1 = parent\\[V\\]; E-&gt;V2 = V; E-&gt;Weight = dist\\[V\\]; InsertEdge( MST, E ); TotalWeight += dist\\[V\\]; dist\\[V\\] = 0; VCount++; for( W=0; W&lt;Graph-&gt;Nv; W++ ) /* 对图中的每个顶点W */ if ( dist\\[W\\]!=0 &amp;&amp; Graph-&gt;G\\[V\\]\\[W\\]&lt;INFINITY ) { /* 若W是V的邻接点并且未被收录 */ if ( Graph-&gt;G\\[V\\]\\[W\\] &lt; dist\\[W\\] ) { /* 若收录V使得dist\\[W\\]变小 */ dist\\[W\\] = Graph-&gt;G\\[V\\]\\[W\\]; /* 更新dist\\[W\\] */ parent\\[W\\] = V; /* 更新树 */ } } } /* while结束*/ if ( VCount &lt; Graph-&gt;Nv ) /* MST中收的顶点不到|V|个 */ TotalWeight = ERROR; return TotalWeight; /* 算法执行完毕，返回最小权重和或错误标记 */ } 8.1.4 Kruskal算法（稀疏图）—将森林合并成树 寻找权重最短的边，初始的情况下认为每一个顶点都是一棵树，通过不断把边收进来，就把两棵树并成了一棵树，最后把所有节点并成一棵树。 伪码如下： void Kruskal(Graph G){ MST = {}; while(MST中不到|V-1|条边&amp;&amp;E中还有边){ 从E中去一条权重最小的边E)(V,W);/最小堆/ 将E(V,W)从E中删除; if(E(V,W)不在MST中构成回路)/并查集/ 将E(V,W)加入MST; else 彻底无视E(V,W); } if(MST中不到|V|-1条边) ERROR(“生成树不存在”);} 复杂度为T=O(|E|log|E|) 完整代码： / 邻接表存储 - Kruskal最小生成树算法 / /——————– 顶点并查集定义 ——————–/typedef Vertex ElementType; / 默认元素可以用非负整数表示 /typedef Vertex SetName; / 默认用根结点的下标作为集合名称 /typedef ElementType SetType[MaxVertexNum]; / 假设集合元素下标从0开始 / void InitializeVSet( SetType S, int N ){ / 初始化并查集 / ElementType X; for ( X=0; X&lt;N; X++ ) S\\[X\\] = -1; } void Union( SetType S, SetName Root1, SetName Root2 ){ / 这里默认Root1和Root2是不同集合的根结点 / / 保证小集合并入大集合 / if ( S[Root2] &lt; S[Root1] ) { / 如果集合2比较大 / S[Root2] += S[Root1]; / 集合1并入集合2 / S[Root1] = Root2; } else { / 如果集合1比较大 / S[Root1] += S[Root2]; / 集合2并入集合1 / S[Root2] = Root1; }} SetName Find( SetType S, ElementType X ){ / 默认集合元素全部初始化为-1 / if ( S[X] &lt; 0 ) / 找到集合的根 / return X; else return S[X] = Find( S, S[X] ); / 路径压缩 /} bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 ){ / 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 / Vertex Root1, Root2; Root1 = Find( VSet, V1 ); /* 得到V1所属的连通集名称 */ Root2 = Find( VSet, V2 ); /* 得到V2所属的连通集名称 */ if( Root1==Root2 ) /* 若V1和V2已经连通，则该边不能要 */ return false; else { /* 否则该边可以被收集，同时将V1和V2并入同一连通集 */ Union( VSet, Root1, Root2 ); return true; } }/——————– 并查集定义结束 ——————–/ /——————– 边的最小堆定义 ——————–/void PercDown( Edge ESet, int p, int N ){ / 改编代码4.24的PercDown( MaxHeap H, int p ) / / 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 / int Parent, Child; struct ENode X; X = ESet\\[p\\]; /* 取出根结点存放的值 */ for( Parent=p; (Parent*2+1)&lt;N; Parent=Child ) { Child = Parent * 2 + 1; if( (Child!=N-1) &amp;&amp; (ESet\\[Child\\].Weight&gt;ESet\\[Child+1\\].Weight) ) Child++; /* Child指向左右子结点的较小者 */ if( X.Weight &lt;= ESet\\[Child\\].Weight ) break; /* 找到了合适位置 */ else /* 下滤X */ ESet\\[Parent\\] = ESet\\[Child\\]; } ESet\\[Parent\\] = X; } void InitializeESet( LGraph Graph, Edge ESet ){ / 将图的边存入数组ESet，并且初始化为最小堆 / Vertex V; PtrToAdjVNode W; int ECount; /* 将图的边存入数组ESet */ ECount = 0; for ( V=0; V&lt;Graph-&gt;Nv; V++ ) for ( W=Graph-&gt;G\\[V\\].FirstEdge; W; W=W-&gt;Next ) if ( V &lt; W-&gt;AdjV ) { /* 避免重复录入无向图的边，只收V1&lt;V2的边 */ ESet\\[ECount\\].V1 = V; ESet\\[ECount\\].V2 = W-&gt;AdjV; ESet\\[ECount++\\].Weight = W-&gt;Weight; } /* 初始化为最小堆 */ for ( ECount=Graph-&gt;Ne/2; ECount&gt;=0; ECount-- ) PercDown( ESet, ECount, Graph-&gt;Ne ); } int GetEdge( Edge ESet, int CurrentSize ){ / 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 / /* 将最小边与当前堆的最后一个位置的边交换 */ Swap( &amp;ESet\\[0\\], &amp;ESet\\[CurrentSize-1\\]); /* 将剩下的边继续调整成最小堆 */ PercDown( ESet, 0, CurrentSize-1 ); return CurrentSize-1; /* 返回最小边所在位置 */ }/——————– 最小堆定义结束 ——————–/ int Kruskal( LGraph Graph, LGraph MST ){ / 将最小生成树保存为邻接表存储的图MST，返回最小权重和 / WeightType TotalWeight; int ECount, NextEdge; SetType VSet; / 顶点数组 / Edge ESet; / 边数组 / InitializeVSet( VSet, Graph-&gt;Nv ); /* 初始化顶点并查集 */ ESet = (Edge)malloc( sizeof(struct ENode)*Graph-&gt;Ne ); InitializeESet( Graph, ESet ); /* 初始化边的最小堆 */ /* 创建包含所有顶点但没有边的图。注意用邻接表版本 */ MST = CreateGraph(Graph-&gt;Nv); TotalWeight = 0; /* 初始化权重和 */ ECount = 0; /* 初始化收录的边数 */ NextEdge = Graph-&gt;Ne; /* 原始边集的规模 */ while ( ECount &lt; Graph-&gt;Nv-1 ) { /* 当收集的边不足以构成树时 */ NextEdge = GetEdge( ESet, NextEdge ); /* 从边集中得到最小边的位置 */ if (NextEdge &lt; 0) /* 边集已空 */ break; /* 如果该边的加入不构成回路，即两端结点不属于同一连通集 */ if ( CheckCycle( VSet, ESet\\[NextEdge\\].V1, ESet\\[NextEdge\\].V2 )==true ) { /* 将该边插入MST */ InsertEdge( MST, ESet+NextEdge ); TotalWeight += ESet\\[NextEdge\\].Weight; /* 累计权重 */ ECount++; /* 生成树中边数加1 */ } } if ( ECount &lt; Graph-&gt;Nv-1 ) TotalWeight = -1; /* 设置错误标记，表示生成树不存在 */ return TotalWeight; } 8.2 拓扑排序8.2.1 拓扑排序 AOV（Activity On Vertex）网络 如图3所示，是指所有的真实活动是表现在顶点上的，顶点与顶点之间的有向边表现了顶点间的先后顺序。 图3 所谓拓扑序是指：如果图中从V到W有一条有向路径，则V一定排在W之前，满足此条件的顶点序列称为一个拓扑序。获得一个拓扑序的过程就是拓扑排序。 AOV网络如果有合理（所谓不合理是指，网络形成了一个环，那就代表着V必须在V开始之前结束，自然不合理）的拓扑序，则必定是有向无环图（Directed Acyclic Graph, DAG）。 所谓拓扑排序，就是每一次输出没有前序顶点的顶点。 伪码描述如下： void TopSort(){ for(cnt=0;cnt&lt;|V|;cnt++){ v = 为输出的入度为0的顶点;/简单粗暴法此步O(|V|)，总为O(|V|2)/ /聪明的算法如下文所述/ if(这样的V不存在_{ Error(“图中有回路”); break; } 输出V，或者记录V的输出序号; for(V的每个邻接点W) Indegree\\[W\\]--; } } 聪明的算法：随时将入度变为0的顶点放到一个容器（数组、堆栈、队列等都行）中，下一次直接从这里面直接拿数据就可以了。利用队列的新的伪码描述： void TopSort(){ for(图中每个顶点V){ if(Indegree[V]==0) Enqueue(V,Q); } while(!IsEmpty(Q){ V=Dequeue(Q); 输出V，或者记录V的输出序号;cnt++; for(V的每个邻接点W) { if(–Indegree[W]==0) Enqueue(W,Q); } } if(cnt!=|V|) Error(“图中有回路”);} 时间复杂度T=O(|V|+|E|) 完整代码： / 邻接表存储 - 拓扑排序算法 / bool TopSort( LGraph Graph, Vertex TopOrder[] ){ / 对Graph进行拓扑排序, TopOrder[]顺序存储排序后的顶点下标 / int Indegree[MaxVertexNum], cnt; Vertex V; PtrToAdjVNode W; Queue Q = CreateQueue( Graph-&gt;Nv ); /* 初始化Indegree\\[\\] */ for (V=0; V&lt;Graph-&gt;Nv; V++) Indegree\\[V\\] = 0; /* 遍历图，得到Indegree\\[\\] */ for (V=0; V&lt;Graph-&gt;Nv; V++) for (W=Graph-&gt;G\\[V\\].FirstEdge; W; W=W-&gt;Next) Indegree\\[W-&gt;AdjV\\]++; /* 对有向边&lt;V, W-&gt;AdjV&gt;累计终点的入度 */ /* 将所有入度为0的顶点入列 */ for (V=0; V&lt;Graph-&gt;Nv; V++) if ( Indegree\\[V\\]==0 ) AddQ(Q, V); /* 下面进入拓扑排序 */ cnt = 0; while( !IsEmpty(Q) ){ V = DeleteQ(Q); /* 弹出一个入度为0的顶点 */ TopOrder\\[cnt++\\] = V; /* 将之存为结果序列的下一个元素 */ /* 对V的每个邻接点W-&gt;AdjV */ for ( W=Graph-&gt;G\\[V\\].FirstEdge; W; W=W-&gt;Next ) if ( --Indegree\\[W-&gt;AdjV\\] == 0 )/* 若删除V使得W-&gt;AdjV入度为0 */ AddQ(Q, W-&gt;AdjV); /* 则该顶点入列 */ } /* while结束*/ if ( cnt != Graph-&gt;Nv ) return false; /* 说明图中有回路, 返回不成功标志 */ else return true; } 8.2.2 关键路径 AOE（Activity On Edge）网络一般用于安排项目的工序。与AOV不同，AOE的活动表示在边上，而节点代表活动到此结束。一般情况下，AOE网络的图示为以下结构： 图4 如图5所示，图中虚线，且权重为0表示的是，要继续执行9/7权重那里，4/5这里必须都得走到了。 图5 问题1：整个工期有多长？ Earliest[0]=0; Earliest[j]=max(&lt;i,j&gt;∈E){Earliest[i]+C&lt;i,j&gt;} 故Earliest[8]=18 问题2：哪几个组有机动时间（保证工期最长18天）？ 方法是设置最后一个最晚完成时间为18天，然后往前推。 注意：虽然7倒推回去5只需要在第10天完工就可以，但是考虑到4必须在第7天完工，而6必须在第16天完工，又由于4、5同时完工才能往下走，所以5的最晚完成时间也必须和4同样，为第7天。 Latest[8]=18; Latest[i]=(min&lt;i,j&gt;∈E){Latest[j]-C&lt;i,j&gt;} 所谓机动时间就是哪些组可以不用急着赶工 机动时间D&lt;i,j&gt;=Latest[j]-Earliest[i]-C&lt;i,j&gt; 所谓关键路径就是整个流程中最需要关注的地方，哪些步骤是一点也不能耽误的，只要它耽误了，整个流程都要耽误，所以它是绝对不允许延误的活动组成的路径。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"数据结构【浙江大学】（第7节）整理","slug":"datastructure_chapter7","date":"2018-05-09T12:48:36.000Z","updated":"2019-03-21T14:51:19.166Z","comments":false,"path":"2018/05/09/datastructure_chapter7/","link":"","permalink":"http://tech.yushuai.xyz/2018/05/09/datastructure_chapter7/","excerpt":"","text":"第七节：最短路径问题7.1 概述 最短路径问题的抽象： 在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径。这条路径就是两点之间的最短路径。第一个顶点称为源点，最后一个顶点为终点。 问题分类： （1）单源最短路径问题：从某固定源点触发，求其到所有其他顶点的最短路径。又分为（有无向）有权图和（有无向）无权图两种。 （2）多源最短路径问题：求任意两顶点间的最短路径。 7.2 无权图的单源最短路 按照递增（非递减）的顺序找出到各个顶点的最短路。例如图1： 图1 我们以v3作为源点，与v3距离为0的点为v3；与v3距离为1的点为v1和v6；与v3距离为2的点（也就是距离v1为1，距离v6为1）的点为v2和v4；距离v3距离为3的点（也就是距离v2为1，距离v4为1）的点为v5和v7。至此，距离各点距离v3都已经清楚。 这个算法类似于BFS算法。但是与BFS不同的是，我们不需要定义一个已经访问的变量，需要重新定义一个数组为 （1）dist[W]=S到W的最短距离。初始情况下，默认距离可以为-1、负无穷或者正无穷。 （2）dist[S]=0 （3）path[W]=S到W的路上经过的某顶点。 代码如下： void Unweighted(Vertex S){ Enqueue(S,Q); while(!IsEmpty(Q)){ V = Dequeue(Q); for(V的每个邻接点W) if(dist[W]==-1){ dist[W]=dist[V]+1; path[W]=V; Enqueue(W,Q); } }} path这个数组的作用就是记录从S到W路径中所经过的点，这个算法就是利用刚刚讲的那个每次基于前面那个点加1来得到下面一个点的这个方法。 时间复杂度为T=O(|V|+|E|)。看这个代码中while的部分，由于它都Dequeue和Enqueue了一次，所以总的次数为2V；又由于for循环遍历了V的每个邻接点W，个数为E，所以时间复杂度是O(|V|+|E|)。 7.3 无权图的单源最短路示例 这里，我们以图1中的图来做示例，仍将v3看做是源点，因此，dist和path做以下初始化： 下标W 1 2 3 4 5 6 7 dist -1 -1 0 -1 -1 -1 -1 path -1 -1 -1 -1 -1 -1 -1 调用Unweighted(3)，然后将v3入队列。然后while循环，判断队列不为空，让v3出队列给V。然后开始for循环，对于V（即v3）的每个邻接点W，如果这个点没有访问过（即该点的dist[W]==-1），则将该点的dist赋值为前一点的dist+1（刚开始的时候前一点的dist为0），然后把前一点（刚开始是v3）赋值给path的第w个值，然后把下一个点压入队列。然后把v1压出，开始for循环，对于V（即v1）的每个邻接点，再进行上面的操作，如此循环直到最后。到最后的时候，dist和path数值为： 下标W 1 2 3 4 5 6 7 dist 1 2 0 2 3 1 3 path 3 1 -1 1 2 3 4 具体代码： / 邻接表存储 - 无权图的单源最短路算法 / / dist[]和path[]全部初始化为-1 /void Unweighted ( LGraph Graph, int dist[], int path[], Vertex S ){ Queue Q; Vertex V; PtrToAdjVNode W; Q = CreateQueue( Graph-&gt;Nv ); /* 创建空队列, MaxSize为外部定义的常数 */ dist\\[S\\] = 0; /* 初始化源点 */ AddQ (Q, S); while( !IsEmpty(Q) ){ V = DeleteQ(Q); for ( W=Graph-&gt;G\\[V\\].FirstEdge; W; W=W-&gt;Next ) /* 对V的每个邻接点W-&gt;AdjV */ if ( dist\\[W-&gt;AdjV\\]==-1 ) { /* 若W-&gt;AdjV未被访问过 */ dist\\[W-&gt;AdjV\\] = dist\\[V\\]+1; /* W-&gt;AdjV到S的距离更新 */ path\\[W-&gt;AdjV\\] = V; /* 将V记录在S到W-&gt;AdjV的路径上 */ AddQ(Q, W-&gt;AdjV); } } /* while结束*/ } 7.4 有权图的单源最短路 仍然是按照递增的顺序找出到各个顶点的最短路。解决这个问题的经典算法就是：Dijkstra算法。 （1）Dijkstra算法 ①令S={源点s+已经确定了最短路径的顶点vi} ②对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过S中的顶点，即路径{s-&gt;(vi∈S)-&gt;v}的最小长度。 若路径是按照递增（非递减）的顺序生成的，则： 真正的最短路径必须只经过s中的顶点； 每次从未收录的顶点中选一个dist最小的收录（贪心算法） 增加一个v进入S，可能影响另外一个w的dist值（若使w的dist值缩小，则v必定在s到w的路径上，并且v到w有一条边），dist[w]=min{dist[w],dist[v]+&lt;v,w&gt;的权重}。代码如下： void Dijkstra(Vertex s){ while(1){ V=未收录顶点中dist最小者; if(这样的V不存在) break; collected[V] = true; for(V的每个邻接点W） if(collected[W] == false) if(dist[V]+E&lt;k,w&gt; &lt; dist[W]) { dist[W] = dist[V] +E&lt;v,w&gt;; path[W] =V; } }} 注意：该算法不能解决有负边的情况。 若只看这段伪码，我们无法判断其复杂度，这主要是因为未收录顶点中dist最小者的这个算法的复杂度我们无法判断。这个算法有以下几种： ①直接扫描所有未收录顶点-O(|V|)，则T=O(|V|2+|E|)。对稠密图效果好。 ②将dist存在最小堆中-O(log|V|)。更新dist[w]的值-O(log|V|)。总体复杂度为T=O(|V|log|V|+|E|log|V|)=O(|E|log|V|)。对稀疏图效果好。 7.5 有权图的单源最短路示例 图如图2所示。 图2 这里我们以v1位源点。dist和path初始化结果如下所示： 下标W 1 2 3 4 5 6 7 dist 0 2 无穷 1 无穷 无穷 无穷 path -1 1 -1 1 -1 -1 -1 当首先访问v4的时候，结果如下 下标W 1 2 3 4 5 6 7 dist 0 2 3 1 3 9 5 path -1 1 4 1 4 4 4 然后看v2，由于v4已经访问过了，因此接下来看v5，由于到v5的距离为12，大于前面的距离，因此跳出循环。由于v2的邻接点只有v4和和v5，因此跳出v2。 接下来看v3和v5距离一样，那么就先看v3。v3的邻接点有v1和v6，v1已经被访问过，所以无视，直接看v6，此时可以看出v3到v6距离为5，所以总距离为8，小于原来的9。因此更新dis[6]=9，path[6]=3。然后看v5，v5只有一个邻接点，就是v7，这样经过v5到v7的距离为9，大于原来的距离，不更新。 在v6和v7中，v7的距离更短一点，所以先看v7。v7的邻接点只有v6。若经过v7访问v6的距离为6，小于原来的8，更新dis[6]=6，path[6]=7。 由于v6没有任何邻接点，所以v6直接不做判断。最后更新的结果如下： 下标W 1 2 3 4 5 6 7 dist 0 2 3 1 3 6 5 path -1 1 4 1 4 7 4 7.6 多源最短路算法 方法1：直接将单源最短路算法调用|V|遍，T=O(|V|3+|E|×|V|)，适合稀疏图。 方法2：Floyd算法，复杂度T=O(|V|3)，更适合稠密图。 （1）Floyd算法 ①Dk[i][j]=路径{i-&gt;{l&lt;=k}-&gt;j}的最小长度。 ②D0,D1,…,D[V]-1[i][j]即给出了i到j的真正最短距离。 ③最初的D-1是带权的邻接矩阵，对角元素是0。 ④若i和j之间没有直接的边，D[i][j]定义为正无穷。 ⑤当Dk-1已经完成，递推到Dk时： 或者k∉最短路径{i-&gt;{l&lt;=k}-&gt;j}，则Dk=Dk-1； 或者k∈{i-&gt;{l&lt;=k}-&gt;j}，则该路径必定由两段最短距离组成：Dk [i][j]= Dk-1[i][k]+ Dk-1[k][j]。 源代码为： void Floyd(){ for(i=0;i&lt;N;i++) for(j=0lj&lt;N;j++){ D[i][j]=G[i][j]; path[i][j]=-1; } for(k=0;k&lt;N;k++) for(i=0;i&lt;N;i++) if(D[i][k]+D[k][j]&lt;D[i][j]) { D[i][j]=D[i][k]+D[k][j]; path[i][j]=k; }}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"数据结构【浙江大学】（第6节）整理","slug":"datastructure_chapter6","date":"2018-04-26T05:01:39.000Z","updated":"2019-03-21T14:51:23.408Z","comments":false,"path":"2018/04/26/datastructure_chapter6/","link":"","permalink":"http://tech.yushuai.xyz/2018/04/26/datastructure_chapter6/","excerpt":"","text":"第六节：图（上）6.1 图1.关于图 图表示的是“多对多”的关系。它包含： （1）一组顶点：通常用V（Vertex）表示顶点集合。 （2）一组边：通常用E（Edge）表示边的集合，表示顶点与顶点的关系： ①边是顶点对：(v,w)∈E，其中v,w∈V。这是一个双向的。 ②有向边：&lt;v,w&gt;，表示从v指向w的边（单行线）。 ③不考虑重边和自回路。 其抽象数据类型为： 类型名称：图（Graph） 数据对象集：一非空的顶点集合Vertex和一个边集合Edge，每条边用对应的一对顶点表示。 操作集：对于任意的图G Î Graph，顶点v、v1和v2 Î ertex，以及任一访问顶点的函数visit()，操作举例： Graph Create( )：构造并返回一个空图； void Destroy( Graph G )：释放图G占用的存储空间； Graph InsertVertex( Graph G, Vertex v )：返回一个在G中增加了新顶点v的图 Graph InsertEdge( Graph G, Vertex v1, Vertex v2 )：返回一个在G中增加了新边 (v1, v2) 的图； Graph DeleteVertex( Graph G, Vertex v )：删除G中顶点v及其相关边，将结果图返回； Graph DFS（ Graph G, Vertex v, visit()）：在图G中，从顶点v出发进行深度优先遍历； 图的一些分类： （1）无向图。边（v, w）等同于边（w, v）。用圆括号“（）”表示无向边。 （2）有向图（Directed Graphs）: 边&lt;v, w&gt;不同于边&lt;w, v&gt;。用尖括号“&lt; &gt;”表示有向边；有向边也称“弧（Arc）”。 （3）简单图（Simple Graphs）:没有重边和自回路的图。 （4）邻接点: 如果（v, w）或 &lt; v, w &gt;是图中任意一条边，那么称v和w互为“邻接点（Adjacent Vertices）”。 （5）路径、简单路径、回路、无环图： 图G中从_vp 到 vq_ 的路径 = { _vp_, _vi_1, _vi_2, ×××, _vin_, _vq_ } 使得( _vp_, _vi_1 ), ( _vi_1, _vi_2 ), ×××, ( _vin_, _vq_ ) 或 &lt; _vp_, _vi_1 &gt;, ×××, &lt; _vin_, _vq_ > 都属于E( G )。 路径长度：路径中边的数量。 简单路径：_vi_1, _vi_2, ×××, _vin_ 都是不同顶点。 回路：起点和终点相同（_vp_ = _vq_ ）的路径。 无环图：不存在任何回路的图。 有向无环图：不存在回路的有向图，也称DAG（Directed Acyclic Graph）。 （6）完全图：分为有向完全图（n(n-1)条边）和无向完全图（n(n-1)/2条边）。 （7）度：与顶点v相关的边数。从该点发出的边数为“出度”，指向该点的边数为“入度”。 （8）稠密图、稀疏图：是否满足 |E| &gt; |V|log2|V|，作为稠密图和稀疏图的分界条件。 （9）权（Cost） 、网络（Network）。 （10）图G的子图 G’ ： V( G’ ) Í V( G ) &amp;&amp; E( G’ ) Í E( G )。 （11）无向图的顶点连通、连通图、连通分量：如果无向图从一个顶点_vi_到另一个顶点_vj (i≠j)_有路径，则称顶点_vi_和vj是“连通的（Connected）”；无向图中任意两顶点都是连通的，则称该图是“连通图（Connected Graph）”；无向图的极大连通子图称为“连通分量（Connected Component）”。连通分量的概念包含以下4个要点：_子图、连通、极大顶点数、极大边数_ （12）有向图的强连通图、连通分量：有向图中任意一对顶点_vi_ 和_vj (i≠j)_均既有从_vi_到_vj_的路径，也有从_vj_到_vi_的路径，则称该有向图是“强连通图（Strongly Connected Graph）”。有向图的极大强连通子图称为“强连通分量（Strongly Connected Component）”。连通分量的概念也包含前面4个要点。 （13）树、生成树：树是图的特例：无环的无向图。 所谓连通图G的“生成树（Spanning Tree）”，是G的包含其全部n 个顶点的一个极小连通子图。它必定包含且仅包含G的n-1条边。 生成树有可能不唯一。 当且仅当G满足下面4个条件之一（完全等价）： ① G有n-1条边，且没有环； ② G有n-1条边，且是连通的； ③ G中的每一对顶点有且只有一条路径相连； ④ G是连通的，但删除任何一条边就会使它不连通。 2.表示图——邻接矩阵 邻接矩阵G[N][N]-N个顶点从0到N-1编号。其中G[i][j]=1（若&lt;vi,vj&gt;是G中的边）或0（不是G中的边）。可以看出邻接矩阵有以下特点： （1）主对角线全为0； （2）这是一个对称矩阵。 那么，对于无向图来说，怎样可以节省一半空间？ 可以用一个长度为N(N+1)/2的1维数组A存储{G00,G10,…,G(n-1)0,…,G(n-1)(n-1)}。则Gij在A中对应的下标是：(i*(i+1)/2+j)。对于网络，只要把G[i][j]的值定义为边&lt;vi,vj&gt;的权重即可。 问题：vi和vj在网络中它们之间没有边该如何表示？ 邻接矩阵有以下优点： （1）直观、简单、好理解； （2）方便检查任意一对顶点间是否存在边； （3）方便找任一顶点的所有“邻接点”（有边直接相连的顶点）； （4）方便计算任一顶点的“度”： 对于无向图来说，对应行（列）非0的元素的个数。对于有向图来说，对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度”。 邻接矩阵的缺点： （1）浪费空间：存稀疏图有大量无效元素。但是对于稠密图（特别是完全图）还是很合算。 （2）浪费时间：统计系数图中一共有多少条边。 3.表示图——邻接表 邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素。对于图G中的每个顶点_vi_，将所有邻接于_vi_的顶点_vj_链成一个单链表，这个单链表就称为顶点_vi_的邻接表，再将所有点的邻接表表头放到一个数组中，就构成了图的邻接表。 一定要够稀疏用邻接表才合算！！！！ 邻接表的特点： （1）方便找任一顶点的所有“邻接点”。 （2）节约稀疏图的空间：需要N个头指针+2E个结点。 （3）方便计算任一顶点的“度”：对于无向图来说是如此，对于有向图来说，这只能计算“出度”；需要构造“逆邻接表”（存指向自己的边）来方便计算“入度”。 6.2 图的遍历1.深度优先搜索（DFS） 代码实现： void DFS( Graph G, int V ){ / 从第V个顶点出发递归地深度优先遍历图G / VertexType W; Visited[V] = TRUE; VisitFunc(V); / 访问第V个顶点 / for( W = FirstAdjV(G, V); W; W = NextAdjV (G, V, W) ) if( !Visited[W] ) DFS(G, W); / 对V的尚未访问的邻接顶点W递归调用DFS /} 这段代码的意思是，首先我们开始访问，然后每访问一个节点，都将其标记为True，然后开始访问V的邻接点，如果没访问，那就去访问并且置为True，当看到邻接点都是True时，我们原路返回，若发现没访问过的邻接点，立即去访问；如果没有发现，继续原路返回，直到返回到第一个结点。 若由N个顶点，E跳边，时间复杂度是： （1）用邻接表存储图：O(N+E)； （2）用邻接矩阵，有O(N2)。 2.广度优先搜索（BFS） 相当于层序遍历。 void BFS(Graph G){ / 按广度优先遍历图G。使用辅助队列Q和访问标志数组Visited / Queue Q; VertexType U, V, W; for ( U = 0; U &lt; G.n; ++U ) Visited[U] = FALSE; Q = CreatQueue( MaxSize ); / 创建空队列Q / for ( U = 0; U&lt;G.n; ++U ) if (!Visited[U] ) { / 若U尚未访问 / Visited[U] = TRUE; VisitFunc(U); / 访问U / AddQ (Q, U); / U入队列 / while ( ! IsEmptyQ(Q) ) { V = DeleteQ( Q ); / 队头元素出队并置为V / for( W = FirstAdjV(G, V); W; W = NextAdjV(G, V, W) ) if ( !Visited[W] ) { Visited[W] = TRUE; VisitFunc (W); / 访问W / AddQ (Q, W); } } / while结束/ } / 结束从U开始的BFS */} 若由N个顶点，E跳边，时间复杂度是： （1）用邻接表存储图：O(N+E)； （2）用邻接矩阵，有O(N2)。 6.3 图的应用1.应用实例：拯救007 如图1所示，如何让007通过这一个个结点（鳄鱼），一步一步跳到岸边呢？这里用深度优先算法更为合适。 原来的总体算法（伪代码）： void ListComponents(Graph G){ for(each V in G) if(!visited[V]){ DFS(V); }} 这里的总体算法（伪代码）： void Save007(Graph G){ for(each V in G) if(!visited[V]&amp;&amp; FirstJump(V))/判断是否踩过这个鳄鱼还有是否能够得着/ { answer = DFS(V); if(answer ==YES) break; } if(answer ==YES) output(“YES”); else output(“BYEBYE”);} DFS部分的伪代码： int DFS(Vertex V){ visited[V] = True; if(IsSafe(V)) answer = YES; else{ for(V的每个邻接点W) if(!visited[W]&amp;&amp; Jump(V,W)) /*Jump计算两个鳄鱼之间距离是否小于007最大跳动距离*/ { answer=DFS(W); DFS(W); } } return answer;} 6.4 图的建立1.用邻接矩阵表示图 typedef struct GNode PtrToGNode;struct GNode{ int Nv;/顶点数/ int Ne;/边数/ WeightType G[MaxVertexNum][MaxVertexNum]; DataType Data[MaxVertexNum];/存顶点的数据/};typedef PtrToGNode MGraph;/以邻接矩阵存储的图类型*/ 2.初始化图 typedef int Vertex;/用顶点下标表示顶点，为整型/MGraph CreateGraph(int VertexNum){ Vertex V,W; MGraph Graph; Graph = (MGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; /*这里默认顶点标号从0开始，到(Graph-&gt;Nv-1)*/ for(V=0;V&lt;Graph-&gt;Nv;V++) for(W=0;W&lt;Graph-&gt;Nv;W++) Graph-&gt;G\\[V\\]\\[W\\] = 0;/*有向图是INFINITY*/ return Graph; } 3.插入边 typedef struct ENode PtrToGNode;struct ENode{ Vertex V1,V2;/有向边&lt;V1,V2&gt;/ WeightType Weight;/权重*/};typedef PtrToGNode Edge; void InsertEdge( MGraph Graph, Edge E){ /插入边&lt;V1,V2&gt;/ Graph-&gt;G[E-&gt;V1][E-&gt;V2]=E-&gt;Weight; /无向图/ Graph-&gt;G[E-&gt;V2][E-&gt;V1]=E-&gt;Weight; } 4.建立图 （1）输入格式：Nv Ne V1 V2 Weight 代码如下： MGraph BuildGraph(){ Edge E; MGraph Graph; Vertex V; int Nv,i; scanf(“%d”,&amp;Nv); Graph = CreateGraph(Nv); scanf(“%d”,&amp;(Graph-&gt;Ne)); if(Graph-&gt;Ne!=0) { E = (Edge)malloc(sizeof(struct ENode)); for(i=0;iNe;i++){ scanf(“%d %d %d”,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight); InsertEdge(Graph, E); } } /如果顶点有数据的话，读入数据/ for(V=0;VNv;V++) scanf(“%c”,&amp;(Graph-&gt;Data[V])); return Graph; } 但是这样来说太麻烦了，如果不要这么麻烦，一个整体的程序（不再需要子程序）可以如下： int G[MAXN][MAXN],Nv,Ne;void BuildGraph(){ int i,j,v1,v2,w; scanf(“%d”,&amp;Nv); /*CreateGraph*/ for(i=0;i&lt;Nv;i++) for(j=0;j&lt;Nv;j++) G[i][j]=0;/初始化，有向图为无穷/ scanf(“%d”, &amp;Ne);/输入有多少个结点/ for(i=0;i&lt;Ne;i++) { scanf(“%d %d %d”, &amp;v1,&amp;v2,&amp;w); /将边插入/ G[v1][v2]=w; G[v2][v1]=w; }} 一气呵成。 5.邻接表表示的图结点的结构 邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素。 typedef struct GNode PtrToGNode;struct GNode{ int Nv;/顶点数/ int Ne;/边数/ AdjList G;/邻接表*/};typedef PtrToGNode LGraph; typedef struct Vnode{ PtrToAdjVNode FirstEdge; DataType Data;/存顶点的数据/}AdjList[MaxVertexNum];/*AdjList是邻接表类型*/ typedef struct AdjVNode PtrToAdjVNode;struct AdjVNode{ Vertex AdjV;/邻接点下标/ WeightType Weight; PtrToAdjVNode Next;/指向下一个邻接点的指针*/}; 6.邻接表表示的图-建立图 （1）初始化一个由VertexNum个顶点但没有边的图 typedef int Vertex;/用顶点下标表示顶点，为整型/LGraph CreateGraph(int VertexNum){ Vertex V,W; LGraph Graph; Graph = (LGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne =0; /*每一个顶点跟着的链表都是空的为没有边*/ for(V=0;V&lt;Graph-&gt;Nv;V++) Graph-&gt;G\\[V\\].FirstEdge = NULL; return Graph; } （2）向LGraph中插入边 void InsertEdge(LGraph Graph, Edge E){ PtrToAdjVNode NewNode; /*插入边&lt;v1,v2&gt;*/ NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV=E-&gt;V2; NewNode-&gt;Weight = E-&gt;Weight; /*将V2插入V1的表头*/ NewNode-Next = Graph-&gt;G\\[E-&gt;V1\\].FirstEdge; Graph-&gt;G\\[E-&gt;V1\\].FirstEdge = NewNode; /*若是无向图，还要插入边&lt;V2,V1&gt;*/ /*为V1建立新的邻接点*/ NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV=E-&gt;V1; NewNode-&gt;Weight = E-&gt;Weight; /*将V1插入V2的表头*/ NewNode-Next = Graph-&gt;G\\[E-&gt;V2\\].FirstEdge; Graph-&gt;G\\[E-&gt;V2\\].FirstEdge = NewNode; } （3）完整建立LGraph LGraph BuildGraph(){ LGraph Graph;/剩余与邻接矩阵完整版类似/}","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"数据结构【浙江大学】（第5节）整理","slug":"datastructure_chapter5","date":"2018-04-24T03:07:32.000Z","updated":"2019-03-21T14:51:27.033Z","comments":false,"path":"2018/04/24/datastructure_chapter5/","link":"","permalink":"http://tech.yushuai.xyz/2018/04/24/datastructure_chapter5/","excerpt":"","text":"第五节：树（下）5.1 堆1.堆的介绍 优先队列：特殊的“队列”，取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。 堆的两个特性： （1）结构性：用数组表示的完全二叉树； （2）有序性：任一结点的关键字是其子树所有结点的的最大值（最小值）： ①最大堆：也称“大顶堆”：最大值 ②最小堆，也称“小顶堆”：最小值。 类型名称：最大堆（MaxHeap） 数据对象集：一个有N&gt;0个元素的最大堆H是一棵完全二叉树，每个结点上的元素值不小于其子结点元素的值。 操作集：对于任意最多有MaxSize个元素的最大堆H Î MaxHeap，元素item Î ElementType，主要操作有： • MaxHeap Create( int MaxSize )：创建一个空的最大堆。 • Boolean IsFull( MaxHeap H )：判断最大堆H是否已满。 • Insert( MaxHeap H, ElementType item )：将元素item插入最大堆H。 • Boolean IsEmpty( MaxHeap H )：判断最大堆H是否为空。 • ElementType DeleteMax( MaxHeap H )：返回H中最大元素(高优先级)。 2.最大堆的操作 （1）最大堆的创建 typedef struct HeapStruct MaxHeap;struct HeapStruct { ElementType \\Elements; /* 存储堆元素的数组 / int Size; / 堆的当前元素个数 / int Capacity; / 堆的最大容量 /};MaxHeap Create( int MaxSize ){ / 创建容量为MaxSize的空的最大堆 /MaxHeap H = malloc( sizeof( struct HeapStruct ) );H-&gt;Elements = malloc( (MaxSize+1) sizeof(ElementType));H-&gt;Size = 0;H-&gt;Capacity = MaxSize;H-&gt;Elements[0] = MaxData; / 定义“哨兵”为大于堆中所有可能元素的值，便于以后更快操作 /return H;} （2）最大堆的插入 当插入一个元素时，我们首先要想到将元素插入到最右下角的位置。然而，所插入的值有可能比其父结点还要大，因此我们需要将其与父结点调换位置。若此时该元素仍然要比新位置的父结点大，那么继续调换位置，直到满足要求。代码实现如下所示： void Insert( MaxHeap H, ElementType item ){ / 将元素item 插入最大堆H，其中H-&gt;Elements[0]已经定义为哨兵 / int i; if ( IsFull(H) ) { printf(“最大堆已满”); return; } i = ++H-&gt;Size; / i指向插入后堆中的最后一个元素的位置 / for ( ; H-&gt;Elements[i/2] &lt; item; i/=2 ) H-&gt;Elements[i] = H-&gt;Elements[i/2]; / 向下过滤结点 / H-&gt;Elements[i] = item; / 将item 插入 /} 注意：H-&gt;Element[ 0 ] 是哨兵元素，它不小于堆中的最大元素，以便省去i&gt;=1的语句，控制顺环结束。 （3）最大堆的删除 取出根结点（最大值）元素，同时删除堆的一个结点。 如图1所示。我们想取出最大值58这个点。我们需要做的是： ①把58取出，然后用最后一个元素来替补根这个位置。 ②找出31的较大的孩子，然后跟31比较。发现孩子44要比31大，于是将44和31交换位置。 ③再比较31和子孩子35，发现35大于31，因此交换35和31的位置。完成。 图1 代码如下： ElementType DeleteMax( MaxHeap H ){ / 从最大堆H中取出键值为最大的元素，并删除一个结点 / int Parent, Child; ElementType MaxItem, temp; if ( IsEmpty(H) ) { printf(“最大堆已为空”); return; } MaxItem = H-&gt;Elements[1]; / 取出根结点最大值 / / 用最大堆中最后一个元素从根结点开始向上过滤下层结点 / temp = H-&gt;Elements[H-&gt;Size–]; for( Parent=1; Parent2&lt;=H-&gt;Size; Parent=Child ) { Child = Parent 2; if( (Child!= H-&gt;Size) &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child+1]) ) Child++; / Child指向左右子结点的较大者 / if( temp &gt;= H-&gt;Elements[Child] ) break; else / 移动temp元素到下一层 / H-&gt;Elements[Parent] = H-&gt;Elements[Child]; } H-&gt;Elements[Parent] = temp; return MaxItem;} _T_ (_N_) = O ( log _N_ ) 3.最大堆的建立 堆的一个重要应用就是堆排序。要进行排序，首先需要建立堆。 建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一位数组中。 方法1：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为O(NlogN)。不合适。 方法2：在限行时间复杂度下建立最大堆。 （1）将N个元素按输入顺序存入，先满足完全二叉树的结构特性。 （2）调整各结点位置，以满足最大堆的有序特性。 要这样做，首先要寻找到最后一个由儿子的结点。由右往左，由下往上，直到根结点。 代码如下： MaxHeap BuildMaxHeap( MaxHeap H ){ / 这里假设所有H-&gt;Size个元素已经存在H-&gt;Elements[]中 / / 本函数将H-&gt;Elements[]中的元素调整，使满足最大堆的有序性 /int Parent, Child, i;ElementType temp;for( i = H-&gt;Size/2; i&gt;0; i– ){ /从最后一个结点的父结点开始 / temp = H-&gt;Elements[i]; for( Parent=i; Parent2&lt;=H-&gt;Size; Parent=Child ) { / 向下过滤 / Child = Parent 2; if( (Child!= H-&gt;Size) &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child+1]) ) Child++; / Child指向左右子结点的较大者 / if( temp &gt;= H-&gt;Elements[Child] ) break; else / 移动temp元素到下一层 / H-&gt;Elements[Parent] = H-&gt;Elements[Child]; } / 结束内部for循环对以H-&gt;Elements[i]为根的子树的调整 / H-&gt;Elements[Parent] = temp; } return H;} 5.2 哈夫曼树和哈夫曼编码1.哈夫曼编码介绍 设一棵二叉树有_n_个叶子结点，每个叶子结点带有权值 _wk_，从根结点到每个叶子结点的长度为 _lk_，则每个叶子结点的带权路径长度之和就是这棵树的“带权路径长度（Weighted Path Length，简称WPL）”。 假设有_n_个权值{_w1_ ,_w2_ , …… , _wn_} ，构造有_n_个叶子的二叉树，每个叶子的权值是_n_个权值之一。这样的二叉树也许可以构造多个，其中必有一个（或几个）是带权路径长度WPL最小的。达到WPL最小的二叉树就称为最优二叉树或哈夫曼树。 2.哈夫曼树的构造 每次把权值最小的两棵二叉树合并 typedef struct TreeNode HuffmanTree;struct TreeNode{int Weight;HuffmanTree Left, Right;}HuffmanTree Huffman( MinHeap H ){ / 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里 / int i; HuffmanTree T; BuildMinHeap(H); /将H-&gt;Elements[]按权值调整为最小堆/ for (i = 1; i &lt; H-&gt;Size; i++) { /做H-&gt;Size-1次合并/ T = malloc( sizeof( struct TreeNode) ); /建立新结点/ T-&gt;Left = DeleteMin(H); /从最小堆中删除一个结点，作为新T的左子结点/ T-&gt;Right = DeleteMin(H); /从最小堆中删除一个结点，作为新T的右子结点/ T-&gt;Weight = T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight; /计算新权值/ Insert( H, T ); /将新T插入最小堆*/ } T = DeleteMin(H); return T;} 3.哈夫曼树的特点 （1）没有度为1的结点； （2）n个叶子结点的哈夫曼树共有2n-1个结点； （3）哈夫曼树的任意非叶节点的左右子树交换后仍是哈夫曼树。 5.3 集合1.集合基本介绍 集合运算包括交、并、补、差以及判定一个元素是否是某一集合中等。逻辑上，可以用树结构表示集合，树的每个结点代表一个集合元素。 但是更好的方法是用数组存储形式。 数组中每个元素的类型描述为： typedef struct { ElementType Data; int Parent;} SetType; 数组每个分量都是一个结构，包含两个域：一个是Data，代表结点的信息；一个是Parent，是一个下标数值，指向父结点的下标，若为-1，代表其为根结点。这样，图2左侧的数组就可以用来表示右侧3棵树。 图2 2.集合运算 （1）集合的查找操作（用根结点表示） int Find( SetType S[ ], ElementType X ) { / 在数组S中查找值为X的元素所属的集合 / / MaxSize是全局变量，为数组S的最大长度 / int i; for ( i=0; i &lt; MaxSize &amp;&amp; S[i].Data != X; i++) ; if( i &gt;= MaxSize ) return -1; / 未找到X，返回-1 / for( ; S[i].Parent &gt; 0; i = S[i].Parent ) ; return i; / 找到X所属集合，返回树根结点在数组S中的下标 /} 这段代码的意思是，首先寻找到X的下标i，如果X不在集合中，那么返回-1；若X在集合中，则需要返回其根结点的下标，这时候就利用若i的父结点大于等于0，那么久把i的父结点赋值给i，直到找到根结点，返回树根结点在数组S中的下标。 （2）集合的并操作 首先分别找到X1和X2两个元素所在集合树的根结点，如果它们不同根，则将其中一个根结点的父结点指针设置成另一个根结点的数组下标就行了。 void Union( SetType S[ ], ElementType X1, ElementType X2 ){ int Root1, Root2; Root1 = Find(S, X1); Root2 = Find(S, X2); if（ Root1 != Root2 ）S[Root2].Parent = Root1;} 为了改善合并以后的查找性能，可以采用**小的集合合并到相对大的集合**中。为了区分小的和大的，所以可以将根结点的Parent由-1改为-A，其中A代表该集合有多少元素。这样我们就可以知道哪个集合小，哪个集合大了。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"数据结构【浙江大学】（第4节）整理","slug":"datastructure_chapter4","date":"2018-04-24T03:02:58.000Z","updated":"2019-03-21T14:51:30.818Z","comments":false,"path":"2018/04/24/datastructure_chapter4/","link":"","permalink":"http://tech.yushuai.xyz/2018/04/24/datastructure_chapter4/","excerpt":"","text":"第四节：二叉搜索树4.1 二叉搜索树二叉搜索树（BST），也称二叉排序树和二叉查找树。一棵这个树，可以为空。如果不为空，满足以下性质： （1）非空左子树的所有键值小于其根结点的键值。 （2）非空右子树的所有键值大于其根结点的键值。 （3）左、右子树都是二叉搜索树。 1.二叉搜索树操作的函数： Position Find(ElementType X, BinTree BST)：从二叉搜索树BST中查找元素X，并返回其结点地址； Position FindMin(ElementType X, BinTree BST)：从二叉搜索树BST中查找最小元素X，并返回其结点地址； Position FindMax(ElementType X, BinTree BST)：从二叉搜索树BST中查找最大元素X，并返回其结点地址； BinTree Insert(ElementType X, BinTree BST) BinTree Delete(ElementType X, BinTree BST) 2.二叉搜索树的查找操作：Find 查找从根结点开始，如果树为空，返回NULL。 若树非空，则根结点关键字与X进行比较，并进行以下处理： （1）若X小于根结点键值，则在左子树中继续搜索； （2）若X大于根节点键值，则在右子树中搜索； （3）若两者相等，搜索完成，返回指向此结点的指针。 代码如下： Position Find(ElementType X, BinTree BST){ if(!BST) return NULL; if(X&gt;BST-&gt;Data) return Find(X,BST-&gt;Right); else if(XData) return Find(X, Bst-&gt;Left); else return BST;} 由于非递归函数的执行效率高，可将尾递归函数修改为迭代函数： Position Find(ElementType X, BinTree BST){ while(BST){ if(X&gt;BST-&gt;Data) BST= BST-&gt;Right; else if(XData) BST= BST-&gt;Left; else return BST; } return NULL;} 3.查找最大和最小元素 最大元素一定在树的最右分支的端结点上；最小元素在最左分支的端结点上。 /查找最小元素的递归函数/Position FindMin(BinTree BST){ if(!BST) return NULL; else if(!BST-&gt;Left) return BST; else return FindMin(BST-&gt;Left);}/查找最大元素的迭代函数/Position FindMax(BinTree BST){ if(BST) while(BST-&gt;Right) BST = BST-&gt;Right; return BST;} 4.二叉搜索树的插入 分析：关键是要找到元素应该插入的位置，可以采用与Find类型的方法。 BinTree Insert(ElementType X, BinTree BST){ if(!BST){ BST = malloc(sizeof(struct TreeNode)); BST-&gt;Data =X; BST-&gt;Left = BST-&gt;Right =NULL; } else if(XData) BST-&gt;Left = Insert(X, BST-&gt;Left); else if(X&gt;BST-&gt;Data) BST-&gt;Right = Inser(X,BST-&gt;Right); return BST;} 4.二叉搜索树的删除 我们需要考虑三种情况： （1）要删除的是叶结点：直接删除，并再修改其父结点指针为NULL。 （2）要删除的结点只有一个孩子结点：要将其父结点的指针指向要删除结点的孩子结点。 （3）要删除的结点有左、右两棵子树：用另一结点代替被删除的结点：右子树的最小元素或者左子树的最大元素。如图2所示。 图1 代码如下所示： BinTree Delete( ElementType X, BinTree BST ){ Position Tmp; if( !BST ) printf(“要删除的元素未找到”); else if( X &lt; BST-&gt;Data ) BST-&gt;Left = Delete( X, BST-&gt;Left); / 左子树递归删除 / else if( X &gt; BST-&gt;Data ) BST-&gt;Right = Delete( X, BST-&gt;Right); / 右子树递归删除 / else /找到要删除的结点 / if( BST-&gt;Left &amp;&amp; BST-&gt;Right ) { /被删除结点有左右两个子结点 / Tmp = FindMin( BST-&gt;Right ); /在右子树中找最小的元素填充删除结点/ BST-&gt;Data = Tmp-&gt;Data; BST-&gt;Right = Delete( BST-&gt;Data, BST-&gt;Right); /在删除结点的右子树中删除最小元素/ } else { /被删除结点有一个或无子结点/ Tmp = BST; if( !BST-&gt;Left ) / 有右孩子或无子结点/ BST = BST-&gt;Right; else if( !BST-&gt;Right ) /有左孩子或无子结点/ BST = BST-&gt;Left; free( Tmp ); } return BST;} 4.2 平衡二叉树1.平衡二叉树基本介绍 查找二叉搜索树（BST）的时间复杂度（最坏情况下）用查找过程中的比较次数来衡量，它取决于树的深度。 对于二叉树中任一结点T，其“平衡因子（Balance Factor，简称BF）”定义为BF(T)=hL-hR。（其中hL和hR分别为T的左、右子树的高度。） “平衡二叉树（Balanced Binary Tree）”又称为“AVL树” 。 AVL树或者是一棵空树，或者是具有下列性质的非空二叉搜索树：任一结点左、右子树高度差的绝对值不超过1。”即|BF(T) |≤ 1。 平衡二叉树的高度能达到logn吗？ 设nh高度为h的平衡二叉树的最少结点树。结点数最少时： nh=n(h-1)+n(h-2)+1 具体见图2. 图2 1.平衡二叉树的调整 （1）右单旋 如图3所示，当只将Mar加上May的时候，其平衡因子为-1，但是当增加了一个Nov的时候，其平衡引子变成了-2，不符合平衡二叉树的要求，因此很显然我们会想到将其调整到图3右侧的结构，这样其三个结点的平衡因子都是0了。 图3 首个不平衡的“发现者”是Mar（未必是根结点），它是调整起点位置。而“麻烦结点”Nov 在发现者右子树的右边，因而叫RR插入，需要RR旋转（右单旋）；一般情况（设A是首个发现者）的调整方式如下: 图4 （2）左单旋 图5 （3）左-右双旋 图6 （4）右-左双旋 图7","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"数据结构【浙江大学】（第3节）整理","slug":"datastructure_chapter3","date":"2018-04-24T03:01:55.000Z","updated":"2019-03-21T14:51:34.068Z","comments":false,"path":"2018/04/24/datastructure_chapter3/","link":"","permalink":"http://tech.yushuai.xyz/2018/04/24/datastructure_chapter3/","excerpt":"","text":"第三讲 树（上）3.1 树与树的表示1.查找 查找是指根据某个给定关键字K，从集合R中找出关键字与K相同的记录。它分为以下两类： （1）静态查找：集合中记录是固定的，没有插入和删除操作。 （2）动态查找：集合中记录是动态变化的，除了查找，还可能发生插入和删除。 首先举一个顺序查找的例子。此例需要注意，其设置了一个哨兵，因此可以减少判断中的一个条件。这个例子要求是在Element[1]~Element[n]中查找关键字为K的数据元素，其结构体如下： typedef struct LNode *List;struct LNode{ ElementType Element[MAXSIZE]; int Length;}; 则查找算法代码如下： int SequentialSearch(List Tb1, ElementType K){ int i; Tb1-&gt;Element[0]=K;/建立哨兵/ for(i-Tb1-&gt;Length;Tb1-&gt;Element[i]!=K;i–); return i;/查找成功返回下标，不成功返回0/} 时间复杂性O(n)。 再举一个二分查找的例子。二分查找遵循以下要求：假设n个数据元素的关键字满足有序，并且是连续存放。 例如，假设有13个数据元素，按照关键字由小到大顺序存放，二分查找关键字为444的数据。 5 16 39 45 51 98 100 202 226 321 368 444 501 理论步骤是如表1.1所示。 表1.1 二分法步骤 left right mid value comparsion 1 13 7 100 100&lt;444，右侧 8 13 10 321 321&lt;444，右侧 11 13 12 444 444=444，结束 程序代码如下： int BinarySearch(List Tbl, ElementType K){ int left, right, mid, NoFount = -1; left = 1;/初始左侧边界/ right = Tbl-&gt;Length;/初始右侧边界/ while (left &lt;= right) { mid = (left + right) / 2; if (K &lt; Tbl-&gt;Element[mid]) right = mid - 1; else if (K &gt; Tbl-&gt;Element[mid]) left = mid + 1; else return mid; } return NotFound;} 时间复杂度是O(logN)。 2.树的定义和术语 树（Tree）：n（n≥0）个结点构成的有限集合。当n=0时，称为空树。 对于任一棵非空树（n&gt;0），它具备以下性质： （1）树种有一个称为根的特殊结点，用r表示； （2）其余结点可分为m（m＞0）个互不相交的有限集T1，T2，…，Tm，其中每个集合本身又是一棵树，称为原来树的“子树”。 （3）子树是不相交的； （4）除了根结点外，每个结点有且只有一个父节点； （5）一棵N个结点的树有N-1条边。 树的一些基本术语： （1）结点的度：结点子树个数。 （2）树的度：树的所有结点中最大的度数。 （3）叶结点：度为0的结点。 （4）父结点：有子树的结点是其子树的根结点的父结点。 （5）子结点：若A结点是B结点的父结点，则称B结点是A结点的子结点。 （6）兄弟结点：具有同一父结点的各结点彼此是兄弟结点。 （7）路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，…nk，其中ni是ni+1的父结点。路径所包含边的个数为路径的长度。 （8）祖先结点：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。 （9）子孙节点：某一结点的子树中的所有结点是这个结点的子孙。 （10）结点的层次：规定根结点在1层，其它任一结点的层数是其父结点的层数加1。 （11）树的深度：树种所有结点总的最大层次是这棵树的深度。 3.树的表示 数组、链表都是很难表示树的，因为树的结构是多变的，无法统一规定。因此在这里用“**儿子-兄弟表示法**”，结构如下面所示。 Element FirstChild NextSibling 如图1左所示的树结构可以表示为图1右所示的表示法。 图1 把这个树往右转向45°，可以看出，这是一个度为2的树。这种方法也被称为——二叉树。 3.2 二叉树1.二叉树的定义 二叉树T：一个有穷的结点集合。这个集合可以为空。若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。 二叉树的五种基本形态如图2所示，几种特殊二叉树如图3所示。 图2 图3 对完全二叉树左一个说明。完全二叉树可以是满二叉树缺少最低一层最右侧几个，只要前面都对的起来即可，但是绝不能在中间缺几个（如图3右下角）。 2.二叉树的几个重要性质 （1）一个二叉树第i层的最大结点数为：2i-1，i≥1。 （2）深度为k的二叉树最大节点数是2k-1，k≥1。 （3）对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶结点个数，那么两者满足n0=n2+1。 3.二叉树的抽象数据类型定义 类型名称：二叉树 数据对象集：一个有穷的结点集合。若不为空，则由根结点和其左、右二叉子树组成。 操作集：BT∈BinTree，Item∈ElementType，重要的操作有： （1）Boolean IsEmpty(BinTree BT)：判断BT是否为空； （2）void Traversal(BinTree BT)：遍历，按某顺序访问每个结点； （3）BinTree CreatBinTree()：创建一个二叉树。 二叉树常用的便利方法有： （1）void PreOrderTraversal(BinTree BT)：先序——根、左子树、右子树； （2）void InOrderTraversal(BinTree BT)：中序——左子树、根、右子树； （3）void PostOrderTraversal(BinTree BT)：后序：左子树、右子树、根； （4）void LevelOrderTraversal(BinTree BT)：层次遍历：从上到下、从左到右。 4.二叉树的存储结构 （1）顺序存储结构 完全二叉树：按从上至下、从左到右顺序存储，n个结点的完全二叉树的结点父子关系，可以使用顺序存储结果。如图4所示。 图4 这个完全二叉树很有规律，很容易找到其父结点和子结点。我们可以发现： ①非根节点（序号i&gt;1）的父结点的序号是[i/2]（在这里[]表示取整）； ②结点（序号为i）的左孩子结点序号为2i（若2i&gt;=n，就没有左孩子）； ③结点（序号为i）的右孩子结点序号为2i+1（若2i+1&gt;=n，就没有右孩子）。 推广来说，一般二叉树也可以采用这种结构，方法就是通过补空位使其变成完全二叉树。但这样的结果是会造成空间浪费。 （2）链表存储 一般二叉树的结点可以用下面的方式表示： Left Data Right 其代码表示如下： typedef struct TreeNode *BinTree;typedef BinTree Position:struct TreeNode{ ElementType Data; BinTree Left; BinTree Right;}; 5.二叉树的递归遍历 （1）先序遍历 遍历过程为： ①访问根结点；②先序遍历其左子树，先序遍历其右子树。 程序如下所示： void PreOrderTraversal(BinTree BT){ if(BT){ printf(“%d”,BT-&gt;Data); PreOrderTraversal(BT-&gt;Left); PreOrderTraversal(BT-&gt;Right); }} （2）中序遍历 遍历过程为： ①中序遍历其左子树；②访问根结点；③中序遍历其右子树。 程序如下所示： void InOrderTraversal(BinTree BT){ if(BT){ PreOrderTraversal(BT-&gt;Left); printf(“%d”,BT-&gt;Data);PreOrderTraversal(BT-&gt;Right); }} （3）后序遍历 便利过程： ①后续遍历其左子树；②后续遍历其右子树；③访问根结点。 代码如下： void PostOrderTraversal(BinTree BT){ if(BT){ PreOrderTraversal(BT-&gt;Left);PreOrderTraversal(BT-&gt;Right)printf(“%d”,BT-&gt;Data);; }} 6.二叉树的非递归遍历（以中序为例） 基本思路：使用堆栈。 如图5所示的二叉树，我们以此未来来介绍利用堆栈进行处理的方法，输出顺序为：DBEFAGHCI。处理的方法见表3.1所示。 图5 表3.1 使用堆栈算法的表格示意 序号 当前结点 堆栈（从左到右相当于从底到顶） 步骤说明 1 A [A] 首先把A压入堆栈 2 B [AB] B为A的左孩子，压入堆栈 3 D [ABD] D为B的左孩子，压入堆栈 4 [AB] D无孩子，将D推出堆栈 5 [A] 将B推出堆栈 6 F [AF] 由于F为B右孩子，在B推出时将F压入堆栈 7 E [AFE] E为F左孩子，压入堆栈 8 [AF] E无孩子，将E推出堆栈 9 [A] 将F推出堆栈 10 [] 将A推出堆栈 11 C [C] 将G压入堆栈 12 G [CG] G为C的左孩子，压入堆栈 13 [C] G没有左孩子，G推出堆栈 14 H [CH] 将G的右孩子压入堆栈 15 [C] H无孩子，H推出堆栈 16 [] 将C推出堆栈 17 I [I] 将I压入堆栈 18 [] 将I推出堆栈 具体执行代码如下： void InOrderTraversal(BinTree BT){ BinTree T=BT; Stack S=CreatStack(MaxSize);/创建并初始化堆栈S/ while(T||!IsEmpty(S)){ while(T) {/一致向左将沿途结点压入堆栈/ Push(S,T); T=T-&gt;Left; } if(!IsEmpty(S)) { T= Pop(S);/结点弹出堆栈/ printf(“%5d”,,T-&gt;Data);/打印结点/ T=T-&gt;Right;/转向右子树/ } }} 同理可得，中序遍历为： void PreOrderTraversal(BinTree BT){ BinTree T=BT; Stack S=CreatStack(MaxSize);/创建并初始化堆栈S/ while(T||!IsEmpty(S)){ while(T) {/一致向左将沿途结点压入堆栈/ printf(“%5d”,,T-&gt;Data);/打印结点/ Push(S,T); T=T-&gt;Left; } if(!IsEmpty(S)) { T= Pop(S);/结点弹出堆栈/ T=T-&gt;Right;/转向右子树/ } }} 7.层序遍历 层次遍历是利用队列的方式进行。遍历从根结点开始，首先将根结点指针入队，然后开始执行下面三个操作： （1）从队列中取出一个元素； （2）访问该元素所指结点； （3）若钙元素所指结点的左、右孩子结点费控，则将其左、右孩子的指针顺序入队。 不断执行这三步操作，直到队列为空，再无元素可取，二叉树的层序遍历就完成了。其代码如下所示： void LevelOrderTraversal(BinTree BT){ BinTree T; Queue Q; if(!BT) return;/空树直接返回/ Q = CreatQueue(MaxSize); AddQ(Q,BT); while(!IsEmptyQ(Q)){ T = DeleteQ(Q); printf(“%d\\\\n”,T-&gt;Data); /访问取出队列的结点/ if(T-&gt;Left) AddQ(Q,T-&gt;Left); if(T-&gt;Right) AddQ(Q,T-&gt;Right); }} 8.遍历应用的例子 【例1】遍历二叉树的应用：输出二叉树中的叶子结点。 void PreOrderTraversal(BinTree BT){ if(BT){ if(!BT-&gt;Left &amp;&amp;!BT-&gt;Right) printf(“%d”,BT-&gt;Data); PreOrderTraversal(BT-&gt;Left); PreOrderTraversal(BT-&gt;Right); }} 【例2】求二叉树的高度。 int PostOrderGetHeight(BinTree BT){ int HL,HR,MaxH; if(BT){ HL = PostOrderGetHeight(BT-&gt;Left); HR = PostOrderGetHeight(BT-&gt;Right); MaxH = (HL&gt;HR)?HL:HR; return MaxH+1; } else return 0;} 【例3】二元运算表达式树及其遍历 如图6所示。 图6 三种遍历可以得到三种不同的访问结果： （1）中序遍历得到中缀表达式：a + b c + d e + f * g （2）先序遍历得到前缀表达式：+ + a b c + * d e f g （3）后序遍历得到后缀表达式：a b c + d e f + g * + 由此直接将表达式存入链表就可以了。 【例4】由两种遍历序列确定二叉树：已知三种遍历中的任意两种遍历序列，能否唯一确定一棵二叉树呢？ 只需要确保其中一个是中序遍历，就可以唯一确定。如果只有前序遍历、后序遍历，这就不可能找到唯一的。 下面以先序和中序遍历序列来确定一棵二叉树。 先序遍历序列的第一个结点就是根结点。这个根结点能够在中序遍历序列中将其余结点分割成两个子序列，根结点前面部分是左子树上的结点，而根结点后面的部分是右子树上的结点。 根据这两个子序列，在先序序列中找到对应的左子序列和右子序列，它们分别对应左子树和右子树。 然后对左子树和右子树分别递归使用相同的方法继续分解。 9.二叉树的创建 由于树是非线性结构，创建一棵二叉树必须首先确定树种结点的输入顺序，常用的方法是**先序创建**和**层序创建**两种。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"数据结构【浙江大学】（第1节）整理","slug":"datastructure_chapter1","date":"2018-04-03T15:01:58.000Z","updated":"2019-03-21T14:51:37.320Z","comments":false,"path":"2018/04/03/datastructure_chapter1/","link":"","permalink":"http://tech.yushuai.xyz/2018/04/03/datastructure_chapter1/","excerpt":"","text":"第一节：数据结构基本知识1.1 什么是数据结构例：写程序实现一个函数PrintN，使得传入一个正整数位N的参数后，能顺序打印从1道N的全部正整数。 代码1（循环实现）： void PrintN(int N){ int i; for(i =1; i&lt;=N; i++) { printf(“%d\\\\n”,i); } return;} 代码2（递归实现）： void PrintN(int N){ if(N){ PrintN(N-1); printf(“%d\\\\n”,N); } return;} 结论：解决问题方法的效率，跟空间的利用率有关。 例3：写程序计算给定多项式在给定点x处的值 代码： double f(int n, double a[], double x){ int i; double p = a[n]; for(i=n;i&gt;0;i–) { p = a[i-1]+x*p; } return p;} C语言中提供了一个函数为clock()，它捕捉从程序开始运行到clock()被调用时所耗费的时间。这个时钟单位是clock tick。常熟CLK_TCK为机器时钟每秒所周的clock tick。例子如下： #include &lt;stdio.h&gt; #include &lt;time.h&gt;clock_t start,stop;/*clock_t是clock()函数返回的变量类型*/double duration; int main(){ start = clock(); MyFunction();//所需要测量运行时间的函数 stop = clock(); duration = ((double)(stop-start)/CLK_TCK; return 0;} 结论：解决问题方法的效率，跟算法的巧妙程度有关。 什么是数据结构？ 数据对象在计算机中的组织方式。数据对象必定与一系列加在其上面的操作相关联，完成这项操作所用的方法就是算法。 抽象数据类型 抽象是指：描述数据类型的方法不依赖与具体事项，它： ①与存放数据的机器无关；②与数据存储的物理结构无关；③与实现操作的算法和编程语言均无关。 它只描述数据对象集和相关操作集“是什么”，并不涉及“如何做”的问题。 1.2 算法1.什么是算法？ 算法是： （1）一个有限指令集； （2）接受一些输入（有时候也没有输入）； （3）产生输出； （4）一定在有限步骤后终止； （5）每一条指令必须：有充分明确的目标，不可以有歧义；计算机能够处理的范围之内；描述应不依赖于任何一种计算机语言以及具体的实现。 2.什么是好的算法？ 在分析一般算法的效率时，我们经常关注一下两种复杂度： （1）最坏情况复杂度Tworst(n)； （2）平均复杂度Tavg(n)。 3 复杂度的渐进表示法 T(n)=O(f(n))表示存在常数C&gt;0，n0&gt;0使得当n≥n0时有T(n)≤Cf(n)； T(n)=Ω(f(n))表示存在常数C&gt;0，n0&gt;0使得当n≥n0时有T(n)≥Cf(n)； T(n)=θ(h(n))表示同时又T(n)= O(f(n))和T(n)=Ω(f(n))。 不同复杂度函数的感性理解，如表1.1所示。 1.1 不同复杂度函数的规模 函数 1 2 4 8 16 32 1 1 1 1 1 1 1 logn 0 1 2 3 4 5 n 1 2 4 8 16 32 nlogn 0 2 8 24 64 160 _n2_ _1_ _4_ _16_ _64_ _256_ _1024_ _n3_ _1_ _8_ _64_ _512_ _4096_ _32768_ _2n_ _1_ _4_ _16_ _256_ _65536_ _4294967296_ _n!_ _1_ _2_ _24_ _40326_ _2092278988000_ _26313*1033_ 如果复杂度为灰色斜体的部份，要想办法尽可能降到黑色部分。 复杂度分析小窍门： （1）若两段算法分别有复杂度T1(n)=O(f1(n))和T2(n)=O(f2(n))，则 ①两段代码的和T1(n)+T2(n)=max(O(f1(n)), T2(n)=O(f2(n))) ②两段代码嵌套起来T1(n)×T2(n)=O(f1(n)×f2(n))。 （2）若T(n)是关于n的k阶多项式，那么T(n)= θ(nk)。 （3）一个for循环的时间复杂度等于循环次数乘循环体内代码的复杂度。 （4）if-else结构的复杂度取决于if的条件判断复杂度和两个分枝部分的复杂度，总体复杂度取三者中最大。 1.3 应用实例1.例1 复杂度为O(N3) 算法2： int MaxSubseqSum2(int A[], int N){ int ThisSum, MaxSum=0; int i ,j; for(i=0;i&lt;N;i++)/*i是子列左端的位置*/ { ThisSum =0;/*ThisSum是从A[i]dao A[j]的子列和*/ for(j=i; j&lt;N;j++) { ThisSum+=A[j]; /对于相同的i，不同的j，只要把j-1此循环的基础上累加1项即可/ if(ThisSum&gt;MaxSum) MaxSum=ThisSum; } } return MaxSum;} 复杂度为O(N2) 算法3：分而治之 先将这个数组分为两半，分别递归的解决两边的问题。在左边我们会得到一个左边的最大值，右边会得到一个右边的最大值，然后再求一个跨越边界的最大子列和。然后对其进行比较，寻找到最大值。 图2 算法4：在线处理 代码： int MaxSubseqSum4(int A[], int N){ int ThisSum, MaxSum; int i; ThisSum=MaxSum=0; for(i=0;i&lt;N;i++){ ThisSum +=A[i];/向右累加/ if(ThisSum&gt;MaxSum) MaxSum=ThisSum;/发现更大和则更新当前结果/ else if(ThisSum&lt;0)/如果当前子列和为负/ ThisSum=0;/则不可能使后面的部分和增大，抛弃之/ } return MaxSum;} 复杂度为O(N) 为了理解这个算法，举个例子来走一遍过程。假设一组数字为： 序号 0 1 2 3 4 5 6 7 取值 -1 3 -2 4 -6 1 6 -1 刚开始，我们就令ThisSum和MaxSum为0。进入for循环。 i取值 步骤 ThisSum MaxSum 0 ThisSum为-1，-1&lt;0，故抛弃这个值 0 0 1 然后ThisSum加上A[1]，由于之前ThisSum令为0了，所以现在值为3。然后ThisSum&gt;MaxSum，所以把ThisSum赋值给MaxSum，后者等于3。 3 3 2 然后ThisSum加上A[2]，当前和为+1，然后MaxSum&gt;ThisSum，所以不赋值，由于ThisSum为+1，故不抛弃。 +1 3 3 ThisSum加上A[3]，结果为5，然后ThisSum&gt;MaxSum，所以把ThisSum赋值给MaxSum，后者等于5 +5 5 4 ThisSum加上A[4]，结果为-1。此时ThisSum小于MaxSum，所以不改变Max的值。又由于This＜0，故赋值为0。 0 5 5 ThisSum加上A[5]，值为1，此时ThisSum小于MaxSum，所以不改变Max的值。 1 5 6 ThisSum加上A[6]，值为7，此时ThisSum大于MaxSum，所以把ThisSum赋值给MaxSum，后者等于7 7 7 7 ThisSum加上A[7]，值为6，此时ThisSum小于MaxSum，所以不改变Max的值。 6 7 故最大值为7。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://tech.yushuai.xyz/categories/数据结构/"}]},{"title":"TIOBE Index for March 2018[TOP 20]","slug":"tiobe-index-for-march-2018top-20","date":"2018-03-09T09:01:26.000Z","updated":"2019-03-20T14:42:29.911Z","comments":false,"path":"2018/03/09/tiobe-index-for-march-2018top-20/","link":"","permalink":"http://tech.yushuai.xyz/2018/03/09/tiobe-index-for-march-2018top-20/","excerpt":"","text":"Mar 2018 Mar 2017 Change Programming Language Ratings Change 1 1 Java 14.941% -1.44% 2 2 C 12.760% +5.02% 3 3 C++ 6.452% +1.27% 4 5 Python 5.869% +1.95% 5 4 C# 5.067% +0.66% 6 6 Visual Basic .NET 4.085% +0.91% 7 7 PHP 4.010% +1.00% 8 8 JavaScript 3.916% +1.25% 9 12 Ruby 2.744% +0.49% 10 - SQL 2.686% +2.69% 11 11 Perl 2.233% -0.03% 12 10 Swift 2.143% -0.13% 13 9 Delphi/Object Pascal 1.792% -0.75% 14 16 Objective-C 1.774% -0.22% 15 15 Visual Basic 1.741% -0.27% 16 13 Assembly language 1.707% -0.53% 17 17 Go 1.444% -0.54% 18 18 MATLAB 1.408% -0.45% 19 19 PL/SQL 1.327% -0.34% 20 14 R 1.128% -0.89%","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"从头到尾彻底理解KMP[转载]","slug":"e4-bb-8e-e5-a4-b4-e5-88-b0-e5bd-ac-e8-bd-bd","date":"2015-04-22T07:09:13.000Z","updated":"2019-03-20T14:41:07.222Z","comments":false,"path":"2015/04/22/e4-bb-8e-e5-a4-b4-e5-88-b0-e5bd-ac-e8-bd-bd/","link":"","permalink":"http://tech.yushuai.xyz/2015/04/22/e4-bb-8e-e5-a4-b4-e5-88-b0-e5bd-ac-e8-bd-bd/","excerpt":"","text":"从头到尾彻底理解KMP作者：July 原文地址：http://blog.csdn.net/v\\_july\\_v/article/details/7041827 1. 引言本KMP原文最初写于2年多前的2011年12月，因当时初次接触KMP，思路混乱导致写也写得混乱。所以一直想找机会重新写下KMP，但苦于一直以来对KMP的理解始终不够，故才迟迟没有修改本文。 然近期因在北京开了个算法班，专门讲解数据结构、面试、算法，才再次仔细回顾了这个KMP，在综合了一些网友的理解、以及跟我一起讲算法的两位讲师朋友曹博、邹博的理解之后，写了9张PPT，发在微博上。随后，一不做二不休，索性将PPT上的内容整理到了本文之中（后来文章越写越完整，所含内容早已不再是九张PPT 那样简单了）。 KMP本身不复杂，但网上绝大部分的文章（包括本文的2011年版本）把它讲混乱了。下面，咱们从暴力匹配算法讲起，随后阐述KMP的流程 步骤、next 数组的简单求解 递推原理 代码求解，接着基于next 数组匹配，谈到有限状态自动机，next 数组的优化，KMP的时间复杂度分析，最后简要介绍两个KMP的扩展算法。 全文力图给你一个最为完整最为清晰的KMP，希望更多的人不再被KMP折磨或纠缠，不再被一些混乱的文章所混乱，有何疑问，欢迎随时留言评论，thanks。 2. 暴力匹配算法假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？ 如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有： 如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符； 如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。 理清楚了暴力匹配算法的流程及内在的逻辑，咱们可以写出暴力匹配的代码，如下： int ViolentMatch(char s, char p) { int sLen = strlen(s); int pLen = strlen(p); int i = 0; int j = 0; while (i &lt; sLen &amp;&amp; j &lt; pLen) { if (s[i] == p[j]) { //①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++ i++; j++; } else { //②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0 i = i - j + 1; j = 0; } } //匹配成功，返回模式串p在文本串s中的位置，否则返回-1 if (j == pLen) return i - j; else return -1; } 举个例子，如果给定文本串S“BBC ABCDAB ABCDABCDABDE”，和模式串P“ABCDABD”，现在要拿模式串P去跟文本串S匹配，整个过程如下所示： _1._ S[0]为B，P[0]为A，不匹配，执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[1]跟P[0]匹配，相当于模式串要往右移动一位（i=1，j=0） _2_. S[1]跟P[0]还是不匹配，继续执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[2]跟P[0]匹配（i=2，j=0），从而模式串不断的向右移动一位（不断的执行“令i = i - (j - 1)，j = 0”，i从2变到4，j一直为0） _3_. 直到S[4]跟P[0]匹配成功（i=4，j=0），此时按照上面的暴力匹配算法的思路，转而执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，可得S[i]为S[5]，P[j]为P[1]，即接下来S[5]跟P[1]匹配（i=5，j=1） ![](http://img.blog.csdn.net/20140726213602848) _4_. S[5]跟P[1]匹配成功，继续执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，得到S[6]跟P[2]匹配（i=6，j=2），如此进行下去 ![](http://img.blog.csdn.net/20140726213343578) _5_. 直到S[10]为空格字符，P[6]为字符D（i=10，j=6），因为不匹配，重新执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，相当于S[5]跟P[0]匹配（i=5，j=0） ![](http://img.blog.csdn.net/20140726213353687) _6_. 至此，我们可以看到，如果按照暴力匹配算法的思路，尽管之前文本串和模式串已经分别匹配到了S[9]、P[5]，但因为S[10]跟P[6]不匹配，所以文本串回溯到S[5]，模式串回溯到P[0]，从而让S[5]跟P[0]匹配。 而S[5]肯定跟P[0]失配。为什么呢？因为在之前第4步匹配中，我们已经得知S[5] = P[1] = B，而P[0] = A，即P[1] != P[0]，故S[5]必定不等于P[0]，所以回溯过去必然会导致失配。那有没有一种算法，让i 不往回退，只需要移动j 即可呢？ 答案是肯定的。这种算法就是本文的主旨KMP算法，它利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置。 3. KMP算法3.1 定义Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。 下面先直接给出KMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释，越往后看越会柳暗花明☺）： 假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文的3.3.3节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。 很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表j 之前的字符串中有最大长度为_k_ 的相同前缀后缀。 此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next \\[j\\] 的位置）。如果next \\[j\\] 等于0或-1，则跳到模式串的开头字符，若next \\[j\\] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。 转换成代码表示，则是： int KmpSearch(char s, char p) { int i = 0; int j = 0; int sLen = strlen(s); int pLen = strlen(p); while (i &lt; sLen &amp;&amp; j &lt; pLen) { //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || s[i] == p[j]) { i++; j++; } else { //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] //next[j]即为j所对应的next值 j = next[j]; } } if (j == pLen) return i - j; else return -1; } 继续拿之前的例子来说，当S\\[10\\]跟P\\[6\\]匹配失败时，KMP不是跟暴力匹配那样简单的把模式串右移一位，而是执行第②条指令：“如果j != -1，且当前字符匹配失败（即S\\[i\\] != P\\[j\\]），则令 i 不变，j = next\\[j\\]”，即j 从6变到2（后面我们将求得P\\[6\\]，即字符D对应的next 值为2），所以相当于模式串向右移动的位数为j - next\\[j\\]（j - next\\[j\\] = 6-2 = 4）。 向右移动4位后，S[10]跟P[2]继续匹配。为什么要向右移动4位呢，因为移动4位后，模式串中又有个“AB”可以继续跟S[8]S[9]对应着，从 而不用让i 回溯。相当于在除去字符D的模式串子串中寻找相同的前缀和后缀，然后根据前缀后缀求出next 数组，最后基于next 数组进行匹配（不关心next 数组是怎么求来的，只想看匹配过程是咋样的，可直接跳到下文3.3.4节）。 3.2 步骤 ①寻找前缀后缀最长公共元素长度 对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示： 比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k + 1 = 2）。 ②求next数组 next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示： 比 如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b 之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1）。 ③根据next数组进行匹配 匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀pj-k pj-k+1, …, pj-1 跟文本串si-k si-k+1, …, si-1匹配成功，但pj 跟si匹配失败时，因为next[j] = k，相当于在不包含pj的模式串中有最大长度为k 的相同前缀后缀，即p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令j = next[j]，从而让模式串右移j - next[j] 位，使得模式串的前缀p0 p1, …, pk-1对应着文本串 si-k si-k+1, …, si-1，而后让pk 跟si 继续匹配。如下图所示： 综上，KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时，下一步用next \\[j\\] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动 j - next\\[j\\] 位。 接下来，分别具体解释上述3个步骤。 3.3 解释3.3.1 寻找最长前缀后缀如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：![](http://img.blog.csdn.net/20140725231726921) 也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（**下简称《最大长度表》**）： 3.3.2 基于《最大长度表》匹配 因为模式串中首尾可能会有重复的字符，故可得出下述结论： 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值 下面，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。如果给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示： ![](http://img.blog.csdn.net/20140723224710203) 1. 因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功： _2_. 继 续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个 （ABCDAB），然后根据《最大长度表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 = 4 位。 _3_. 模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右移动：2 - 0 =2 位。 ![](http://img.blog.csdn.net/20140721223539765) _4_. A与空格失配，向右移动1 位。 _5_. 继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6 - 2 = 4 位。 ![](http://img.blog.csdn.net/20140721223558140) _6_. 经历第5步后，发现匹配成功，过程结束。 ![](http://img.blog.csdn.net/20140721223611515) 通过上述匹配过程可以看出，问题的关键就是寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是next 数组要表达的含义。 3.3.3 根据《最大长度表》求next 数组由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为： 而且，根据这个表可以得出下述结论 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值 上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。 给定字符串“ABCDABD”，可求得它的next 数组如下： 把next 数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。 换言之，对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下： 根据最大长度表求出了next 数组后，从而有 失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值 而后，你会发现，无论是基于《最大长度表》的匹配，还是基于next 数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？因为： 根据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值 而根据《next 数组》，失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符对应的next 值 其中，从0开始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），而失配字符对应的next 值 = 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。 所以，你可以把《最大长度表》看做是next 数组的雏形，甚至就把它当做next 数组也是可以的，区别不过是怎么用的问题。 3.3.4 通过代码递推计算next 数组接下来，咱们来写代码求下next 数组。 基于之前的理解，可知计算next 数组的方法可以采用递推： _1_. 如果对于值k，已有p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k。 此意味着什么呢？究其本质，next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀。有了这个next 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动j - next[j] 位。 举个例子，如下图，根据模式串“ABCDABD”的next 数组可知失配位置的字符D对应的next 值为2，代表字符D前有长度为2的相同前缀和后缀（这个相同的前缀后缀即为“AB”），失配后，模式串需要向右移动j - next [j] = 6 - 2 =4位。 向右移动4位后，模式串中的字符C继续跟文本串匹配。 2. 下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？ 对于P的前j+1个序列字符： 若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1； 若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] = next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1的前缀”p0 p1, …, pk-1 pk”跟后缀“pj-k pj-k+1, …, pj-1 pj”相等，那么是否可能存在另一个值t+1 &lt; k+1，使得长度更小的前缀 “p0 p1, …, pt-1 pt” 等于长度更小的后缀 “pj-t pj-t+1, …, pj-1 pj” 呢？如果存在，那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组（next [0, …, k, …, j]）进行P串前缀跟P串后缀的匹配。 一般的文章或教材可能就此一笔带过，但大部分的初学者可能还是不能很好的理解上述求解next 数组的原理，故接下来，我再来着重说明下。 如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。 但**如果pk != pj 呢**？ 说明“p0 pk-1 pk” ≠ “pj-k pj-1 pj”。换言之，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next\\[j + 1\\] = next\\[j\\] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。 结合上图来讲，若能**在前缀****“ p0 pk-1 pk ” 中不断的递归前缀索引k = next \\[k\\]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk&apos;-1 pk&apos; = pj-k&apos; pj-1 pj，则最大相同的前缀后缀长度为k&apos; + 1**，从而next \\[j + 1\\] = k’ + 1 = next \\[k&apos; \\] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next \\[j + 1\\] = 0。 那为何递归前缀索引k = next\\[k\\]，就能找到长度更小的相同前缀后缀呢？这又归根到next数组的含义。**为 了寻找长度相同的前缀后缀，我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p\\[next\\[k\\]\\] 去跟pj 继续匹配，如果p\\[ next\\[k\\] \\]跟pj还是不匹配，则下一步用p\\[ next\\[ next\\[k\\] \\] \\]去跟pj匹配**。相当于模式串的自我匹配，所以不断的递归k = next\\[k\\]，直到要么找到长度更小的相同前缀后缀，要么没有长度更小的相同前缀后缀。 所以，因最终在前缀ABC中没有找到D，故E的next 值为0： 模式串的后缀：ABDE 模式串的前缀：ABC 前缀右移两位： ABC 读到此，有的读者可能又有疑问了，那能否举一个能在前缀中找到字符D的例子呢？OK，咱们便来看一个能在前缀中找到字符D的例子，如下图所示： 给定模式串DABCDABDE，我们很顺利的求得字符D之前的“DABCDAB”的各个子串的最长相同前缀后缀的长度分别为0 0 0 0 1 2 3，但当遍历到字符D，要求包括D在内的“DABCDABD”最长相同前缀后缀时，我们发现pj处的字符D跟pk处的字符C不一样，换言之，前缀DABC 的最后一个字符C 跟后缀DABD的最后一个字符D不相同，所以不存在长度为4的相同前缀后缀。 怎么办呢？既然没有长度为4的相同前缀后缀，咱们可以寻找长度短点的相同前缀后缀，最终，因在p0处发现也有个字符D，p0 = pj，所以p\\[j\\]对应的长度值为1，相当于E对应的next 值为1。 综上，可以通过递推求得next 数组，代码如下所示： void GetNext(char* p,int next[]) { int pLen = strlen(p); next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1) { //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) { ++k; ++j; next[j] = k; } else { k = next[k]; } } } 用代码重新计算下“ABCDABD”的next 数组，以验证之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为-1”得到的next 数组是否正确，计算结果如下表格所示： 从上述表格可以看出，无论是之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为-1”得到的next 数组，还是之后通过代码递推计算求得的next 数组，结果是完全一致的。 3.3.5 基于《next 数组》匹配下面，我们来基于next 数组进行匹配。 还是给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示： 在正式匹配之前，让我们来再次回顾下上文2.1节所述的KMP算法的匹配流程： “假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。” _1_. 最开始匹配时 P[0]跟S[0]匹配失败 所 以执行“如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]”，所以j = -1，故转而执行“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++”，得到i = 1，j = 0，即P[0]继续跟S[1]匹配。 P[0]跟S[1]又失配，j再次等于-1，i、j继续自增，从而P[0]跟S[2]匹配。 P[0]跟S[2]失配后，P[0]又跟S[3]匹配。 P[0]跟S[3]再失配，直到P[0]跟S[4]匹配成功，开始执行此条指令的后半段：“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++”。 2. P[1]跟S[5]匹配成功，P[2]跟S[6]也匹配成功, …，直到当匹配到P[6]处的字符D时失配（即S[10] != P[6]），由于P[6]处的D对应的next 值为2，所以下一步用P[2]处的字符C继续跟S[10]匹配，相当于向右移动：j - next[j] = 6 - 2 =4 位。 _3_. 向右移动4位后，P[2]处的C再次失配，由于C对应的next值为0，所以下一步用P[0]处的字符继续跟S[10]匹配，相当于向右移动：j - next[j] = 2 - 0 = 2 位。 _4_. 移动两位之后，A 跟空格不匹配，模式串后移1 位。 _5_. P[6]处的D再次失配，因为P[6]对应的next值为2，故下一步用P[2]继续跟文本串匹配，相当于模式串向右移动 j - next[j] = 6 - 2 = 4 位。 _6_. 匹配成功，过程结束。 匹配过程一模一样。也从侧面佐证了，next 数组确实是只要将各个最大前缀后缀的公共元素的长度值右移一位，且把初值赋为-1 即可。 3.3.6 基于《最大长度表》与基于《next 数组》等价我们已经知道，利用next 数组进行匹配失配时，模式串向右移动 j - next [ j ] 位，等价于已匹配字符数 - 失配字符的上一位字符所对应的最大长度值。原因是： j 从0开始计数，那么当数到失配字符时，j 的数值就是已匹配的字符数； 由于next 数组是由最大长度值表整体向右移动一位（且初值赋为-1）得到的，那么失配字符的上一位字符所对应的最大长度值，即为当前失配字符的next 值。 但为何本文不直接利用next 数组进行匹配呢？因为next 数组不好求，而一个字符串的前缀后缀的公共元素的最大长度值很容易求。例如若给定模式串“ababa”，要你快速口算出其next 数组，乍一看，每次求对应字符的next值时，还得把该字符排除之外，然后看该字符之前的字符串中有最大长度为多大的相同前缀后缀，此过程不够直接。而如 果让你求其前缀后缀公共元素的最大长度，则很容易直接得出结果：0 0 1 2 3，如下表格所示： 然后这5个数字 全部整体右移一位，且初值赋为-1，即得到其next 数组：-1 0 0 1 2。 3.3.7 Next 数组与有限状态自动机next 负责把模式串向前移动，且当第j位不匹配的时候，用第next[j]位和主串匹配，就像打了张“表”。此外，next 也可以看作有限状态自动机的状态，在已经读了多少字符的情况下，失配后，前面读的若干个字符是有用的。 3.3.8 Next 数组的优化行文至此，咱们全面了解了暴力匹配的思路、KMP算法的原理、流程、流程之间的内在逻辑联系，以及next 数组的简单求解（《最大长度表》整体右移一位，然后初值赋为-1）和代码求解，最后基于《next 数组》的匹配，看似洋洋洒洒，清晰透彻，但以上忽略了一个小问题。 比如，如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1（0 0 1 2整体右移一位，初值赋为-1），当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。 右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？ 问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失 配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。 所以，咱们得修改下求next 数组的代码。 //优化过后的next 数组求法 void GetNextval(char* p, int next[]) { int pLen = strlen(p); next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1) { //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) { ++j; ++k; //较之前next数组求法，改动在下面4行 if (p[j] != p[k]) next[j] = k; //之前只有这一行 else //因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]] next[j] = next[k]; } else { k = next[k]; } } } 利用优化过后的next 数组求法，可知模式串“abab”的新next数组为：-1 0 -1 0。可能有些读者会问：原始next 数组是前缀后缀最长公共元素长度值右移一位， 然后初值赋为-1而得，那么优化后的next 数组如何快速心算出呢？实际上，只要求出了原始next 数组，便可以根据原始next 数组快速求出优化后的next 数组。还是以abab为例，如下表格所示： 只要出现了p[next[j]] = p[j]的情况，则把next[j]的值再次递归。例如在求模式串“abab”的第2个a的next值时，如果是未优化的next值的话，第2个a对应的next值为0，相当于第2个a失配时，下一步匹配模式串会用p[0]处的a再次跟文本串匹配，必然失配。所以求第2个a的next值时，需要再次递归：next[2] = next[ next[2] ] = next[0] = -1（此后，根据优化后的新next值可知，第2个a失配时，执行“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符”），同理，第2个b对应的next值为0。 对于优化后的next数组可以发现一点：如果模式串的后缀跟前缀相同，那么它们的next值也是相同的，例如模式串abcabc，它的前缀后缀都是abc，其优化后的next数组为：-1 0 0 -1 0 0，前缀后缀abc的next值都为-1 0 0。 然后引用下之前3.1节的KMP代码： int KmpSearch(char s, char p) { int i = 0; int j = 0; int sLen = strlen(s); int pLen = strlen(p); while (i &lt; sLen &amp;&amp; j &lt; pLen) { //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || s[i] == p[j]) { i++; j++; } else { //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] //next[j]即为j所对应的next值 j = next[j]; } } if (j == pLen) return i - j; else return -1; } 接下来，咱们继续拿之前的例子说明，整个匹配过程如下： _1_. S[3]与P[3]匹配失败。 _ 2_. S[3]保持不变，P的下一个匹配位置是P[next[3]]，而next[3]=0，所以P[next[3]]=P[0]与S[3]匹配。 _3_. 由 于上一步骤中P[0]与S[3]还是不匹配。此时i=3，j=next [0]=-1，由于满足条件j==-1，所以执行“++i, ++j”，即主串指针下移一个位置，P[0]与S[4]开始匹配。最后j==pLen，跳出循环，输出结果i - j = 4（即模式串第一次在文本串中出现的位置），匹配成功，算法结束。 3.4 KMP的时间复杂度分析相信大部分读者读完上文之后，已经发觉其实理解KMP非常容易，无非是循序渐进把握好下面几点： 如果模式串中存在相同前缀和后缀，即pj-k pj-k+1, …, pj-1 = p0 p1, …, pk-1，那么在pj跟si失配后，让模式串的前缀p0 p1…pk-1对应着文本串si-k si-k+1…si-1，而后让pk跟si继续匹配。 之前本应是pj跟si匹配，结果失配了，失配后，令pk跟si匹配，相当于j 变成了k，模式串向右移动j - k位。 因 为k 的值是可变的，所以我们用next[j]表示j处字符失配后，下一次匹配模式串应该跳到的位置。换言之，失配前是j，pj跟si失配时，用p[ next[j] ]继续跟si匹配，相当于j变成了next[j]，所以，j = next[j]，等价于把模式串向右移动j - next [j] 位。 而next[j]应该等于多少呢？next[j]的值由j 之前的模式串子串中有多大长度的相同前缀后缀所决定，如果j 之前的模式串子串中（不含j）有最大长度为k的相同前缀后缀，那么next [j] = k。 如之前的图所示： 接下来，咱们来分析下KMP的时间复杂度。分析之前，先来回顾下KMP匹配算法的流程： “KMP的算法流程： 假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。” 我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++、j++；如果匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。 所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。 4. 扩展1：BM算法KMP的匹配是从模式串的开头开始匹配的，而1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了一种新的字符串匹配算法：Boyer-Moore算法，简称BM算法。该算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的 时间复杂度。在实践中，比KMP算法的实际效能高。 BM算法定义了两个规则： 坏字符规则：当文本串中的某 个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为-1。 好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。 下面举例说明BM算法。例如，给定文本串“HERE IS A SIMPLE EXAMPLE”，和模式串“EXAMPLE”，现要查找模式串是否在文本串中，如果存在，返回模式串在文本串中的位置。 _1_. 首 先，”文本串”与”模式串”头部对齐，从尾部开始比较。”S”与”E”不匹配。这时，”S”就被称为”坏字符”（bad character），即不匹配的字符，它对应着模式串的第6位。且”S”不包含在模式串”EXAMPLE”之中（相当于最右出现位置是-1），这意味着 可以把模式串后移6-(-1)=7位，从而直接移到”S”的后一位。 _2_. 依 然从尾部开始比较，发现”P”与”E”不匹配，所以”P”是”坏字符”。但是，”P”包含在模式串”EXAMPLE”之中。因为“P”这个“坏字符”对应 着模式串的第6位（从0开始编号），且在模式串中的最右出现位置为4，所以，将模式串后移6-4=2位，两个”P”对齐。 _3_. 依次比较，得到 “MPLE”匹配，称为”好后缀”（good suffix），即所有尾部匹配的字符串。注意，”MPLE”、”PLE”、”LE”、”E”都是好后缀。 _4_. 发现“I”与“A”不匹配：“I”是坏字符。如果是根据坏字符规则，此时模式串应该后移2-(-1)=3位。问题是，有没有更优的移法？ _5_. 更优的移法是利用好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串中上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。 所有的“好后缀”（MPLE、PLE、LE、E）之中，只有“E”在“EXAMPLE”的头部出现，所以后移6-0=6位。 可以看出，“坏字符规则”只能移3位，“好后缀规则”可以移6位。每次后移这两个规则之中的较大值。这两个规则的移动位数，只与模式串有关，与原文本串无关。 _6_. 继续从尾部开始比较，“P”与“E”不匹配，因此“P”是“坏字符”，根据“坏字符规则”，后移 6 - 4 = 2位。因为是最后一位就失配，尚未获得好后缀。 由上可知，BM算法不仅效率高，而且构思巧妙，容易理解。 5. 扩展2：Sunday算法上文中，我们已经介绍了KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数 strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，本文最后再介绍一种比BM算法更快的查 找算法即Sunday算法。 Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似： 只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1； 否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。 下面举个例子说明下Sunday算法。假定现在要在文本串”substring searching algorithm”中查找模式串”search”。 _1_. 刚开始时，把模式串与文本串左边对齐： substring searching algorithm search ^ _2_. 结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图： substring searching algorithm search ^ _3_. 结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下： substring searching algorithm search ^ _4_. 匹配成功。 回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比较大，效率很高。完。 6. 参考文献 《算法导论》的第十二章：字符串匹配； 本文中模式串“ABCDABD”的部分图来自于此文：http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html； 本文3.3.7节中有限状态自动机的图由微博网友@龚陆安 绘制：http://d.pr/i/NEiz； 北京7月暑假班邹博半小时KMP视频：http://v.youku.com/v_show/id_XNzQzMjQ1OTYw.html； 北京7月暑假班邹博第二次课的PPT：http://yun.baidu.com/s/1mgFmw7u； 理解KMP 的9张PPT：http://weibo.com/1580904460/BeCCYrKz3#_rnd1405957424876； 详解KMP算法（多图）：http://www.cnblogs.com/yjiyjige/p/3263858.html； 本文第4部分的BM算法参考自此文：http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html； http://youlvconglin.blog.163.com/blog/static/5232042010530101020857； 《数据结构 第二版》，严蔚敏 &amp; 吴伟民编著； http://blog.csdn.net/v_JULY_v/article/details/6545192； http://blog.csdn.net/v_JULY_v/article/details/6111565； Sunday算法的原理与实现：http://blog.chinaunix.net/uid-22237530-id-1781825.html； 模式匹配之Sunday算法：http://blog.csdn.net/sunnianzhong/article/details/8820123； 一篇KMP的英文介绍：http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm； 我2014年9月3日在西安电子科技大学的面试&amp;算法讲座视频（第36分钟~第94分钟讲KMP）：http://v.youku.com/v_show/id_XNzc2MDYzNDg4.html。 7. 后记对之前混乱的文章给广大读者带来的困扰表示致歉，对重新写就后的本文即将给读者带来的清晰表示欣慰。希望大部分的初学者，甚至少部分的非计算机专业读者也能看懂此文。有任何问题，欢迎随时批评指正，thanks。 July、二零一四年八月二十二日晚九点。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++：实现“鱼额宝”","slug":"c-ef-bc-9a-e5-ae-9e-e7-8e-b0-e9-b1-bc-e9-a2-9d-e5-ae-9d","date":"2015-04-20T08:37:40.000Z","updated":"2019-03-20T14:40:01.996Z","comments":false,"path":"2015/04/20/c-ef-bc-9a-e5-ae-9e-e7-8e-b0-e9-b1-bc-e9-a2-9d-e5-ae-9d/","link":"","permalink":"http://tech.yushuai.xyz/2015/04/20/c-ef-bc-9a-e5-ae-9e-e7-8e-b0-e9-b1-bc-e9-a2-9d-e5-ae-9d/","excerpt":"","text":"题目描述 请实现一个“鱼额宝”类，下面已给出代码模板，请根据main函数中对该类的操作，补充类实现部分完成代码。 “鱼额宝”类可以记录账户余额、存钱、取钱、计算利息。该类中有一个私有静态成员变量profitRate存储“鱼额宝”的利率，可以用共有静态成员函数setProfitRate修改利率的值。程序输入为第1天至第n天连续n天的账户操作，每天只能进行一次账户操作，或存或取，每一天产生的利息是前一天的账户余额与“鱼额宝”利率的乘积，产生的利息当天也将存入账户余额，由于第1天之前账户不存在，所以第1天一定是新建账户并存钱，且当天不会有利息存入余额。程序在接受n天操作的输入后，要求计算出第n天操作完成后的账户余额并输出。 输入描述 每个测例共n+2行 第1行输入一个整数n，表示接下来有n天的操作 第2行输入一个实数，为“鱼额宝”的利率，n天中利率不变 接下来有n行，代表n天的操作，每行有2个数，第1个数或0或1，0表示存钱，1表示取钱，第二个实数为存取的金额 1 &lt;= n &lt;= 20 输出描述 对于每一个测例，输出第n天操作完成后的账户余额 样例输入 30.10 100 101 10 样例输出 13.1 程序代码 #include using namespace std; class Yuebao { static double profitRate; double yu_e; public: static void setProfitRate(double rate) {profitRate = rate ;} Yuebao(double a=0):yu_e(0) {} void addProfit() { yu_e += (yu_e * profitRate); } void deposit(double a) { yu_e += a; } void withdraw(double a) { yu_e -= a; } double getBalance() { return yu_e; } }; double Yuebao::profitRate = 0; int main() { int n; while(cin &gt;&gt; n) { double profitRate; cin &gt;&gt; profitRate; Yuebao::setProfitRate(profitRate);//设定鱼额宝的利率 Yuebao y(0); //新建鱼额宝账户，余额初始化为0 int operation;//接受输入判断是存还是取 double amount;//接受输入存取金额 for (int i = 0; i &lt; n; ++i) { y.addProfit();//加入前一天余额产生的利息 cin &gt;&gt; operation &gt;&gt; amount; if (operation == 0) y.deposit(amount);//存入金额 else y.withdraw(amount);//取出金额 } cout &lt;&lt; y.getBalance() &lt;&lt; endl;//输出最终账户余额 } return 0; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"第四章：类与对象（三）析构函数","slug":"e7-ac-ac-e5-9b-9b-e7-88-e4-b8-89-ef-bc-89-e6-9e-90-e6-9e-84-e5-87-bd-e6-95-b0","date":"2015-04-08T12:00:57.000Z","updated":"2019-03-20T14:38:59.130Z","comments":false,"path":"2015/04/08/e7-ac-ac-e5-9b-9b-e7-88-e4-b8-89-ef-bc-89-e6-9e-90-e6-9e-84-e5-87-bd-e6-95-b0/","link":"","permalink":"http://tech.yushuai.xyz/2015/04/08/e7-ac-ac-e5-9b-9b-e7-88-e4-b8-89-ef-bc-89-e6-9e-90-e6-9e-84-e5-87-bd-e6-95-b0/","excerpt":"","text":"析构函数完成对象被删除前的一些清理工作。比如说因为这个对象打开了一个文件，那么用了这个就可以关闭文件。在对象生存期结束之时，系统自动调用析构函数。如果程序中未定义析构函数，则编译器自动产生一个默认的析构函数，它的函数体是空的，我们可以简单认为它是什么都不做的。语法规定了构造函数时一定需要一个构造函数，删除的时候一定要构造一个析构函数，这是为什么我们不定义，系统也会给我们定义构造函数和析构函数。 析构函数原型： ~ 类名; 析构函数没有参数，没有返回值类型。 例如： class Point { public: Point(int xx, int yy); ~Point(); private: int hour; }; Point::Point(int xx, int yy) { 内容 } Point::~Point(){ }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++递归用法","slug":"c-e9-80-92-e5-bd-92-e7-94-a8-e6-b3-95","date":"2015-04-08T11:43:43.000Z","updated":"2019-03-20T14:40:05.549Z","comments":false,"path":"2015/04/08/c-e9-80-92-e5-bd-92-e7-94-a8-e6-b3-95/","link":"","permalink":"http://tech.yushuai.xyz/2015/04/08/c-e9-80-92-e5-bd-92-e7-94-a8-e6-b3-95/","excerpt":"","text":"很多初学者往往对递归迷惑不解，也在这上面花了不少的时间。其实教材上的例子很经典，只是它说的有一些唠叨了。初学者会看的头大的。编程是解决问题的，而现实中很多的问题都是比较简单的，没有象汉诺塔那么复杂。我们也不必追究递归到底是怎样实现的，我们只是要会用递归，会用递归来为我们解决一些问题，这就行了。 首先来看一个例子： 有一个Febonacci序列： 1,1,2,3,5,8,13,,21,34…….. 它的问题是：求这个序列中的第N个数。 由于它的函数原形是：f(N)=f(n-1)+f(n-2) 这用递归很容易就可以写出代码来，一点都不费事： int Febc(int n) { if(n&lt;3) return (1); else return (Febc(n-1)+Febc(n-2)); } 噢~也许你会说递归真是太简单了，简直就是一个数学模型嘛，呵呵。 其实，递归函数的工作过程就是自己调用自己。有一些问题用递归就很容易解决，简单的你自己都会吃惊。 我们做事情，一般都是从头开始的，而递归却是从末尾开始的。比如上面的函数吧，当n&gt;3时，它显然只能求助于n-1,n-2。而(n-1)&gt;2,(n-2)&gt;2时，它们就求助于：(n-1)-1,(n-1)-2;(n-2)-1,(n-2)-2;然后··············直到（n-k)&lt;3,(n-k-1)&lt;3时，函数Febc终于有了返回值1 了，它再从头开始计算，然后一直算到n 为止。 通过上面的例子，我们知道递归一定要有一个停止的条件，否则递归就不知道停止了。在上面的例子中， if(n&lt;3) return (1); 就是停止的条件。 然而，使用递归的代价是十分巨大的：它会消耗大量的内存！！递归循环时它用的是堆栈，而堆栈的资源是十分有限的。上面的例子你只能用一个很小的n值。如果n=20，即Febc(20)的话，它将调用Febc(N)函数10000多次！！！而上面一个例子用循环也是十分容易写的： /*using turboc2*/ int febc(int); main() { int n; scanf(“%d”,&amp;n); febc(N); } int febc(int n) { int a[3],i; a[0]=a[1]=a[2]=1; for(i=3;i&lt;=n;i++) a[i%3]=a[(i+1)%3]+a[(i+2)%3]; /实现 Febc(I)=Febc(i-1)+Febc(i-2)/ printf(“\\\\n%d\\\\n”,a[n%3]); } 有兴趣者不妨输入一个较大的n值，然后比较比较这二个函数计算的速度。当然， 如果你使用的n太大的话，递归可能发生错误。如果死机了可别骂我哦~~~ 我已经提醒过你了 ：） 现在我们再来看看一个求从1 加到100的循环： /*turboc2*/ main() { int i,n; for(i=1;i&lt;101;i++) n+=i; } 这很简单没什么可说的。 但是，你能不能写出相应的递归函数呢？ 下面就是递归（请注意了，这种做法不推荐！！ 我只是为了说明问题才这么写的。） /*using Turboc2*/ int a=0; int account(int); main() { account(100); printf(“%d”,a); } int account(int i) { if(i==1) return 1; /停止条件/ else return (n+f(n-1)); /此句有问题/ } 在C/C++的问题中，我曾经回答过这样的一个问题： 若一头小母牛，从出生起第四个年头开始每年生一头母牛，按此规律，第n年时有多少头母牛？ 请问如何用递归涵数求此问题？ 先写出函数表达式：f(N)=f(n-1)+f(n-3) 为什么f(N)=f(n-1)+f(n-3)呢，请看： f(N)-f(n-1)=f(n-3) 因为第n年要比n-1年多的牛，都是大于三岁的牛生的小牛，而f(n-3)正是那些在n年大于三岁的牛，然后它们在第n年生下相同数量的小牛。（请用BorlandC++3.1或其他C++编译器） #include&lt;iostream.h&gt; #include&lt;conio.h&gt; int cattle(int,int); void main() { int ct,n; cout&lt;&lt;”Please input the original cattle number:”&lt;&lt;endl; /输入起始牛的数量/ cin&gt;&gt;ct; cout&lt;&lt;”Input how many years it past:”&lt;&lt;endl; cin&gt;&gt;n; cout&lt;&lt;”You have “&lt;&lt;cattle(ct,n)&lt;&lt;” cattle now!”&lt;&lt;endl; getch(); } int cattle(int ct,int n) { if(n&lt;4) return (ct); /停止条件/ else return (cattle(ct,n-1)+cattle(ct,n-3)); /实现递归/ } 怎么样，很简单吧。 会用循环求解吗？ 递归在实际的编程中并不常用，但是在某些情况下，它是非常强有力而漂亮的工具。掌握它的原理时会十分有用的。 转自： 其它参考： 1、 http://www.nbrkb.net/lwt/jsjsj/sjjg&amp;sf/c++dgyf.htm 2、 http://www.e-van.net/c-prog-hannuo.html 3、 http://www.cppblog.com/haosola/archive/2009/11/17/101163.aspx 4、 http://www.cnblogs.com/eslizn/archive/2011/05/29/2062043.html 5、 http://edu.3gmgc.com/tuwenjiaocheng/C__/diwuzhang_hanshuyuyuchuli/455.html 6、 http://www.asp119.com/program/ccc/2010-09-25/570.html 7、 http://comapp.ecjtu.jx.cn/view.php?id=45 8、 http://webservices.ctocio.com.cn/35/11398035.shtml 9、 http://www.gzu521.com/campus/article/it/200701/139273.htm 转自：http://bbs.ikaka.com/showtopic-664019.aspx","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"第四章：类与对象（二）构造函数","slug":"e7-ac-ac-e5-9b-9b-e7-ab-a0-ef-bc-9a-e7-b1-bb-80-a0-e5-87-bd-e6-95-b0","date":"2015-04-08T09:32:11.000Z","updated":"2019-03-20T14:38:54.909Z","comments":false,"path":"2015/04/08/e7-ac-ac-e5-9b-9b-e7-ab-a0-ef-bc-9a-e7-b1-bb-80-a0-e5-87-bd-e6-95-b0/","link":"","permalink":"http://tech.yushuai.xyz/2015/04/08/e7-ac-ac-e5-9b-9b-e7-ab-a0-ef-bc-9a-e7-b1-bb-80-a0-e5-87-bd-e6-95-b0/","excerpt":"","text":"构造函数的作用 在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态。 例如：希望在构造一个Clock类对象时，将初试时间设为0:0:0，就可以通过构造函数来设置。 构造函数的形式 函数名与类名相同； 不能定义返回值类型，也不能有return语句； 可以有形式参数，也可以没有形式参数； 可以是内联函数； 可以重载； 可以带默认参数值。 构造函数的调用时机 在对象创建时被自动调用 例如： Clock myClock（0,0,0）; 默认构造函数 调用时可以不需要实参的构造函数 参数表为空的构造函数 全部参数都有默认值的构造函数 下面两个都是默认构造函数，如在类中同时出现，将产生编译错误： Clock(); Clock(int newH=0,int newM=0,int newS=0); 隐含生成的构造函数 如果程序中未定义构造函数，编译器将在需要时自动生成一个默认构造函数 参数列表为空，不为数据成员设置初始值； 如果类内定义了成员的初始值，则使用内类定义的初始值； 如果没有定义类内的初始值，则以默认方式初始化； 基本类型的数据默认初始化的值是不确定的。 “=default” 如果程序中未定义构造函数，默认情况下编译器就不再隐含生成默认构造函数。如果此时依然希望编译器隐含生成默认构造函数，可以使用“=default”。 例如 class Clock { public: Clock() =default; //指示编译器提供默认构造函数 Clock(int newH, int newM, int newS); //构造函数 private: int hour, minute, second; }; 例1： //类定义 class Clock { public: Clock(int newH,int newM,int newS);//构造函数 void setTime(int newH, int newM, int newS); void showTime(); private: int hour, minute, second; }; //构造函数的实现： Clock::Clock(int newH,int newM,int newS): hour(newH),minute(newM), second(newS) { } //简单的赋值，不必要在大括号里面赋值。 //其它函数实现同例4_1 int main() { Clock c(0,0,0); //自动调用构造函数 c.showTime(); return 0; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"第四章：类与对象（一）","slug":"e7-ac-ac-e5-9b-9b-e7-ab-a0-ef-bc-9a","date":"2015-04-08T08:58:34.000Z","updated":"2019-03-20T14:39:03.151Z","comments":false,"path":"2015/04/08/e7-ac-ac-e5-9b-9b-e7-ab-a0-ef-bc-9a/","link":"","permalink":"http://tech.yushuai.xyz/2015/04/08/e7-ac-ac-e5-9b-9b-e7-ab-a0-ef-bc-9a/","excerpt":"","text":"一、面向对象程序的基本特点 1.抽象。抽象又分为数据抽象和代码抽象。 以钟表为例： 数据抽象：描述某类对象的属性或状态（对象相互区别的物理量），如int hour, int minute, int second等。 代码抽象：描述某类对象的共有的行为特征或具有的功能，如setTime() ， showTime()等。 封装：将抽象出的数据、代码封装在一起，形成类。 目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。 实现封装：类声明中的{} 例如： class Clock { public: void setTime(int newH, int newM, int newS); void showTime(); private: int hour, minute, second; }; public函数提供了类对外的访问接口，setTime()和showTime()是外部访问接口。private里面几个数据则是隐藏在类里面的，从外面看不到的。 2、继承。在已有类的基础上，进行扩展形成新的类。 3、多态：同一名称，不同的功能实现方式。 目的：达到行为标识统一，减少程序中标识符的个数。 实现：重载函数和虚函数 二、类与对象 类与对象的定义 对象是现实中的对象在程序中的模拟。 类是同一类对象的抽象，对象时类的某一特定实体。通过定义类的对象，才可以通过对象使用类中定义的功能。 设计一个类就是设计一个类型。 类的定义： class 类名称 { public: 公有成员（外部接口） private: 私有成员 protected: 保护型成员 } 初始化类内对象值： class Clock { public: void setTime(int newH, int newM, int newS); void showTime(); private: int hour = 0, minute = 0, second = 0; }; Ⅰ公有类型成员 在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。 Ⅱ 私有类型成员 在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。 Ⅲ保护类型成员 与private类似，其差别表现在继承与派生时对派生类的影响不同，详见第七章。 对象定义的语法 类名 对象名； 例：Clock myClock; 类成员的访问权限 类中成员互相访问：直接使用成员名访问 类外访问：使用“对象名.成员名”方式访问 public 属性的成员 类的成员函数 在类中说明函数原型； 可以在类外给出函数体实现，并在函数名前使用类名加以限定； 也可以直接在类中给出函数体，形成内联成员函数； 允许声明重载函数和带默认参数值的函数。 内联成员函数 为了提高运行时的效率，对于较简单的函数可以声明为内联形式。 内联函数体中不要有复杂结构（如循环语句和switch语句）。 在类中声明内联成员函数的方式： 将函数体放在类的声明中。 使用inline关键字。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++第二周程序设计作业","slug":"c-e7-ac-ac-e4-ba-8c-e5-91-a8-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e4-bd-9c-e4-b8-9a","date":"2015-03-16T12:46:58.000Z","updated":"2019-03-20T14:40:54.667Z","comments":false,"path":"2015/03/16/c-e7-ac-ac-e4-ba-8c-e5-91-a8-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e4-bd-9c-e4-b8-9a/","link":"","permalink":"http://tech.yushuai.xyz/2015/03/16/c-e7-ac-ac-e4-ba-8c-e5-91-a8-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e4-bd-9c-e4-b8-9a/","excerpt":"","text":"Question 1： 题目描述 任意给定n个整数，求这n个整数序列的和、最小值、最大值 输入描述 输入一个整数n，代表接下来输入整数个数，n&lt;=100,接着输入n个整数，整数范围是-10000~10000。 输出描述 输出整数序列的和、最小值、最大值。用空格隔开，占一行 代码： #include using namespace std; int main() { int n,i,b,max,min; int s=0; int a[100]; cin &gt;&gt; n; for(i=0;i&lt;n;i++) { cin &gt;&gt; b; a[i]=b; } for(i=0;i&lt;n;i++) s=s+a[i]; max=a[0]; for(i=1;i&lt;n;i++) { if(a[i]&gt;max) max=a[i]; } min=a[0]; for(i=1;i&lt;n;i++) { if(a[i]&lt;min) min=a[i]; } cout &lt;&lt; s &lt;&lt; ‘ ‘ &lt;&lt; min &lt;&lt; ‘ ‘ &lt;&lt; max; return 0; } Question 2： 题目描述 打印n阶实心菱形 输入描述 输入一个整数n，n&lt;=10 输出描述 输出n阶实心菱形，占2n-1行 代码： #include using namespace std; int main() { int n,i,j,m,h,b; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=n-i;j++) cout &lt;&lt; ‘ ‘; for(j=1;j&lt;=(2\\i-1);j++) cout &lt;&lt; ‘*‘; cout &lt;&lt; ‘\\\\n’; } for(h=1;h&lt;n;h++) { for(m=1;m&lt;=h;m++) cout &lt;&lt; ‘ ‘; for(b=(2(n-h)-1);b&gt;0;b–) cout &lt;&lt; ‘‘; cout &lt;&lt; ‘\\\\n’; } return 0; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"TIOBE Index for March 2015[TOP 20]","slug":"tiobe-index-for-march-2015top-20","date":"2015-03-15T06:53:39.000Z","updated":"2019-03-20T14:42:32.989Z","comments":false,"path":"2015/03/15/tiobe-index-for-march-2015top-20/","link":"","permalink":"http://tech.yushuai.xyz/2015/03/15/tiobe-index-for-march-2015top-20/","excerpt":"","text":"TIOBE Software: Tiobe Index // &lt;![CDATA[ urlPageName=”tiobe_index”;urlBase=”/“; // ]]&gt;// &lt;![CDATA[ var _gaq = _gaq || []; _gaq.push([‘_setAccount’, ‘UA-18555865-1’]); _gaq.push([‘_trackPageview’]); (function() { var ga = document.createElement(‘script’); ga.type = ‘text/javascript’; ga.async = true; ga.src = (‘https:’ == document.location.protocol ? ‘https://ssl&#39; : ‘http://www&#39;) + ‘.google-analytics.com/ga.js’; var s = document.getElementsByTagName(‘script’)[0]; s.parentNode.insertBefore(ga, s); })(); // ]]&gt; Mar 2015 Mar 2014 Change Programming Language Ratings Change 1 1 C 16.642% -0.89% 2 2 Java 15.580% -0.83% 3 3 Objective-C 6.688% -5.45% 4 4 C++ 6.636% +0.32% 5 5 C# 4.923% -0.65% 6 6 PHP 3.997% +0.30% 7 9 JavaScript 3.629% +1.73% 8 8 Python 2.614% +0.59% 9 10 Visual Basic .NET 2.326% +0.46% 10 - Visual Basic 1.949% +1.95% 11 12 F# 1.510% +0.29% 12 13 Perl 1.332% +0.18% 13 15 Delphi/Object Pascal 1.154% +0.27% 14 11 Transact-SQL 1.149% -0.33% 15 21 Pascal 1.092% +0.41% 16 31 ABAP 1.080% +0.70% 17 19 PL/SQL 1.032% +0.32% 18 14 Ruby 1.030% +0.06% 19 20 MATLAB 0.998% +0.31% 20 45 R 0.951% +0.72% 来源：http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C++：自定义类型与不定作用域枚举知识点","slug":"c-ef-bc-9a-e8-87-aa-e5-ae-9a-e4-b9-89-e7-b1-bb-e5-9e-8b-e4-b-82-b9","date":"2015-03-15T04:31:17.000Z","updated":"2019-03-20T14:39:57.382Z","comments":false,"path":"2015/03/15/c-ef-bc-9a-e8-87-aa-e5-ae-9a-e4-b9-89-e7-b1-bb-e5-9e-8b-e4-b-82-b9/","link":"","permalink":"http://tech.yushuai.xyz/2015/03/15/c-ef-bc-9a-e8-87-aa-e5-ae-9a-e4-b9-89-e7-b1-bb-e5-9e-8b-e4-b-82-b9/","excerpt":"","text":"类型别名：为已有类型另外命名 typedef 已有类型名 新类型名表 例： typedef double Area, Volume; typedef int Natural; Natural i1,i2; Area a; Volume v; l using 新类型名 = 已有类型名; 例： using Area = double; using Volume = double; 枚举类型 定义方式： 将全部可取值一一列举出来。 语法形式： enum 枚举类型名 {变量值列表}; 例：enum Weekday {SUN, MON, TUE, WED, THU, FRI, SAT}; 默认情况下 SUN=0，MON=1，TUE=2，……，SAT=6 C++包含两种枚举类型： 不限定作用域枚举类型： enum 枚举类型名 {变量值列表}; 限定作用域的enum类将在第4章介绍。 不限定作用域枚举类型说明： 枚举元素是常量，不能对它们赋值 例如有如下定义 enum Weekday {SUN, MON, TUE, WED, THU, FRI, SAT}; 不能写赋值表达式：SUN = 0 l 枚举元素具有默认值，它们依次为： 0,1,2,……。 l 也可以在声明时另行指定枚举元素的值，如： enum Weekday{SUN=7,MON=1,TUE,WED, THU,FRI,SAT}; l 也可以在声明时另行指定枚举元素的值； l 枚举值可以进行关系运算。 l 整数值不能直接赋给枚举变量，如需要将整数赋值给枚举变量，应进行强 制类型转换。 l 枚举值可以赋给整型变量。 例2-11 设某次体育比赛的结果有四种可能：胜（WIN）、负（LOSE）、平局（TIE）、比赛取消（CANCEL），编写程序顺序输出这四种情况。 分析： 比赛结果只有四种可能，可以声明一个枚举类型。 #include &lt;iostream&gt; using namespace std; enum GameResult {WIN, LOSE, TIE, CANCEL}; int main() { GameResult result; enum GameResult omit = CANCEL; for (int count = WIN; count &lt;= CANCEL; count++) { result = GameResult(count); if (result == omit) cout &lt;&lt; &quot;The game was cancelled&quot; &lt;&lt; endl; else { cout &lt;&lt; &quot;The game was played &quot;; if (result == WIN) cout &lt;&lt; &quot;and we won!&quot;; if (result == LOSE) cout &lt;&lt; &quot;and we lost.&quot;; cout &lt;&lt; endl; } } return 0; } auto类型与decltype类型 auto：编译器通过初始值自动推断变量的类型 例如：auto val = val1 + val2; 如果val1+val2是int类型，则val是int类型； 如果val1+val2是double类型，则val是double类型。 decltype：定义一个变量与某一表达式的类型相同，但并不用该表达式初始化变量 n 例如：decltype(i) j = 2;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]},{"title":"C语言程序学习网站","slug":"c-e8-af-ad-e8-a8-80-e7-a8-8b-e5-ba-8f-e5-ad-a6-e4-b9-a0-e7-bd-91-e7-ab-99","date":"2014-05-29T13:50:15.000Z","updated":"2019-03-20T14:40:51.309Z","comments":false,"path":"2014/05/29/c-e8-af-ad-e8-a8-80-e7-a8-8b-e5-ba-8f-e5-ad-a6-e4-b9-a0-e7-bd-91-e7-ab-99/","link":"","permalink":"http://tech.yushuai.xyz/2014/05/29/c-e8-af-ad-e8-a8-80-e7-a8-8b-e5-ba-8f-e5-ad-a6-e4-b9-a0-e7-bd-91-e7-ab-99/","excerpt":"","text":"地址：http://see.xidian.edu.cn/cpp/u/jiaocheng/ 里面有学习C语言还有单片机的各种教程，非常棒。 Keil C51 V9.00 uVision4下载：http://www.cr173.com/soft/13757.html","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://tech.yushuai.xyz/tags/编程/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://tech.yushuai.xyz/categories/C-C/"}]}]}