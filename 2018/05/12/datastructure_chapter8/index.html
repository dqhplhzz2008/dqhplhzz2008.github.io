<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="小奥の部落格">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://tech.yushuai.xyz">
    <!--SEO-->

    <meta name="keywords" content="数据结构">


    <meta name="description" content="第八讲：图（下）8.1 最小生成树问题8.1.1 最小生成树（Minimum Spanning Tree）
如图1所示。
 
图1
它是一棵树：无回路；|V|个顶点一定有|V|-1条边；
它是生...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>数据结构【浙江大学】（第8节）整理 | 小奥の部落格</title>


    <link rel="alternate" href="/atom.xml" title="小奥の部落格" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1276822649 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1276822649%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="小奥">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">

            
                <h2> 不忘初心，奋力前行 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://tech.yushuai.xyz">小奥の部落格</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/algorithm/"><i class="fa "></i>Algorithm</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Speech-Process-Notes/"><i class="fa "></i>Speech Process Notes</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/C-C/"><i class="fa "></i>C/C++</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/数据结构/"><i class="fa "></i>Data Structure</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Learning-Notes/"><i class="fa "></i>Learning Notes</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="http://www.yushuai.xyz/"><i class="fa "></i>Blog</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="http://www.yushuai.xyz/cv"><i class="fa "></i>About</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="数据结构【浙江大学】（第8节）整理">
            
	            数据结构【浙江大学】（第8节）整理
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/数据结构/">数据结构</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/数据结构/">数据结构</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/05/12</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>547</strong>天之前发表，文中内容可能已经过时，如有问题，请联系我。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="第八讲：图（下）"><a href="#第八讲：图（下）" class="headerlink" title="第八讲：图（下）"></a>第八讲：图（下）</h1><h2 id="8-1-最小生成树问题"><a href="#8-1-最小生成树问题" class="headerlink" title="8.1 最小生成树问题"></a>8.1 最小生成树问题</h2><p><strong>8.1.1 最小生成树（Minimum Spanning Tree）</strong></p>
<p>如图1所示。</p>
<p><img src="/wp-content/uploads/image/20180512/1526113146122922.jpg" alt="1.jpg" title="1526113146122922.jpg"> </p>
<p>图1</p>
<p>它是一棵树：无回路；|V|个顶点一定有|V|-1条边；</p>
<p>它是生成树：包含全部顶点；|V|-1条边都在图里。在图1中，第2/3/4个图都是图1的生成树，可以看出，<strong>生成树中任加一条边都一定构成回路</strong>。</p>
<p>最小：边的权重和<strong>最小</strong>。</p>
<p>显然可以得出，<strong>最小生成树存在<->图连通</-></strong>。</p>
<p><strong>8.1.2 贪心算法</strong></p>
<p>贪：每一步都要最好的。好：权重最小的边。</p>
<p>需要约束：只能用图里有的边；只能正好用掉|V|-1条边；不能有回路。</p>
<p><strong>8.1.3 Prim算法（密集图）—让一棵小树长大</strong></p>
<p>如图2所示，我们选择v1作为源节点，选择权重最小的（为1），到v4；然后我们看这个图，权重最小的为2有两个边，分别到v2和v3，我们先选择连到v2，再用v4连接到v3；为了不构成回路，我们需要选择权重为4的由v4到v7的边；再选择权重为1的v6，再选择权重为6的v5。</p>
<p><img src="/wp-content/uploads/image/20180512/1526113152617262.jpg" alt="2.jpg" title="1526113152617262.jpg"> </p>
<p>图2</p>
<p>其伪码描述如下，其中dist[V]=E(s,v)或正无穷，parent[s]=-1：</p>
<p>void Prim()<br>{<br>       MST={s};<br>       while(1){<br>              V=未收录顶点中dist最小者;<br>              if(V不存在)<br>                     break;<br>              将V收录进MST,dist[V]=0;<br>              for(V的每一个邻接点W)<br>                     if(dist[W]!=0)/<em>即这个点未被收入</em>/<br>                            if(E[V,W]&lt;dist[W]){<br>                                   dist[W]=E[V,W];<br>                                   parent[W]=v;<br>                            }<br>       }<br>       if(MST中收的顶点不到|V|个)<br>              Error(“生成树不存在”);<br>}</p>
<p>完整代码：</p>
<p>/<em> 邻接矩阵存储 - Prim最小生成树算法 </em>/</p>
<p>Vertex FindMinDist( MGraph Graph, WeightType dist[] )<br>{ /<em> 返回未被收录顶点中dist最小者 </em>/<br>    Vertex MinV, V;<br>    WeightType MinDist = INFINITY;</p>
<pre><code>for (V=0; V&lt;Graph-&gt;Nv; V++) {
    if ( dist\[V\]!=0 &amp;&amp; dist\[V\]&lt;MinDist) {
        /* 若V未被收录，且dist\[V\]更小 */
        MinDist = dist\[V\]; /* 更新最小距离 */
        MinV = V; /* 更新对应顶点 */
    }
}
if (MinDist &lt; INFINITY) /* 若找到最小dist */
    return MinV; /* 返回对应的顶点下标 */
else return ERROR;  /* 若这样的顶点不存在，返回-1作为标记 */
</code></pre><p>}</p>
<p>int Prim( MGraph Graph, LGraph MST )<br>{ /<em> 将最小生成树保存为邻接表存储的图MST，返回最小权重和 </em>/<br>    WeightType dist[MaxVertexNum], TotalWeight;<br>    Vertex parent[MaxVertexNum], V, W;<br>    int VCount;<br>    Edge E;</p>
<pre><code>/* 初始化。默认初始点下标是0 */
   for (V=0; V&lt;Graph-&gt;Nv; V++) {
    /* 这里假设若V到W没有直接的边，则Graph-&gt;G\[V\]\[W\]定义为INFINITY */
       dist\[V\] = Graph-&gt;G\[0\]\[V\];
       parent\[V\] = 0; /* 暂且定义所有顶点的父结点都是初始点0 */
}
TotalWeight = 0; /* 初始化权重和     */
VCount = 0;      /* 初始化收录的顶点数 */
/* 创建包含所有顶点但没有边的图。注意用邻接表版本 */
MST = CreateGraph(Graph-&gt;Nv);
E = (Edge)malloc( sizeof(struct ENode) ); /* 建立空的边结点 */

/* 将初始点0收录进MST */
dist\[0\] = 0;
VCount ++;
parent\[0\] = -1; /* 当前树根是0 */

while (1) {
    V = FindMinDist( Graph, dist );
    /* V = 未被收录顶点中dist最小者 */
    if ( V==ERROR ) /* 若这样的V不存在 */
        break;   /* 算法结束 */

    /* 将V及相应的边&lt;parent\[V\], V&gt;收录进MST */
    E-&gt;V1 = parent\[V\];
    E-&gt;V2 = V;
    E-&gt;Weight = dist\[V\];
    InsertEdge( MST, E );
    TotalWeight += dist\[V\];
    dist\[V\] = 0;
    VCount++;

    for( W=0; W&lt;Graph-&gt;Nv; W++ ) /* 对图中的每个顶点W */
        if ( dist\[W\]!=0 &amp;&amp; Graph-&gt;G\[V\]\[W\]&lt;INFINITY ) {
        /* 若W是V的邻接点并且未被收录 */
            if ( Graph-&gt;G\[V\]\[W\] &lt; dist\[W\] ) {
            /* 若收录V使得dist\[W\]变小 */
                dist\[W\] = Graph-&gt;G\[V\]\[W\]; /* 更新dist\[W\] */
                parent\[W\] = V; /* 更新树 */
            }
        }
} /* while结束*/
if ( VCount &lt; Graph-&gt;Nv ) /* MST中收的顶点不到|V|个 */
   TotalWeight = ERROR;
return TotalWeight;   /* 算法执行完毕，返回最小权重和或错误标记 */
</code></pre><p>}</p>
<p><strong>8.1.4 Kruskal算法（稀疏图）—将森林合并成树</strong></p>
<p>寻找权重最短的边，初始的情况下认为每一个顶点都是一棵树，通过不断把边收进来，就把两棵树并成了一棵树，最后把所有节点并成一棵树。</p>
<p>伪码如下：</p>
<p>void Kruskal(Graph G)<br>{<br>       MST = {};<br>       while(MST中不到|V-1|条边&amp;&amp;E中还有边){<br>              从E中去一条权重最小的边E)(V,W);/<em>最小堆</em>/<br>              将E(V,W)从E中删除;<br>              if(E(V,W)不在MST中构成回路)/<em>并查集</em>/<br>                     将E(V,W)加入MST;<br>              else<br>                     彻底无视E(V,W);<br>       }<br>       if(MST中不到|V|-1条边)<br>              ERROR(“生成树不存在”);<br>}</p>
<p>复杂度为T=O(|E|log|E|)</p>
<p>完整代码：</p>
<p>/<em> 邻接表存储 - Kruskal最小生成树算法 </em>/</p>
<p>/<em>——————– 顶点并查集定义 ——————–</em>/<br>typedef Vertex ElementType; /<em> 默认元素可以用非负整数表示 </em>/<br>typedef Vertex SetName;     /<em> 默认用根结点的下标作为集合名称 </em>/<br>typedef ElementType SetType[MaxVertexNum]; /<em> 假设集合元素下标从0开始 </em>/</p>
<p>void InitializeVSet( SetType S, int N )<br>{ /<em> 初始化并查集 </em>/<br>    ElementType X;</p>
<pre><code>for ( X=0; X&lt;N; X++ ) S\[X\] = -1;
</code></pre><p>}</p>
<p>void Union( SetType S, SetName Root1, SetName Root2 )<br>{ /<em> 这里默认Root1和Root2是不同集合的根结点 </em>/<br>    /<em> 保证小集合并入大集合 </em>/<br>    if ( S[Root2] &lt; S[Root1] ) { /<em> 如果集合2比较大 </em>/<br>        S[Root2] += S[Root1];     /<em> 集合1并入集合2  </em>/<br>        S[Root1] = Root2;<br>    }<br>    else {                         /<em> 如果集合1比较大 </em>/<br>        S[Root1] += S[Root2];     /<em> 集合2并入集合1  </em>/<br>        S[Root2] = Root1;<br>    }<br>}</p>
<p>SetName Find( SetType S, ElementType X )<br>{ /<em> 默认集合元素全部初始化为-1 </em>/<br>    if ( S[X] &lt; 0 ) /<em> 找到集合的根 </em>/<br>        return X;<br>    else<br>        return S[X] = Find( S, S[X] ); /<em> 路径压缩 </em>/<br>}</p>
<p>bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )<br>{ /<em> 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 </em>/<br>    Vertex Root1, Root2;</p>
<pre><code>Root1 = Find( VSet, V1 ); /* 得到V1所属的连通集名称 */
Root2 = Find( VSet, V2 ); /* 得到V2所属的连通集名称 */

if( Root1==Root2 ) /* 若V1和V2已经连通，则该边不能要 */
    return false;
else { /* 否则该边可以被收集，同时将V1和V2并入同一连通集 */
    Union( VSet, Root1, Root2 );
    return true;
}
</code></pre><p>}<br>/<em>——————– 并查集定义结束 ——————–</em>/</p>
<p>/<em>——————– 边的最小堆定义 ——————–</em>/<br>void PercDown( Edge ESet, int p, int N )<br>{ /<em> 改编代码4.24的PercDown( MaxHeap H, int p )    </em>/<br>  /<em> 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 </em>/<br>    int Parent, Child;<br>    struct ENode X;</p>
<pre><code>X = ESet\[p\]; /* 取出根结点存放的值 */
for( Parent=p; (Parent*2+1)&lt;N; Parent=Child ) {
    Child = Parent * 2 + 1;
    if( (Child!=N-1) &amp;&amp; (ESet\[Child\].Weight&gt;ESet\[Child+1\].Weight) )
        Child++;  /* Child指向左右子结点的较小者 */
    if( X.Weight &lt;= ESet\[Child\].Weight ) break; /* 找到了合适位置 */
    else  /* 下滤X */
        ESet\[Parent\] = ESet\[Child\];
}
ESet\[Parent\] = X;
</code></pre><p>}</p>
<p>void InitializeESet( LGraph Graph, Edge ESet )<br>{ /<em> 将图的边存入数组ESet，并且初始化为最小堆 </em>/<br>    Vertex V;<br>    PtrToAdjVNode W;<br>    int ECount;</p>
<pre><code>/* 将图的边存入数组ESet */
ECount = 0;
for ( V=0; V&lt;Graph-&gt;Nv; V++ )
    for ( W=Graph-&gt;G\[V\].FirstEdge; W; W=W-&gt;Next )
        if ( V &lt; W-&gt;AdjV ) { /* 避免重复录入无向图的边，只收V1&lt;V2的边 */
            ESet\[ECount\].V1 = V;
            ESet\[ECount\].V2 = W-&gt;AdjV;
            ESet\[ECount++\].Weight = W-&gt;Weight;
        }
/* 初始化为最小堆 */
for ( ECount=Graph-&gt;Ne/2; ECount&gt;=0; ECount-- )
    PercDown( ESet, ECount, Graph-&gt;Ne );
</code></pre><p>}</p>
<p>int GetEdge( Edge ESet, int CurrentSize )<br>{ /<em> 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 </em>/</p>
<pre><code>/* 将最小边与当前堆的最后一个位置的边交换 */
Swap( &amp;ESet\[0\], &amp;ESet\[CurrentSize-1\]);
/* 将剩下的边继续调整成最小堆 */
PercDown( ESet, 0, CurrentSize-1 );

return CurrentSize-1; /* 返回最小边所在位置 */
</code></pre><p>}<br>/<em>——————– 最小堆定义结束 ——————–</em>/</p>
<p>int Kruskal( LGraph Graph, LGraph MST )<br>{ /<em> 将最小生成树保存为邻接表存储的图MST，返回最小权重和 </em>/<br>    WeightType TotalWeight;<br>    int ECount, NextEdge;<br>    SetType VSet; /<em> 顶点数组 </em>/<br>    Edge ESet;    /<em> 边数组 </em>/</p>
<pre><code>InitializeVSet( VSet, Graph-&gt;Nv ); /* 初始化顶点并查集 */
ESet = (Edge)malloc( sizeof(struct ENode)*Graph-&gt;Ne );
InitializeESet( Graph, ESet ); /* 初始化边的最小堆 */
/* 创建包含所有顶点但没有边的图。注意用邻接表版本 */
MST = CreateGraph(Graph-&gt;Nv);
TotalWeight = 0; /* 初始化权重和     */
ECount = 0;      /* 初始化收录的边数 */

NextEdge = Graph-&gt;Ne; /* 原始边集的规模 */
while ( ECount &lt; Graph-&gt;Nv-1 ) {  /* 当收集的边不足以构成树时 */
    NextEdge = GetEdge( ESet, NextEdge ); /* 从边集中得到最小边的位置 */
    if (NextEdge &lt; 0) /* 边集已空 */
        break;
    /* 如果该边的加入不构成回路，即两端结点不属于同一连通集 */
    if ( CheckCycle( VSet, ESet\[NextEdge\].V1, ESet\[NextEdge\].V2 )==true ) {
        /* 将该边插入MST */
        InsertEdge( MST, ESet+NextEdge );
        TotalWeight += ESet\[NextEdge\].Weight; /* 累计权重 */
        ECount++; /* 生成树中边数加1 */
    }
}
if ( ECount &lt; Graph-&gt;Nv-1 )
    TotalWeight = -1; /* 设置错误标记，表示生成树不存在 */

return TotalWeight;
</code></pre><p>}</p>
<h2 id="8-2-拓扑排序"><a href="#8-2-拓扑排序" class="headerlink" title="8.2 拓扑排序"></a>8.2 拓扑排序</h2><p><strong>8.2.1 拓扑排序</strong></p>
<p>AOV（Activity On Vertex）网络</p>
<p>如图3所示，是指所有的真实活动是表现在顶点上的，顶点与顶点之间的有向边表现了顶点间的先后顺序。</p>
<p><img src="/wp-content/uploads/image/20180512/1526113216428445.jpg" alt="3.jpg" title="1526113216428445.jpg"> </p>
<p>图3</p>
<p>所谓拓扑序是指：如果图中从V到W有一条有向路径，则V一定排在W之前，满足此条件的顶点序列称为一个拓扑序。获得一个拓扑序的过程就是拓扑排序。</p>
<p>AOV网络如果有<strong>合理（所谓不合理是指，网络形成了一个环，那就代表着V必须在V开始之前结束，自然不合理）</strong>的拓扑序，则必定是<strong>有向无环图</strong>（Directed Acyclic Graph, DAG）。</p>
<p>所谓拓扑排序，就是每一次输出没有前序顶点的顶点。</p>
<p>伪码描述如下：</p>
<p>void TopSort()<br>{<br>       for(cnt=0;cnt&lt;|V|;cnt++){<br>              v = 为输出的入度为0的顶点;/<em>简单粗暴法此步O(|V|)，总为O(|V|2)</em>/<br>              /<em>聪明的算法如下文所述</em>/<br>              if(这样的V不存在_{<br>                     Error(“图中有回路”);<br>                     break;<br>              }</p>
<pre><code>       输出V，或者记录V的输出序号;
       for(V的每个邻接点W)
              Indegree\[W\]--;
}
</code></pre><p>}</p>
<p>聪明的算法：随时将入度变为0的顶点放到一个容器（数组、堆栈、队列等都行）中，下一次直接从这里面直接拿数据就可以了。利用队列的新的伪码描述：</p>
<p>void TopSort()<br>{<br>       for(图中每个顶点V){<br>              if(Indegree[V]==0)<br>                     Enqueue(V,Q);<br>       }<br>              while(!IsEmpty(Q){<br>                     V=Dequeue(Q);<br>                     输出V，或者记录V的输出序号;cnt++;<br>                     for(V的每个邻接点W)<br>                     {<br>                            if(–Indegree[W]==0)<br>                                   Enqueue(W,Q);<br>                     }<br>              }<br>              if(cnt!=|V|)<br>                     Error(“图中有回路”);<br>}</p>
<p>时间复杂度T=O(|V|+|E|)</p>
<p>完整代码：</p>
<p>/<em> 邻接表存储 - 拓扑排序算法 </em>/</p>
<p>bool TopSort( LGraph Graph, Vertex TopOrder[] )<br>{ /<em> 对Graph进行拓扑排序,  TopOrder[]顺序存储排序后的顶点下标 </em>/<br>    int Indegree[MaxVertexNum], cnt;<br>    Vertex V;<br>    PtrToAdjVNode W;<br>       Queue Q = CreateQueue( Graph-&gt;Nv );</p>
<pre><code>/* 初始化Indegree\[\] */
for (V=0; V&lt;Graph-&gt;Nv; V++)
    Indegree\[V\] = 0;

/* 遍历图，得到Indegree\[\] */
for (V=0; V&lt;Graph-&gt;Nv; V++)
    for (W=Graph-&gt;G\[V\].FirstEdge; W; W=W-&gt;Next)
        Indegree\[W-&gt;AdjV\]++; /* 对有向边&lt;V, W-&gt;AdjV&gt;累计终点的入度 */

/* 将所有入度为0的顶点入列 */
for (V=0; V&lt;Graph-&gt;Nv; V++)
    if ( Indegree\[V\]==0 )
        AddQ(Q, V);

/* 下面进入拓扑排序 */
cnt = 0;
while( !IsEmpty(Q) ){
    V = DeleteQ(Q); /* 弹出一个入度为0的顶点 */
    TopOrder\[cnt++\] = V; /* 将之存为结果序列的下一个元素 */
    /* 对V的每个邻接点W-&gt;AdjV */
    for ( W=Graph-&gt;G\[V\].FirstEdge; W; W=W-&gt;Next )
        if ( --Indegree\[W-&gt;AdjV\] == 0 )/* 若删除V使得W-&gt;AdjV入度为0 */
            AddQ(Q, W-&gt;AdjV); /* 则该顶点入列 */
} /* while结束*/

if ( cnt != Graph-&gt;Nv )
    return false; /* 说明图中有回路, 返回不成功标志 */
else
    return true;
</code></pre><p>}</p>
<p><strong>8.2.2 关键路径</strong></p>
<p>AOE（Activity On Edge）网络一般用于安排项目的工序。与AOV不同，AOE的活动表示在边上，而节点代表活动到此结束。一般情况下，AOE网络的图示为以下结构：</p>
<p><img src="/wp-content/uploads/image/20180512/1526113272929914.jpg" alt="4.jpg" title="1526113272929914.jpg"> </p>
<p>图4</p>
<p>如图5所示，图中虚线，且权重为0表示的是，要继续执行9/7权重那里，4/5这里必须都得走到了。</p>
<p><img src="/wp-content/uploads/image/20180512/1526113276128244.jpg" alt="5.jpg" title="1526113276128244.jpg"> </p>
<p>图5</p>
<p>问题1：整个工期有多长？</p>
<p>Earliest[0]=0;</p>
<p>Earliest[j]=max(&lt;i,j&gt;∈E){Earliest[i]+C&lt;i,j&gt;}</p>
<p>故Earliest[8]=18</p>
<p>问题2：哪几个组有机动时间（保证工期最长18天）？</p>
<p>方法是设置最后一个最晚完成时间为18天，然后往前推。</p>
<p>注意：虽然7倒推回去5只需要在第10天完工就可以，但是考虑到4必须在第7天完工，而6必须在第16天完工，又由于4、5同时完工才能往下走，所以5的最晚完成时间也必须和4同样，为第7天。</p>
<p>Latest[8]=18;</p>
<p>Latest[i]=(min&lt;i,j&gt;∈E){Latest[j]-C&lt;i,j&gt;}</p>
<p>所谓机动时间就是哪些组可以不用急着赶工</p>
<p>机动时间D&lt;i,j&gt;=Latest[j]-Earliest[i]-C&lt;i,j&gt;</p>
<p>所谓关键路径就是整个流程中最需要关注的地方，哪些步骤是一点也不能耽误的，只要它耽误了，整个流程都要耽误，所以它是<strong>绝对不允许延误的活动</strong>组成的路径。</p>

    </div>
    
        <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="http://www.yushuai.xyz/zjyt/alipay.jpg"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="http://www.yushuai.xyz/zjyt/weixin.jpg"><b>微信打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="http://www.yushuai.xyz/zjyt/unipay.png"><b>QQ钱包打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">感觉不错？欢迎给我 打个赏~我将不胜感激！</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="http://www.yushuai.xyz" target="_blank">小奥</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/05/12/datastructure_chapter9/" class="pre-post btn btn-default" title="数据结构【浙江大学】（第9节）整理">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">数据结构【浙江大学】（第9节）整理</span>
        </a>
    
    
        <a href="/2018/05/09/datastructure_chapter7/" class="next-post btn btn-default" title="数据结构【浙江大学】（第7节）整理">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">数据结构【浙江大学】（第7节）整理</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>






                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第八讲：图（下）"><span class="toc-text">第八讲：图（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-最小生成树问题"><span class="toc-text">8.1 最小生成树问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-拓扑排序"><span class="toc-text">8.2 拓扑排序</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//www.yushuai.xyz" class="copyright-links" target="_blank" rel="nofollow">小奥の部落格</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>