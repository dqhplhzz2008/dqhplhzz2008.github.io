<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="小奥の部落格">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://tech.yushuai.xyz">
    <!--SEO-->

    <meta name="keywords" content="编程">


    <meta name="description" content="第六周：多态
第一节 虚函数和多态的基本概念1.**虚函数 在类的定义中，前面有virtual关键字的成员函数就是虚函数。 class base{ virtual int get(); } in...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>C++面向对象程序设计课程笔记（第六周） | 小奥の部落格</title>


    <link rel="alternate" href="/atom.xml" title="小奥の部落格" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1276822649 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1276822649%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="小奥">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">

            
                <h2> 不忘初心，奋力前行 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://tech.yushuai.xyz">小奥の部落格</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/algorithm/"><i class="fa "></i>Algorithm</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Speech-Process-Notes/"><i class="fa "></i>Speech Process Notes</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/C-C/"><i class="fa "></i>C/C++</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/数据结构/"><i class="fa "></i>Data Structure</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Learning-Notes/"><i class="fa "></i>Learning Notes</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="http://www.yushuai.xyz/"><i class="fa "></i>Blog</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="http://www.yushuai.xyz/cv"><i class="fa "></i>About</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="C++面向对象程序设计课程笔记（第六周）">
            
	            C++面向对象程序设计课程笔记（第六周）
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/C-C/">C/C++</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/编程/">编程</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/09/17</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>568</strong>天之前发表，文中内容可能已经过时，如有问题，请联系我。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p><strong>第六周：多态</strong></p>
<h2 id="第一节-虚函数和多态的基本概念"><a href="#第一节-虚函数和多态的基本概念" class="headerlink" title="第一节 虚函数和多态的基本概念"></a>第一节 虚函数和多态的基本概念</h2><p><strong>1.**</strong>虚函数<strong> 在类的定义中，前面有virtual关键字的成员函数就是虚函数。 class base{ virtual int get(); } int base::get(){} virtual关键字只在类定义里的函数声明中，写函数体的时候不用。</strong>构造函数和静态函数不能使用<strong><strong>virtual</strong></strong>，即不能成为虚函数。<strong> </strong>2.<strong>**多态</strong> （1）表现形式一 派生类的指针可以赋给基类指针。 通过基类指针调用基类和派生类中的同名虚函数时： ①若该指针指向一个基类的对象，那么背调用的是基类的虚函数； ②若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。 这种机制称为多态。例如： class CBase{ public: virtual void SomeVirtualFunction(){} }; class CDerived:public CBase{ public: virtual void SomVirtualFunction(){} }; int main(){ CDerived ODerived; CBase <em>p = &ODerived; p-&gt;SomeVirtualFunction();//p指向派生类对象，所以调用派生类里面的 return 0; } （2）表现形式二 派生类的对象可以赋给基类引用 通过基类引用调用基类和派生类中的同名虚函数时： ①若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数； ②若该引用引用的是一个派生类的对象，那么调用的是派生类的虚函数。 class CBase{ public: virtual void SomeVirtualFunction(){} }; class CDerived:public CBase{ public: virtual void SomVirtualFunction(){} }; int main(){ CDerived ODerived; CBase &amp;r = ODerived; r-&gt;SomeVirtualFunction();//在这里调用的是派生类中的 return 0; } <strong>3.**</strong>多态的作用*</em> 在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。</p>
<h2 id="第二节-多态实例：魔法门之英雄无敌"><a href="#第二节-多态实例：魔法门之英雄无敌" class="headerlink" title="第二节 多态实例：魔法门之英雄无敌"></a>第二节 多态实例：魔法门之英雄无敌</h2><p>在游戏中有很多怪物，没种怪物都有一个类与之对应，每个怪物就是一个对象。怪物能够互相攻击，攻击敌人和被攻击时都有相应的动作，动作是通过对象的成员函数实现的。游戏版本升级时，要增加新的怪物——雷鸟（CThunderBird）。如何编程使代码改动和增加量较小？ 基本思路： 为每个怪物类编写 Attack、FightBack和 Hurted成员函数。 Attact函数表现攻击动作，攻击某个怪物，并调用被攻击怪物的Hurted函数，以减少被攻击怪物的生命值，同时也调用被攻击怪物的 FightBack成员函数，遭受被攻击怪物反击。 Hurted函数减少自身生命值，并表现受伤动作。 FightBack成员函数表现反击动作，并调用被反击对象的Hurted成员函数，使被反击对象受伤。 设置基类CCreature，并且使CDragon、CWolf等其他类都从该基类派生而来，如图2.1所示。 <a href="https://dqhplhzz2008-1251830035.cos.ap-guangzhou.myqcloud.com/wp-content/uploads/2018/09/jibensilu.jpg" target="_blank" rel="noopener"><img src="https://dqhplhzz2008-1251830035.cos.ap-guangzhou.myqcloud.com/wp-content/uploads/2018/09/jibensilu.jpg" alt></a></p>
<p>图2.1 基本思路图</p>
<p><strong>1.**</strong>非多态实现方法：<strong> class class CCreature { protected: int nPower ; //代表攻击力 int nLifeValue ; //代表生命值 }; class CDragon:public CCreature  { public: void Attack(CWolf <em> pWolf) { //．．．表现攻击动作的代码 pWolf-&gt;Hurted( nPower); pWolf-&gt;FightBack( this); } void Attack(CGhost </em> pGhost){ //表现攻击动作代码 pGhost-&gt;Hurted( nPower); pGhost-&gt;FightBack( this); } void Hurted(int nPower){ //表现受伤动作代码 nLifeValue -=nPower; } void FightBack(CWolf *pWolf){ //表现反击动作的代码 pWolf-&gt;Hurted(nPower/2); } void FightBack(CGhost *pGhost){ //表现反击动作代码 pGhost-&gt;Hurted(nPower/2); } } //……还有很多 有n种怪物，CDrogon就要有n个Attack成员函数和n个FightBack成员函数，对于其他类也是如此。 如果游戏版本升级，增加了新的怪物雷鸟CthunderBird，则程序改动非常大，所有的类都需要增加两个成员函数（攻击和反击）。 </strong>2.<strong>**多态实现方法：</strong> 代码如下： class class CCreature { protected: int nPower ; //代表攻击力 int nLifeValue ; //代表生命值 public: virtual void Attack(CCreature *pCreature){} virtual void Hurted(int nPower){} virtual void FightBack(CCreature *pCreature){} }; class CDragon:public CCreature  { public: virtual void Attack(CCreature *pCreature); virtual void Hurted(int nPower); virtual void FightBack(CCreature *pCreature); };   void CDragon::Attack(CCreature <em> p) { //．．．表现攻击动作的代码 p-&gt;Hurted(m_nPower); pWolf-&gt;FightBack(this); } void CDragon::Hurted(int nPower){ //表现受伤动作代码 m_nLifeValue -=nPower; } void CDragon::FightBack(CCreature \</em>p){ //表现反击动作的代码 pWolf-&gt;Hurted(m_nPower/2); } 基类只有一个Attack、FightBack成员函数，所有CCreature的派生类也一样。 如果游戏版本升级，增加了新的怪物雷鸟CThunderBird，只需要编写心累CThunderBird，不需要在已有的类例专门为新怪物增加： void Attack( CThunderBird * pThunderBird) ; void FightBack( CThunderBird * pThunderBird) ;</p>
<h2 id="第三节-多态实例：几何形体程序"><a href="#第三节-多态实例：几何形体程序" class="headerlink" title="第三节 多态实例：几何形体程序"></a>第三节 多态实例：几何形体程序</h2><p>几何形体处理程序：输入若干个几何形体的参数，要求按面积排序输出，输出时要指明形状。 输入： 第一行是几何体数目n（不超过100行），下面有n行，每行以一个字母开头： （1）若字母为“R”，则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高； （2）若字母为“C”，则代表一个圆，本行后面跟着一个整数代表其半径； （3）若字母为“T”，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度。 输出： 按面积从小到大依次输出每个几何形体的种类及面积。每行一个几何形体，输出格式为： 形体名称：面积 代码如下： #include <iostream> #include &lt;stdlib.h&gt; #include &lt;math.h&gt; using namespace std; class CShape { public: virtual double Area() = 0;//纯虚函数 virtual void PrintInfo() = 0; };   class CRectangle :public CShape { public: int w, h; virtual double Area(); virtual void PrintInfo(); };   class CCircle :public CShape { public: int r; virtual double Area(); virtual void PrintInfo(); };   class CTriangle :public CShape { public: int a, b, c; virtual double Area(); virtual void PrintInfo(); }; double CRectangle::Area() { return w*h; } void CRectangle::PrintInfo() { cout &lt;&lt; “Rectangle:” &lt;&lt; Area() &lt;&lt; endl; } double CCircle::Area() { return 3.14*r*r; }   void CCircle::PrintInfo() { cout &lt;&lt; “Circle:” &lt;&lt; Area() &lt;&lt; endl; } double CTriangle::Area() { double p = (a + b + c) / 2.0; return sqrt(p*(p - a)<em>(p - b)</em>(p - c)); }   void CTriangle::PrintInfo() { cout &lt;&lt; “Triangle:” &lt;&lt; Area() &lt;&lt; endl; } CShape <em> pShapes[100];//基类指针，可以指向不同派生类 int MyCompare(const void \</em>s1, const void*s2); int main() { int i, n; CRectangle *pr; CCircle *pc; CTriangle *pt; cin &gt;&gt; n; for (i = 0; i &lt; n; i++) { char c; cin &gt;&gt; c; switch (c) { case ‘R’: pr = new CRectangle(); cin &gt;&gt; pr-&gt;w &gt;&gt; pr-&gt;h; pShapes[i] = pr; break; case ‘C’: pc = new CCircle(); cin &gt;&gt; pc-&gt;r; pShapes[i] = pc; break; case ‘T’: pt = new CTriangle(); cin &gt;&gt; pt-&gt;a &gt;&gt; pt-&gt;b &gt;&gt; pt-&gt;c; pShapes[i] = pt; break; } } qsort(pShapes, n, sizeof(CShape*), MyCompare); for (int i = 0; i &lt; n; i++) pShapes[i]-&gt;PrintInfo();//利用多态操作不同类的输出函数   system(“pause”); return 0;   } int MyCompare(const void <em> s1, const void \</em>s2) { double a1, a2; CShape **p1;//s1,s2是void<em>,不可写\</em>s1来取得s1指向的内容 CShape **p2; p1 = (CShape <strong>)s1;//s1,s2指向pShapes数组中的元素，数组元素的类型是CShape * p2 = (CShape </strong>)s2; a1 = (*p1)-&gt;Area(); a2 = (*p2)-&gt;Area(); if (a1 &lt; a2) return  -1; else if (a2 &lt; a1) return 1; else return 0; } 因为s1和s2都是void<em>，所以没办法直接获取到指向的内容。所以设置了两个CShape<strong>的变量p1和p2，把s1和s2强制转换成CShape</strong>类型。s1和s2是指向pShapes数组中的元素，数组元素类型为CShape</em>。p1，p2是指向指针的指针，所以要用两个<em>。 <em>*用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组，就能对各个派生类对象做各种操作。</em></em> 又一个例子，还是比较好理解的： <a href="https://dqhplhzz2008-1251830035.cos.ap-guangzhou.myqcloud.com/wp-content/uploads/2018/09/2duotai.jpg" target="_blank" rel="noopener"><img src="https://dqhplhzz2008-1251830035.cos.ap-guangzhou.myqcloud.com/wp-content/uploads/2018/09/2duotai.jpg" alt></a></iostream></p>
<p>图3.1 多态又一例子</p>
<p><strong>在非构造函数、非析构函数的成员函数中调用虚函数，是多态。</strong> <strong>构造函数和析构函数中调用虚函数，不是多态。编译时即可确定，调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。</strong> <strong>派生类中和基类中虚函数同名同参数表的函数，不加**</strong>virtual<strong>**也自动成为虚函数。</strong> <a href="https://dqhplhzz2008-1251830035.cos.ap-guangzhou.myqcloud.com/wp-content/uploads/2018/09/3xuhanshu.jpg" target="_blank" rel="noopener"><img src="https://dqhplhzz2008-1251830035.cos.ap-guangzhou.myqcloud.com/wp-content/uploads/2018/09/3xuhanshu.jpg" alt></a></p>
<p>图3.2 虚函数访问权限介绍</p>
<p>在这里会出现编译出错。因为语法检查是不考虑运行结果，所以在fun2()是Base的私有成员的时候，语法检查直接给判错，即便运行到此时实际上按照规定是调用的Derived的公有成员fun2()。 但是如果基类中是public，派生类中即使是private，编译依然能通过，因为语法检查还是只看能不能访问基类的，运行的时候再看实际情况。这里面因为基类指针指向了派生类，所以派生类中成员函数是private也是可以运行出来的。</p>
<h2 id="第四节-多态的实现原理"><a href="#第四节-多态的实现原理" class="headerlink" title="第四节 多态的实现原理"></a>第四节 多态的实现原理</h2><p>“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定——这叫“动态联编”。<strong>当然多态就是在运行的时候才确定调用谁的函数，而不是在编译的时候确定</strong>。 例程如下： class Base{ public: int i; virtual void Print(){cout &lt;&lt; “Base Print”&lt;&lt;endl;} }; class Derived:public Base{ public: int n; virtual void Print){cout&lt;&lt;”Derived Print”&lt;&lt;endl;} }; int main(){ Derived d; cout&lt;&lt;sizeof(Base)&lt;&lt;sizeof(Derived); return 0; } 输出结果本来我们认为是4和8，但实际上却是8和12，这是为什么呢？   <strong>1.**</strong>多态实现的关键——虚函数表** 每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。多出来的4个字节就是用来放虚函数表的地址的。 <a href="https://dqhplhzz2008-1251830035.cos.ap-guangzhou.myqcloud.com/wp-content/uploads/2018/09/4baselei.jpg" target="_blank" rel="noopener"><img src="https://dqhplhzz2008-1251830035.cos.ap-guangzhou.myqcloud.com/wp-content/uploads/2018/09/4baselei.jpg" alt></a></p>
<p>图4.1 Base类的虚函数表</p>
<p><a href="https://dqhplhzz2008-1251830035.cos.ap-guangzhou.myqcloud.com/wp-content/uploads/2018/09/5derivedlei.jpg" target="_blank" rel="noopener"><img src="https://dqhplhzz2008-1251830035.cos.ap-guangzhou.myqcloud.com/wp-content/uploads/2018/09/5derivedlei.jpg" alt></a></p>
<p>图4.2 Deriverd类的虚函数表</p>
<pre><code>多态程序会有额外的时间（查询函数表）和空间开销（虚函数表）。 又一个例程： #include &lt;iostream&gt; using namespace std; class A{ public:virtual void Func(){cout &lt;&lt;&quot;A::Func&quot;&quot;&lt;&lt;endl;} }; class B: public A{ public:virtual void Func(){cout&lt;&lt;&quot;B::Func&quot;&lt;&lt;endl;} }; int main(){ A a; A* pa = new B(); pa-&gt;Func();//显然，输出结果为B::Func //在64位电脑执行，64位程序指针为8字节 long long \*p1 = (long long \*)&amp;a;//把a的地址转换成一个longlong型的地址指针赋值给p1 long long \*p2 = (long long \*)pa;//把new出来的B的地址转换成longlong型的地址指针赋给p2 \*p2 = \*p1;//=是赋值号。把p1指向地方的内容放在p2指向的地方去。 //由于p1是longlong型，所以*p1是8字节的内容。8个地址正好也是一个地址，这个地址放在a对象的开头，是classA的虚函数表的地址。 //p2指向New出来的B对象，所以p2的开头也应该放着classB的虚函数表的地址，也是8个字节。 //把p1指向的8个字节赋值给了p2指向的8个字节，所以下面语句输出值为A::Func pa-&gt;Func(); return 0; }
</code></pre><h2 id="第五节-虚析构函数、纯虚函数和抽象类"><a href="#第五节-虚析构函数、纯虚函数和抽象类" class="headerlink" title="第五节 虚析构函数、纯虚函数和抽象类"></a>第五节 虚析构函数、纯虚函数和抽象类</h2><p><strong>1.**</strong>虚析构函数（<strong><strong>不是多态</strong></strong>）<strong> 通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数。但是，删除一个派生类的对象时，应该先调用派生类的析构函数，然后调用基类的析构函数。 </strong>解决方法：把基类的析构函数声明为<strong><strong>virtual</strong></strong>。<strong> 派生类的析构函数可以不进行声明也是虚函数。通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数。 一般来说，</strong>一个类如果定义了虚函数，则应该将析构函数也定义成虚函数<strong>。或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。 注意：</strong>不允许以虚函数作为构造函数<strong>。 例子： class son{ public: virtual ~son() {cout&lt;&lt;”bye from son”&lt;&lt;endl;}; }; class grandson:public son{ public: ~grandson(){cout&lt;&lt;”bye from grandson”&lt;&lt;endl;}; }; int main() { son *pson; pson= new grandson(); delete pson; return 0; } 输出结果：bye from grandson bye from son </strong>2.<strong>**纯虚函数和抽象类</strong> 纯虚函数：没有函数体的虚函数，<strong>不等同于函数体无语句！！！</strong>。 格式如下： virtual void Print( )=0;//纯虚函数 包含纯虚函数的类叫抽象类。抽象类只能作为基类来派生新类使用，<strong>不能创建抽象类的对象</strong>；抽象类的指针和引用可以指向由抽象类派生出来的类的对象。 如下例： A a ; // 错，A 是抽象类，不能创建对象 A * pa ; // ok,可以定义抽象类的指针和引用 pa = new A ; //错误, A 是抽象类，不能创建对象 在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。 例程： class A{ public: virtual void f() =0;//纯虚函数 void g(){this-&gt;f();//ok } A(){//f();//错误 } }; class B:public A{ public: void f(){cout&lt;&lt;”B:f()”&lt;&lt;endl;} }; int main(){ B b; b.g(); return 0; } 输出：B.f()</p>

    </div>
    
        <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="http://www.yushuai.xyz/zjyt/alipay.jpg"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="http://www.yushuai.xyz/zjyt/weixin.jpg"><b>微信打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="http://www.yushuai.xyz/zjyt/unipay.png"><b>QQ钱包打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">感觉不错？欢迎给我 打个赏~我将不胜感激！</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="http://www.yushuai.xyz" target="_blank">小奥</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/09/17/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae/" class="pre-post btn btn-default" title="C++面向对象程序设计课程笔记（第七周）">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">C++面向对象程序设计课程笔记（第七周）</span>
        </a>
    
    
        <a href="/2018/09/14/c-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7e8-ae-a1-e8-af-be-e7/" class="next-post btn btn-default" title="C++面向对象程序设计课程笔记（第五周）">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">C++面向对象程序设计课程笔记（第五周）</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>






                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一节-虚函数和多态的基本概念"><span class="toc-text">第一节 虚函数和多态的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二节-多态实例：魔法门之英雄无敌"><span class="toc-text">第二节 多态实例：魔法门之英雄无敌</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三节-多态实例：几何形体程序"><span class="toc-text">第三节 多态实例：几何形体程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第四节-多态的实现原理"><span class="toc-text">第四节 多态的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第五节-虚析构函数、纯虚函数和抽象类"><span class="toc-text">第五节 虚析构函数、纯虚函数和抽象类</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>
<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//www.yushuai.xyz" class="copyright-links" target="_blank" rel="nofollow">小奥の部落格</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>